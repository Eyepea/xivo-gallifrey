#!/usr/bin/python
#
# Authors : Sylvain Boily, Guillaume Knispel
#           Proformatique
#           67, rue Voltaire
#           92800 PUTEAUX
#           (+33/0)1.41.38.99.60
#           mailto:technique@proformatique.com
#           (C) 2007 Proformatique
#

__version__ = "$Revision: 1136 $ $Date: 2007-07-13 19:49:46 +0200 (Fri, 13 Jul 2007) $"
__license__ = """
    Copyright (C) 2007, Proformatique

    This software is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
"""

PIDFILE = '/var/run/xivo_daemon_bazile.pid'

import xivo.to_path
import sys, time, ami, Queue, urllib, daemonize, syslog

# Dictionnaire des status Callerid, Channel et status du channel
# identifiant unique UniqID Asterisk
# 0 = appel qui arrive
# 1 = appel decroche
# 2 = appel unlink
# 3 = appel raccroche
lines = {}
idqueue = Queue.Queue()
login = 'jas'
passwd = 'jas'
ip = '127.0.0.1'
key = 'SAD8Z8ZR53D1FZEER872N2QA873'
website = 'http://monbazile.fr/connect.php'

def handle_shutdown(event, mng):
   log_stderr_and_syslog("Received shutdown event")
   mng.close()
      
def handle_event(event, mng):
   log_stderr_and_syslog("Received event: %s" % event.name)
   log_stderr_and_syslog(event.headers)

def handle_newchannel(event, mng):
	if event.headers['State'] == 'Ring':
		infos = [event.headers['CallerID'], event.headers['Channel'], '', 0]
		lines[event.headers['Uniqueid']] = infos
		idqueue.put(event.headers['Uniqueid'])

def handle_link(event, mng):
	(tech, chan) = event.headers['Channel2'].split('/')
	c = chan.split('-')
	infos = [event.headers['CallerID1'], event.headers['Channel1'], c[0], 1]
	lines[event.headers['Uniqueid1']] = infos
	idqueue.put(event.headers['Uniqueid1'])

def handle_unlink(event, mng):
	infos = [event.headers['CallerID1'], event.headers['Channel1'], '', 2]
	lines[event.headers['Uniqueid1']] = infos
	idqueue.put(event.headers['Uniqueid1'])

def handle_hangup(event, mng):
	try:
		if event.headers['Channel'] == lines[event.headers['Uniqueid']][1]:
			infos = [lines[event.headers['Uniqueid']][0], event.headers['Channel'], lines[event.headers['Uniqueid']][2], 3]
			lines[event.headers['Uniqueid']] = infos
			idqueue.put(event.headers['Uniqueid'])
	except LookupError:
		# Hangup non correspondant a un appel entrant pour le context actuel
		pass

def url_call(id):
	url = ''
	response = ''
	callerid = lines[id][0]
	channel = lines[id][1]
	operator = lines[id][2]
	status = lines[id][3]
	if not 'Zap' in channel:
		return -1
	if len(callerid) < 10:
		callerid = '0%s' % callerid
	if status == 0:
		# Gere en AGI
		log_stderr_and_syslog("Appel arrive")
		return -1
	if status == 1:
		url = "%s?N=%s&I=%s&W=2&C=%s&E=%s" % (website, callerid, key, channel, operator)
		log_stderr_and_syslog("Appel decroche")
	if status == 3:
		url = "%s?N=%s&I=%s&W=3&C=%s&E=%s" % (website, callerid, key, channel, operator)
		log_stderr_and_syslog("Appel hangup")

	if url:
		response = urllib.urlopen(url).read()
		log_stderr_and_syslog(url)

	if response == "ok":
		return status
	
	return -1

def log_stderr_and_syslog(x):
	print >> sys.stderr, x
	syslog.syslog(syslog.LOG_ERR, x)


daemonize.daemonize(log_stderr_and_syslog, PIDFILE, True)

log_stderr_and_syslog("Bazile call center starting")

mng = ami.Manager()
try:
    #try:
       mng.connect(ip) 
       mng.login(login, passwd)

       # register some callbacks
       mng.register_event('Shutdown', handle_shutdown)
       #mng.register_event('*', handle_event)
       mng.register_event('Newchannel', handle_newchannel)
       mng.register_event('Link', handle_link)
       #mng.register_event('Unlink', handle_unlink)
       mng.register_event('Hangup', handle_hangup)

       if mng.version != "1.0":
         log_stderr_and_syslog("Version Manager error")
	 sys.exit()
       if mng.title != "Asterisk Call Manager":
       	 log_stderr_and_syslog("Banner Manager error")
	 sys.exit()
        
       # get a status report
       response = mng.status()

       if str(response) != "Success":
       	 log_stderr_and_syslog("Error Manager is not ready")
	 sys.exit()

       while 1:
	  uniqid = [idqueue.get()]
	  try:
	    while True:
	      uniqid.append(idqueue.get_nowait())
	  except Queue.Empty:
	    pass
	  uniqid.reverse()
	  idx = 0
	  while idx < len(uniqid):
	    one_id = uniqid[idx]
	    other_idx = idx + 1
	    while other_idx < len(uniqid):
	      if uniqid[other_idx] == one_id:
	        del uniqid[other_idx]
	      else:
	        other_idx += 1
            idx += 1
	  uniqid.reverse()

	  for id in uniqid:
	     r = url_call(id)
	     if r == 3:
		del lines[id]
	     if r == -1:
	        log_stderr_and_syslog("Error for get URL")
	     	del lines[id]

       mng.logoff()

    #except mng.ManagerSocketException, (errno, reason):
    #   print "Error connecting to the manager: %s" % reason
    #   sys.exit(1)
    #except mng.ManagerAuthException, reason:
    #   print "Error logging in to the manager: %s" % reason
    #   sys.exit(1)
    #except mng.ManagerException, reason:
    #   print "Error: %s" % reason
    #   sys.exit(1)
       
finally:
   # remember to clean up
   try:
      mng.close()
   except ami.ManagerSocketException:
      log_stderr_and_syslog("Connexion close")
