#!/usr/bin/python

__version__ = "$Revision$ $Date$"
__license__ = """
    Copyright (C) 2007  Proformatique

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""

PIDFILE = '/var/run/xivo_daemon_bazile.pid'
SYSLOG_NAME = 'xivo_daemon_bazile'

import sys
import time
import Queue
import urllib
import logging
from logging.handlers import SysLogHandler

from xivo import ami
from xivo import daemonize

logging.basicConfig(level=logging.INFO)
log = logging.getLogger("xivo_daemon_bazile")
sysloghandler = SysLogHandler("/dev/log", SysLogHandler.LOG_DAEMON)
sysloghandler.setFormatter(logging.Formatter("%s[%%(process)d]: %%(message)s" % SYSLOG_NAME))
logging.getLogger('').addHandler(sysloghandler)

# Dictionnaire des status Callerid, Channel et status du channel
# identifiant unique UniqID Asterisk
# 0 = appel qui arrive
# 1 = appel decroche
# 2 = appel unlink
# 3 = appel raccroche
lines = {}
idqueue = Queue.Queue()
login = 'jas'
passwd = 'jas'
ip = '127.0.0.1'
key = 'SAD8Z8ZR53D1FZEER872N2QA873'
website = 'http://monbazile.fr/connect.php'

def handle_shutdown(event, mng):
   log.info("Received shutdown event")
   mng.close()
      
def handle_event(event, mng):
   log.info("Received event: %s", event.name)
   log.info(event.headers)

def handle_newchannel(event, mng):
	if event.headers['State'] == 'Ring':
		infos = [event.headers['CallerID'], event.headers['Channel'], '', 0]
		lines[event.headers['Uniqueid']] = infos
		idqueue.put(event.headers['Uniqueid'])

def handle_link(event, mng):
	(tech, chan) = event.headers['Channel2'].split('/')
	c = chan.split('-')
	infos = [event.headers['CallerID1'], event.headers['Channel1'], c[0], 1]
	lines[event.headers['Uniqueid1']] = infos
	idqueue.put(event.headers['Uniqueid1'])

def handle_unlink(event, mng):
	infos = [event.headers['CallerID1'], event.headers['Channel1'], '', 2]
	lines[event.headers['Uniqueid1']] = infos
	idqueue.put(event.headers['Uniqueid1'])

def handle_hangup(event, mng):
	try:
		if event.headers['Channel'] == lines[event.headers['Uniqueid']][1]:
			infos = [lines[event.headers['Uniqueid']][0], event.headers['Channel'], lines[event.headers['Uniqueid']][2], 3]
			lines[event.headers['Uniqueid']] = infos
			idqueue.put(event.headers['Uniqueid'])
	except LookupError:
		# Hangup non correspondant a un appel entrant pour le context actuel
		pass

def url_call(uid):
	url = ''
	response = ''
	callerid = lines[uid][0]
	channel = lines[uid][1]
	operator = lines[uid][2]
	status = lines[uid][3]
	if not 'Zap' in channel:
		return -1
	if len(callerid) < 10:
		callerid = '0%s' % callerid
	if status == 0:
		# Gere en AGI
		log.info("Appel arrive")
		return -1
	if status == 1:
		url = "%s?N=%s&I=%s&W=2&C=%s&E=%s" % (website, callerid, key, channel, operator)
		log.info("Appel decroche")
	if status == 3:
		url = "%s?N=%s&I=%s&W=3&C=%s&E=%s" % (website, callerid, key, channel, operator)
		log.info("Appel hangup")

	if url:
		response = urllib.urlopen(url).read()
		log.info(url)

	if response == "ok":
		return status
	
	return -1

daemonize.daemonize(PIDFILE, True)

log.info("Bazile call center starting")

mng = ami.Manager()
try:
    #try:
       mng.connect(ip) 
       mng.login(login, passwd)

       # register some callbacks
       mng.register_event('Shutdown', handle_shutdown)
       #mng.register_event('*', handle_event)
       mng.register_event('Newchannel', handle_newchannel)
       mng.register_event('Link', handle_link)
       #mng.register_event('Unlink', handle_unlink)
       mng.register_event('Hangup', handle_hangup)

       if mng.version != "1.0":
         log.info("Version Manager error")
	 sys.exit()
       if mng.title != "Asterisk Call Manager":
       	 log.info("Banner Manager error")
	 sys.exit()
        
       # get a status report
       response = mng.status()

       if str(response) != "Success":
       	 log.info("Error Manager is not ready")
	 sys.exit()

       while 1:
	  uniqid = [idqueue.get()]
	  try:
	    while True:
	      uniqid.append(idqueue.get_nowait())
	  except Queue.Empty:
	    pass
	  uniqid.reverse()
	  idx = 0
	  while idx < len(uniqid):
	    one_id = uniqid[idx]
	    other_idx = idx + 1
	    while other_idx < len(uniqid):
	      if uniqid[other_idx] == one_id:
	        del uniqid[other_idx]
	      else:
	        other_idx += 1
            idx += 1
	  uniqid.reverse()

	  for uid in uniqid:
	     r = url_call(uid)
	     if r == 3:
		del lines[uid]
	     if r == -1:
	        log.info("Error for get URL")
	     	del lines[uid]

       mng.logoff()

    #except mng.ManagerSocketException, (errno, reason):
    #   print "Error connecting to the manager: %s" % reason
    #   sys.exit(1)
    #except mng.ManagerAuthException, reason:
    #   print "Error logging in to the manager: %s" % reason
    #   sys.exit(1)
    #except mng.ManagerException, reason:
    #   print "Error: %s" % reason
    #   sys.exit(1)
       
finally:
   # remember to clean up
   try:
      mng.close()
   except ami.ManagerSocketException:
      log.info("Connexion close")
