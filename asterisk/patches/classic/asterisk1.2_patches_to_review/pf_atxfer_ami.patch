2007-10-22  Corentin Le Gall <clegall@proformatique.com>

        pf_atxfer_ami.patch
        $Revision$
        $Date$
        Feature

        The Attended Transfer can be issued with AMI.

        This patch comes from http://bugs.digium.com/view.php?id=10585
	It has been backported to Asterisk 1.2.24

        Patch status: a few tests (OK) have been done, need more statistics

Index: asterisk-1.2.24/channel.c
===================================================================
--- asterisk-1.2.24.orig/channel.c	2007-10-22 15:21:55.000000000 +0200
+++ asterisk-1.2.24/channel.c	2007-10-22 15:21:57.000000000 +0200
@@ -689,6 +689,17 @@
 	return ast_queue_frame(chan, &f);
 }
 
+/*! \brief Queue a control frame with payload */
+int ast_queue_control_data(struct ast_channel *chan, int control,
+			   const void *data, size_t datalen)
+{
+	struct ast_frame f = { AST_FRAME_CONTROL, };
+	f.subclass = control;
+	f.data = (void *) data;
+	f.datalen = datalen;
+	return ast_queue_frame(chan, &f);
+}
+
 /*--- ast_channel_defer_dtmf: Set defer DTMF flag on channel */
 int ast_channel_defer_dtmf(struct ast_channel *chan)
 {
Index: asterisk-1.2.24/manager.c
===================================================================
--- asterisk-1.2.24.orig/manager.c	2007-10-22 15:21:55.000000000 +0200
+++ asterisk-1.2.24/manager.c	2007-10-22 15:21:57.000000000 +0200
@@ -916,6 +916,50 @@
 	return 0;
 }
 
+
+static char mandescr_atxfer[] =
+"Description: do attended transfer.\n"
+"Variables: (Names marked with * are required)\n"
+"	*Channel: transferer Channel\n"
+"	*Exten: Extension to transfer to\n"
+"	Context: Context to transfer to\n"
+"	ActionID: Optional Action id for message matching.\n";
+
+static int action_atxfer(struct mansession *s, const struct message *m)
+{
+	struct ast_channel *c;
+	const char *name = astman_get_header(m, "Channel");
+	const char *exten = astman_get_header(m, "Exten");
+	const char *context = astman_get_header(m, "Context");
+	char *xferto;
+	int len;
+
+	if (ast_strlen_zero(name)) {
+		astman_send_error(s, m, "No channel specified");
+		return 0;
+	}
+	if (ast_strlen_zero(exten)) {
+		astman_send_error(s, m, "No exten specified");
+		return 0;
+	}
+	c = ast_get_channel_by_name_locked(name);
+	if (!c) {
+		astman_send_error(s, m, "No such channel");
+		return 0;
+	}
+	len = asprintf(&xferto, "%s@%s", exten, context);
+	if (len < 0) {
+		astman_send_error(s, m, "Out of memory!");
+		goto cleanup;
+	}
+	ast_queue_control_data(c, AST_CONTROL_ATXFERCMD, xferto, len+1);
+	free(xferto);
+	astman_send_ack(s, m, "Attended transfer started");
+cleanup:
+	ast_mutex_unlock(&c->lock);
+	return 0;
+}
+
 static char mandescr_command[] = 
 "Description: Run a CLI command.\n"
 "Variables: (Names marked with * are required)\n"
@@ -1665,6 +1709,7 @@
 		ast_manager_register2("Setvar", EVENT_FLAG_CALL, action_setvar, "Set Channel Variable", mandescr_setvar );
 		ast_manager_register2("Getvar", EVENT_FLAG_CALL, action_getvar, "Gets a Channel Variable", mandescr_getvar );
 		ast_manager_register2("Redirect", EVENT_FLAG_CALL, action_redirect, "Redirect (transfer) a call", mandescr_redirect );
+		ast_manager_register2("Atxfer", EVENT_FLAG_CALL, action_atxfer, "Attended transfer", mandescr_atxfer );
 		ast_manager_register2("Originate", EVENT_FLAG_CALL, action_originate, "Originate Call", mandescr_originate);
 		ast_manager_register2("Command", EVENT_FLAG_COMMAND, action_command, "Execute Asterisk CLI Command", mandescr_command );
 		ast_manager_register2("ExtensionState", EVENT_FLAG_CALL, action_extensionstate, "Check Extension Status", mandescr_extensionstate );
Index: asterisk-1.2.24/include/asterisk/channel.h
===================================================================
--- asterisk-1.2.24.orig/include/asterisk/channel.h	2007-10-22 15:21:55.000000000 +0200
+++ asterisk-1.2.24/include/asterisk/channel.h	2007-10-22 15:21:57.000000000 +0200
@@ -555,6 +555,9 @@
 /*! \brief Queue a control frame */
 int ast_queue_control(struct ast_channel *chan, int control);
 
+/*! \brief Queue a control frame with payload */
+int ast_queue_control_data(struct ast_channel *chan, int control,
+                           const void *data, size_t datalen);
 
 /*! \brief Change channel name */
 void ast_change_name(struct ast_channel *chan, char *newname);
Index: asterisk-1.2.24/include/asterisk/frame.h
===================================================================
--- asterisk-1.2.24.orig/include/asterisk/frame.h	2007-10-22 15:21:55.000000000 +0200
+++ asterisk-1.2.24/include/asterisk/frame.h	2007-10-22 15:21:57.000000000 +0200
@@ -243,6 +243,8 @@
 #define AST_CONTROL_UNHOLD			17
 /*! Indicate video frame update */
 #define AST_CONTROL_VIDUPDATE		18
+/*! AMI triggered attended transfer */
+#define AST_CONTROL_ATXFERCMD           19
 
 #define AST_SMOOTHER_FLAG_G729		(1 << 0)
 
Index: asterisk-1.2.24/include/asterisk/strings.h
===================================================================
--- asterisk-1.2.24.orig/include/asterisk/strings.h	2007-10-22 15:21:55.000000000 +0200
+++ asterisk-1.2.24/include/asterisk/strings.h	2007-10-22 15:21:57.000000000 +0200
@@ -35,6 +35,8 @@
 	return (!s || (*s == '\0'));
 }
 
+#define S_OR(a, b)    (!ast_strlen_zero(a) ? (a) : (b))
+
 /*!
   \brief Gets a pointer to the first non-whitespace character in a string.
   \param ast_skip_blanks function being used
Index: asterisk-1.2.24/CREDITS
===================================================================
--- asterisk-1.2.24.orig/CREDITS	2007-10-22 15:21:55.000000000 +0200
+++ asterisk-1.2.24/CREDITS	2007-10-22 15:21:57.000000000 +0200
@@ -87,6 +87,7 @@
 Steve Murphy - privacy support
 Claude Patry - bug fixes, feature enhancements, and bug marshalling
 	cpatry@gmail.com
+Paolo Ornati - export Attended Transfer feature over Manager Interface
 
 === OTHER CONTRIBUTIONS ===
 John Todd - Monkey sounds and associated teletorture prompt
Index: asterisk-1.2.24/res/res_features.c
===================================================================
--- asterisk-1.2.24.orig/res/res_features.c	2007-10-22 15:21:55.000000000 +0200
+++ asterisk-1.2.24/res/res_features.c	2007-10-22 15:21:57.000000000 +0200
@@ -663,15 +663,18 @@
 	return FEATURE_RETURN_SUCCESS;
 }
 
-static int builtin_atxfer(struct ast_channel *chan, struct ast_channel *peer, struct ast_bridge_config *config, char *code, int sense)
+static int do_atxfer(struct ast_channel *chan, struct ast_channel *peer, struct ast_bridge_config *config, int sense,
+                     const char *toExt, const char *toCont)
 {
 	struct ast_channel *transferer;
 	struct ast_channel *transferee;
 	struct ast_channel *newchan, *xferchan=NULL;
 	int outstate=0;
 	struct ast_bridge_config bconfig;
-	char *transferer_real_context;
-	char xferto[256],dialstr[265];
+	const char * transferer_real_context;
+	const char * transfer_context;
+	char xferto[256];
+        char dialstr[256];
 	char *cid_num;
 	char *cid_name;
 	int res;
@@ -686,171 +689,182 @@
 		transferer = chan;
 		transferee = peer;
 	}
-	if (!(transferer_real_context=pbx_builtin_getvar_helper(transferee, "TRANSFER_CONTEXT")) &&
-	   !(transferer_real_context=pbx_builtin_getvar_helper(transferer, "TRANSFER_CONTEXT"))) {
+	if (!(transferer_real_context = pbx_builtin_getvar_helper(transferee, "TRANSFER_CONTEXT")) &&
+	   !(transferer_real_context = pbx_builtin_getvar_helper(transferer, "TRANSFER_CONTEXT"))) {
 		/* Use the non-macro context to transfer the call */
 		if (!ast_strlen_zero(transferer->macrocontext))
 			transferer_real_context = transferer->macrocontext;
 		else
 			transferer_real_context = transferer->context;
 	}
+
+        transfer_context = S_OR(toCont, transferer_real_context);
+
 	/* Start autoservice on chan while we talk
 	   to the originator */
 	ast_indicate(transferee, AST_CONTROL_HOLD);
 	ast_autoservice_start(transferee);
 	ast_moh_start(transferee, NULL);
 	memset(xferto, 0, sizeof(xferto));
-	/* Transfer */
-	if ((res = ast_streamfile(transferer, "pbx-transfer", transferer->language))) {
-		ast_moh_stop(transferee);
-		ast_autoservice_stop(transferee);
-		ast_indicate(transferee, AST_CONTROL_UNHOLD);
-		return res;
-	}
-	if ((res=ast_waitstream(transferer, AST_DIGIT_ANY)) < 0) {
-		ast_moh_stop(transferee);
-		ast_autoservice_stop(transferee);
-		ast_indicate(transferee, AST_CONTROL_UNHOLD);
-		return res;
-	} else if(res > 0) {
-		/* If they've typed a digit already, handle it */
-		xferto[0] = (char) res;
-	}
-	if ((ast_app_dtget(transferer, transferer_real_context, xferto, sizeof(xferto), 100, transferdigittimeout))) {
-		cid_num = transferer->cid.cid_num;
-		cid_name = transferer->cid.cid_name;
-		if (ast_exists_extension(transferer, transferer_real_context,xferto, 1, cid_num)) {
-			snprintf(dialstr, sizeof(dialstr), "%s@%s/n", xferto, transferer_real_context);
-			newchan = ast_feature_request_and_dial(transferer, "Local", ast_best_codec(transferer->nativeformats), dialstr, 15000, &outstate, cid_num, cid_name);
-			ast_indicate(transferer, -1);
-			if (newchan) {
-				res = ast_channel_make_compatible(transferer, newchan);
-				if (res < 0) {
-					ast_log(LOG_WARNING, "Had to drop call because I couldn't make %s compatible with %s\n", transferer->name, newchan->name);
-					ast_hangup(newchan);
-					return -1;
-				}
-				memset(&bconfig,0,sizeof(struct ast_bridge_config));
-				ast_set_flag(&(bconfig.features_caller), AST_FEATURE_DISCONNECT);
-				ast_set_flag(&(bconfig.features_callee), AST_FEATURE_DISCONNECT);
-				res = ast_bridge_call(transferer,newchan,&bconfig);
-				if (newchan->_softhangup || !transferer->_softhangup) {
-					ast_hangup(newchan);
-					if (f) {
-						ast_frfree(f);
-						f = NULL;
-					}
-					if (!ast_strlen_zero(xfersound) && !ast_streamfile(transferer, xfersound, transferer->language)) {
-						if (ast_waitstream(transferer, "") < 0) {
-							ast_log(LOG_WARNING, "Failed to play transfer sound!\n");
-						}
-					}
-					ast_moh_stop(transferee);
-					ast_autoservice_stop(transferee);
-					ast_indicate(transferee, AST_CONTROL_UNHOLD);
-					transferer->_softhangup = 0;
-					return FEATURE_RETURN_SUCCESS;
-				}
-				
-				res = ast_channel_make_compatible(transferee, newchan);
-				if (res < 0) {
-					ast_log(LOG_WARNING, "Had to drop call because I couldn't make %s compatible with %s\n", transferee->name, newchan->name);
-					ast_hangup(newchan);
-					return -1;
-				}
-				
-				
-				ast_moh_stop(transferee);
-				ast_indicate(transferee, AST_CONTROL_UNHOLD);
-				
-				if ((ast_autoservice_stop(transferee) < 0)
-				   || (ast_waitfordigit(transferee, 100) < 0)
-				   || (ast_waitfordigit(newchan, 100) < 0) 
-				   || ast_check_hangup(transferee) 
-				   || ast_check_hangup(newchan)) {
-					ast_hangup(newchan);
-					res = -1;
-					return -1;
-				}
 
-				if ((xferchan = ast_channel_alloc(0))) {
-					snprintf(xferchan->name, sizeof (xferchan->name), "Transfered/%s",transferee->name);
-					/* Make formats okay */
-					xferchan->readformat = transferee->readformat;
-					xferchan->writeformat = transferee->writeformat;
-					ast_channel_masquerade(xferchan, transferee);
-					ast_explicit_goto(xferchan, transferee->context, transferee->exten, transferee->priority);
-					xferchan->_state = AST_STATE_UP;
-					ast_clear_flag(xferchan, AST_FLAGS_ALL);	
-					xferchan->_softhangup = 0;
+	if (!ast_strlen_zero(toExt)) {
+		ast_copy_string(xferto, toExt, sizeof(xferto));
+	} else {
+                /* Ask for extension to transfer to on the transferer channel */
+                if ((res = ast_streamfile(transferer, "pbx-transfer", transferer->language))) {
+                        ast_moh_stop(transferee);
+                        ast_autoservice_stop(transferee);
+                        ast_indicate(transferee, AST_CONTROL_UNHOLD);
+                        return res;
+                }
+                if ((res=ast_waitstream(transferer, AST_DIGIT_ANY)) < 0) {
+                        ast_moh_stop(transferee);
+                        ast_autoservice_stop(transferee);
+                        ast_indicate(transferee, AST_CONTROL_UNHOLD);
+                        return res;
+                } else if(res > 0) {
+                        /* If they've typed a digit already, handle it */
+                        xferto[0] = (char) res;
+                }
+                res = ast_app_dtget(transferer, transfer_context, xferto, sizeof(xferto), 100, transferdigittimeout);
+                if (res == 0) {
+                        ast_log(LOG_WARNING, "Did not read data.\n");
+                        ast_moh_stop(transferee);
+                        ast_autoservice_stop(transferee);
+                        ast_indicate(transferee, AST_CONTROL_UNHOLD);
+                        res = ast_streamfile(transferer, "beeperr", transferer->language);
+                        if (ast_waitstream(transferer, "") < 0) {
+                                return -1;
+                        }
+                        return FEATURE_RETURN_SUCCESS;
+                }
+        }
 
-					if ((f = ast_read(xferchan))) {
-						ast_frfree(f);
-						f = NULL;
-					}
-					
-				} else {
-					ast_hangup(newchan);
-					return -1;
-				}
+        cid_num = transferer->cid.cid_num;
+        cid_name = transferer->cid.cid_name;
+        if (ast_exists_extension(transferer, transfer_context,xferto, 1, cid_num)) {
+                snprintf(dialstr, sizeof(dialstr), "%s@%s/n", xferto, transfer_context);
+                newchan = ast_feature_request_and_dial(transferer, "Local", ast_best_codec(transferer->nativeformats), dialstr, 15000, &outstate, cid_num, cid_name);
+                ast_indicate(transferer, -1);
+                if (newchan) {
+                        res = ast_channel_make_compatible(transferer, newchan);
+                        if (res < 0) {
+                                ast_log(LOG_WARNING, "Had to drop call because I couldn't make %s compatible with %s\n", transferer->name, newchan->name);
+                                ast_hangup(newchan);
+                                return -1;
+                        }
+                        memset(&bconfig,0,sizeof(struct ast_bridge_config));
+                        ast_set_flag(&(bconfig.features_caller), AST_FEATURE_DISCONNECT);
+                        ast_set_flag(&(bconfig.features_callee), AST_FEATURE_DISCONNECT);
+                        res = ast_bridge_call(transferer,newchan,&bconfig);
+                        if (newchan->_softhangup || !transferer->_softhangup) {
+                                ast_hangup(newchan);
+                                if (f) {
+                                        ast_frfree(f);
+                                        f = NULL;
+                                }
+                                if (!ast_strlen_zero(xfersound) && !ast_streamfile(transferer, xfersound, transferer->language)) {
+                                        if (ast_waitstream(transferer, "") < 0) {
+                                                ast_log(LOG_WARNING, "Failed to play transfer sound!\n");
+                                        }
+                                }
+                                ast_moh_stop(transferee);
+                                ast_autoservice_stop(transferee);
+                                ast_indicate(transferee, AST_CONTROL_UNHOLD);
+                                transferer->_softhangup = 0;
+					return FEATURE_RETURN_SUCCESS;
+                        }
+
+                        res = ast_channel_make_compatible(transferee, newchan);
+                        if (res < 0) {
+                                ast_log(LOG_WARNING, "Had to drop call because I couldn't make %s compatible with %s\n", transferee->name, newchan->name);
+                                ast_hangup(newchan);
+                                return -1;
+                        }
+
+
+                        ast_moh_stop(transferee);
+                        ast_indicate(transferee, AST_CONTROL_UNHOLD);
+
+                        if ((ast_autoservice_stop(transferee) < 0)
+                            || (ast_waitfordigit(transferee, 100) < 0)
+                            || (ast_waitfordigit(newchan, 100) < 0)
+                            || ast_check_hangup(transferee)
+                            || ast_check_hangup(newchan)) {
+                                ast_hangup(newchan);
+                                res = -1;
+                                return -1;
+                        }
+
+                        if ((xferchan = ast_channel_alloc(0))) {
+                                snprintf(xferchan->name, sizeof (xferchan->name), "Transfered/%s",transferee->name);
+                                /* Make formats okay */
+                                xferchan->readformat = transferee->readformat;
+                                xferchan->writeformat = transferee->writeformat;
+                                ast_channel_masquerade(xferchan, transferee);
+                                ast_explicit_goto(xferchan, transferee->context, transferee->exten, transferee->priority);
+                                xferchan->_state = AST_STATE_UP;
+                                ast_clear_flag(xferchan, AST_FLAGS_ALL);
+                                xferchan->_softhangup = 0;
+
+                                if ((f = ast_read(xferchan))) {
+                                        ast_frfree(f);
+                                        f = NULL;
+                                }
+
+                        } else {
+                                ast_hangup(newchan);
+                                return -1;
+                        }
+
+                        newchan->_state = AST_STATE_UP;
+                        ast_clear_flag(newchan, AST_FLAGS_ALL);
+                        newchan->_softhangup = 0;
+
+                        tobj = malloc(sizeof(struct ast_bridge_thread_obj));
+                        if (tobj) {
+                                memset(tobj,0,sizeof(struct ast_bridge_thread_obj));
+                                tobj->chan = xferchan;
+                                tobj->peer = newchan;
+                                tobj->bconfig = *config;
+
+                                if (!ast_strlen_zero(xfersound) && !ast_streamfile(newchan, xfersound, newchan->language)) {
+                                        if (ast_waitstream(newchan, "") < 0) {
+                                                ast_log(LOG_WARNING, "Failed to play transfer sound!\n");
+                                        }
+                                }
+                                ast_bridge_call_thread_launch(tobj);
+                        } else {
+                                ast_log(LOG_WARNING, "Out of memory!\n");
+                                ast_hangup(xferchan);
+                                ast_hangup(newchan);
+                        }
+                        return -1;
+
+                } else {
+                        ast_moh_stop(transferee);
+                        ast_autoservice_stop(transferee);
+                        ast_indicate(transferee, AST_CONTROL_UNHOLD);
+                        /* any reason besides user requested cancel and busy triggers the failed sound */
+                        if (outstate != AST_CONTROL_UNHOLD && outstate != AST_CONTROL_BUSY && !ast_strlen_zero(xferfailsound)) {
+                                res = ast_streamfile(transferer, xferfailsound, transferer->language);
+                                if (!res && (ast_waitstream(transferer, "") < 0)) {
+                                        return -1;
+                                }
+                        }
+                        return FEATURE_RETURN_SUCCESS;
+                }
+        } else {
+                ast_log(LOG_WARNING, "Extension %s does not exist in context %s\n",xferto,transfer_context);
+                ast_moh_stop(transferee);
+                ast_autoservice_stop(transferee);
+                ast_indicate(transferee, AST_CONTROL_UNHOLD);
+                res = ast_streamfile(transferer, "beeperr", transferer->language);
+                if (!res && (ast_waitstream(transferer, "") < 0)) {
+                        return -1;
+                }
+        }
 
-				newchan->_state = AST_STATE_UP;
-				ast_clear_flag(newchan, AST_FLAGS_ALL);	
-				newchan->_softhangup = 0;
-
-				tobj = malloc(sizeof(struct ast_bridge_thread_obj));
-				if (tobj) {
-					memset(tobj,0,sizeof(struct ast_bridge_thread_obj));
-					tobj->chan = xferchan;
-					tobj->peer = newchan;
-					tobj->bconfig = *config;
-	
-					if (!ast_strlen_zero(xfersound) && !ast_streamfile(newchan, xfersound, newchan->language)) {
-						if (ast_waitstream(newchan, "") < 0) {
-							ast_log(LOG_WARNING, "Failed to play transfer sound!\n");
-						}
-					}
-					ast_bridge_call_thread_launch(tobj);
-				} else {
-					ast_log(LOG_WARNING, "Out of memory!\n");
-					ast_hangup(xferchan);
-					ast_hangup(newchan);
-				}
-				return -1;
-				
-			} else {
-				ast_moh_stop(transferee);
-				ast_autoservice_stop(transferee);
-				ast_indicate(transferee, AST_CONTROL_UNHOLD);
-				/* any reason besides user requested cancel and busy triggers the failed sound */
-				if (outstate != AST_CONTROL_UNHOLD && outstate != AST_CONTROL_BUSY && !ast_strlen_zero(xferfailsound)) {
-					res = ast_streamfile(transferer, xferfailsound, transferer->language);
-					if (!res && (ast_waitstream(transferer, "") < 0)) {
-						return -1;
-					}
-				}
-				return FEATURE_RETURN_SUCCESS;
-			}
-		} else {
-			ast_log(LOG_WARNING, "Extension %s does not exist in context %s\n",xferto,transferer_real_context);
-			ast_moh_stop(transferee);
-			ast_autoservice_stop(transferee);
-			ast_indicate(transferee, AST_CONTROL_UNHOLD);
-			res = ast_streamfile(transferer, "beeperr", transferer->language);
-			if (!res && (ast_waitstream(transferer, "") < 0)) {
-				return -1;
-			}
-		}
-	}  else {
-		ast_log(LOG_WARNING, "Did not read data.\n");
-		ast_moh_stop(transferee);
-		ast_autoservice_stop(transferee);
-		ast_indicate(transferee, AST_CONTROL_UNHOLD);
-		res = ast_streamfile(transferer, "beeperr", transferer->language);
-		if (ast_waitstream(transferer, "") < 0) {
-			return -1;
-		}
-	}
 	ast_moh_stop(transferee);
 	ast_autoservice_stop(transferee);
 	ast_indicate(transferee, AST_CONTROL_UNHOLD);
@@ -858,6 +872,19 @@
 	return FEATURE_RETURN_SUCCESS;
 }
 
+static int builtin_atxfer(struct ast_channel *chan, struct ast_channel *peer, struct ast_bridge_config *config, char *code, int sense)
+{
+	return do_atxfer(chan, peer, config, sense, NULL, NULL);
+}
+
+static void cmd_atxfer(struct ast_channel *a, struct ast_channel *b, struct ast_bridge_config *conf, struct ast_channel *who, char *xferto)
+{
+        int sense = (a == who) ? FEATURE_SENSE_CHAN : FEATURE_SENSE_PEER;
+        char *context = strchr(xferto, '@');;
+        if (context)
+                *context++ = '\0';
+        do_atxfer(a, b, conf, sense, xferto, context);
+}
 
 /* add atxfer and automon as undefined so you can only use em if you configure them */
 #define FEATURES_COUNT (sizeof(builtin_features) / sizeof(builtin_features[0]))
@@ -1410,6 +1437,9 @@
 			else
 				ast_indicate(chan, AST_CONTROL_FLASH);
 		}
+		if ((f->frametype == AST_FRAME_CONTROL) && (f->subclass == AST_CONTROL_ATXFERCMD)) {
+			cmd_atxfer(chan, peer, config, who, f->data);
+		}
 		if ((f->frametype == AST_FRAME_CONTROL) && (f->subclass == AST_CONTROL_OPTION)) {
 			aoh = f->data;
 			/* Forward option Requests */
