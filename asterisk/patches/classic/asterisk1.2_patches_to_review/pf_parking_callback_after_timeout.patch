2007-10-20  Guillaume Knispel <gknispel@proformatique.com>

	pf_parking_callback_after_timeout.patch
	$Revision$
	$Date$
	Bugfix / Behavioral change
	
	When parked by an AMI Redirect, the right peer is set to be called back
	once the timeout is done.
	Without this patch it seems that the parked side tries to call itself
	back when the timeout expires, which is kind of a really strange
	behavior :) This is because, as the Redirect message is completely
	asynchronous to an existing bridge between two chans, one of which
	being the target of the call transfer, the implementation has no other
	choice than doing a masquerade which will both send the target to a new
	context / exten / priority and make it appears having hung up to the
	other side of the bridge. The "put in parking" code then wrongly
	understand that the target chan is going to the parking all by itself
	and should be resent to its previous extension when the timeout
	expires.
	We are using the fact that BRIDGEPEER is only updated if a new bridging
	occurs involving the target chan, and is never deleted. So in
	ast_park_call() if BRIDGEPEER is present it means we just have been
	parked by a third party while being bridge with somebody, so it seems
	more reasonnable to behave as if our previous peer just parked us,
	instead of the "we parked ourself" default.
	Default is still taken anyway if the BRIDGEPEER variable is absent.

	Patch status: known as OK on 2007-11-03

Index: asterisk-1.2.27/res/res_features.c
===================================================================
--- asterisk-1.2.27.orig/res/res_features.c	2008-03-19 11:32:20.000000000 +0100
+++ asterisk-1.2.27/res/res_features.c	2008-03-19 11:34:11.000000000 +0100
@@ -280,6 +280,7 @@
 	struct parkeduser *pu, *cur;
 	int i,x,parking_range;
 	char exten[AST_MAX_EXTENSION];
+        char peername[AST_CHANNEL_NAME];
 	struct ast_context *con;
 
 	pu = malloc(sizeof(struct parkeduser));
@@ -327,8 +328,16 @@
 		pu->parkingtime = parkingtime;
 	if (extout)
 		*extout = x;
-	if (peer) 
-		ast_copy_string(pu->peername, peer->name, sizeof(pu->peername));
+        if (peer) {
+                const char *bridgepeer = pbx_builtin_getvar_helper(chan, "BRIDGEPEER");
+                /* If (chan == peer) (which occurs in the case of an Originate action), we fill the peername in order
+                   for the right peer to be called back after the parking's timeout */
+                if ((chan == peer) && bridgepeer)
+                        ast_copy_string(peername, bridgepeer, sizeof(peername));
+                else
+                        ast_copy_string(peername, peer->name, sizeof(peername));
+                ast_copy_string(pu->peername, peername, sizeof(pu->peername));
+        }
 
 	/* Remember what had been dialed, so that if the parking
 	   expires, we try to come back to the same place */
@@ -362,7 +371,7 @@
 		"Timeout: %ld\r\n"
 		"CallerID: %s\r\n"
 		"CallerIDName: %s\r\n"
-		,pu->parkingnum, pu->chan->name, peer ? peer->name : ""
+		,pu->parkingnum, pu->chan->name, peer ? peername : ""
 		,(long)pu->start.tv_sec + (long)(pu->parkingtime/1000) - (long)time(NULL)
 		,(pu->chan->cid.cid_num ? pu->chan->cid.cid_num : "<unknown>")
 		,(pu->chan->cid.cid_name ? pu->chan->cid.cid_name : "<unknown>")
