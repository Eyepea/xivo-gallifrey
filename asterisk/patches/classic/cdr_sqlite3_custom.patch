## /bin/sh -e simulate dpatch for prepend_chlog.py
## Feature
## DP: CDR in SQLite3

Index: asterisk-1.2.24.dfsg+pf.0.1~svn1329/cdr/Makefile
===================================================================
--- asterisk-1.2.24.dfsg+pf.0.1~svn1329.orig/cdr/Makefile	2007-08-08 14:42:39.000000000 +0200
+++ asterisk-1.2.24.dfsg+pf.0.1~svn1329/cdr/Makefile	2007-08-08 14:43:13.000000000 +0200
@@ -110,6 +110,9 @@
 ifneq ($(wildcard $(CROSS_COMPILE_TARGET)/usr/include/sqlite.h),)
   MODS+=cdr_sqlite.so
 endif
+ifneq ($(wildcard $(CROSS_COMPILE_TARGET)/usr/include/sqlite3.h),)
+  MODS+=cdr_sqlite3_custom.so
+endif
 
 all: depend $(MODS)
 
@@ -138,6 +141,9 @@
 cdr_sqlite.so: cdr_sqlite.o
 	$(CC) $(SOLINK) -o $@ ${CYGSOLINK} $< ${CYGSOLIB} -lsqlite $(MLFLAGS)
 
+cdr_sqlite3_custom.so: cdr_sqlite3_custom.o
+	$(CC) $(SOLINK) -o $@ ${CYGSOLINK} $< ${CYGSOLIB} -lsqlite3 $(MLFLAGS)
+
 depend: .depend
 
 .depend:
Index: asterisk-1.2.24.dfsg+pf.0.1~svn1329/cdr/cdr_sqlite3_custom.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ asterisk-1.2.24.dfsg+pf.0.1~svn1329/cdr/cdr_sqlite3_custom.c	2007-08-08 14:43:13.000000000 +0200
@@ -0,0 +1,251 @@
+/*
+ * Asterisk -- An open source telephony toolkit.
+ *
+ * Copyright (C) 1999 - 2005, Digium, Inc.
+ *
+ * Mark Spencer <markster@digium.com> and others.
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+/*! \file
+ *
+ * \brief Custom SQLite3 CDR records.
+ *
+ * \author Adapted by Alejandro Rios <alejandro.rios@avatar.com.co> from 
+ *  cdr_mysql_custom by Edward Eastman <ed@dm3.co.uk>,
+ *	and cdr_sqlite by Holger Schurig <hs4233@mail.mn-solutions.de>
+ *	
+ *
+ * \arg See also \ref AstCDR
+ *
+ *
+ * \ingroup cdr_drivers
+ */
+
+/*** moduleinfo
+	<depend>sqlite3</depend>
+ ***/
+
+#include <sys/types.h>
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <time.h>
+#include <sqlite3.h>
+
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 7221 $")
+#include "asterisk/channel.h"
+#include "asterisk/cdr.h"
+#include "asterisk/module.h"
+#include "asterisk/config.h"
+#include "asterisk/pbx.h"
+#include "asterisk/logger.h"
+#include "asterisk/utils.h"
+#include "asterisk/cli.h"
+#include "asterisk/options.h"
+AST_MUTEX_DEFINE_STATIC(lock);
+
+static char *desc = "Customizable SQLite3 CDR Backend";
+
+static char *name = "cdr_sqlite3_custom";
+
+static sqlite3 *db = NULL;
+
+static char table[80];
+static char columns[1024];
+static char values[1024];
+
+static int load_config(int reload)
+{
+	struct ast_config *cfg;
+	struct ast_variable *mappingvar;
+	char *tmp;
+	int res = -1;
+
+	if ((cfg = ast_config_load("cdr_sqlite3_custom.conf"))) {
+		if (reload != 1) {
+			ast_mutex_lock(&lock);
+		}
+		mappingvar = ast_variable_browse(cfg, "master");
+		if (!mappingvar) {
+			/* nothing configured */
+			return 0;
+		}
+		/* Mapping must have a table name */
+		tmp = ast_variable_retrieve(cfg, "master", "table");
+		if (!ast_strlen_zero(tmp)) {
+			ast_copy_string(table, tmp, sizeof(table));
+		} else {
+			ast_log(LOG_WARNING, "%s: Table name not specified.  Assuming cdr.\n", name);
+			strcpy(table, "cdr");
+		}
+		tmp = ast_variable_retrieve(cfg, "master", "columns");
+		if (!ast_strlen_zero(tmp)) {
+			ast_copy_string(columns, tmp, sizeof(columns));
+		} else {
+			ast_log(LOG_WARNING, "%s: Column names not specified. Module not loaded.\n",
+					name);
+			return -1;
+		}
+		tmp = ast_variable_retrieve(cfg, "master", "values");
+		if (!ast_strlen_zero(tmp)) {
+			ast_copy_string(values, tmp, sizeof(values));
+		} else {
+			ast_log(LOG_WARNING, "%s: Values not specified. Module not loaded.\n", name);
+			return -1;
+		}
+
+		if (reload != 1) {
+			ast_mutex_unlock(&lock);
+		}
+
+		ast_config_destroy(cfg);
+
+		res = 0;
+
+	} else {
+		if (reload)
+			ast_log(LOG_WARNING, "%s: Failed to reload configuration file.\n", name);
+		else
+			ast_log(LOG_WARNING,
+					"%s: Failed to load configuration file. Module not activated.\n",
+					name);
+	}
+
+	return res;
+}
+
+static int sqlite3_log(struct ast_cdr *cdr)
+{
+	int res = 0;
+	char *zErr = 0;
+
+	/* Make sure we have a big enough buf */
+	char sql_insert_cmd[2048];
+	char sql_tmp_cmd[1024];
+	snprintf(sql_tmp_cmd, sizeof(sql_tmp_cmd), "INSERT INTO %s (%s) VALUES (%s)", table,
+			 columns, values);
+	struct ast_channel dummy;
+
+	int count = 0;
+
+	memset(sql_insert_cmd, 0, sizeof(sql_insert_cmd));
+	/* Not quite the first use of a static struct ast_channel, we need it so the var funcs will work */
+	memset(&dummy, 0, sizeof(dummy));
+	dummy.cdr = cdr;
+	pbx_substitute_variables_helper(&dummy, sql_tmp_cmd, sql_insert_cmd,
+									sizeof(sql_insert_cmd) - 1);
+
+	ast_mutex_lock(&lock);
+
+	for (count = 0; count < 5; count++) {
+		res = sqlite3_exec(db, sql_insert_cmd, NULL, NULL, &zErr);
+		if (res != SQLITE_BUSY && res != SQLITE_LOCKED)
+			break;
+		usleep(200);
+	}
+
+	if (zErr) {
+		ast_log(LOG_ERROR, "%s: %s. sentence: %s.\n", name, zErr, sql_insert_cmd);
+		free(zErr);
+	}
+
+	ast_mutex_unlock(&lock);
+	return res;
+}
+
+char *description(void)
+{
+	return desc;
+}
+
+int unload_module(void)
+{
+	if (db)
+		sqlite3_close(db);
+	ast_cdr_unregister(name);
+	return 0;
+}
+
+int load_module(void)
+{
+	char *zErr;
+	char fn[PATH_MAX];
+	int res;
+
+	if (!load_config(0)) {
+		res = ast_cdr_register(name, desc, sqlite3_log);
+		if (res) {
+			ast_log(LOG_ERROR, "%s: Unable to register custom SQLite3 CDR handling\n",
+					name);
+			return -1;
+		}
+	}
+
+	/* is the database there? */
+	snprintf(fn, sizeof(fn), "%s/master.db", ast_config_AST_LOG_DIR);
+	res = sqlite3_open(fn, &db);
+	if (!db) {
+		ast_log(LOG_ERROR, "%s: Could not open database %s.\n", name, fn);
+		free(zErr);
+		return -1;
+	}
+
+	/* is the table there? */
+	res = sqlite3_exec(db, "SELECT COUNT(AcctId) FROM %s;", NULL, NULL, NULL), table;
+	if (res) {
+		char sql_create_cmd[1024];
+		snprintf(sql_create_cmd, sizeof(sql_create_cmd),
+				 "CREATE TABLE %s (AcctId INTEGER PRIMARY KEY,%s)", table, columns);
+		res = sqlite3_exec(db, sql_create_cmd, NULL, NULL, &zErr);
+		if (zErr) {
+			ast_log(LOG_WARNING, "%s: %s.\n", name, zErr);
+			free(zErr);
+			return 0;
+		}
+
+		if (res) {
+			ast_log(LOG_ERROR, "%s: Unable to create table '%s': %s.\n", name, table,
+					zErr);
+			free(zErr);
+			if (db)
+				sqlite3_close(db);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+int reload(void)
+{
+	int res = 0;
+	ast_mutex_lock(&lock);
+	res = load_config(1);
+	ast_mutex_unlock(&lock);
+	return res;
+}
+
+int usecount(void)
+{
+	return 0;
+}
+
+char *key(void)
+{
+	return ASTERISK_GPL_KEY;
+}
