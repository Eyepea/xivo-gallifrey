## /bin/sh -e simulate dpatch for prepend_chlog.py
## Feature
## func_odbc_12.dpatch by Tzafrir Cohen <tzafrir.cohen@xorcom.com>
## DP: The backport of func_odbc from
## DP: http://svncommunity.digium.com/svn/func_odbc/1.2/ , revision 9
## DP: Code will be merged into trunk in 1.4.

Index: asterisk-1.2.27/configs/func_odbc.conf.sample
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ asterisk-1.2.27/configs/func_odbc.conf.sample	2008-03-19 11:33:11.000000000 +0100
@@ -0,0 +1,38 @@
+;
+; func_odbc.conf
+;
+; Each context is a separately defined function.  By convention, all
+; functions are entirely uppercase, so the defined contexts should also
+; be all-uppercase, but there is nothing that enforces this.  All functions
+; are case-sensitive, however.
+;
+; For substitution, you have ${ARG1}, ${ARG2} ... ${ARGn}
+; for the arguments to each SQL statement.
+;
+; In addition, for write statements, you have ${VAL1}, ${VAL2} ... ${VALn}
+; parsed, just like arguments, for the values.  In addition, if you want the
+; whole value, never mind the parsing, you can get that with ${VALUE}.
+;
+;
+; If you have data which may potentially contain single ticks, you may wish
+; to use the dialplan function SQL_ESC() to escape the data prior to its
+; inclusion in the SQL statement.
+
+
+; ODBC_SQL - Allow an SQL statement to be built entirely in the dialplan
+[SQL]
+dsn=mysql1
+read=${ARG1}
+
+; ODBC_ANTIGF - A blacklist.
+[ANTIGF]
+dsn=mysql1
+read=SELECT COUNT(*) FROM exgirlfriends WHERE callerid='${SQL_ESC(${ARG1})}'
+
+; ODBC_PRESENCE - Retrieve and update presence
+[PRESENCE]
+dsn=mysql1
+read=SELECT location FROM presence WHERE id='${SQL_ESC(${ARG1})}'
+write=UPDATE presence SET location='${SQL_ESC(${VAL1})}' WHERE id='${SQL_ESC(${ARG1})}'
+;prefix=OFFICE		; Changes this function from ODBC_PRESENCE to OFFICE_PRESENCE
+
Index: asterisk-1.2.27/funcs/func_array.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ asterisk-1.2.27/funcs/func_array.c	2008-03-19 11:33:11.000000000 +0100
@@ -0,0 +1,191 @@
+/*
+ * Asterisk -- An open source telephony toolkit.
+ *
+ * Copyright (C) 2005, Tilghman Lesher.
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+/*! \file
+ *
+ * \brief ARRAY dialplan function
+ *
+ * \author Tilghman Lesher
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sched.h>
+
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 20003 $")
+
+#include "asterisk/module.h"
+#include "asterisk/channel.h"
+#include "asterisk/pbx.h"
+#include "asterisk/logger.h"
+#include "asterisk/utils.h"
+#include "asterisk/app.h"
+#include "asterisk/localtime.h"
+
+AST_MUTEX_DEFINE_STATIC(local_lock);
+static int use_count = 0;
+
+static unsigned int trunk_app_separate_args(char *buf, char delim, char **array, int arraylen)
+{
+	int argc;
+	char *scan;
+	int paren = 0, quote = 0;
+
+	if (!buf || !array || !arraylen)
+		return 0;
+
+	memset(array, 0, arraylen * sizeof(*array));
+
+	scan = buf;
+
+	for (argc = 0; *scan && (argc < arraylen - 1); argc++) {
+		array[argc] = scan;
+		for (; *scan; scan++) {
+			if (*scan == '(')
+				paren++;
+			else if (*scan == ')') {
+				if (paren)
+					paren--;
+			} else if (*scan == '"') {
+				quote = quote ? 0 : 1;
+				/* Remove quote character from argument */
+				memmove(scan, scan + 1, strlen(scan));
+				scan--;
+			} else if (*scan == '\\') {
+				/* Literal character, don't parse */
+				memmove(scan, scan + 1, strlen(scan));
+			} else if ((*scan == delim) && !paren && !quote) {
+				*scan++ = '\0';
+				break;
+			}
+		}
+	}
+
+	if (*scan)
+		array[argc++] = scan;
+
+	return argc;
+}
+
+static void array(struct ast_channel *chan, char *cmd, char *var, const char *value)
+{
+	AST_DECLARE_APP_ARGS(arg1,
+			     AST_APP_ARG(var)[100];
+	);
+	AST_DECLARE_APP_ARGS(arg2,
+			     AST_APP_ARG(val)[100];
+	);
+	char *value2;
+	int i;
+
+	value2 = ast_strdupa(value);
+	if (!var || !value2)
+		return;
+
+	ast_mutex_lock(&local_lock);
+	use_count++;
+	ast_mutex_unlock(&local_lock);
+
+	/* The functions this will generally be used with are SORT and ODBC_*, which
+	 * both return comma-delimited lists.  However, if somebody uses literal lists,
+	 * their commas will be translated to vertical bars by the load, and I don't
+	 * want them to be surprised by the result.  Hence, we prefer commas as the
+	 * delimiter, but we'll fall back to vertical bars if commas aren't found.
+	 */
+	ast_log(LOG_DEBUG, "array (%s=%s)\n", var, value2);
+	if (strchr(var, ','))
+		arg1.argc = trunk_app_separate_args(var, ',', arg1.argv, (sizeof(arg1) - sizeof(arg1.argc)) / sizeof(arg1.argv[0]));
+	else
+		arg1.argc = trunk_app_separate_args(var, '|', arg1.argv, (sizeof(arg1) - sizeof(arg1.argc)) / sizeof(arg1.argv[0]));
+
+	if (strchr(value2, ','))
+		arg2.argc = trunk_app_separate_args(value2, ',', arg2.argv, (sizeof(arg2) - sizeof(arg2.argc)) / sizeof(arg2.argv[0]));
+	else
+		arg2.argc = trunk_app_separate_args(value2, '|', arg2.argv, (sizeof(arg2) - sizeof(arg2.argc)) / sizeof(arg2.argv[0]));
+
+	for (i = 0; i < arg1.argc; i++) {
+		ast_log(LOG_DEBUG, "array set value (%s=%s)\n", arg1.var[i],
+			arg2.val[i]);
+		if (i < arg2.argc) {
+			pbx_builtin_setvar_helper(chan, arg1.var[i], arg2.val[i]);
+		} else {
+			/* We could unset the variable, by passing a NULL, but due to
+			 * pushvar semantics, that could create some undesired behavior. */
+			pbx_builtin_setvar_helper(chan, arg1.var[i], "");
+		}
+	}
+
+	ast_mutex_lock(&local_lock);
+	use_count--;
+	ast_mutex_unlock(&local_lock);
+
+	return;
+}
+
+static struct ast_custom_function array_function = {
+	.name = "ARRAY",
+	.synopsis = "Allows setting multiple variables at once",
+	.syntax = "ARRAY(var1[,var2[...][,varN]])",
+	.write = array,
+	.desc =
+		"The comma-separated list passed as a value to which the function is set will\n"
+		"be interpreted as a set of values to which the comma-separated list of\n"
+		"variable names in the argument should be set.\n"
+		"Hence, Set(ARRAY(var1,var2)=1,2) will set var1 to 1 and var2 to 2\n"
+		"Note: remember to either backslash your commas in extensions.conf or quote the\n"
+		"entire argument, since Set can take multiple arguments itself.\n",
+};
+
+static char *tdesc = "String handling dialplan functions";
+
+int unload_module(void)
+{
+	int res = 0;
+
+	res |= ast_custom_function_unregister(&array_function);
+	sched_yield(); /* Any remaining process gets time to clear out.  Increases safety if a force unload is attempted. */
+
+	return res;
+}
+
+int load_module(void)
+{
+	int res = 0;
+
+	res |= ast_custom_function_register(&array_function);
+
+	return res;
+}
+
+char *description(void)
+{
+	return tdesc;
+}
+
+int usecount(void)
+{
+	return use_count;
+}
+
+char *key(void)
+{
+	return ASTERISK_GPL_KEY;
+}
+
Index: asterisk-1.2.27/funcs/func_odbc.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ asterisk-1.2.27/funcs/func_odbc.c	2008-03-19 11:33:11.000000000 +0100
@@ -0,0 +1,658 @@
+/*
+ * Asterisk -- An open source telephony toolkit.
+ *
+ * Copyright (c) 2005 Tilghman Lesher
+ *
+ * Tilghman Lesher <func_odbc__200604@the-tilghman.com>
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+/*!
+ * \file
+ *
+ * \brief ODBC lookups
+ *
+ * \author Tilghman Lesher <func_odbc__200604@the-tilghman.com>
+ */
+
+#include <sys/types.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 7 $")
+
+#include <asterisk/module.h>
+#include <asterisk/file.h>
+#include <asterisk/logger.h>
+#include <asterisk/options.h>
+#include <asterisk/channel.h>
+#include <asterisk/pbx.h>
+#include <asterisk/module.h>
+#include <asterisk/config.h>
+#include <asterisk/res_odbc.h>
+#include <asterisk/app.h>
+
+static char *tdesc = "ODBC lookups";
+
+static char *config = "func_odbc.conf";
+
+struct acf_odbc_query {
+	AST_LIST_ENTRY(acf_odbc_query) list;
+	char dsn[30];
+	char sql_read[2048];
+	char sql_write[2048];
+	struct ast_custom_function *acf;
+};
+
+AST_LIST_HEAD_STATIC(queries, acf_odbc_query);
+
+#ifdef NEEDTRACE
+static void acf_odbc_error(SQLHSTMT stmt, int res)
+{
+	char state[10] = "", diagnostic[256] = "";
+	SQLINTEGER nativeerror = 0;
+	SQLSMALLINT diagbytes = 0;
+	SQLGetDiagRec(SQL_HANDLE_STMT, stmt, 1, state, &nativeerror, diagnostic, sizeof(diagnostic), &diagbytes);
+	ast_log(LOG_WARNING, "SQL return value %d: error %s: %s (len %d)\n", res, state, diagnostic, diagbytes);
+}
+#endif
+
+/*
+ * Master control routine
+ */
+static void acf_odbc_write(struct ast_channel *chan, char *cmd, char *data, const char *value)
+{
+	odbc_obj *obj;
+	struct acf_odbc_query *query;
+	char *s, *t, *arg, buf[2048]="", varname[15];
+	int res, argcount=0, valcount=0, i, retry=0;
+	struct ast_channel *ast;
+	SQLHSTMT stmt;
+	SQLINTEGER nativeerror=0, numfields=0, rows=0;
+	SQLSMALLINT diagbytes=0;
+	unsigned char state[10], diagnostic[256];
+#ifdef NEEDTRACE
+	SQLINTEGER enable = 1;
+	char *tracefile = "/tmp/odbc.trace";
+#endif
+
+	AST_LIST_LOCK(&queries);
+	AST_LIST_TRAVERSE(&queries, query, list) {
+		if (!strcmp(query->acf->name, cmd)) {
+			break;
+		}
+	}
+
+	if (!query) {
+		ast_log(LOG_ERROR, "No such function '%s'\n", cmd);
+		AST_LIST_UNLOCK(&queries);
+		return;
+	}
+
+	obj = fetch_odbc_obj(query->dsn, 0);
+
+	if (!obj) {
+		ast_log(LOG_ERROR, "No such DSN registered: %s (check res_odbc.conf)\n", query->dsn);
+		AST_LIST_UNLOCK(&queries);
+		return;
+	}
+
+	/* Parse our arguments */
+	s = ast_strdupa(data);
+	if (value) {
+		t = ast_strdupa(value);
+	} else {
+		t = "";
+	}
+
+	if (!s || !t) {
+		ast_log(LOG_ERROR, "Out of memory\n");
+		AST_LIST_UNLOCK(&queries);
+		return;
+	}
+
+	/* XXX You might be tempted to change this section into using
+	 * pbx_builtin_pushvar_helper().  However, note that if you try
+	 * to set a NULL (like for VALUE), then nothing gets set, and the
+	 * value doesn't get masked out.  Even worse, when you subsequently
+	 * try to remove the value you just set, you'll wind up unsetting
+	 * the previous value (which is wholly undesireable).  Hence, this
+	 * has to remain the way it is done here. XXX
+	 */
+
+	/* Save old arguments as variables in a fake channel */
+	ast = ast_channel_alloc(0);
+	while ((arg = strsep(&s, "|"))) {
+		argcount++;
+		snprintf(varname, sizeof(varname), "ARG%d", argcount);
+		pbx_builtin_setvar_helper(ast, varname, pbx_builtin_getvar_helper(chan, varname));
+		pbx_builtin_setvar_helper(chan, varname, arg);
+	}
+
+	/* Parse values, just like arguments */
+	while ((arg = strsep(&t, "|"))) {
+		valcount++;
+		snprintf(varname, sizeof(varname), "VAL%d", valcount);
+		pbx_builtin_setvar_helper(ast, varname, pbx_builtin_getvar_helper(chan, varname));
+		pbx_builtin_setvar_helper(chan, varname, arg);
+	}
+
+	/* Additionally set the value as a whole */
+	/* Note that pbx_builtin_setvar_helper will quite happily take a NULL for the 3rd argument */
+	pbx_builtin_setvar_helper(ast, "VALUE", pbx_builtin_getvar_helper(chan, "VALUE"));
+	pbx_builtin_setvar_helper(chan, "VALUE", value);
+
+	pbx_substitute_variables_helper(chan, query->sql_write, buf, sizeof(buf) - 1);
+
+	/* Restore prior values */
+	for (i=1; i<=argcount; i++) {
+		snprintf(varname, sizeof(varname), "ARG%d", argcount);
+		pbx_builtin_setvar_helper(chan, varname, pbx_builtin_getvar_helper(ast, varname));
+	}
+
+	for (i=1; i<=valcount; i++) {
+		snprintf(varname, sizeof(varname), "VAL%d", argcount);
+		pbx_builtin_setvar_helper(chan, varname, pbx_builtin_getvar_helper(ast, varname));
+	}
+	pbx_builtin_setvar_helper(chan, "VALUE", pbx_builtin_getvar_helper(ast, "VALUE"));
+
+	ast_channel_free(ast);
+	AST_LIST_UNLOCK(&queries);
+
+retry_write:
+#ifdef NEEDTRACE
+	SQLSetConnectAttr(obj->con, SQL_ATTR_TRACE, &enable, SQL_IS_INTEGER);
+	SQLSetConnectAttr(obj->con, SQL_ATTR_TRACEFILE, tracefile, strlen(tracefile));
+#endif
+
+	res = SQLAllocHandle (SQL_HANDLE_STMT, obj->con, &stmt);
+	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {
+		ast_log(LOG_WARNING, "SQL Alloc Handle failed!\n");
+		pbx_builtin_setvar_helper(chan, "ODBCROWS", "-1");
+		return;
+	}
+
+	res = SQLPrepare(stmt, (unsigned char *)buf, SQL_NTS);
+	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {
+		ast_log(LOG_WARNING, "SQL Prepare failed![%s]\n", buf);
+		SQLFreeHandle (SQL_HANDLE_STMT, stmt);
+		pbx_builtin_setvar_helper(chan, "ODBCROWS", "-1");
+		return;
+	}
+
+	res = SQLExecute(stmt);
+	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {
+		if (res == SQL_ERROR) {
+			SQLGetDiagField(SQL_HANDLE_STMT, stmt, 1, SQL_DIAG_NUMBER, &numfields, SQL_IS_INTEGER, &diagbytes);
+			for (i = 0; i <= numfields; i++) {
+				SQLGetDiagRec(SQL_HANDLE_STMT, stmt, i + 1, state, &nativeerror, diagnostic, sizeof(diagnostic), &diagbytes);
+				ast_log(LOG_WARNING, "SQL Execute returned an error %d: %s: %s (%d)\n", res, state, diagnostic, diagbytes);
+				if (i > 10) {
+					ast_log(LOG_WARNING, "Oh, that was good.  There are really %d diagnostics?\n", (int)numfields);
+					break;
+				}
+			}
+		}
+		SQLFreeHandle(SQL_HANDLE_STMT, stmt);
+		odbc_obj_disconnect(obj);
+		/* All handles are now invalid (after a disconnect), so we gotta redo all handles */
+		odbc_obj_connect(obj);
+		if (!retry) {
+			retry = 1;
+			goto retry_write;
+		}
+		rows = -1;
+	} else {
+		/* Rows affected */
+		SQLRowCount(stmt, &rows);
+	}
+
+	/* Output the affected rows, for all cases.  In the event of failure, we
+	 * flag this as -1 rows.  Note that this is different from 0 affected rows
+	 * which would be the case if we succeeded in our query, but the values did
+	 * not change. */
+	snprintf(varname, sizeof(varname), "%d", (int)rows);
+	pbx_builtin_setvar_helper(chan, "ODBCROWS", varname);
+
+	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {
+		ast_log(LOG_WARNING, "SQL Execute error!\n[%s]\n\n", buf);
+	}
+
+	SQLFreeHandle(SQL_HANDLE_STMT, stmt);
+}
+
+static char *acf_odbc_read(struct ast_channel *chan, char *cmd, char *data, char *buf, size_t len)
+{
+	odbc_obj *obj;
+	struct acf_odbc_query *query;
+	char *s, *arg, sql[2048] = "", varname[15];
+	int count=0, res, x, buflen = 0;
+	SQLHSTMT stmt;
+	SQLSMALLINT colcount=0;
+	SQLINTEGER indicator;
+#ifdef NEEDTRACE
+	SQLINTEGER enable = 1;
+	char *tracefile = "/tmp/odbc.trace";
+#endif
+
+	AST_LIST_LOCK(&queries);
+	AST_LIST_TRAVERSE(&queries, query, list) {
+		if (!strcmp(query->acf->name, cmd)) {
+			break;
+		}
+	}
+
+	if (!query) {
+		ast_log(LOG_ERROR, "No such function '%s'\n", cmd);
+		AST_LIST_UNLOCK(&queries);
+		return "";
+	}
+
+	obj = fetch_odbc_obj(query->dsn, 0);
+
+	if (!obj) {
+		ast_log(LOG_ERROR, "No such DSN registered: %s (check res_odbc.conf)\n", query->dsn);
+		AST_LIST_UNLOCK(&queries);
+		return "";
+	}
+
+#ifdef NEEDTRACE
+	SQLSetConnectAttr(obj->con, SQL_ATTR_TRACE, &enable, SQL_IS_INTEGER);
+	SQLSetConnectAttr(obj->con, SQL_ATTR_TRACEFILE, tracefile, strlen(tracefile));
+#endif
+
+	/* Parse our arguments */
+	if (!(s = ast_strdupa(data))) {
+		AST_LIST_UNLOCK(&queries);
+		return "";
+	}
+
+	while ((arg = strsep(&s, "|"))) {
+		count++;
+		snprintf(varname, sizeof(varname), "ARG%d", count);
+		/* arg is by definition non-NULL, so this works, here */
+		pbx_builtin_pushvar_helper(chan, varname, arg);
+	}
+
+	pbx_substitute_variables_helper(chan, query->sql_read, sql, sizeof(sql) - 1);
+
+	/* Restore prior values */
+	for (x = 1; x <= count; x++) {
+		snprintf(varname, sizeof(varname), "ARG%d", x);
+		pbx_builtin_setvar_helper(chan, varname, NULL);
+	}
+
+	AST_LIST_UNLOCK(&queries);
+
+	res = SQLAllocHandle (SQL_HANDLE_STMT, obj->con, &stmt);
+	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {
+		ast_log(LOG_WARNING, "SQL Alloc Handle failed!\n");
+		return "";
+	}
+
+	res = SQLPrepare(stmt, (unsigned char *)sql, SQL_NTS);
+	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {
+		ast_log(LOG_WARNING, "SQL Prepare failed![%s]\n", sql);
+		SQLFreeHandle (SQL_HANDLE_STMT, stmt);
+		return "";
+	}
+
+	res = odbc_smart_execute(obj, stmt);
+	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {
+		ast_log(LOG_WARNING, "SQL Execute error!\n[%s]\n\n", sql);
+		SQLFreeHandle (SQL_HANDLE_STMT, stmt);
+		return "";
+	}
+
+	res = SQLNumResultCols(stmt, &colcount);
+	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {
+		ast_log(LOG_WARNING, "SQL Column Count error!\n[%s]\n\n", sql);
+		SQLFreeHandle (SQL_HANDLE_STMT, stmt);
+		return "";
+	}
+
+	memset(buf, 0, len);
+
+	res = SQLFetch(stmt);
+	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {
+		if (res == SQL_NO_DATA) {
+			if (option_verbose > 3) {
+				ast_verbose(VERBOSE_PREFIX_4 "Found no rows [%s]\n", sql);
+			}
+		} else if (option_verbose > 3) {
+			ast_log(LOG_WARNING, "Error %d in FETCH [%s]\n", res, sql);
+		}
+		goto acf_out;
+	}
+
+	for (x = 0; x < colcount; x++) {
+		int i;
+		char coldata[256];
+
+		buflen = strlen(buf);
+		res = SQLGetData(stmt, x + 1, SQL_CHAR, coldata, sizeof(coldata), &indicator);
+		if (indicator == SQL_NULL_DATA) {
+			coldata[0] = '\0';
+			res = SQL_SUCCESS;
+		}
+
+		if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {
+			ast_log(LOG_WARNING, "SQL Get Data error!\n[%s]\n\n", sql);
+			SQLFreeHandle(SQL_HANDLE_STMT, stmt);
+			return "";
+		}
+
+		/* Copy data, encoding '\' and ',' for the argument parser */
+		for (i = 0; i < sizeof(coldata); i++) {
+			if (coldata[i] == '\\' || coldata[i] == ',') {
+				buf[buflen++] = '\\';
+			}
+			buf[buflen++] = coldata[i];
+
+			if (buflen >= len - 2) {
+				buf[buflen >= len ? len - 1 : buflen] = '\0';
+				break;
+			}
+
+			if (coldata[i] == '\0')
+				break;
+		}
+
+		buf[buflen - 1] = ',';
+	}
+	/* Trim trailing comma */
+	buf[buflen - 1] = '\0';
+
+acf_out:
+	SQLFreeHandle(SQL_HANDLE_STMT, stmt);
+	return buf;
+}
+
+static char *acf_escape(struct ast_channel *chan, char *cmd, char *data, char *buf, size_t len)
+{
+	char *in, *out = buf;
+	for (in = data; *in && out - buf < len; in++) {
+		if (*in == '\'') {
+			*out = '\'';
+			out++;
+		}
+		*out = *in;
+		out++;
+	}
+	*out = '\0';
+	return buf;
+}
+
+static struct ast_custom_function escape_function = {
+	.name = "SQL_ESC",
+	.synopsis = "Escapes single ticks for use in SQL statements",
+	.syntax = "SQL_ESC(<string>)",
+	.desc =
+"Used in SQL templates to escape data which may contain single ticks (') which\n"
+"are otherwise used to delimit data.  For example:\n"
+"SELECT foo FROM bar WHERE baz='${SQL_ESC(${ARG1})}'\n",
+	.read = acf_escape,
+	.write = NULL,
+};
+
+
+
+static int init_acf_query(struct ast_config *cfg, char *catg, struct acf_odbc_query **query)
+{
+	char *tmp;
+
+	if (!cfg || !catg) {
+		return -1;
+	}
+
+	*query = calloc(1, sizeof(struct acf_odbc_query));
+	if (! (*query))
+		return -1;
+
+	if ((tmp = ast_variable_retrieve(cfg, catg, "dsn"))) {
+		ast_copy_string((*query)->dsn, tmp, sizeof((*query)->dsn));
+	} else {
+		return -1;
+	}
+
+	if ((tmp = ast_variable_retrieve(cfg, catg, "read"))) {
+		ast_copy_string((*query)->sql_read, tmp, sizeof((*query)->sql_read));
+	}
+
+	if ((tmp = ast_variable_retrieve(cfg, catg, "write"))) {
+		ast_copy_string((*query)->sql_write, tmp, sizeof((*query)->sql_write));
+	}
+
+	(*query)->acf = calloc(1, sizeof(struct ast_custom_function));
+	if (! (*query)->acf) {
+		free(*query);
+		return -1;
+	}
+
+	if ((tmp = ast_variable_retrieve(cfg, catg, "prefix")) && !ast_strlen_zero(tmp)) {
+		asprintf((char **)&((*query)->acf->name), "%s_%s", tmp, catg);
+	} else {
+		asprintf((char **)&((*query)->acf->name), "ODBC_%s", catg);
+	}
+
+	if (!((*query)->acf->name)) {
+		free((*query)->acf);
+		free(*query);
+		return -1;
+	}
+
+	asprintf((char **)&((*query)->acf->syntax), "%s(<arg1>[...[,<argN>]])", (*query)->acf->name);
+
+	if (!((*query)->acf->syntax)) {
+		free((char *)(*query)->acf->name);
+		free((*query)->acf);
+		free(*query);
+		return -1;
+	}
+
+	(*query)->acf->synopsis = "Runs the referenced query with the specified arguments";
+	if (!ast_strlen_zero((*query)->sql_read) && !ast_strlen_zero((*query)->sql_write)) {
+		asprintf((char **)&((*query)->acf->desc),
+					"Runs the following query, as defined in func_odbc.conf, performing\n"
+				   	"substitution of the arguments into the query as specified by ${ARG1},\n"
+					"${ARG2}, ... ${ARGn}.  When setting the function, the values are provided\n"
+					"either in whole as ${VALUE} or parsed as ${VAL1}, ${VAL2}, ... ${VALn}.\n"
+					"\nRead:\n%s\n\nWrite:\n%s\n",
+					(*query)->sql_read,
+					(*query)->sql_write);
+	} else if (!ast_strlen_zero((*query)->sql_read)) {
+		asprintf((char **)&((*query)->acf->desc),
+					"Runs the following query, as defined in func_odbc.conf, performing\n"
+				   	"substitution of the arguments into the query as specified by ${ARG1},\n"
+					"${ARG2}, ... ${ARGn}.  This function may only be read, not set.\n\nSQL:\n%s\n",
+					(*query)->sql_read);
+	} else if (!ast_strlen_zero((*query)->sql_write)) {
+		asprintf((char **)&((*query)->acf->desc),
+					"Runs the following query, as defined in func_odbc.conf, performing\n"
+				   	"substitution of the arguments into the query as specified by ${ARG1},\n"
+					"${ARG2}, ... ${ARGn}.  The values are provided either in whole as\n"
+					"${VALUE} or parsed as ${VAL1}, ${VAL2}, ... ${VALn}.\n"
+					"This function may only be set.\nSQL:\n%s\n",
+					(*query)->sql_write);
+	}
+
+	/* Could be out of memory, or could be we have neither sql_read nor sql_write */
+	if (! ((*query)->acf->desc)) {
+		free((char *)(*query)->acf->syntax);
+		free((char *)(*query)->acf->name);
+		free((*query)->acf);
+		free(*query);
+		return -1;
+	}
+
+	if (ast_strlen_zero((*query)->sql_read)) {
+		(*query)->acf->read = NULL;
+	} else {
+		(*query)->acf->read = acf_odbc_read;
+	}
+
+	if (ast_strlen_zero((*query)->sql_write)) {
+		(*query)->acf->write = NULL;
+	} else {
+		(*query)->acf->write = acf_odbc_write;
+	}
+
+	return 0;
+}
+
+static int free_acf_query(struct acf_odbc_query *query)
+{
+	if (query) {
+		if (query->acf) {
+			if (query->acf->name)
+				free(query->acf->name);
+			if (query->acf->syntax)
+				free(query->acf->syntax);
+			if (query->acf->desc)
+				free(query->acf->desc);
+			free(query->acf);
+		}
+		free(query);
+	}
+	return 0;
+}
+
+static int odbc_load_module(void)
+{
+	int res = 0;
+	struct ast_config *cfg;
+	char *catg;
+
+	AST_LIST_LOCK(&queries);
+
+	cfg = ast_config_load(config);
+	if (!cfg) {
+		ast_log(LOG_WARNING, "Unable to load config for func_odbc: %s\n", config);
+		AST_LIST_UNLOCK(&queries);
+		return -1;
+	}
+
+	for (catg = ast_category_browse(cfg, NULL);
+	     catg;
+	     catg = ast_category_browse(cfg, catg)) {
+		struct acf_odbc_query *query = NULL;
+
+		if (init_acf_query(cfg, catg, &query)) {
+			ast_log(LOG_ERROR, "Out of memory\n");
+			free_acf_query(query);
+		} else {
+			AST_LIST_INSERT_HEAD(&queries, query, list);
+			ast_custom_function_register(query->acf);
+		}
+	}
+
+	ast_config_destroy(cfg);
+	ast_custom_function_register(&escape_function);
+
+	AST_LIST_UNLOCK(&queries);
+	return res;
+}
+
+static int odbc_unload_module(void)
+{
+	struct acf_odbc_query *query;
+
+	AST_LIST_LOCK(&queries);
+	while (!AST_LIST_EMPTY(&queries)) {
+		query = AST_LIST_REMOVE_HEAD(&queries, list);
+		ast_custom_function_unregister(query->acf);
+		free_acf_query(query);
+	}
+
+	ast_custom_function_unregister(&escape_function);
+
+	/* Allow any threads waiting for this lock to pass (avoids a race) */
+	AST_LIST_UNLOCK(&queries);
+	AST_LIST_LOCK(&queries);
+
+	AST_LIST_UNLOCK(&queries);
+	return 0;
+}
+
+int reload(void)
+{
+	int res = 0;
+	struct ast_config *cfg;
+	struct acf_odbc_query *oldquery;
+	char *catg;
+
+	AST_LIST_LOCK(&queries);
+
+	while (!AST_LIST_EMPTY(&queries)) {
+		oldquery = AST_LIST_REMOVE_HEAD(&queries, list);
+		ast_custom_function_unregister(oldquery->acf);
+		free_acf_query(oldquery);
+	}
+
+	cfg = ast_config_load(config);
+	if (!cfg) {
+		ast_log(LOG_WARNING, "Unable to load config for func_odbc: %s\n", config);
+		goto reload_out;
+	}
+
+	for (catg = ast_category_browse(cfg, NULL);
+	     catg;
+	     catg = ast_category_browse(cfg, catg)) {
+		struct acf_odbc_query *query = NULL;
+
+		if (init_acf_query(cfg, catg, &query)) {
+			ast_log(LOG_ERROR, "Cannot initialize query %s\n", catg);
+		} else {
+			AST_LIST_INSERT_HEAD(&queries, query, list);
+			ast_custom_function_register(query->acf);
+		}
+	}
+
+	ast_config_destroy(cfg);
+reload_out:
+	AST_LIST_UNLOCK(&queries);
+	return res;
+}
+
+int unload_module(void)
+{
+	return odbc_unload_module();
+}
+
+int load_module(void)
+{
+	return odbc_load_module();
+}
+
+char *description(void)
+{
+	return tdesc;
+}
+
+int usecount(void)
+{
+	if (! ast_mutex_trylock(&(&queries)->lock)) {
+		ast_mutex_unlock(&(&queries)->lock);
+		return 0;
+	} else {
+		return 1;
+	}
+}
+
+char *key()
+{
+	return ASTERISK_GPL_KEY;
+}
