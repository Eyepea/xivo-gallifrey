2009-09-23  Adrien DELLE CAVE <decryptus@proformatique.com>

	pf_gosub_args.patch
	$Revision$
	$Date$
	Gosub interface change (backport from Asterisk 1.6 for 1.4)

	XIVO needs this Asterisk 1.6 style Gosub interface, so we backported
	it for Asterisk 1.4.

Index: asterisk-1.4.26.2/apps/app_stack.c
===================================================================
--- asterisk-1.4.26.2.orig/apps/app_stack.c	2007-10-15 22:29:35.000000000 +0200
+++ asterisk-1.4.26.2/apps/app_stack.c	2009-09-23 11:38:36.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * Asterisk -- An open source telephony toolkit.
  *
- * Copyright (c) 2004-2006 Tilghman Lesher <app_stack_v002@the-tilghman.com>.
+ * Copyright (c) 2004-2006 Tilghman Lesher <app_stack_v003@the-tilghman.com>.
  *
  * This code is released by the author with no restrictions on usage.
  *
@@ -20,29 +20,20 @@
  *
  * \brief Stack applications Gosub, Return, etc.
  *
- * \author Tilghman Lesher <app_stack_v002@the-tilghman.com>
+ * \author Tilghman Lesher <app_stack_v003@the-tilghman.com>
  * 
  * \ingroup applications
  */
 
 #include "asterisk.h"
  
-ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-
-#include "asterisk/options.h"
-#include "asterisk/logger.h"
-#include "asterisk/channel.h"
-#include "asterisk/chanvars.h"
 #include "asterisk/pbx.h"
 #include "asterisk/module.h"
-#include "asterisk/config.h"
-
-#define STACKVAR	"~GOSUB~STACK~"
+#include "asterisk/app.h"
+#include "asterisk/manager.h"
+#include "asterisk/channel.h"
 
 
 static const char *app_gosub = "Gosub";
@@ -56,63 +47,275 @@
 static const char *pop_synopsis = "Remove one address from gosub stack";
 
 static const char *gosub_descrip =
-"Gosub([[context|]exten|]priority)\n"
-"  Jumps to the label specified, saving the return address.\n";
+"  Gosub([[context,]exten,]priority[(arg1[,...][,argN])]):\n"
+"Jumps to the label specified, saving the return address.\n";
 static const char *gosubif_descrip =
-"GosubIf(condition?labeliftrue[:labeliffalse])\n"
-"  If the condition is true, then jump to labeliftrue.  If false, jumps to\n"
+"  GosubIf(condition?labeliftrue[(arg1[,...])][:labeliffalse[(arg1[,...])]]):\n"
+"If the condition is true, then jump to labeliftrue.  If false, jumps to\n"
 "labeliffalse, if specified.  In either case, a jump saves the return point\n"
 "in the dialplan, to be returned to with a Return.\n";
 static const char *return_descrip =
-"Return()\n"
-"  Jumps to the last label on the stack, removing it.\n";
+"  Return([return-value]):\n"
+"Jumps to the last label on the stack, removing it.  The return value, if\n"
+"any, is saved in the channel variable GOSUB_RETVAL.\n";
 static const char *pop_descrip =
-"StackPop()\n"
-"  Removes last label on the stack, discarding it.\n";
+"  StackPop():\n"
+"Removes last label on the stack, discarding it.\n";
+
+static void gosub_free(void *data);
+
+static struct ast_datastore_info stack_info = {
+	.type = "GOSUB",
+	.destroy = gosub_free,
+};
+
+struct gosub_stack_frame {
+	AST_LIST_ENTRY(gosub_stack_frame) entries;
+	/* 100 arguments is all that we support anyway, but this will handle up to 255 */
+	unsigned char arguments;
+	struct varshead varshead;
+	int priority;
+	char *context;
+	char extension[0];
+};
+
+static int frame_set_var(struct ast_channel *chan, struct gosub_stack_frame *frame, const char *var, const char *value)
+{
+	struct ast_var_t *variables;
+	int found = 0;
+
+	/* Does this variable already exist? */
+	AST_LIST_TRAVERSE(&frame->varshead, variables, entries) {
+		if (!strcmp(var, ast_var_name(variables))) {
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found) {
+		variables = ast_var_assign(var, "");
+		AST_LIST_INSERT_HEAD(&frame->varshead, variables, entries);
+		pbx_builtin_pushvar_helper(chan, var, value);
+	} else {
+		pbx_builtin_setvar_helper(chan, var, value);
+	}
+
+	manager_event(EVENT_FLAG_DIALPLAN, "VarSet",
+		"Channel: %s\r\n"
+		"Variable: LOCAL(%s)\r\n"
+		"Value: %s\r\n"
+		"Uniqueid: %s\r\n",
+		chan->name, var, value, chan->uniqueid);
+	return 0;
+}
+
+static void gosub_release_frame(struct ast_channel *chan, struct gosub_stack_frame *frame)
+{
+	struct ast_var_t *vardata;
+
+	/* If chan is not defined, then we're calling it as part of gosub_free,
+	 * and the channel variables will be deallocated anyway.  Otherwise, we're
+	 * just releasing a single frame, so we need to clean up the arguments for
+	 * that frame, so that we re-expose the variables from the previous frame
+	 * that were hidden by this one.
+	 */
+	while ((vardata = AST_LIST_REMOVE_HEAD(&frame->varshead, entries))) {
+		if (chan)
+			pbx_builtin_setvar_helper(chan, ast_var_name(vardata), NULL);	
+		ast_var_delete(vardata);
+	}
+
+	ast_free(frame);
+}
+
+static struct gosub_stack_frame *gosub_allocate_frame(const char *context, const char *extension, int priority, unsigned char arguments)
+{
+	struct gosub_stack_frame *new = NULL;
+	int len_extension = strlen(extension), len_context = strlen(context);
 
+	if ((new = ast_calloc(1, sizeof(*new) + 2 + len_extension + len_context))) {
+		AST_LIST_HEAD_INIT_NOLOCK(&new->varshead);
+		strcpy(new->extension, extension);
+		new->context = new->extension + len_extension + 1;
+		strcpy(new->context, context);
+		new->priority = priority;
+		new->arguments = arguments;
+	}
+	return new;
+}
+
+static void gosub_free(void *data)
+{
+	AST_LIST_HEAD(, gosub_stack_frame) *oldlist = data;
+	struct gosub_stack_frame *oldframe;
+	AST_LIST_LOCK(oldlist);
+	while ((oldframe = AST_LIST_REMOVE_HEAD(oldlist, entries))) {
+		gosub_release_frame(NULL, oldframe);
+	}
+	AST_LIST_UNLOCK(oldlist);
+	AST_LIST_HEAD_DESTROY(oldlist);
+	ast_free(oldlist);
+}
 
 static int pop_exec(struct ast_channel *chan, void *data)
 {
-	pbx_builtin_setvar_helper(chan, STACKVAR, NULL);
+	struct ast_module_user *u;
+	struct ast_datastore *stack_store = ast_channel_datastore_find(chan, &stack_info, NULL);
+	struct gosub_stack_frame *oldframe;
+	AST_LIST_HEAD(, gosub_stack_frame) *oldlist;
+
+	if (!stack_store) {
+		ast_log(LOG_WARNING, "%s called with no gosub stack allocated.\n", app_pop);
+		return 0;
+	}
+
+	u = ast_module_user_add(chan);
+
+	oldlist = stack_store->data;
+	AST_LIST_LOCK(oldlist);
+	oldframe = AST_LIST_REMOVE_HEAD(oldlist, entries);
+	AST_LIST_UNLOCK(oldlist);
+
+	if (oldframe) {
+		gosub_release_frame(chan, oldframe);
+	} else {
+		ast_log(LOG_DEBUG, "%s called with an empty gosub stack\n", app_pop);
+	}
+
+	ast_module_user_remove(u);
 
 	return 0;
 }
 
 static int return_exec(struct ast_channel *chan, void *data)
 {
-	const char *label = pbx_builtin_getvar_helper(chan, STACKVAR);
+	struct ast_module_user *u;
+	struct ast_datastore *stack_store = ast_channel_datastore_find(chan, &stack_info, NULL);
+	struct gosub_stack_frame *oldframe;
+	AST_LIST_HEAD(, gosub_stack_frame) *oldlist;
+	char *retval = data;
 
-	if (ast_strlen_zero(label)) {
-		ast_log(LOG_ERROR, "Return without Gosub: stack is empty\n");
+	if (!stack_store) {
+		ast_log(LOG_ERROR, "Return without Gosub: stack is unallocated\n");
 		return -1;
-	} else if (ast_parseable_goto(chan, label)) {
-		ast_log(LOG_WARNING, "No next statement after Gosub?\n");
+	}
+
+	u = ast_module_user_add(chan);
+
+	oldlist = stack_store->data;
+	AST_LIST_LOCK(oldlist);
+	oldframe = AST_LIST_REMOVE_HEAD(oldlist, entries);
+	AST_LIST_UNLOCK(oldlist);
+
+	if (!oldframe) {
+		ast_log(LOG_ERROR, "Return without Gosub: stack is empty\n");
+		ast_module_user_remove(u);
 		return -1;
 	}
 
-	pbx_builtin_setvar_helper(chan, STACKVAR, NULL);
+	ast_explicit_goto(chan, oldframe->context, oldframe->extension, oldframe->priority);
+	gosub_release_frame(chan, oldframe);
+
+	/* Set a return value, if any */
+	pbx_builtin_setvar_helper(chan, "GOSUB_RETVAL", S_OR(retval, ""));
+
+	ast_module_user_remove(u);
+
 	return 0;
 }
 
 static int gosub_exec(struct ast_channel *chan, void *data)
 {
-	char newlabel[AST_MAX_EXTENSION * 2 + 3 + 11];
 	struct ast_module_user *u;
+	struct ast_datastore *stack_store = ast_channel_datastore_find(chan, &stack_info, NULL);
+	AST_LIST_HEAD(, gosub_stack_frame) *oldlist;
+	struct gosub_stack_frame *newframe;
+	char argname[15], *tmp = ast_strdupa(data), *label, *endparen;
+	unsigned int i;
+	AST_DECLARE_APP_ARGS(args2,
+		AST_APP_ARG(argval)[100];
+	);
 
 	if (ast_strlen_zero(data)) {
-		ast_log(LOG_ERROR, "%s requires an argument: %s([[context|]exten|]priority)\n", app_gosub, app_gosub);
+		ast_log(LOG_ERROR, "%s requires an argument: %s([[context,]exten,]priority[(arg1[,...][,argN])])\n", app_gosub, app_gosub);
 		return -1;
 	}
 
 	u = ast_module_user_add(chan);
-	snprintf(newlabel, sizeof(newlabel), "%s|%s|%d", chan->context, chan->exten, chan->priority + 1);
 
-	if (ast_parseable_goto(chan, data)) {
+	if (!stack_store) {
+		ast_log(LOG_DEBUG, "Channel %s has no datastore, so we're allocating one.\n", chan->name);
+		stack_store = ast_channel_datastore_alloc(&stack_info, NULL);
+		if (!stack_store) {
+			ast_log(LOG_ERROR, "Unable to allocate new datastore.  Gosub will fail.\n");
+			ast_module_user_remove(u);
+			return -1;
+		}
+
+		oldlist = ast_calloc(1, sizeof(*oldlist));
+		if (!oldlist) {
+			ast_log(LOG_ERROR, "Unable to allocate datastore list head.  Gosub will fail.\n");
+			ast_channel_datastore_free(stack_store);
+			ast_module_user_remove(u);
+			return -1;
+		}
+
+		stack_store->data = oldlist;
+		AST_LIST_HEAD_INIT(oldlist);
+		ast_channel_datastore_add(chan, stack_store);
+	}
+
+	/* Separate the arguments from the label */
+	/* NOTE:  you cannot use ast_app_separate_args for this, because '(' cannot be used as a delimiter. */
+	label = strsep(&tmp, "(");
+	if (tmp) {
+		endparen = strrchr(tmp, ')');
+		if (endparen)
+			*endparen = '\0';
+		else
+			ast_log(LOG_WARNING, "Ouch.  No closing paren: '%s'?\n", (char *)data);
+		AST_STANDARD_RAW_ARGS(args2, tmp);
+	} else
+		args2.argc = 0;
+
+	/* Create the return address, but don't save it until we know that the Gosub destination exists */
+	newframe = gosub_allocate_frame(chan->context, chan->exten, chan->priority + 1, args2.argc);
+
+	if (!newframe) {
+		ast_module_user_remove(u);
+		return -1;
+	}
+
+	if (ast_parseable_goto(chan, label)) {
+		ast_log(LOG_ERROR, "Gosub address is invalid: '%s'\n", (char *)data);
+		ast_free(newframe);
 		ast_module_user_remove(u);
 		return -1;
 	}
 
-	pbx_builtin_pushvar_helper(chan, STACKVAR, newlabel);
+	if (!ast_exists_extension(chan, chan->context, chan->exten, ast_test_flag(chan, AST_FLAG_IN_AUTOLOOP) ? chan->priority + 1 : chan->priority, chan->cid.cid_num)) {
+		ast_log(LOG_ERROR, "Attempt to reach a non-existent destination for gosub: (Context:%s, Extension:%s, Priority:%d)\n",
+				chan->context, chan->exten, chan->priority);
+		ast_copy_string(chan->context, newframe->context, sizeof(chan->context));
+		ast_copy_string(chan->exten, newframe->extension, sizeof(chan->exten));
+		chan->priority = newframe->priority;
+		ast_free(newframe);
+		ast_module_user_remove(u);
+		return -1;
+	}
+
+	/* Now that we know for certain that we're going to a new location, set our arguments */
+	for (i = 0; i < args2.argc; i++) {
+		snprintf(argname, sizeof(argname), "ARG%d", i + 1);
+		frame_set_var(chan, newframe, argname, args2.argval[i]);
+		ast_log(LOG_DEBUG, "Setting '%s' to '%s'\n", argname, args2.argval[i]);
+	}
+
+	/* And finally, save our return address */
+	oldlist = stack_store->data;
+	AST_LIST_LOCK(oldlist);
+	AST_LIST_INSERT_HEAD(oldlist, newframe, entries);
+	AST_LIST_UNLOCK(oldlist);
 	ast_module_user_remove(u);
 
 	return 0;
@@ -121,40 +324,123 @@
 static int gosubif_exec(struct ast_channel *chan, void *data)
 {
 	struct ast_module_user *u;
-	char *condition="", *label1, *label2, *args;
+	char *args;
 	int res=0;
+	AST_DECLARE_APP_ARGS(cond,
+		AST_APP_ARG(ition);
+		AST_APP_ARG(labels);
+	);
+	AST_DECLARE_APP_ARGS(label,
+		AST_APP_ARG(iftrue);
+		AST_APP_ARG(iffalse);
+	);
 
 	if (ast_strlen_zero(data)) {
-		ast_log(LOG_WARNING, "GosubIf requires an argument\n");
+		ast_log(LOG_WARNING, "GosubIf requires an argument: GosubIf(cond?label1(args):label2(args)\n");
 		return 0;
 	}
 
+	u = ast_module_user_add(chan);
+
 	args = ast_strdupa(data);
+	AST_NONSTANDARD_RAW_ARGS(cond, args, '?');
+	if (cond.argc != 2) {
+		ast_log(LOG_WARNING, "GosubIf requires an argument: GosubIf(cond?label1(args):label2(args)\n");
+		ast_module_user_remove(u);
+		return 0;
+	}
+
+	AST_NONSTANDARD_RAW_ARGS(label, cond.labels, ':');
+
+	if (pbx_checkcondition(cond.ition)) {
+		if (!ast_strlen_zero(label.iftrue))
+			res = gosub_exec(chan, label.iftrue);
+	} else if (!ast_strlen_zero(label.iffalse)) {
+		res = gosub_exec(chan, label.iffalse);
+	}
+
+	ast_module_user_remove(u);
+
+	return res;
+}
+
+static int local_read(struct ast_channel *chan, char *cmd, char *data, char *buf, size_t len)
+{
+	struct ast_module_user *u;
+	struct ast_datastore *stack_store = ast_channel_datastore_find(chan, &stack_info, NULL);
+	AST_LIST_HEAD(, gosub_stack_frame) *oldlist;
+	struct gosub_stack_frame *frame;
+	struct ast_var_t *variables;
+
+	if (!stack_store)
+		return -1;
 
 	u = ast_module_user_add(chan);
 
-	condition = strsep(&args, "?");
-	label1 = strsep(&args, ":");
-	label2 = args;
-
-	if (pbx_checkcondition(condition)) {
-		if (!ast_strlen_zero(label1)) {
-			res = gosub_exec(chan, label1);
+	oldlist = stack_store->data;
+	AST_LIST_LOCK(oldlist);
+	if (!(frame = AST_LIST_FIRST(oldlist))) {
+		/* Not within a Gosub routine */
+		AST_LIST_UNLOCK(oldlist);
+		ast_module_user_remove(u);
+		return -1;
+	}
+
+	AST_LIST_TRAVERSE(&frame->varshead, variables, entries) {
+		if (!strcmp(data, ast_var_name(variables))) {
+			const char *tmp = pbx_builtin_getvar_helper(chan, data);
+			ast_copy_string(buf, S_OR(tmp, ""), len);
+			break;
 		}
-	} else if (!ast_strlen_zero(label2)) {
-		res = gosub_exec(chan, label2);
 	}
+	AST_LIST_UNLOCK(oldlist);
+	ast_module_user_remove(u);
 
+	return 0;
+}
+
+static int local_write(struct ast_channel *chan, char *cmd, char *var, const char *value)
+{
+	struct ast_module_user *u;
+	struct ast_datastore *stack_store = ast_channel_datastore_find(chan, &stack_info, NULL);
+	AST_LIST_HEAD(, gosub_stack_frame) *oldlist;
+	struct gosub_stack_frame *frame;
+
+	if (!stack_store) {
+		ast_log(LOG_ERROR, "Tried to set LOCAL(%s), but we aren't within a Gosub routine\n", var);
+		return -1;
+	}
+
+	u = ast_module_user_add(chan);
+
+	oldlist = stack_store->data;
+	AST_LIST_LOCK(oldlist);
+	frame = AST_LIST_FIRST(oldlist);
+
+	if (frame)
+		frame_set_var(chan, frame, var, value);
+
+	AST_LIST_UNLOCK(oldlist);
 	ast_module_user_remove(u);
-	return res;
+
+	return 0;
 }
 
+static struct ast_custom_function local_function = {
+	.name = "LOCAL",
+	.synopsis = "Variables local to the gosub stack frame",
+	.syntax = "LOCAL(<varname>)",
+	.write = local_write,
+	.read = local_read,
+};
+
 static int unload_module(void)
 {
 	ast_unregister_application(app_return);
 	ast_unregister_application(app_pop);
 	ast_unregister_application(app_gosubif);
 	ast_unregister_application(app_gosub);
+	ast_custom_function_unregister(&local_function);
 
 	ast_module_user_hangup_all();
 
@@ -167,8 +453,9 @@
 	ast_register_application(app_return, return_exec, return_synopsis, return_descrip);
 	ast_register_application(app_gosubif, gosubif_exec, gosubif_synopsis, gosubif_descrip);
 	ast_register_application(app_gosub, gosub_exec, gosub_synopsis, gosub_descrip);
+	ast_custom_function_register(&local_function);
 
 	return 0;
 }
 
-AST_MODULE_INFO_STANDARD(ASTERISK_GPL_KEY, "Stack Routines");
+AST_MODULE_INFO_STANDARD(ASTERISK_GPL_KEY, "Dialplan subroutines (Gosub, Return, etc)");
Index: asterisk-1.4.26.2/include/asterisk/app.h
===================================================================
--- asterisk-1.4.26.2.orig/include/asterisk/app.h	2008-06-12 01:47:23.000000000 +0200
+++ asterisk-1.4.26.2/include/asterisk/app.h	2009-09-23 10:56:55.000000000 +0200
@@ -244,11 +244,11 @@
 #define AST_APP_ARG(name) char *name
 
 /*!
-  \brief Declare a structure to hold the application's arguments.
+  \brief Declare a structure to hold an application's arguments.
   \param name The name of the structure
   \param arglist The list of arguments, defined using AST_APP_ARG
 
-  This macro defines a structure intended to be used in a call
+  This macro declares a structure intended to be used in a call
   to ast_app_separate_args(). The structure includes all the
   arguments specified, plus an argv array that overlays them and an
   argc argument counter. The arguments must be declared using AST_APP_ARG,
@@ -258,12 +258,28 @@
   ast_app_separate_args() will perform that function before parsing
   the arguments.
  */
-#define AST_DECLARE_APP_ARGS(name, arglist) \
-	struct { \
+#define AST_DECLARE_APP_ARGS(name, arglist) AST_DEFINE_APP_ARGS_TYPE(, arglist) name
+
+/*!
+  \brief Define a structure type to hold an application's arguments.
+  \param type The name of the structure type
+  \param arglist The list of arguments, defined using AST_APP_ARG
+
+  This macro defines a structure type intended to be used in a call
+  to ast_app_separate_args(). The structure includes all the
+  arguments specified, plus an argv array that overlays them and an
+  argc argument counter. The arguments must be declared using AST_APP_ARG,
+  and they will all be character pointers (strings).
+
+  \note This defines a structure type, but does not declare an instance
+  of the structure. That must be done separately.
+ */
+#define AST_DEFINE_APP_ARGS_TYPE(type, arglist) \
+	struct type { \
 		unsigned int argc; \
 		char *argv[0]; \
 		arglist \
-	} name
+	}
 
 /*!
   \brief Performs the 'standard' argument separation process for an application.
@@ -275,7 +291,9 @@
   the argc argument counter field.
  */
 #define AST_STANDARD_APP_ARGS(args, parse) \
-	args.argc = ast_app_separate_args(parse, '|', args.argv, ((sizeof(args) - offsetof(typeof(args), argv)) / sizeof(args.argv[0])))
+	args.argc = __ast_app_separate_args(parse, '|', 1, args.argv, ((sizeof(args) - offsetof(typeof(args), argv)) / sizeof(args.argv[0])))
+#define AST_STANDARD_RAW_ARGS(args, parse) \
+	args.argc = __ast_app_separate_args(parse, '|', 0, args.argv, ((sizeof(args) - offsetof(typeof(args), argv)) / sizeof(args.argv[0])))
 	
 /*!
   \brief Performs the 'nonstandard' argument separation process for an application.
@@ -288,12 +306,15 @@
   the argc argument counter field.
  */
 #define AST_NONSTANDARD_APP_ARGS(args, parse, sep) \
-	args.argc = ast_app_separate_args(parse, sep, args.argv, ((sizeof(args) - offsetof(typeof(args), argv)) / sizeof(args.argv[0])))
+	args.argc = __ast_app_separate_args(parse, sep, 1, args.argv, ((sizeof(args) - offsetof(typeof(args), argv)) / sizeof(args.argv[0])))
+#define AST_NONSTANDARD_RAW_ARGS(args, parse, sep) \
+	args.argc = __ast_app_separate_args(parse, sep, 0, args.argv, ((sizeof(args) - offsetof(typeof(args), argv)) / sizeof(args.argv[0])))
 	
 /*!
   \brief Separate a string into arguments in an array
   \param buf The string to be parsed (this must be a writable copy, as it will be modified)
   \param delim The character to be used to delimit arguments
+  \param remove_chars Remove backslashes and quote characters, while parsing
   \param array An array of 'char *' to be filled in with pointers to the found arguments
   \param arraylen The number of elements in the array (i.e. the number of arguments you will accept)
 
@@ -304,7 +325,8 @@
 
   \return The number of arguments found, or zero if the function arguments are not valid.
 */
-unsigned int ast_app_separate_args(char *buf, char delim, char **array, int arraylen);
+unsigned int __ast_app_separate_args(char *buf, char delim, int remove_chars, char **array, int arraylen);
+#define ast_app_separate_args(a,b,c,d)	__ast_app_separate_args(a,b,1,c,d)
 
 /*!
   \brief A structure to hold the description of an application 'option'.
Index: asterisk-1.4.26.2/include/asterisk/manager.h
===================================================================
--- asterisk-1.4.26.2.orig/include/asterisk/manager.h	2009-09-23 10:41:51.000000000 +0200
+++ asterisk-1.4.26.2/include/asterisk/manager.h	2009-09-23 10:45:56.000000000 +0200
@@ -56,6 +56,10 @@
 #define EVENT_FLAG_USER                 (1 << 6) /* Ability to read/set user info */
 #define EVENT_FLAG_CONFIG		(1 << 7) /* Ability to modify configurations */
 #define EVENT_FLAG_DTMF  		(1 << 8) /* Ability to read DTMF events */
+#define EVENT_FLAG_REPORTING		(1 << 9) /* Reporting events such as rtcp sent */
+#define EVENT_FLAG_CDR			(1 << 10) /* CDR events */
+#define EVENT_FLAG_DIALPLAN		(1 << 11) /* Dialplan events (VarSet, NewExten) */
+#define EVENT_FLAG_ORIGINATE		(1 << 12) /* Originate a call to an extension */
 
 /* Export manager structures */
 #define AST_MAX_MANHEADERS 128
Index: asterisk-1.4.26.2/main/app.c
===================================================================
--- asterisk-1.4.26.2.orig/main/app.c	2009-03-03 00:09:01.000000000 +0100
+++ asterisk-1.4.26.2/main/app.c	2009-09-23 10:51:02.000000000 +0200
@@ -969,7 +969,10 @@
 	return AST_LIST_UNLOCK(&groups);
 }
 
-unsigned int ast_app_separate_args(char *buf, char delim, char **array, int arraylen)
+#undef ast_app_separate_args
+unsigned int ast_app_separate_args(char *buf, char delim, char **array, int arraylen);
+
+unsigned int __ast_app_separate_args(char *buf, char delim, int remove_chars, char **array, int arraylen)
 {
 	int argc;
 	char *scan, *wasdelim = NULL;
@@ -992,12 +995,18 @@
 					paren--;
 			} else if (*scan == '"' && delim != '"') {
 				quote = quote ? 0 : 1;
-				/* Remove quote character from argument */
-				memmove(scan, scan + 1, strlen(scan));
-				scan--;
+				if (remove_chars) {
+					/* Remove quote character from argument */
+					memmove(scan, scan + 1, strlen(scan));
+					scan--;
+				}
 			} else if (*scan == '\\') {
-				/* Literal character, don't parse */
-				memmove(scan, scan + 1, strlen(scan));
+				if (remove_chars) {
+					/* Literal character, don't parse */
+					memmove(scan, scan + 1, strlen(scan));
+				} else {
+					scan++;
+				}
 			} else if ((*scan == delim) && !paren && !quote) {
 				wasdelim = scan;
 				*scan++ = '\0';
@@ -1015,6 +1024,12 @@
 	return argc;
 }
 
+/* ABI compatible function */
+unsigned int ast_app_separate_args(char *buf, char delim, char **array, int arraylen)
+{
+	return __ast_app_separate_args(buf, delim, 1, array, arraylen);
+}
+
 enum AST_LOCK_RESULT ast_lock_path(const char *path)
 {
 	char *s;
Index: asterisk-1.4.26.2/main/manager.c
===================================================================
--- asterisk-1.4.26.2.orig/main/manager.c	2009-09-23 10:41:51.000000000 +0200
+++ asterisk-1.4.26.2/main/manager.c	2009-09-23 10:46:43.000000000 +0200
@@ -130,6 +130,10 @@
 	{ EVENT_FLAG_USER, "user" },
 	{ EVENT_FLAG_CONFIG, "config" },
 	{ EVENT_FLAG_DTMF, "dtmf" },
+	{ EVENT_FLAG_REPORTING, "reporting" },
+	{ EVENT_FLAG_CDR, "cdr" },
+	{ EVENT_FLAG_DIALPLAN, "dialplan" },
+	{ EVENT_FLAG_ORIGINATE, "originate" },
 	{ -1, "all" },
 	{ 0, "none" },
 };
