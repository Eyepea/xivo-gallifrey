2007-09-05  Guillaume Knispel <gknispel@proformatique.com>

	pf_h323_noearlystart.patch
	$Revision$
	$Date$
	New Feature

	This patch adds the noEarlyStart user/peer/global option that is
	similar to the noFastStart one in the way it must be configured.

	noEarlyStart implies noFastStart.

	When set, Asterisk will make its possible to retain from initiating
	H.245 negotiations before sending or receiving the CONNECT message.

	For outgoing calls, this involves setting mediaWaitForConnect in the
	SETUP message. Everything will be fine if the peer honor it.
	Note that OpenH323 1.18.0 will honor the flag.

	For incoming calls, Asterisk (through ast_h323.cpp) will ask OpenH323 to
	perform <<AnswerCallDeferred>> operations instead of
	<<AnswerCallDeferredWithMedia>>. This has exactly the same effect as if
	mediaWaitForConnect was set (no problem if it indeed was) in the SETUP
	message sent by the peer, and this behavior is handled correctly by
	OpenH323 1.18.0.

Index: asterisk-classic/channels/chan_h323.c
===================================================================
--- asterisk-classic.orig/channels/chan_h323.c	2007-10-21 01:35:49.000000000 +0200
+++ asterisk-classic/channels/chan_h323.c	2007-10-21 01:35:50.000000000 +0200
@@ -682,7 +682,7 @@
 		return -1;
 	case AST_CONTROL_PROGRESS:
 		if (c->_state != AST_STATE_UP) {
-			h323_send_progress(token);
+			h323_send_progress(token, pvt->options.noEarlyStart);
 			break;
 		}
 		if (token)
@@ -1453,7 +1453,7 @@
  *
  * Returns 1 on success
  */
-static int answer_call(unsigned call_reference, const char *token)
+static call_options_t *answer_call(unsigned call_reference, const char *token)
 {
 	struct oh323_pvt *pvt;
 	struct ast_channel *c = NULL;
@@ -1465,7 +1465,7 @@
 	pvt = find_call_locked(call_reference, token); 
 	if (!pvt) {
 		ast_log(LOG_ERROR, "Something is wrong: answer_call\n");
-		return 0;
+		return NULL;
 	}
 	/* allocate a channel and tell asterisk about it */
 	c = __oh323_new(pvt, AST_STATE_RINGING, pvt->cd.call_token);
@@ -1474,9 +1474,9 @@
 	ast_mutex_unlock(&pvt->lock);
 	if (!c) {
 		ast_log(LOG_ERROR, "Couldn't create channel. This is bad\n");
-		return 0;
+		return NULL;
 	}
-	return 1;
+	return &pvt->options;
 }
 
 /**
@@ -1890,8 +1890,14 @@
 		options->nat = ast_true(v->value);
 	} else if (!strcasecmp(v->name, "noFastStart")) {
 		options->noFastStart = ast_true(v->value);
+		if (options->noEarlyStart)
+			options->noFastStart = 1;
 	} else if (!strcasecmp(v->name, "noH245Tunneling")) {
 		options->noH245Tunneling = ast_true(v->value);
+	} else if (!strcasecmp(v->name, "noEarlyStart")) {
+		options->noEarlyStart = ast_true(v->value);
+		if (options->noEarlyStart)
+			options->noFastStart = 1;
 	} else if (!strcasecmp(v->name, "noSilenceSuppression")) {
 		options->noSilenceSuppression = ast_true(v->value);
 	} else if (!strcasecmp(v->name, "progress_setup")) {
Index: asterisk-classic/channels/h323/ast_h323.cpp
===================================================================
--- asterisk-classic.orig/channels/h323/ast_h323.cpp	2007-10-21 01:35:49.000000000 +0200
+++ asterisk-classic/channels/h323/ast_h323.cpp	2007-10-21 01:35:50.000000000 +0200
@@ -594,7 +594,8 @@
 	conn = new MyH323Connection(*this, callReference, options);
 	if (conn) {
 		if (opts)
-			conn->SetCallOptions(opts);
+			conn->SetCallOptions(opts,
+			                     setupPDU != NULL); /* incoming? */
 	}
 	return conn;
 }
@@ -656,6 +657,7 @@
 								  const H323SignalPDU & setupPDU,
 								  H323SignalPDU & /*connectPDU*/)
 {
+	const call_options_t *opts;
 	unsigned pi;
 
 	if (h323debug) {
@@ -683,12 +685,15 @@
 		cout << "\t\t- Inserting PI of " << pi << " into ALERTING message" << endl;
 	}
 
-	if (!on_answer_call(GetCallReference(), (const char *)GetCallToken())) {
+	if (!(opts = on_answer_call(GetCallReference(), (const char *)GetCallToken()))) {
 		return H323Connection::AnswerCallDenied;
 	}
 	/* The call will be answered later with "AnsweringCall()" function.
-	 */ 
-	return H323Connection::AnswerCallDeferredWithMedia;
+	 */
+	if (opts->noEarlyStart)
+		return H323Connection::AnswerCallDeferred;
+	else
+		return H323Connection::AnswerCallDeferredWithMedia;
 }
 
 BOOL MyH323Connection::OnAlerting(const H323SignalPDU & alertingPDU, const PString & username)
@@ -724,7 +729,7 @@
         return connectionState != ShuttingDownConnection;
 }
 
-void MyH323Connection::SetCallOptions(void *o)
+void MyH323Connection::SetCallOptions(void *o, bool incoming)
 {
 	call_options_t *opts = (call_options_t *)o;
 	progressSetup = opts->progress_setup;
@@ -735,6 +740,8 @@
 		userDataDiscriminator = opts->user_data_discriminator;
 	} else
 		userDataDiscriminator = -1;
+	if (!incoming && opts->noEarlyStart)
+		mediaWaitForConnect = TRUE;
 }
 
 BOOL MyH323Connection::SetUserDataInSetup(H323SignalPDU & setupPDU) const
@@ -915,6 +922,9 @@
 		return FALSE;
 	}
 
+	H225_Setup_UUIE & setup = setupPDU.m_h323_uu_pdu.m_h323_message_body;
+	setup.m_mediaWaitForConnect = mediaWaitForConnect;
+
 	if (progressSetup) {
 		setupPDU.GetQ931().SetProgressIndicator(progressSetup);
 	}
@@ -1516,7 +1526,7 @@
 }
 
 /* Send Progress PDU to H.323 caller */
-int h323_send_progress(const char *token)
+int h323_send_progress(const char *token, int noEarlyStart)
 {
         const PString currentToken(token);
         H323Connection * connection;
@@ -1526,7 +1536,10 @@
                 cout << "No connection found for " << token << endl;
                 return -1;
         }
-        connection->AnsweringCall(H323Connection::AnswerCallDeferredWithMedia);
+	if (noEarlyStart)
+		connection->AnsweringCall(H323Connection::AnswerCallDeferred);
+	else
+	        connection->AnsweringCall(H323Connection::AnswerCallDeferredWithMedia);
         connection->Unlock();
         return 0;  
 }
Index: asterisk-classic/channels/h323/ast_h323.h
===================================================================
--- asterisk-classic.orig/channels/h323/ast_h323.h	2007-10-21 01:35:45.000000000 +0200
+++ asterisk-classic/channels/h323/ast_h323.h	2007-10-21 01:35:50.000000000 +0200
@@ -178,7 +178,7 @@
 	BOOL OnReceivedCapabilitySet(const H323Capabilities &, const H245_MultiplexCapability *,
 				     H245_TerminalCapabilitySetReject &);
 	void SetCause(int _cause) { cause = _cause; };
-	void SetCallOptions(void *opts);
+	void SetCallOptions(void *opts, bool incoming);
 	BOOL SetUserDataInSetup(H323SignalPDU & setupPDU) const;
 	void GetUserDataFromSetup(const H323SignalPDU & setupPDU);
 
Index: asterisk-classic/channels/h323/chan_h323.h
===================================================================
--- asterisk-classic.orig/channels/h323/chan_h323.h	2007-10-21 01:35:49.000000000 +0200
+++ asterisk-classic/channels/h323/chan_h323.h	2007-10-21 01:35:50.000000000 +0200
@@ -37,6 +37,7 @@
 	int				user_data_discriminator;
 	int				noFastStart;
 	int				noH245Tunneling;
+	int				noEarlyStart;
 	int				noSilenceSuppression;
 	int				progress_setup;
 	int				progress_alert;
@@ -156,7 +157,7 @@
 
 /* This is a callback prototype function, called when
     an H.323 call is answered */
-typedef int (*answer_call_cb)(unsigned, const char *);
+typedef call_options_t *(*answer_call_cb)(unsigned, const char *);
 extern answer_call_cb on_answer_call;
 
 /* This is a callback prototype function, called when
@@ -230,7 +231,7 @@
 	
 	/* H.323 alerting and progress */
 	int h323_send_alerting(const char *token);
-	int h323_send_progress(const char *token);
+	int h323_send_progress(const char *token, int noEarlyStart);
 	int h323_answering_call(const char *token, int);
 	int h323_soft_hangup(const char *data);	
 	int h323_show_codec(int fd, int argc, char *argv[]);
