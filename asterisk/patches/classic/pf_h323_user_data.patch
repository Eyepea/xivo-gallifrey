2007-02-26  Guillaume Knispel <gknispel@proformatique.com>

	pf_h323_user_data.patch
	$Revision$
	$Date$
	New Feature

	Allow injection of H323-UserInformation.user-data in H.323 SETUP
	messages to be sent, and retrieval of the same fields from received
	H.323 SETUP.

	H323-UserInformation.user-data.protocol-discriminator correspond to the
	channel variable USER_DATA_DISCRIMINATOR directly accessible in the
	DialPlan, or from C code by calling pbx_builtin_getvar_helper().

	H323-UserInformation.user-data.user-information correspond to the
	channel variable USER_DATA.

	Note that neither variable of an incoming call is created as propagable
	throw channel bridging. If you want transparent propagation of these
	fields set the variables again in the DialPlan while prepending an
	underscore charater to their name; for example call
	Set(_USER_DATA=${USER_DATA}) before a Dial() to an other H.323 peer.

Index: asterisk-classic/channels/chan_h323.c
===================================================================
--- asterisk-classic.orig/channels/chan_h323.c	2007-10-21 01:35:22.000000000 +0200
+++ asterisk-classic/channels/chan_h323.c	2007-10-21 01:35:45.000000000 +0200
@@ -294,6 +294,10 @@
                 free(cd->sourceIp);
                 cd->sourceIp = NULL;
         }
+        if (cd->user_data_information) {
+                free(cd->user_data_information);
+                cd->user_data_information = NULL;
+	}
 }
 
 static void __oh323_destroy(struct oh323_pvt *pvt)
@@ -391,6 +395,8 @@
 	struct oh323_pvt *pvt = (struct oh323_pvt *)c->tech_pvt;
 	char addr[INET_ADDRSTRLEN];
 	char called_addr[1024];
+	char *user_data_info;
+	char *user_data_disc;
 
 	if (h323debug) {
 		ast_log(LOG_DEBUG, "Calling to %s on %s\n", dest, c->name);
@@ -428,6 +434,30 @@
 	/* indicate that this is an outgoing call */
 	pvt->outgoing = 1;
 
+	/* send the user-data if necessary */
+	pvt->options.user_data_discriminator = -1;
+	pvt->options.user_data_information[0] = 0;
+	user_data_info = pbx_builtin_getvar_helper(c, "USER_DATA");
+	user_data_disc = pbx_builtin_getvar_helper(c, "USER_DATA_DISCRIMINATOR");
+	if (user_data_info && !user_data_disc)
+		user_data_disc = "0";		/* User specific protocol */
+
+	if (user_data_info && user_data_disc) {
+		char *endptr;
+		int discriminator = strtol(user_data_disc, &endptr, 0);
+		int user_data_len = strlen(user_data_info);
+		if (discriminator >= 0 && discriminator <= 255
+		    && user_data_len > 0 && user_data_len <= 128
+		    && *endptr == '\0' ) {
+			strncpy(pvt->options.user_data_information, user_data_info, sizeof(pvt->options.user_data_information));
+			pvt->options.user_data_information[sizeof(pvt->options.user_data_information)-1] = 0;
+			pvt->options.user_data_discriminator = discriminator;
+		} else
+			ast_log(LOG_WARNING, "User-data in SETUP message wanted, but incorrect "
+			        "content in USER_DATA (\"%s\") or USER_DATA_DISCRIMINATOR "
+				"(\"%s\")\n", user_data_info, user_data_disc);
+	}
+
 	ast_log(LOG_DEBUG, "Placing outgoing call to %s, %d\n", called_addr, pvt->options.dtmfcodec);
 	ast_mutex_unlock(&pvt->lock);
 	res = h323_make_call(called_addr, &(pvt->cd), &pvt->options);
@@ -785,6 +815,12 @@
 		}
 		ast_setstate(ch, state);
 		if (state != AST_STATE_DOWN) {
+			if (pvt->options.user_data_discriminator >= 0) {
+				char str_discriminator[8];
+				snprintf(str_discriminator, 8, "%d", pvt->options.user_data_discriminator);
+				pbx_builtin_setvar_helper(ch, "USER_DATA", pvt->options.user_data_information);
+				pbx_builtin_setvar_helper(ch, "USER_DATA_DISCRIMINATOR", str_discriminator);
+			}
 			if (ast_pbx_start(ch)) {
 				ast_log(LOG_WARNING, "Unable to start PBX on %s\n", ch->name);
 				ast_hangup(ch);
@@ -1303,6 +1339,17 @@
 	memcpy(&pvt->cd, cd, sizeof(pvt->cd));
 	memcpy(&pvt->options, &global_options, sizeof(pvt->options));
 
+	/* Propagate private data to pvt->options, so they can be forwarded
+	 * to channels variables (and to other H.323 chan when bridging) */
+	if (cd->user_data_discriminator >= 0) {
+		strncpy(pvt->options.user_data_information, cd->user_data_information, sizeof(pvt->options.user_data_information));
+		pvt->options.user_data_information[sizeof(pvt->options.user_data_information)-1] = 0;
+		pvt->options.user_data_discriminator = cd->user_data_discriminator;
+	} else {
+		pvt->options.user_data_information[0] = 0;
+		pvt->options.user_data_discriminator = -1;
+	}
+	
 	if (h323debug) {
 		ast_verbose(VERBOSE_PREFIX_3 "Setting up Call\n");
 		ast_verbose(VERBOSE_PREFIX_3 "\tCall token:  [%s]\n", pvt->cd.call_token);
@@ -2021,6 +2068,7 @@
 	h323debug = 0;
 	memset(&bindaddr, 0, sizeof(bindaddr));
 	memset(&global_options, 0, sizeof(global_options));
+	global_options.user_data_discriminator = -1;
 	global_options.dtmfcodec = 101;
 	global_options.dtmfmode = H323_DTMF_RFC2833;
 	global_options.capability = AST_FORMAT_G723_1 | AST_FORMAT_GSM | AST_FORMAT_ULAW | AST_FORMAT_ALAW | AST_FORMAT_G729A | AST_FORMAT_H261;
Index: asterisk-classic/channels/h323/ast_h323.cpp
===================================================================
--- asterisk-classic.orig/channels/h323/ast_h323.cpp	2007-10-21 01:35:22.000000000 +0200
+++ asterisk-classic/channels/h323/ast_h323.cpp	2007-10-21 01:35:45.000000000 +0200
@@ -588,6 +588,7 @@
 	bridging = FALSE;
 	progressSetup = progressAlert = 0;
 	dtmfCodec = (RTP_DataFrame::PayloadTypes)0;
+	userDataDiscriminator = -1;
 	if (h323debug) {
 		cout << "	== New H.323 Connection created." << endl;
 	}
@@ -705,10 +706,47 @@
 void MyH323Connection::SetCallOptions(void *o)
 {
 	call_options_t *opts = (call_options_t *)o;
-
 	progressSetup = opts->progress_setup;
 	progressAlert = opts->progress_alert;
 	dtmfCodec = (RTP_DataFrame::PayloadTypes)opts->dtmfcodec;
+	if (opts->user_data_discriminator >= 0 && strlen(opts->user_data_information)) {
+		userDataInformation = opts->user_data_information;
+		userDataDiscriminator = opts->user_data_discriminator;
+	} else
+		userDataDiscriminator = -1;
+}
+
+BOOL MyH323Connection::SetUserDataInSetup(H323SignalPDU & setupPDU) const
+{
+	if ((userDataDiscriminator < 0 && !userDataInformation.IsEmpty())
+	    || (userDataDiscriminator > 255)
+	    || (userDataDiscriminator >= 0 && userDataInformation.GetLength() == 0)
+	    || (userDataDiscriminator >= 0 && userDataInformation.GetLength() > 128))
+		return FALSE; /* invalid parameters, refuse to change anything in the setupPDU */
+
+	/* user_data parameters are now validated, just set them in SetupPDU */
+	if (userDataDiscriminator < 0) {
+		setupPDU.RemoveOptionalField(H225_H323_UserInformation::e_user_data);
+	} else {
+		/* Makes use of the = operator of PASN_Integer: */
+		setupPDU.m_user_data.m_protocol_discriminator = userDataDiscriminator;
+		/* Makes use of the = operator of PASN_OctetString: */
+		setupPDU.m_user_data.m_user_information = userDataInformation;
+		setupPDU.IncludeOptionalField(H225_H323_UserInformation::e_user_data);
+	}
+
+	return TRUE;
+}
+
+void MyH323Connection::GetUserDataFromSetup(const H323SignalPDU & setupPDU)
+{
+	if (!setupPDU.HasOptionalField(H225_H323_UserInformation::e_user_data)) {
+		userDataDiscriminator = -1;
+		userDataInformation.MakeEmpty();
+	} else {
+		userDataDiscriminator = (unsigned) setupPDU.m_user_data.m_protocol_discriminator;
+		userDataInformation = setupPDU.m_user_data.m_user_information.AsString();
+	}
 }
 
 BOOL MyH323Connection::OnReceivedSignalSetup(const H323SignalPDU & setupPDU)
@@ -721,7 +759,7 @@
 	PString destAliases;
 	PIPSocket::Address Ip;
 	WORD sourcePort;
-	char *s, *s1; 
+	char *s, *s1;
 
 	if (h323debug) {
 		cout << ("\t--Received SETUP message\n");
@@ -732,7 +770,7 @@
 
 	sourceAliases = setupPDU.GetSourceAliases();
 	destAliases = setupPDU.GetDestinationAlias();
-			
+
 	sourceE164 = "";
 	setupPDU.GetSourceE164(sourceE164);
 	sourceName = "";
@@ -740,6 +778,8 @@
 	destE164 = "";
 	setupPDU.GetDestinationE164(destE164);
 
+	GetUserDataFromSetup(setupPDU);
+
 	/* Convert complex strings */
 	//  FIXME: deal more than one source alias 
     	if ((s = strchr(sourceAliases, ' ')) != NULL) {
@@ -767,6 +807,9 @@
 	GetSignallingChannel()->GetRemoteAddress().GetIpAndPort(Ip, sourcePort);
  	cd.sourceIp = strdup((const char *)Ip.AsString());
 
+	cd.user_data_information = strdup((const char *)userDataInformation);
+	cd.user_data_discriminator = userDataDiscriminator;
+
 	/* Notify Asterisk of the request */
 	call_options_t *res = on_incoming_call(&cd);
 
@@ -836,6 +879,12 @@
 	cd.call_dest_alias = strdup((const char *)destAliases);
 	cd.call_source_e164 = strdup((const char *)sourceE164);
 	cd.call_dest_e164 = strdup((const char *)destE164);
+	cd.user_data_information = strdup((const char *)userDataInformation);
+	cd.user_data_discriminator = userDataDiscriminator;
+
+	/* Send user-data after the H.225 SETUP if necessary */
+	if (userDataDiscriminator > -1)
+		SetUserDataInSetup(setupPDU);
 
 	int res = on_outgoing_call(&cd);
 	if (!res) {
Index: asterisk-classic/channels/h323/ast_h323.h
===================================================================
--- asterisk-classic.orig/channels/h323/ast_h323.h	2007-10-21 01:35:22.000000000 +0200
+++ asterisk-classic/channels/h323/ast_h323.h	2007-10-21 01:35:45.000000000 +0200
@@ -179,18 +179,22 @@
 				     H245_TerminalCapabilitySetReject &);
 	void SetCause(int _cause) { cause = _cause; };
 	void SetCallOptions(void *opts);
+	BOOL SetUserDataInSetup(H323SignalPDU & setupPDU) const;
+	void GetUserDataFromSetup(const H323SignalPDU & setupPDU);
 
 	PString sourceAliases;
 	PString destAliases;
 	PString sourceE164;
 	PString destE164;
+	PString userDataInformation;
 
 	WORD sessionId;
-	BOOL bridging;			
+	BOOL bridging;
 
 	unsigned progressSetup;
 	unsigned progressAlert;
 	int cause;
+	int userDataDiscriminator;
 
 	RTP_DataFrame::PayloadTypes dtmfCodec;
 
Index: asterisk-classic/channels/h323/chan_h323.h
===================================================================
--- asterisk-classic.orig/channels/h323/chan_h323.h	2007-10-21 01:35:22.000000000 +0200
+++ asterisk-classic/channels/h323/chan_h323.h	2007-10-21 01:35:45.000000000 +0200
@@ -33,6 +33,8 @@
 typedef struct call_options {
 	char			cid_num[80];
 	char			cid_name[80];
+	char			user_data_information[129];
+	int				user_data_discriminator;
 	int				noFastStart;
 	int				noH245Tunneling;
 	int				noSilenceSuppression;
@@ -98,6 +100,8 @@
 	int presentation;
 	int screening;
 	char *sourceIp;
+	char *user_data_information;
+	int user_data_discriminator;
 } call_details_t;
 
 typedef struct rtp_info {
