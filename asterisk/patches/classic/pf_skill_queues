Index: asterisk-1.4.30/apps/app_queue.c
===================================================================
--- asterisk-1.4.30.orig/apps/app_queue.c	2010-03-30 16:48:31.000000000 +0200
+++ asterisk-1.4.30/apps/app_queue.c	2010-04-12 03:59:13.000000000 +0200
@@ -150,7 +150,7 @@
 static char *synopsis = "Queue a call for a call queue";
 
 static char *descrip =
-"  Queue(queuename[|options[|URL][|announceoverride][|timeout][|AGI]):\n"
+"  Queue(queuename[|options[|URL][|announceoverride][|timeout][|AGI][|skill_ruleset]):\n"
 "Queues an incoming call in a particular call queue as defined in queues.conf.\n"
 "This application will return to the dialplan if the queue does not exist, or\n"
 "any of the join options cause the caller to not enter the queue.\n"
@@ -192,7 +192,7 @@
 static char *app_aqm = "AddQueueMember" ;
 static char *app_aqm_synopsis = "Dynamically adds queue members" ;
 static char *app_aqm_descrip =
-"   AddQueueMember(queuename[|interface[|penalty[|options[|membername[|state_interface[|incominglimit]]]]]]):\n"
+"   AddQueueMember(queuename[|interface[|penalty[|options[|membername[|state_interface[|incominglimit[|skills]]]]]]]):\n"
 "Dynamically adds interface to an existing queue.\n"
 "If the interface is already in the queue and there exists an n+101 priority\n"
 "then it will then jump to this priority.  Otherwise it will return an error\n"
@@ -331,9 +331,14 @@
 	struct member *member;
 };
 
+struct virtual_queue {
+	char id[80];                        /*!< Argument 'ruleset' to the Queue() app. */
+	int holdtime;                       /*!< Estimated Waiting Time for this virtual queue. */
+};
 
 struct queue_ent {
 	struct call_queue *parent;          /*!< What queue is our parent */
+	struct virtual_queue *vqueue;       /*!< Virtual queue in case there is skills routing */
 	char moh[80];                       /*!< Name of musiconhold to be used */
 	char announce[80];                  /*!< Announcement to play for member when call is answered */
 	char context[AST_MAX_CONTEXT];      /*!< Context when user exits queue */
@@ -349,24 +354,111 @@
 	int handled;                        /*!< Whether our call was handled */
 	int pending;                        /*!< Non-zero if we are attempting to call a member */
 	int max_penalty;                    /*!< Limit the members that can take this call to this penalty or lower */
+	char skill_ruleset[80];             /*!< Name of the skill ruleset */
+	time_t skills_next_check;            /*!< Next check of skills rules. */
 	time_t start;                       /*!< When we started holding */
 	time_t expire;                      /*!< When this entry should expire (time out of queue) */
+	struct ao2_container *mem_selection;/*!< Members who match skill rules. */
 	struct ast_channel *chan;           /*!< Our channel */
 	struct queue_ent *next;             /*!< The next queue entry */
 };
 
+enum skill_rule_operand_type {
+	SKILL_RULE_OPERAND_UNKNOWN,
+	SKILL_RULE_OPERAND_VARIABLE,
+	SKILL_RULE_OPERAND_VALUE,
+	SKILL_RULE_OPERAND_OPERATOR,
+};
+
+struct skill_rule_operand {
+	union {
+		char var[80];
+		int value;
+		struct skill_rule_operator* operator;
+	} u;
+	enum skill_rule_operand_type type;
+	AST_LIST_ENTRY(skill_rule_operand) entry;
+};
+
+enum skill_rule_operator_type {
+	SKILL_RULE_OPERATOR_UNKNOWN,
+	SKILL_RULE_OPERATOR_DIVISION,       /*!<  op1 / op2  */
+	SKILL_RULE_OPERATOR_MULTIPLICATION, /*!<  op1 * op2  */
+	SKILL_RULE_OPERATOR_SUBTRACTION,    /*!<  op1 - op2  */
+	SKILL_RULE_OPERATOR_ADDITION,       /*!<  op1 + op2  */
+	SKILL_RULE_OPERATOR_NOTEQUAL,       /*!<  op1 ! op2  */
+	SKILL_RULE_OPERATOR_EQUAL,          /*!<  op1 = op2  */
+	SKILL_RULE_OPERATOR_GREATER,        /*!<  op1 > op2  */
+	SKILL_RULE_OPERATOR_LESSER,         /*!<  op1 < op2  */
+	SKILL_RULE_OPERATOR_AND,            /*!<  op1 & op2  */
+	SKILL_RULE_OPERATOR_OR              /*!<  op1 | op2  */
+};
+
+#define SKILL_RULE_OPERATORS_CHARS "/*-+!=><&|"
+static enum skill_rule_operator_type skill_rule_operator_type_str[] = {
+	['/'] = SKILL_RULE_OPERATOR_DIVISION,
+	['*'] = SKILL_RULE_OPERATOR_MULTIPLICATION,
+	['-'] = SKILL_RULE_OPERATOR_SUBTRACTION,
+	['+'] = SKILL_RULE_OPERATOR_ADDITION,
+	['!'] = SKILL_RULE_OPERATOR_NOTEQUAL,
+	['='] = SKILL_RULE_OPERATOR_EQUAL,
+	['>'] = SKILL_RULE_OPERATOR_GREATER,
+	['<'] = SKILL_RULE_OPERATOR_LESSER,
+	['&'] = SKILL_RULE_OPERATOR_AND,
+	['|'] = SKILL_RULE_OPERATOR_OR,
+};
+
+struct skill_rule_operator {
+	struct skill_rule_operator *parent;
+	AST_LIST_HEAD_NOLOCK(,skill_rule_operand) operands;
+	enum skill_rule_operator_type type;
+};
+
+struct skill_rule {
+	struct skill_rule_operator *dcond;           /*!< Condition against dynamical variables */
+	struct skill_rule_operator *cond;            /*!< Condition against skills */
+};
+
+struct skill_ruleset {
+	char name[80];
+	struct ao2_container *rules;
+	AST_LIST_ENTRY(skill_ruleset) entry;
+};
+
+static AST_LIST_HEAD_STATIC(skill_rulesets, skill_ruleset);
+
+struct rule_var {
+	char name[80];
+	char value[80];
+};
+
+struct skill {
+	char name[80];                      /*!< Name of skill */
+	int weight;                         /*!< Weight */
+};
+
+struct skills_group {
+	char name[80];
+	struct ao2_container *skills;       /*!< Head of the list of skills */
+	AST_LIST_ENTRY(skills_group) entry;
+};
+
+static AST_LIST_HEAD_STATIC(skills_groups, skills_group);
+
 struct member {
 	char interface[80];                 /*!< Technology/Location */
-	char state_interface[80];			/*!< Technology/Location from which to read device state changes */
+	char state_interface[80];           /*!< Technology/Location from which to read device state changes */
 	char membername[80];                /*!< Member name to use in queue logs */
+	char skills[80];                    /*!< Member skills */
 	int penalty;                        /*!< Are we a last resort? */
 	int calls;                          /*!< Number of calls serviced by this member */
 	int dynamic;                        /*!< Are we dynamically added? */
 	int realtime;                       /*!< Is this member realtime? */
 	int status;                         /*!< Status of queue member */
 	int paused;                         /*!< Are we paused (not accepting calls)? */
-	int current_calls;		    /*!< Number of calls this member is servicing */
-	int incominglimit;		    /*!< Maximum number of calls this member can be servicing */
+	int current_calls;                  /*!< Number of calls this member is servicing */
+	int incominglimit;                  /*!< Maximum number of calls this member can be servicing */
+	int holdtime;                       /*!< Average holdtime. */
 	time_t lastcall;                    /*!< When last successful call was hungup */
 	unsigned int dead:1;                /*!< Used to detect members deleted in realtime */
 	unsigned int delme:1;               /*!< Flag to delete entry on reload */
@@ -441,6 +533,7 @@
 	int memberdelay;                    /*!< Seconds to delay connecting member to caller */
 	int autofill;                       /*!< Ignore the head call status and ring an available agent */
 	
+	struct ao2_container *vqueues;      /*!< Virtual queues */
 	struct ao2_container *members;             /*!< Head of the list of members */
 	/*! 
 	 * \brief Number of members _logged in_
@@ -457,6 +550,7 @@
 static int set_member_paused(const char *queuename, const char *interface, int paused);
 static void queue_transfer_fixup(void *data, struct ast_channel *old_chan, struct ast_channel *new_chan); 
 static void free_members(struct call_queue *q, int all);
+static int update_queue_ent_skills_next_check(struct call_queue *q);
 
 static void rr_dep_warning(void)
 {
@@ -532,6 +626,751 @@
 		free_members(q, 1);
 		ao2_ref(q->members, -1);
 	}
+	if (q->vqueues) {
+		ao2_ref(q->vqueues, -1);
+	}
+}
+
+static void destroy_skills_group(void *obj)
+{
+	struct skills_group *skgrp = obj;
+	struct skill *cur;
+	struct ao2_iterator sk_iter = ao2_iterator_init(skgrp->skills, 0);
+
+	while ((cur = ao2_iterator_next(&sk_iter))) {
+		ao2_unlink(skgrp->skills, cur);
+		ao2_ref(cur, -1);
+	}
+	ao2_iterator_destroy(&sk_iter);
+	ao2_ref(skgrp->skills, -1);
+}
+
+static void destroy_operator(struct skill_rule_operator *op)
+{
+	struct skill_rule_operand *operand;
+
+	if (!op)
+		return;
+
+	AST_LIST_TRAVERSE_SAFE_BEGIN(&op->operands, operand, entry) {
+		AST_LIST_REMOVE_CURRENT(&op->operands, entry);
+		if (operand->type == SKILL_RULE_OPERAND_OPERATOR)
+			destroy_operator(operand->u.operator);
+
+		ast_free(operand);
+	}
+	AST_LIST_TRAVERSE_SAFE_END;
+	ast_free(op);
+}
+
+static void destroy_skill_rule(void* obj)
+{
+	struct skill_rule* r = obj;
+	if (r->dcond)
+		destroy_operator(r->dcond);
+	if (r->cond)
+		destroy_operator(r->cond);
+}
+
+static void destroy_skill_ruleset(void *obj)
+{
+	struct skill_ruleset *ruleset = obj;
+	struct skill_rule *cur;
+	struct ao2_iterator rule_iter = ao2_iterator_init(ruleset->rules, 0);
+
+	while ((cur = ao2_iterator_next(&rule_iter))) {
+		ao2_unlink(ruleset->rules, cur);
+		ao2_ref(cur, -1);
+	}
+	ao2_iterator_destroy(&rule_iter);
+	ao2_ref(ruleset->rules, -1);
+}
+
+static struct skill_rule_operator *create_skill_rule_operator(enum skill_rule_operator_type t, struct skill_rule_operator *parent)
+{
+	struct skill_rule_operator *op;
+	op = ast_calloc(1, sizeof(*op));
+	if (!op)
+		return NULL;
+
+	op->type = t;
+	AST_LIST_HEAD_INIT_NOLOCK(&op->operands);
+	op->parent = parent;
+
+	return op;
+}
+
+static struct skill_rule_operand *create_skill_rule_operand(enum skill_rule_operand_type t)
+{
+	struct skill_rule_operand *operand;
+	operand = ast_calloc(1, sizeof(*operand));
+	if (!operand)
+		return NULL;
+
+	operand->type = t;
+	return operand;
+}
+
+static char* display_operator(struct skill_rule_operator *op)
+{
+	struct skill_rule_operand *operand;
+	size_t len = 512;
+	char *str = malloc(len);
+	char *s = str;
+
+	*str = '\0';
+	AST_LIST_TRAVERSE(&op->operands, operand, entry) {
+		char t;
+		switch(op->type) {
+		case SKILL_RULE_OPERATOR_NOTEQUAL: t = '!'; break;
+		case SKILL_RULE_OPERATOR_EQUAL:    t = '='; break;
+		case SKILL_RULE_OPERATOR_GREATER:    t = '>'; break;
+		case SKILL_RULE_OPERATOR_LESSER:    t = '<'; break;
+		case SKILL_RULE_OPERATOR_AND:      t = '&'; break;
+		case SKILL_RULE_OPERATOR_OR:       t = '|'; break;
+		default:                     t = '?'; break;
+		}
+
+		if (*str != '\0')
+			ast_build_string(&s, &len, "%c", t);
+
+		switch(operand->type) {
+		case SKILL_RULE_OPERAND_VARIABLE:
+			ast_build_string(&s, &len, "%s", operand->u.var);
+			break;
+		case SKILL_RULE_OPERAND_VALUE:
+			ast_build_string(&s, &len, "%d", operand->u.value);
+			break;
+		case SKILL_RULE_OPERAND_OPERATOR:
+		{
+			char *tmp = display_operator(operand->u.operator);
+			ast_build_string(&s, &len, "(%s)", tmp);
+			free(tmp);
+			break;
+		}
+		case SKILL_RULE_OPERAND_UNKNOWN:
+			ast_build_string(&s, &len, "<unknown>");
+		}
+	}
+	return str;
+}
+
+static struct skill_rule_operator* parse_expr(const char *expr)
+{
+	struct skill_rule_operator *op, *head;
+	struct skill_rule_operand *operand = NULL;
+	const char *ptr, *start = NULL;
+
+	op = create_skill_rule_operator(SKILL_RULE_OPERATOR_UNKNOWN, NULL);
+	if (!op)
+		return NULL;
+
+	head = op;
+	ptr = expr;
+	do {
+		if (start) {
+			/* currently parsing a variable name. */
+			if ((*ptr >= 'a' && *ptr <= 'z') ||
+			    (*ptr >= 'A' && *ptr <= 'Z') ||
+			    (*ptr >= '0' && *ptr <= '9') ||
+			    (*ptr != '\0' && strchr("$-_", *ptr))) {
+				++ptr;
+				continue;
+			}
+
+			if (operand) {
+				ast_log(LOG_ERROR, "Unable to parse rule: syntax error, missing operator.\n");
+				goto error;
+			}
+
+			operand = create_skill_rule_operand(SKILL_RULE_OPERAND_VARIABLE);
+			if (!operand) {
+				/* OOM */
+				ast_log(LOG_ERROR, "Unable to parse rule: out-of-memory.\n");
+				goto error;
+			}
+			ast_copy_string(operand->u.var, start, (ptr + 1 - start) > sizeof(operand->u.var)
+			                                                         ? sizeof(operand->u.var)
+			                                                         : (ptr + 1 - start));
+			start = NULL;
+		}
+		if ((*ptr >= 'a' && *ptr <= 'z') ||
+		    (*ptr >= 'A' && *ptr <= 'Z') ||
+		    *ptr == '$') {
+			/* starting to parse a variable name. */
+			start = ptr++;
+			continue;
+		}
+		if ((*ptr >= '0' && *ptr <= '9') || *ptr == '-') {
+			/* parsing an integer value. */
+			int value;
+			start = ptr;
+			errno = 0;
+			value = strtol(start, (char**)&ptr, 10);
+			if (start == ptr) {
+				/* no digits found */
+				ast_log(LOG_ERROR, "Unable to parse rule: syntax error, no-digits.\n");
+				goto error;
+			}
+			if ((errno == ERANGE && (value == LONG_MAX || value == LONG_MIN)) ||
+			    (errno != 0 && value == 0)) {
+				/* error */
+				ast_log(LOG_ERROR, "Unable to parse rule: strtol error: %s.\n", strerror(errno));
+				goto error;
+			}
+
+			if (operand) {
+				/* WTF syn error */
+				ast_log(LOG_ERROR, "Unable to parse rule: syntax error, missing operator.\n");
+				goto error;
+			}
+			operand = create_skill_rule_operand(SKILL_RULE_OPERAND_VALUE);
+			if (!operand) {
+				/* OOM */
+				ast_log(LOG_ERROR, "Unable to parse rule: out-of-memory.\n");
+				goto error;
+			}
+			operand->u.value = value;
+			start = NULL;
+			continue;
+		}
+		if (*ptr == '(') {
+			struct skill_rule_operator *newop;
+			char *tmp;
+
+			if (operand) {
+				ast_log(LOG_ERROR, "Unable to parse rule: missing operator before '('\n");
+				goto error;
+			}
+
+			start = ++ptr;
+			ptr += strlen(ptr);
+			while (ptr >= start && *ptr != ')')
+				--ptr;
+
+			if (ptr == start) {
+				ast_log(LOG_ERROR, "Unable to parse rule: empty expression between ()\n");
+				goto error;
+			}
+			if (ptr < start) {
+				ast_log(LOG_ERROR, "Unable to parse rule: missing ')'\n");
+				goto error;
+			}
+
+			tmp = ast_strndup(start, ptr-start);
+			newop = parse_expr(tmp);
+			ast_free(tmp);
+
+			if (!newop) {
+				/* Something failed while parsing subexpr. Do
+				 * not display any message as parse_expr()
+				 * probably dit it.
+				 */
+				goto error;
+			}
+
+			operand = create_skill_rule_operand(SKILL_RULE_OPERAND_OPERATOR);
+			if (!operand) {
+				ast_log(LOG_ERROR, "Unable to parse rule: out-of-memory\n");
+				ast_free(newop);
+				goto error;
+			}
+			operand->u.operator = newop;
+			start = NULL;
+			++ptr;
+		}
+		/* if *ptr == '\0', strchr("...", *ptr) != NULL */
+		if (strchr(SKILL_RULE_OPERATORS_CHARS, *ptr)) {
+			/* operator */
+			enum skill_rule_operator_type flag = SKILL_RULE_OPERATOR_UNKNOWN;
+
+			if (!operand) {
+				/* syntax error */
+				ast_log(LOG_ERROR, "Unable to parse rule: syntax error, no operand before '%c'.\n", *ptr ? *ptr : ';');
+				goto error;
+			}
+
+			if (*ptr != '\0')
+				flag = skill_rule_operator_type_str[(size_t)*ptr];
+			else
+				flag = op->type;
+
+			if (op->type == SKILL_RULE_OPERATOR_UNKNOWN) {
+				if (flag == SKILL_RULE_OPERATOR_UNKNOWN) {
+					/* syntax error */
+					ast_log(LOG_ERROR, "Unable to parse rule: syntax error, no operator.\n");
+					goto error;
+				}
+				op->type = flag;
+			}
+
+			if (op->type < flag) {
+				/* last operator has a greater priority than current operator. */
+				struct skill_rule_operator *parent;
+
+				/* Firstly, add the operand in the current operator. */
+				AST_LIST_INSERT_TAIL(&op->operands, operand, entry);
+				operand = NULL;
+
+				/* Then we try to jump to an upper operator, or to create one. */
+
+				/* look for a parent operator with a lower or equal priority. */
+				for(parent = op->parent; parent && parent->type < flag; parent = parent->parent)
+					op = parent;
+
+				if (!parent) {
+					/* There isn't any other operator with a lower or equal priority */
+					parent = create_skill_rule_operator(flag, NULL);
+					if (!parent) {
+						/* OOM */
+						ast_log(LOG_ERROR, "Unable to parse rule: out-of-memory.\n");
+						goto error;
+					}
+
+					operand = create_skill_rule_operand(SKILL_RULE_OPERAND_OPERATOR);
+					if (!operand) {
+						/* OOM */
+						ast_log(LOG_ERROR, "Unable to parse rule: out-of-memory.\n");
+						ast_free(parent);
+						goto error;
+					}
+					operand->u.operator = op;
+
+					op->parent = parent;
+					AST_LIST_INSERT_TAIL(&parent->operands, operand, entry);
+
+					head = parent;
+
+					operand = NULL;
+				} else if (parent->type > flag) {
+					/* There is an operator with a greater priority, so we insert this
+					 * operator between this one and his last child. */
+					struct skill_rule_operator *newop;
+					newop = create_skill_rule_operator(flag, parent);
+					if (!newop) {
+						/* OOM */
+						ast_log(LOG_ERROR, "Unable to parse rule: out-of-memory.\n");
+						goto error;
+					}
+
+					AST_LIST_TRAVERSE(&parent->operands, operand, entry) {
+						if (operand->type == SKILL_RULE_OPERAND_OPERATOR && operand->u.operator == op)
+							break;
+					}
+
+					if (!operand) {
+						/* WTF */
+						ast_free(newop);
+						ast_log(LOG_ERROR, "Unable to parse rule: internal error (unable to find operand).\n");
+						goto error;
+					}
+					op->parent = newop;
+
+					AST_LIST_REMOVE(&parent->operands, operand, entry);
+					AST_LIST_INSERT_TAIL(&newop->operands, operand, entry);
+					operand = NULL;
+
+					operand = create_skill_rule_operand(SKILL_RULE_OPERAND_OPERATOR);
+					if (!operand) {
+						/* OOM */
+						ast_free(newop);
+						ast_log(LOG_ERROR, "Unable to parse rule: out-of-memory.\n");
+						goto error;
+					}
+					operand->u.operator = newop;
+					AST_LIST_INSERT_TAIL(&parent->operands, operand, entry);
+
+					operand = NULL;
+
+					parent = newop;
+				}
+				op = parent;
+
+			} else if (op->type > flag) {
+				/* last operator has a lower priority than current operator. */
+				struct skill_rule_operator *newop;
+				newop = create_skill_rule_operator(flag, op);
+				if (!newop) {
+					/* OOM */
+					ast_log(LOG_ERROR, "Unable to parse rule: out-of-memory.\n");
+					goto error;
+				}
+
+				AST_LIST_INSERT_TAIL(&newop->operands, operand, entry);
+				operand = NULL;
+
+				operand = create_skill_rule_operand(SKILL_RULE_OPERAND_OPERATOR);
+				if (!operand) {
+					/* OOM */
+					ast_log(LOG_ERROR, "Unable to parse rule: out-of-memory.\n");
+					ast_free(newop);
+					goto error;
+				}
+				operand->u.operator = newop;
+				AST_LIST_INSERT_TAIL(&op->operands, operand, entry);
+				operand = NULL;
+
+				op = newop;
+			} else {
+				AST_LIST_INSERT_TAIL(&op->operands, operand, entry);
+				operand = NULL;
+			}
+		}
+
+		++ptr;
+	} while (*(ptr-1));
+
+	return head;
+
+error:
+	destroy_operator(head);
+	if(operand)
+		ast_free(operand);
+	return NULL;
+}
+
+static int parse_skill_rule(struct skill_rule *r, const char *line)
+{
+	char* dcond = ast_strdupa(line);
+	char* cond;
+
+	cond = strchr(dcond, ',');
+	if (cond) {
+		*cond++ = '\0';
+		r->dcond = parse_expr(dcond);
+	}
+	else
+		cond = dcond;
+
+	r->cond = parse_expr(cond);
+	return 0;
+}
+
+static int operator_eval(struct skill_rule_operator *op, struct ao2_container *variables, struct ast_channel* chan,
+                         int (*getvalue_fn) (const char* key, void* data), void* data,
+                         void (*operator_proceeded_cb) (const char* left_name, int left_value, enum skill_rule_operator_type operator, const char* right_name, int right_value, void* data))
+{
+	struct skill_rule_operand *opnd = NULL;
+	int ret = 0;
+	const char* last_name = NULL;
+	int first = 1;
+
+	if (!op) {
+		ast_log(LOG_WARNING, "Rule is empty\n");
+		return 0;
+	}
+
+	AST_LIST_TRAVERSE(&op->operands, opnd, entry) {
+		const char *name = NULL;
+		int value = 0;
+		switch(opnd->type) {
+			case SKILL_RULE_OPERAND_VARIABLE:
+			{
+				struct rule_var *var = NULL;
+				name = opnd->u.var;
+
+				if (*name == '$') {
+					++name;
+
+					/* This is a meta-variable, find the value in the variables list. */
+					if (variables != NULL) {
+						struct ao2_iterator variter = ao2_iterator_init(variables, 0);
+
+						while ((var = ao2_iterator_next(&variter)) && strcmp(name, var->name))
+							ao2_ref(var, -1);
+
+						if (var)
+							name = var->value;
+
+						ao2_iterator_destroy(&variter);
+					}
+
+					/* If doesn't found in variables list, try with env vars */
+					if (!var && chan != NULL)
+						name = pbx_builtin_getvar_helper(chan, name);
+				}
+
+				if (name) {
+					char *endptr = NULL;
+					int v = strtoul(name, &endptr, 10);
+
+					if (endptr == '\0') {
+						value = v; /* name is an integer, so that's the value. */
+					} else if (getvalue_fn) {
+						/* Use callback to get the value of this variable. */
+						value = getvalue_fn(name, data);
+					} else {
+						ast_log(LOG_ERROR, "There is no 'getvalue' callback defined");
+					}
+				}
+
+				if (var)
+					ao2_ref(var, -1);
+				break;
+			}
+			case SKILL_RULE_OPERAND_VALUE:
+				value = opnd->u.value;
+				break;
+			case SKILL_RULE_OPERAND_OPERATOR:
+				value = operator_eval(opnd->u.operator, variables, chan, getvalue_fn, data, operator_proceeded_cb);
+				break;
+			case SKILL_RULE_OPERAND_UNKNOWN:
+				/* WTF */
+				return 0;
+		}
+
+		if (first)
+			ret = value;
+		else {
+			if (operator_proceeded_cb)
+				operator_proceeded_cb(last_name, ret, op->type, name, value, data);
+
+			switch(op->type) {
+				case SKILL_RULE_OPERATOR_DIVISION:
+					if (value != 0)
+						ret /= value;
+					else {
+						ast_log(LOG_WARNING, "Rule error: division by zero.\n");
+						return 0;
+					}
+					break;
+				case SKILL_RULE_OPERATOR_MULTIPLICATION:
+					ret *= value;
+					break;
+				case SKILL_RULE_OPERATOR_SUBTRACTION:
+					ret -= value;
+					break;
+				case SKILL_RULE_OPERATOR_ADDITION:
+					ret += value;
+					break;
+				case SKILL_RULE_OPERATOR_NOTEQUAL:
+					ret = (ret != value);
+					break;
+				case SKILL_RULE_OPERATOR_EQUAL:
+					ret = (ret == value);
+					break;
+				case SKILL_RULE_OPERATOR_GREATER:
+					ret = (ret > value);
+					break;
+				case SKILL_RULE_OPERATOR_LESSER:
+					ret = (ret < value);
+					break;
+				case SKILL_RULE_OPERATOR_AND:
+					ret = (ret && value);
+					break;
+				case SKILL_RULE_OPERATOR_OR:
+					ret = (ret || value);
+					break;
+				case SKILL_RULE_OPERATOR_UNKNOWN:
+					/* WTF */
+					return 0;
+			}
+		}
+
+		first = 0;
+		last_name = name;
+	}
+
+	return ret;
+}
+
+static int operator_eval_skills_getvalue(const char *key, void* data)
+{
+	struct skills_group *skills = data;
+	int value = 0;
+	struct skill* skill;
+	struct ao2_iterator iter = ao2_iterator_init(skills->skills, 0);
+	while ((skill = ao2_iterator_next(&iter)) && strcmp(skill->name, key))
+		ao2_ref(skill, -1);
+
+	if (!skill)
+		value = 0;
+	else {
+		value = skill->weight;
+		ao2_ref(skill, -1);
+	}
+	ao2_iterator_destroy(&iter);
+	return value;
+}
+
+static int operator_eval_skills(struct skill_rule_operator *op, struct skills_group *skills, struct ao2_container *variables, struct queue_ent *qe)
+{
+	return operator_eval(op, variables, qe->chan, operator_eval_skills_getvalue, skills, NULL);
+}
+
+static int calculate_estimated_waiting_time(struct queue_ent *qe)
+{
+	struct ao2_iterator iter;
+	struct member *mem;
+	struct queue_ent *ch;
+	int sum = 0, count = 0;
+	float aht, ciqu = 0;
+	float ali;
+
+	if (!qe->mem_selection || ao2_container_count(qe->mem_selection) == 0)
+		return qe->vqueue->holdtime;
+
+	iter = ao2_iterator_init(qe->mem_selection, 0);
+	while ((mem = ao2_iterator_next(&iter))) {
+		sum += mem->holdtime;
+		count++;
+		ast_log(LOG_WARNING, "PTC %d (%d)\n", sum, count);
+		ao2_ref(mem, -1);
+	}
+	ao2_iterator_destroy(&iter);
+
+	ali = count > 0 ? count : 0.0001;
+	aht = sum / ali;
+
+	for (ch = qe->parent->head; ch; ch = ch->next) {
+		ast_log(LOG_WARNING,"- pending: %d, vqueue[%p] == vqueue[%p]\n", ch->pending, ch->vqueue, qe->vqueue);
+		if (!ch->pending && ch->vqueue == qe->vqueue)
+			ciqu++;
+	}
+	ast_log(LOG_WARNING, "sum: %d, count: %d, ali: %.2f, aht: %.2f, ciqu: %.2f\n", sum, count, ali, aht, ciqu);
+
+	return (qe->vqueue->holdtime = aht * ciqu / ali);
+}
+
+static int get_estimated_waiting_time(struct queue_ent *qe)
+{
+	if (qe->vqueue)
+		return calculate_estimated_waiting_time(qe);
+	else
+		return qe->parent->holdtime;
+}
+
+static int get_waiting_time(struct queue_ent *qe)
+{
+	return time(NULL) - qe->start;
+}
+
+static int operator_eval_dynamics_getvalue(const char *key, void* data)
+{
+	static const struct {
+		const char *name;
+		int (*func) (struct queue_ent *qe);
+	} static_vars[] = {
+		{ "EWT", get_estimated_waiting_time },
+		{ "WT", get_waiting_time },
+	};
+	struct queue_ent* qe = data;
+	size_t i;
+	int value = 0;
+
+	for (i = 0; i < sizeof(static_vars) / sizeof(*static_vars) && strcmp(static_vars[i].name, key); ++i)
+		;
+
+	if (i < (sizeof(static_vars) / sizeof(*static_vars)))
+		value = static_vars[i].func(qe);
+
+	ast_log(LOG_WARNING, "%s = %d\n", key, value);
+	return value;
+}
+
+static void operator_eval_dynamics_proceed_cb(const char *left_name, int left_value, enum skill_rule_operator_type op,
+                                              const char *right_name, int right_value, void* data)
+{
+	struct queue_ent* qe = data;
+	int left_wt = left_name && !strcmp(left_name, "WT");
+	int right_wt = right_name && !strcmp(right_name, "WT");
+	int new_check = 0;
+
+	if (left_wt && right_wt) {
+		/* WTF */
+		return;
+	}
+
+	switch(op)
+	{
+	case SKILL_RULE_OPERATOR_EQUAL:
+		if (left_wt)
+			new_check = time(NULL) + right_value - get_waiting_time(qe);
+		if (right_wt)
+			new_check = time(NULL) + left_value - get_waiting_time(qe);
+
+		break;
+	case SKILL_RULE_OPERATOR_GREATER:
+		if (right_wt)
+			new_check = time(NULL) + left_value - get_waiting_time(qe);
+		break;
+	case SKILL_RULE_OPERATOR_LESSER:
+		if (left_wt)
+			new_check = time(NULL) + right_value - get_waiting_time(qe);
+		break;
+	case SKILL_RULE_OPERATOR_DIVISION:
+	case SKILL_RULE_OPERATOR_MULTIPLICATION:
+	case SKILL_RULE_OPERATOR_SUBTRACTION:
+	case SKILL_RULE_OPERATOR_ADDITION:
+	case SKILL_RULE_OPERATOR_NOTEQUAL:
+	case SKILL_RULE_OPERATOR_AND:
+	case SKILL_RULE_OPERATOR_OR:
+	case SKILL_RULE_OPERATOR_UNKNOWN:
+		break;
+	}
+	if (new_check && (!qe->skills_next_check || qe->skills_next_check > new_check))
+		qe->skills_next_check = new_check;
+}
+
+static int operator_eval_dynamics(struct skill_rule_operator *op, struct ao2_container* variables, struct queue_ent* qe)
+{
+	return operator_eval(op, variables, qe->chan, operator_eval_dynamics_getvalue, qe, operator_eval_dynamics_proceed_cb);
+}
+
+/** Syntax of a rule name with their arguments: Rule(arg1=value1^arg2=value2^...)
+ *
+ * This function returns a container of 'struct rule_var' with every variables,
+ * and rulename value is set to the real rulename.
+ */
+static struct ao2_container *get_rule_variables(struct queue_ent *qe, char **rulename)
+{
+	char *ptr, *var;
+	struct rule_var *v;
+	struct ao2_container *variables = ao2_container_alloc(37, NULL, NULL);
+
+	if (!variables) {
+		return NULL;
+	}
+
+	if (!(ptr = strchr(*rulename, '(')))
+		return variables;
+
+	*ptr++ = '\0';
+	while ((var = strsep(&ptr, ",|^)"))) {
+		char *value = strchr(var, '=');
+
+		if (!value)
+			continue;
+
+		*value++ = '\0';
+		v = ao2_alloc(sizeof(*v), NULL);
+		if (!v)
+			break;
+		ast_copy_string(v->name, var, sizeof(v->name));
+		ast_copy_string(v->value, value, sizeof(v->value));
+		ao2_link(variables, v);
+		ao2_ref(v, -1);
+	}
+
+	return variables;
+}
+
+static int member_is_selected(struct queue_ent *qe, struct member *mem)
+{
+	struct member *m;
+
+	/* If there isn't any queue entry or if there isn't any
+	 * selection, it's because he doesn't use the skills routing.
+	 */
+	if (!qe || !qe->mem_selection)
+		return 1;
+
+	m = ao2_find(qe->mem_selection, mem, OBJ_POINTER);
+
+	if (m)
+		ao2_ref(m, -1);
+
+	return m != NULL;
 }
 
 /*! \brief Insert the 'new' entry after the 'prev' entry of queue 'q' */
@@ -571,7 +1410,7 @@
  * is available, the function immediately returns QUEUE_NORMAL. If no members are available,
  * the appropriate reason why is returned
  */
-static enum queue_member_status get_member_status(struct call_queue *q, int max_penalty)
+static enum queue_member_status get_member_status(struct call_queue *q, int max_penalty, struct queue_ent* qe)
 {
 	struct member *member;
 	struct ao2_iterator mem_iter;
@@ -595,6 +1434,11 @@
 			continue;
 		}
 
+		if (qe && !member_is_selected(qe, member)) {
+			ao2_ref(member, -1);
+			continue;
+		}
+
 		switch (member->status) {
 		case AST_DEVICE_INVALID:
 			/* nothing to do */
@@ -651,6 +1495,7 @@
 					continue;
 				}
 
+				update_queue_ent_skills_next_check(q);
 				manager_event(EVENT_FLAG_AGENT, "QueueMemberStatus",
                                               "Queue: %s\r\n"
                                               "Location: %s\r\n"
@@ -662,7 +1507,8 @@
                                               "Status: %d\r\n"
                                               "Paused: %d\r\n"
                                               "IncomingLimit: %d\r\n"
-                                              "CurrentCalls: %d\r\n",
+                                              "CurrentCalls: %d\r\n"
+                                              "Skills: %s\r\n",
                                               q->name,
                                               cur->interface,
                                               cur->membername,
@@ -673,7 +1519,8 @@
                                               cur->status,
                                               cur->paused,
                                               cur->incominglimit,
-                                              cur->current_calls);
+                                              cur->current_calls,
+					      cur->skills);
 			}
 			ao2_ref(cur, -1);
 		}
@@ -798,11 +1645,12 @@
 
 	return 0;
 }
+
 /*! \brief allocate space for new queue member and set fields based on parameters passed */
-static struct member *create_queue_member(const char *interface, const char *membername, int penalty, int paused, const char *state_interface, int incominglimit)
+static struct member *create_queue_member(const char *interface, const char *membername, int penalty, int paused, const char *state_interface, int incominglimit, const char *skills)
 {
 	struct member *cur;
-	
+
 	if ((cur = ao2_alloc(sizeof(*cur), NULL))) {
 		cur->penalty = penalty;
 		cur->paused = paused;
@@ -820,6 +1668,10 @@
 			ast_log(LOG_WARNING, "No location at interface '%s'\n", interface);
 		cur->status = ast_device_state(cur->state_interface);
 		cur->incominglimit = incominglimit;
+		if (!ast_strlen_zero(skills))
+			ast_copy_string(cur->skills, skills, sizeof(cur->skills));
+		else
+			cur->skills[0] = '\0';
 	}
 
 	return cur;
@@ -1166,7 +2018,7 @@
 	}
 }
 
-static void rt_handle_member_record(struct call_queue *q, char *interface, const char *membername, const char *penalty_str, const char *paused_str, const char *state_interface, const char *incominglimit_str)
+static void rt_handle_member_record(struct call_queue *q, char *interface, const char *membername, const char *penalty_str, const char *paused_str, const char *state_interface, const char *incominglimit_str, const char *skills)
 {
 	struct member *m, tmpmem;
 	int penalty = 0;
@@ -1197,10 +2049,11 @@
 
 	/* Create a new one if not found, else update penalty and incominglimit */
 	if (!m) {
-		if ((m = create_queue_member(interface, membername, penalty, paused, state_interface, incominglimit))) {
+		if ((m = create_queue_member(interface, membername, penalty, paused, state_interface, incominglimit, skills))) {
 			m->dead = 0;
 			m->realtime = 1;
 			add_to_interfaces(m->state_interface);
+			update_queue_ent_skills_next_check(q);
 			ao2_link(q->members, m);
 			ao2_ref(m, -1);
 			m = NULL;
@@ -1217,7 +2070,12 @@
 		}
 		m->penalty = penalty;
 		m->incominglimit = incominglimit;
+		if (!ast_strlen_zero(skills))
+			ast_copy_string(m->skills, skills, sizeof(m->skills));
+		else
+			m->skills[0] = '\0';
 		ao2_ref(m, -1);
+		update_queue_ent_skills_next_check(q);
 	}
 }
 
@@ -1344,7 +2202,8 @@
 			ast_variable_retrieve(member_config, interface, "penalty"),
 			ast_variable_retrieve(member_config, interface, "paused"),
 			S_OR(ast_variable_retrieve(member_config, interface, "state_interface"),interface),
-			ast_variable_retrieve(member_config, interface, "call-limit"));
+			ast_variable_retrieve(member_config, interface, "call-limit"),
+			ast_variable_retrieve(member_config, interface, "skills"));
 	}
 
 	/* Delete all realtime members that have been deleted in DB. */
@@ -1418,7 +2277,8 @@
 			ast_variable_retrieve(member_config, interface, "penalty"),
 			ast_variable_retrieve(member_config, interface, "paused"),
 			S_OR(ast_variable_retrieve(member_config, interface, "state_interface"), interface),
-			ast_variable_retrieve(member_config, interface, "call-limit"));
+			ast_variable_retrieve(member_config, interface, "call-limit"),
+			ast_variable_retrieve(member_config, interface, "skills"));
 	}
 
 	/* Delete all realtime members that have been deleted in DB. */
@@ -1488,6 +2348,125 @@
 	return q;
 }
 
+static int join_virtual_queue(struct call_queue *q, struct queue_ent *qe)
+{
+	struct virtual_queue *vq = NULL;
+
+	if (!q->vqueues) {
+		q->vqueues = ao2_container_alloc(37, NULL, NULL);
+		if (!q->vqueues)
+			return -1;
+	} else {
+		struct ao2_iterator iter;
+
+		iter = ao2_iterator_init(q->vqueues, 0);
+		while ((vq = ao2_iterator_next(&iter)) && strcmp(vq->id, qe->skill_ruleset))
+			ao2_ref(vq, -1);
+		ao2_iterator_destroy(&iter);
+	}
+
+	if (!vq) {
+		vq = ao2_alloc(sizeof(*vq), NULL);
+		if (!vq)
+			return -1;
+		ast_copy_string(vq->id, qe->skill_ruleset, sizeof(vq->id));
+		ao2_link(q->vqueues, vq);
+	}
+
+	qe->vqueue = vq;
+	/* do not unref vq because it's keept by the queue entry. */
+
+	return 0;
+}
+
+static int select_members_from_skills(struct queue_ent *qe)
+{
+	struct call_queue* q = qe->parent;
+	struct member *member;
+	struct ao2_container *variables;
+	struct skill_ruleset* rs;
+	struct skill_rule* rule;
+	struct ao2_iterator rule_iter, mem_iter;
+	char* ruleset_name = ast_strdupa(qe->skill_ruleset);
+
+	qe->skills_next_check = 0;
+	variables = get_rule_variables(qe, &ruleset_name);
+
+	if (!variables)
+		return -1;
+
+	AST_LIST_LOCK(&skill_rulesets);
+	AST_LIST_LOCK(&skills_groups);
+
+	AST_LIST_TRAVERSE(&skill_rulesets, rs, entry) {
+		if (!strcmp(rs->name, ruleset_name))
+			break;
+	}
+
+	if (!rs) {
+		ast_log(LOG_WARNING, "Ruleset '%s' does not exist.\n", ruleset_name);
+	} else {
+		rule_iter = ao2_iterator_init(rs->rules, 0);
+
+		/* Clear the current selection (if any) */
+		if (qe->mem_selection) {
+			ao2_ref(qe->mem_selection, -1);
+			qe->mem_selection = NULL;
+		}
+
+		ast_log(LOG_WARNING, "YEAH, Selecting members\n");
+
+		while (!qe->mem_selection && (rule = ao2_iterator_next(&rule_iter))) {
+			qe->mem_selection = ao2_container_alloc(37, member_hash_fn, member_cmp_fn);
+			mem_iter = ao2_iterator_init(q->members, 0);
+			while ((member = ao2_iterator_next(&mem_iter))) {
+				struct skills_group* skills;
+				AST_LIST_TRAVERSE(&skills_groups, skills, entry) {
+					if (!strcmp(skills->name, member->skills))
+						break;
+				}
+
+				if (!skills) {
+					ast_log(LOG_WARNING, "Skills group '%s' does not exist.\n", member->skills);
+					continue;
+				}
+
+				if (!ast_strlen_zero(member->skills) &&
+				    operator_eval_skills(rule->cond, skills, variables, qe)) {
+					ao2_link(qe->mem_selection, member);
+					ast_log(LOG_NOTICE, "User %s is associated.\n", member->interface);
+				} else
+					ast_log(LOG_NOTICE, "User %s is NOT associated.\n", member->interface);
+				ao2_ref(member, -1);
+			}
+			ao2_iterator_destroy(&mem_iter);
+			if (!operator_eval_dynamics(rule->dcond, variables, qe)) {
+				/* CLEAR to retry. */
+				ast_log(LOG_NOTICE, "Too Bad, but we need to ENLARGE\n");
+				ao2_ref(qe->mem_selection, -1);
+				qe->mem_selection = NULL;
+			}
+			ao2_ref(rule, -1);
+		}
+		ao2_iterator_destroy(&rule_iter);
+	}
+
+	AST_LIST_UNLOCK(&skill_rulesets);
+	AST_LIST_UNLOCK(&skills_groups);
+
+	/* 0 only if a rule match. */
+	return qe->mem_selection == NULL;
+}
+
+static int update_queue_ent_skills_next_check(struct call_queue *q)
+{
+	struct queue_ent* ch = q->head;
+	time_t now = time(NULL);
+	for (; ch; ch = ch->next)
+		ch->skills_next_check = now;
+	return 0;
+}
+
 static int join_queue(char *queuename, struct queue_ent *qe, enum queue_result *reason)
 {
 	struct call_queue *q;
@@ -1503,8 +2482,11 @@
 	AST_LIST_LOCK(&queues);
 	ao2_lock(q);
 
+	if (!ast_strlen_zero(qe->skill_ruleset))
+		join_virtual_queue(q, qe);
+
 	/* This is our one */
-	stat = get_member_status(q, qe->max_penalty);
+	stat = get_member_status(q, qe->max_penalty, qe);
 	if (!q->joinempty && (stat == QUEUE_NO_MEMBERS))
 		*reason = QUEUE_JOINEMPTY;
 	else if ((q->joinempty == QUEUE_EMPTY_STRICT) && (stat == QUEUE_NO_REACHABLE_MEMBERS || stat == QUEUE_NO_MEMBERS))
@@ -1537,6 +2519,7 @@
 		ast_copy_string(qe->announce, q->announce, sizeof(qe->announce));
 		ast_copy_string(qe->context, q->context, sizeof(qe->context));
 		q->count++;
+		update_queue_ent_skills_next_check(q);
 		res = 0;
 		manager_event(EVENT_FLAG_CALL, "Join",
                               "Channel: %s\r\n"
@@ -1614,7 +2597,7 @@
 
 static int say_position(struct queue_ent *qe)
 {
-	int res = 0, avgholdmins, avgholdsecs;
+	int res = 0, avgholdmins, avgholdsecs, holdtime;
 	time_t now;
 
 	/* Check to see if this is ludicrous -- if we just announced position, don't do it again*/
@@ -1646,11 +2629,12 @@
 			goto playout;
 	}
 	/* Round hold time to nearest minute */
-	avgholdmins = abs(((qe->parent->holdtime + 30) - (now - qe->start)) / 60);
+	holdtime = get_estimated_waiting_time(qe);
+	avgholdmins = abs(((holdtime + 30) - (now - qe->start)) / 60);
 
 	/* If they have specified a rounding then round the seconds as well */
 	if (qe->parent->roundingseconds) {
-		avgholdsecs = (abs(((qe->parent->holdtime + 30) - (now - qe->start))) - 60 * avgholdmins) / qe->parent->roundingseconds;
+		avgholdsecs = (abs(((holdtime + 30) - (now - qe->start))) - 60 * avgholdmins) / qe->parent->roundingseconds;
 		avgholdsecs *= qe->parent->roundingseconds;
 	} else {
 		avgholdsecs = 0;
@@ -1721,6 +2705,14 @@
 	return res;
 }
 
+static void recalc_member_holdtime(struct member *mem, int newholdtime)
+{
+	int oldvalue;
+	oldvalue = mem->holdtime;
+	mem->holdtime = (((oldvalue << 2) - oldvalue) + newholdtime) >> 2;
+	ast_log(LOG_WARNING, "!!!!! old: %d new: %d\n", oldvalue, mem->holdtime);
+}
+
 static void recalc_holdtime(struct queue_ent *qe, int newholdtime)
 {
 	int oldvalue;
@@ -1750,6 +2742,7 @@
 	for (cur = q->head; cur; cur = cur->next) {
 		if (cur == qe) {
 			q->count--;
+			update_queue_ent_skills_next_check(q);
 
 			/* Take us out of the queue */
 			manager_event(EVENT_FLAG_CALL, "Leave",
@@ -1807,9 +2800,10 @@
  * \note The queue passed in should be locked prior to this function call
  *
  * \param[in] q The queue for which we are couting the number of available members
+ * \param[in] qe The queue entry for which we are counting the number of available associated members (can be NULL).
  * \return Return the number of available members in queue q
  */
-static int num_available_members(struct call_queue *q)
+static int num_available_members(struct call_queue *q, struct queue_ent* qe)
 {
 	struct member *mem;
 	int avl = 0;
@@ -1825,7 +2819,8 @@
 		case AST_DEVICE_NOT_INUSE:
 		case AST_DEVICE_UNKNOWN:
 			if (!mem->paused &&
-			    !(mem->incominglimit && mem->current_calls >= mem->incominglimit)) {
+			    !(mem->incominglimit && mem->current_calls >= mem->incominglimit) &&
+			    (!qe || member_is_selected(qe, mem))) {
 				avl++;
 			}
 			break;
@@ -1868,7 +2863,7 @@
 		if (q->count && q->members) {
 			if ((mem = ao2_find(q->members, member, OBJ_POINTER))) {
 				ast_log(LOG_DEBUG, "Found matching member %s in queue '%s'\n", mem->interface, q->name);
-				if (q->weight > rq->weight && q->count >= num_available_members(q)) {
+				if (q->weight > rq->weight && q->count >= num_available_members(q, NULL)) {
 					ast_log(LOG_DEBUG, "Queue '%s' (weight %d, calls %d) is preferred over '%s' (weight %d, calls %d)\n", q->name, q->weight, q->count, rq->name, rq->weight, rq->count);
 					found = 1;
 				}
@@ -1976,6 +2971,15 @@
 		return 0;
 	}
 
+	if (!member_is_selected(qe, tmp->member)) {
+		if (option_debug)
+			ast_log(LOG_DEBUG, "%s doesn't match ruleset '%s'\n", tmp->interface, qe->skill_ruleset);
+		if (qe->chan->cdr)
+			ast_cdr_busy(qe->chan->cdr);
+		tmp->stillgoing = 0;
+		return 0;
+	}
+
 	if (use_weight && compare_weight(qe->parent,tmp->member)) {
 		ast_log(LOG_DEBUG, "Priority queue delaying call to %s:%s\n", qe->parent->name, tmp->interface);
 		if (qe->chan->cdr)
@@ -2570,7 +3574,7 @@
 	/* This needs a lock. How many members are available to be served? */
 	ao2_lock(qe->parent);
 
-	avl = num_available_members(qe->parent);
+	avl = num_available_members(qe->parent, qe);
 
 	ch = qe->parent->head;
 
@@ -2579,7 +3583,7 @@
 	}
 
 	while ((idx < avl) && (ch) && (ch != qe)) {
-		if (!ch->pending)
+		if (!ch->pending && ch->vqueue == qe->vqueue)
 			idx++;
 		ch = ch->next;			
 	}
@@ -2628,7 +3632,7 @@
 			break;
 		}
 
-		stat = get_member_status(qe->parent, qe->max_penalty);
+		stat = get_member_status(qe->parent, qe->max_penalty, qe);
 
 		/* leave the queue if no agents, if enabled */
 		if (qe->parent->leavewhenempty && (stat == QUEUE_NO_MEMBERS)) {
@@ -2681,6 +3685,11 @@
 			*reason = QUEUE_TIMEOUT;
 			break;
 		}
+
+		if (qe->skills_next_check && (time(NULL) >= qe->skills_next_check) &&
+			(res = select_members_from_skills(qe))) {
+			break;
+		}
 	}
 
 	return res;
@@ -3153,6 +4162,7 @@
 		member = lpeer->member;
 		/* Increment the refcount for this member, since we're going to be using it for awhile in here. */
 		ao2_ref(member, 1);
+		recalc_member_holdtime(member, (now - qe->start));
 		hangupcalls(outgoing, peer);
 		outgoing = NULL;
 		if (announce || qe->parent->reportholdtime || qe->parent->memberdelay) {
@@ -3469,7 +4479,7 @@
 
 /* Dump all members in a specific queue to the database
  *
- * <pm_family>/<queuename> = <interface>;<penalty>;<paused>;<state_interface>;<incominglimit>[|...]
+ * <pm_family>/<queuename> = <interface>;<penalty>;<paused>;<state_interface>;<incominglimit>;<skills>[|...]
  *
  */
 static void dump_queue_members(struct call_queue *pm_queue)
@@ -3492,8 +4502,9 @@
 			continue;
 		}
 
-		res = snprintf(value + value_len, sizeof(value) - value_len, "%s%s;%d;%d;%s;%s;%d",
-			value_len ? "|" : "", cur_member->interface, cur_member->penalty, cur_member->paused, cur_member->membername, cur_member->state_interface, cur_member->incominglimit);
+		res = snprintf(value + value_len, sizeof(value) - value_len, "%s%s;%d;%d;%s;%s;%d;%s",
+			value_len ? "|" : "", cur_member->interface, cur_member->penalty, cur_member->paused,
+			cur_member->membername, cur_member->state_interface, cur_member->incominglimit, cur_member->skills);
 
 		ao2_ref(cur_member, -1);
 
@@ -3517,6 +4528,7 @@
 {
 	struct call_queue *q;
 	struct member *mem, tmpmem;
+	struct queue_ent* qe;
 	int res = RES_NOSUCHQUEUE;
 
 	ast_copy_string(tmpmem.interface, interface, sizeof(tmpmem.interface));
@@ -3545,6 +4557,13 @@
                                       q->name,
                                       mem->interface, mem->membername);
 			ao2_unlink(q->members, mem);
+			update_queue_ent_skills_next_check(q);
+
+			/* Remove member from selection of each callers. */
+			for(qe = q->head; qe; qe = qe->next)
+				if (qe->mem_selection)
+					ao2_unlink(qe->mem_selection, mem);
+
 			remove_from_interfaces(mem->state_interface);
 			ao2_ref(mem, -1);
 
@@ -3565,7 +4584,7 @@
 }
 
 
-static int add_to_queue(const char *queuename, const char *interface, const char *membername, int penalty, int paused, int dump, const char *state_interface, int incominglimit)
+static int add_to_queue(const char *queuename, const char *interface, const char *membername, int penalty, int paused, int dump, const char *state_interface, int incominglimit, const char *skills)
 {
 	struct call_queue *q;
 	struct member *new_member, *old_member;
@@ -3580,11 +4599,12 @@
 
 	ao2_lock(q);
 	if ((old_member = interface_exists(q, interface)) == NULL) {
-		if ((new_member = create_queue_member(interface, membername, penalty, paused, state_interface, incominglimit))) {
+		if ((new_member = create_queue_member(interface, membername, penalty, paused, state_interface, incominglimit, skills))) {
 			add_to_interfaces(new_member->state_interface);
 			new_member->dynamic = 1;
 			ao2_link(q->members, new_member);
 			q->membercount++;
+			update_queue_ent_skills_next_check(q);
 			manager_event(EVENT_FLAG_AGENT, "QueueMemberAdded",
                                       "Queue: %s\r\n"
                                       "Location: %s\r\n"
@@ -3658,6 +4678,7 @@
 
 				ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE"), "%s", "");
 
+				update_queue_ent_skills_next_check(q);
 				manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",
                                               "Queue: %s\r\n"
                                               "Location: %s\r\n"
@@ -3683,6 +4704,7 @@
 	char *member;
 	char *interface;
 	char *membername = NULL;
+	char *skills = NULL;
 	char *state_interface;
 	char *penalty_tok;
 	int penalty = 0;
@@ -3736,6 +4758,7 @@
 			membername = strsep(&member, ";");
 			state_interface = strsep(&member,";");
 			incominglimit_tok = strsep(&member,";");
+			skills = strsep(&member, ";");
 
 			if (!penalty_tok) {
 				ast_log(LOG_WARNING, "Error parsing persistent member string for '%s' (penalty)\n", queue_name);
@@ -3771,8 +4794,8 @@
 
 			if (option_debug)
 				ast_log(LOG_DEBUG, "Reload Members: Queue: %s  Member: %s  Name: %s  Penalty: %d  Paused: %d IncomingLimit: %d\n", queue_name, interface, membername, penalty, paused, incominglimit);
-			
-			if (add_to_queue(queue_name, interface, membername, penalty, paused, 0, state_interface, incominglimit) == RES_OUTOFMEMORY) {
+
+			if (add_to_queue(queue_name, interface, membername, penalty, paused, 0, state_interface, incominglimit, skills) == RES_OUTOFMEMORY) {
 				ast_log(LOG_ERROR, "Out of Memory when reloading persistent queue member\n");
 				break;
 			}
@@ -3973,12 +4996,13 @@
 		AST_APP_ARG(membername);
 		AST_APP_ARG(state_interface);
 		AST_APP_ARG(incominglimit);
+		AST_APP_ARG(skills);
 	);
 	int penalty = 0;
 	int incominglimit = 0;
 
 	if (ast_strlen_zero(data)) {
-		ast_log(LOG_WARNING, "AddQueueMember requires an argument (queuename[|interface[|penalty[|options[|membername[|state_interface[|incominglimit]]]]]])\n");
+		ast_log(LOG_WARNING, "AddQueueMember requires an argument (queuename[|interface[|penalty[|options[|membername[|state_interface[|incominglimit[|skills]]]]]]])\n");
 		return -1;
 	}
 
@@ -4014,7 +5038,7 @@
 		}
 	}
 
-	switch (add_to_queue(args.queuename, args.interface, args.membername, penalty, 0, queue_persistent_members, args.state_interface, incominglimit)) {
+	switch (add_to_queue(args.queuename, args.interface, args.membername, penalty, 0, queue_persistent_members, args.state_interface, incominglimit, args.skills)) {
 	case RES_OKAY:
 		ast_queue_log(args.queuename, chan->uniqueid, args.interface, "ADDMEMBER", "%s", "");
 		ast_log(LOG_NOTICE, "Added interface '%s' to queue '%s'\n", args.interface, args.queuename);
@@ -4115,15 +5139,16 @@
 		AST_APP_ARG(announceoverride);
 		AST_APP_ARG(queuetimeoutstr);
 		AST_APP_ARG(agi);
+		AST_APP_ARG(skill_ruleset);
 	);
 	/* Our queue entry */
 	struct queue_ent qe = { 0 };
-	
+
 	if (ast_strlen_zero(data)) {
-		ast_log(LOG_WARNING, "Queue requires an argument: queuename[|options[|URL[|announceoverride[|timeout[|agi]]]]]\n");
+		ast_log(LOG_WARNING, "Queue requires an argument: queuename[|options[|URL[|announceoverride[|timeout[|agi[|skill_ruleset]]]]]]\n");
 		return -1;
 	}
-	
+
 	parse = ast_strdupa(data);
 	AST_STANDARD_APP_ARGS(args, parse);
 
@@ -4181,6 +5206,9 @@
 	qe.chan = chan;
 	qe.prio = prio;
 	qe.max_penalty = max_penalty;
+	if (!ast_strlen_zero(args.skill_ruleset)) {
+		ast_copy_string(qe.skill_ruleset, args.skill_ruleset, sizeof(qe.skill_ruleset));
+	}
 	qe.last_pos_said = 0;
 	qe.last_pos = 0;
 	qe.last_periodic_announce_time = time(NULL);
@@ -4198,6 +5226,9 @@
 			ast_moh_start(chan, qe.moh, NULL);
 		}
 
+		if (select_members_from_skills(&qe))
+			goto stop;
+
 		/* This is the wait loop for callers 2 through maxlen */
 		res = wait_our_turn(&qe, ringing, &reason);
 		if (res)
@@ -4258,7 +5289,7 @@
 			if (res)
 				goto stop;
 
-			stat = get_member_status(qe.parent, qe.max_penalty);
+			stat = get_member_status(qe.parent, qe.max_penalty, &qe);
 
 			/* exit after 'timeout' cycle if 'n' option enabled */
 			if (noption && tries >= qe.parent->membercount) {
@@ -4357,6 +5388,15 @@
 		set_queue_result(chan, reason);
 		res = 0;
 	}
+	if (qe.mem_selection) {
+		ao2_ref(qe.mem_selection, -1);
+	}
+	if (qe.vqueue && ao2_ref(qe.vqueue, -1) == 1 && qe.parent) {
+		/* unref vqueue, and if nobody has reference to vqueue except
+		 * the vqueues list, destroy the vqueue object by removing it
+		 * from list. */
+		ao2_unlink(qe.parent->vqueues, qe.vqueue);
+	}
 	if (qe.parent) {
 		/* every queue_ent is given a reference to it's parent call_queue when it joins the queue.
 		 * This ref must be taken away right before the queue_ent is destroyed.  In this case
@@ -4611,6 +5651,7 @@
 	char *parse;
 	char *interface, *state_interface;
 	char *membername = NULL;
+	char *skills = NULL;
 	int penalty;
 	int incominglimit;
 	AST_DECLARE_APP_ARGS(args,
@@ -4619,8 +5660,9 @@
 		AST_APP_ARG(membername);
 		AST_APP_ARG(state_interface);
 		AST_APP_ARG(incominglimit);
+		AST_APP_ARG(skills);
 	);
-	
+
 	if (!(cfg = ast_config_load("queues.conf"))) {
 		ast_log(LOG_NOTICE, "No call queueing config file (queues.conf), so no call queues\n");
 		return 0;
@@ -4716,6 +5758,10 @@
 							membername = ast_skip_blanks(args.membername);
 						}
 
+						if (!ast_strlen_zero(args.skills)) {
+							skills = ast_skip_blanks(args.skills);
+						}
+
 						if (!ast_strlen_zero(args.state_interface)) {
 							state_interface = ast_skip_blanks(args.state_interface);
 						} else {
@@ -4740,13 +5786,14 @@
 							remove_from_interfaces(cur->state_interface);
 						}
 
-						newm = create_queue_member(interface, membername, penalty, cur ? cur->paused : 0, state_interface, incominglimit);
+						newm = create_queue_member(interface, membername, penalty, cur ? cur->paused : 0, state_interface, incominglimit, skills);
 						if (!cur || (cur && strcasecmp(cur->state_interface, state_interface))) {
 							add_to_interfaces(state_interface);
 						}
 						ao2_link(q->members, newm);
 						ao2_ref(newm, -1);
 						newm = NULL;
+						update_queue_ent_skills_next_check(q);
 
 						if (cur)
 							ao2_ref(cur, -1);
@@ -4804,9 +5851,122 @@
 	}
 	AST_LIST_TRAVERSE_SAFE_END;
 	AST_LIST_UNLOCK(&queues);
+
+	return 1;
+}
+
+static int reload_skills(void)
+{
+	struct ast_config *cfg;
+	char *cat = NULL, *tmp;
+	struct ast_variable *var;
+	struct skills_group *skgrp;
+
+	if (!(cfg = ast_config_load("queueskills.conf"))) {
+		ast_log(LOG_NOTICE, "No skills groups config file (queueskills.conf), so no call queues skills\n");
+		return 0;
+	}
+	AST_LIST_LOCK(&skills_groups);
+
+	/* Clear current skills */
+	AST_LIST_TRAVERSE_SAFE_BEGIN(&skills_groups, skgrp, entry) {
+		AST_LIST_REMOVE_CURRENT(&skills_groups, entry);
+		ao2_ref(skgrp, -1);
+	}
+	AST_LIST_TRAVERSE_SAFE_END;
+
+	while ((cat = ast_category_browse(cfg, cat))) {
+		skgrp = ao2_alloc(sizeof(*skgrp), destroy_skills_group);
+
+		if (!skgrp) {
+			ast_log(LOG_WARNING, "Unable to allocate memory for skills group");
+			break;
+		}
+		ast_copy_string(skgrp->name, cat, sizeof(skgrp->name));
+		skgrp->skills = ao2_container_alloc(37, NULL, NULL);
+
+		for (var = ast_variable_browse(cfg, cat); var; var = var->next) {
+			struct skill* sk;
+			sk = ao2_alloc(sizeof(*sk), NULL);
+			if (!sk) {
+				ast_log(LOG_WARNING, "Unable to allocate memory for a skill");
+				break;
+			}
+			ast_copy_string(sk->name, var->name, sizeof(sk->name));
+			tmp = ast_skip_blanks(var->value);
+			sk->weight = atoi(tmp);
+
+			ao2_link(skgrp->skills, sk);
+			ao2_ref(sk, -1);
+		}
+
+		AST_LIST_INSERT_HEAD(&skills_groups, skgrp, entry);
+	}
+	AST_LIST_UNLOCK(&skills_groups);
+	ast_config_destroy(cfg);
 	return 1;
 }
 
+static int reload_skill_rules(void)
+{
+	struct ast_config *cfg;
+	struct ast_variable *var;
+	struct skill_ruleset *ruleset;
+	char *cat = NULL;
+
+	if (!(cfg = ast_config_load("queueskillrules.conf"))) {
+		ast_log(LOG_NOTICE, "No rules config file (queueskillrules.conf), so no call queues rules\n");
+		return 0;
+	}
+	AST_LIST_LOCK(&skill_rulesets);
+
+	/* Clear current skill_rulesets */
+	AST_LIST_TRAVERSE_SAFE_BEGIN(&skill_rulesets, ruleset, entry) {
+		AST_LIST_REMOVE_CURRENT(&skill_rulesets, entry);
+		ao2_ref(ruleset, -1);
+	}
+	AST_LIST_TRAVERSE_SAFE_END;
+
+	while ((cat = ast_category_browse(cfg, cat))) {
+		ruleset = ao2_alloc(sizeof(*ruleset), destroy_skill_ruleset);
+		if (!ruleset) {
+			ast_log(LOG_WARNING, "Unable to allocate memory for a ruleset.");
+			break;
+		}
+		ast_copy_string(ruleset->name, cat, sizeof(ruleset->name));
+		ruleset->rules = ao2_container_alloc(37, NULL, NULL);
+		for (var = ast_variable_browse(cfg, cat); var; var = var->next) {
+			struct skill_rule *r = ao2_alloc(sizeof(*r), destroy_skill_rule);
+			if (!r) {
+				ast_log(LOG_WARNING, "Unable to allocate memory for a rule.");
+				break;
+			}
+			parse_skill_rule(r, var->value);
+
+			/* check if this rule is empty. */
+			if (r->cond)
+				ao2_link(ruleset->rules, r);
+			ao2_ref(r, -1);
+		}
+
+		AST_LIST_INSERT_HEAD(&skill_rulesets, ruleset, entry);
+	}
+	AST_LIST_UNLOCK(&skill_rulesets);
+	ast_config_destroy(cfg);
+	return 1;
+}
+
+static int reload_all(void)
+{
+	int ret = 0;
+
+	ret |= reload_queues();
+	ret |= reload_skills();
+	ret |= reload_skill_rules();
+
+	return ret;
+}
+
 static int __queues_show(struct mansession *s, int manager, int fd, int argc, char **argv)
 {
 	struct call_queue *q;
@@ -4917,6 +6077,8 @@
 					ast_build_string(&max, &max_left, " (paused)");
 				if (mem->incominglimit && mem->current_calls >= mem->incominglimit)
 					ast_build_string(&max, &max_left, " (incoming limit reached)");
+				if (!ast_strlen_zero(mem->skills))
+					ast_build_string(&max, &max_left, " (skills: %s)", mem->skills);
 				ast_build_string(&max, &max_left, " (%s)", devstate2str(mem->status));
 				if (mem->calls) {
 					ast_build_string(&max, &max_left, " has taken %d calls (last was %ld secs ago)",
@@ -4935,12 +6097,42 @@
 		else	
 			ast_cli(fd, "   No Members%s", term);
 		if (q->head) {
+			if (q->vqueues) {
+				struct virtual_queue *vqueue;
+				struct ao2_iterator iter;
+				iter = ao2_iterator_init(q->vqueues, 0);
+				while ((vqueue = ao2_iterator_next(&iter)))
+				{
+					pos = 1;
+					if (s)
+						astman_append(s, "   Virtual queue %s: %s", vqueue->id, term);
+					else
+						ast_cli(fd, "   Virtual queue %s: %s", vqueue->id, term);
+					for (qe = q->head; qe; qe = qe->next) {
+						if (qe->vqueue != vqueue)
+							continue;
+						if (s)
+							astman_append(s, "      %d. %s (wait: %ld:%2.2ld, prio: %d)%s",
+								pos++, qe->chan->name, (long) (now - qe->start) / 60,
+								(long) (now - qe->start) % 60, qe->prio, term);
+						else
+							ast_cli(fd, "      %d. %s (wait: %ld:%2.2ld, prio: %d)%s", pos++,
+								qe->chan->name, (long) (now - qe->start) / 60,
+								(long) (now - qe->start) % 60, qe->prio, term);
+					}
+					ao2_ref(vqueue, -1);
+				}
+				ao2_iterator_destroy(&iter);
+			}
+
 			pos = 1;
 			if (s)
 				astman_append(s, "   Callers: %s", term);
 			else
 				ast_cli(fd, "   Callers: %s", term);
 			for (qe = q->head; qe; qe = qe->next) {
+				if (qe->vqueue)
+					continue;
 				if (s)
 					astman_append(s, "      %d. %s (wait: %ld:%2.2ld, prio: %d)%s",
 						pos++, qe->chan->name, (long) (now - qe->start) / 60,
@@ -5067,6 +6259,7 @@
                                                       "Paused: %d\r\n"
                                                       "IncomingLimit: %d\r\n"
                                                       "CurrentCalls: %d\r\n"
+                                                      "Skills: %s\r\n"
                                                       "%s"
                                                       "\r\n",
                                                       q->name,
@@ -5080,6 +6273,7 @@
                                                       mem->paused,
                                                       mem->incominglimit,
                                                       mem->current_calls,
+                                                      mem->skills,
                                                       idText);
 				}
 				ao2_ref(mem, -1);
@@ -5122,7 +6316,7 @@
 
 static int manager_add_queue_member(struct mansession *s, const struct message *m)
 {
-	const char *queuename, *interface, *penalty_s, *paused_s, *membername, *state_interface, *incominglimit_s;
+	const char *queuename, *interface, *penalty_s, *paused_s, *membername, *state_interface, *incominglimit_s, *skills;
 	int paused, penalty, incominglimit = 0;
 
 	queuename = astman_get_header(m, "Queue");
@@ -5132,6 +6326,7 @@
 	membername = astman_get_header(m, "MemberName");
 	state_interface = astman_get_header(m, "StateInterface");
 	incominglimit_s = astman_get_header(m, "IncomingLimit");
+	skills = astman_get_header(m, "Skills");
 
 	if (ast_strlen_zero(queuename)) {
 		astman_send_error(s, m, "'Queue' not specified.");
@@ -5158,7 +6353,7 @@
 	else if (sscanf(incominglimit_s, "%30d", &incominglimit) != 1 || incominglimit < 0)
 		incominglimit = 0;
 
-	switch (add_to_queue(queuename, interface, membername, penalty, paused, queue_persistent_members, state_interface, incominglimit)) {
+	switch (add_to_queue(queuename, interface, membername, penalty, paused, queue_persistent_members, state_interface, incominglimit, skills)) {
 	case RES_OKAY:
 		ast_queue_log(queuename, "MANAGER", interface, "ADDMEMBER", "%s", "");
 		astman_send_ack(s, m, "Added interface to queue");
@@ -5234,12 +6429,91 @@
 	return 0;
 }
 
+static int handle_queue_skills_groups(int fd, int argc, char *argv[])
+{
+	const char *name = NULL;
+	struct skills_group *skills;
+	struct skill *skill;
+
+	if (argc == 4) {
+		name = argv[3];
+	} else if (argc != 3) {
+		return RESULT_SHOWUSAGE;
+	} else {
+		ast_cli(fd, "Skill groups:\n");
+	}
+
+	AST_LIST_LOCK(&skills_groups);
+	AST_LIST_TRAVERSE(&skills_groups, skills, entry) {
+		if (!name || !strcmp(skills->name, name)) {
+			struct ao2_iterator iter = ao2_iterator_init(skills->skills, 0);
+			if (name) {
+				ast_cli(fd, "Skill group '%s':\n", skills->name);
+			} else {
+				ast_cli(fd, "  - %-15s: ", skills->name);
+			}
+
+			while ((skill = ao2_iterator_next(&iter))) {
+				if (name) {
+					ast_cli(fd, "  - %-15s: %d\n", skill->name, skill->weight);
+				} else {
+					ast_cli(fd, "%s=%d ", skill->name, skill->weight);
+				}
+				ao2_ref(skill, -1);
+			}
+			ast_cli(fd, "\n");
+			ao2_iterator_destroy(&iter);
+		}
+	}
+	AST_LIST_UNLOCK(&skills_groups);
+
+	return 0;
+}
+
+static int handle_queue_skills_rules(int fd, int argc, char *argv[])
+{
+	const char *name = NULL;
+	struct skill_ruleset* rs;
+	struct skill_rule* rule;
+
+	if (argc == 4) {
+		name = argv[3];
+	} else if (argc != 3) {
+		return RESULT_SHOWUSAGE;
+	}
+
+	AST_LIST_LOCK(&skill_rulesets);
+	AST_LIST_TRAVERSE(&skill_rulesets, rs, entry) {
+		if (!name || !strcmp(rs->name, name)) {
+			struct ao2_iterator iter = ao2_iterator_init(rs->rules, 0);
+
+			ast_cli(fd, "Skill rules '%s':\n", rs->name);
+			while ((rule = ao2_iterator_next(&iter))) {
+				char *cond = display_operator(rule->cond);
+				if (rule->dcond) {
+					char *dcond = display_operator(rule->dcond);
+					ast_cli(fd, "  => [%s] %s\n", dcond, cond);
+					ast_free(dcond);
+				}
+				else
+					ast_cli(fd, "  => %s\n", cond);
+				ast_free(cond);
+				ao2_ref(rule, -1);
+			}
+			ao2_iterator_destroy(&iter);
+		}
+	}
+	AST_LIST_UNLOCK(&skill_rulesets);
+
+	return 0;
+}
+
 static int handle_queue_add_member(int fd, int argc, char *argv[])
 {
-	char *queuename, *interface, *membername = NULL, *state_interface = NULL;
+	char *queuename, *interface, *membername = NULL, *state_interface = NULL, *skills = NULL;
 	int penalty, incominglimit;
 
-	if ((argc != 6) && (argc != 8) && (argc != 10) && (argc != 12) && (argc != 14)) {
+	if ((argc != 6) && (argc != 8) && (argc != 10) && (argc != 12) && (argc != 14) && (argc != 16)) {
 		return RESULT_SHOWUSAGE;
 	} else if (strcmp(argv[4], "to")) {
 		return RESULT_SHOWUSAGE;
@@ -5251,6 +6525,8 @@
 		return RESULT_SHOWUSAGE;
 	} else if ((argc == 14) && strcmp(argv[12], "incominglimit")) {
 		return RESULT_SHOWUSAGE;
+	} else if ((argc == 16) && strcmp(argv[14], "skills")) {
+		return RESULT_SHOWUSAGE;
 	}
 
 	queuename = argv[5];
@@ -5291,7 +6567,11 @@
 		incominglimit = 0;
 	}
 
-	switch (add_to_queue(queuename, interface, membername, penalty, 0, queue_persistent_members, state_interface, incominglimit)) {
+	if (argc >= 16) {
+		skills = argv[15];
+	}
+
+	switch (add_to_queue(queuename, interface, membername, penalty, 0, queue_persistent_members, state_interface, incominglimit, skills)) {
 	case RES_OKAY:
 		ast_queue_log(queuename, "CLI", interface, "ADDMEMBER", "%s", "");
 		ast_cli(fd, "Added interface '%s' to queue '%s'\n", interface, queuename);
@@ -5310,9 +6590,56 @@
 	}
 }
 
+static char *complete_queue_skills_groups(const char *line, const char *word, int pos, int state)
+{
+	int which = 0;
+	char *value = NULL;
+	struct skills_group *skills;
+
+	/* 0 - queue; 1 - skills; 2 - groups; 3 - <group> */
+	if (pos != 3)
+		return NULL;
+
+	AST_LIST_LOCK(&skills_groups);
+	AST_LIST_TRAVERSE(&skills_groups, skills, entry) {
+		if (++which > state) {
+			value = ast_strdup(skills->name);
+			break;
+		}
+	}
+	AST_LIST_UNLOCK(&skills_groups);
+
+	return value;
+}
+
+static char *complete_queue_skills_rules(const char *line, const char *word, int pos, int state)
+{
+	int which = 0;
+	char *value = NULL;
+	struct skill_ruleset* rs;
+
+	/* 0 - queue; 1 - skills; 2 - rules; 3 - <ruleset> */
+	if (pos != 3)
+		return NULL;
+
+	AST_LIST_LOCK(&skill_rulesets);
+	AST_LIST_TRAVERSE(&skill_rulesets, rs, entry) {
+		if (++which > state) {
+			value = ast_strdup(rs->name);
+			break;
+		}
+	}
+	AST_LIST_UNLOCK(&skill_rulesets);
+
+	return value;
+}
+
 static char *complete_queue_add_member(const char *line, const char *word, int pos, int state)
 {
-	/* 0 - queue; 1 - add; 2 - member; 3 - <interface>; 4 - to; 5 - <queue>; 6 - penalty; 7 - <penalty>; 8 - as; 9 - <membername> - 10 state_interface; - 11 <state_interface>; - 12 incominglimit; - 13 <incominglimit>; */
+	/* 0 - queue; 1 - add; 2 - member; 3 - <interface>; 4 - to; 5 - <queue>;
+	 * 6 - penalty; 7 - <penalty>; * 8 - as; 9 - <membername> - 10 state_interface; - 11 <state_interface>;
+	 * - 12 incominglimit; - 13 <incominglimit>; - 14 skills; - 15 <skills>
+	 */
 	switch (pos) {
 	case 3:	/* Don't attempt to complete name of interface (infinite possibilities) */
 		return NULL;
@@ -5341,6 +6668,8 @@
 		return state == 0 ? ast_strdup("state_interface") : NULL;
 	case 12:
 		return state == 0 ? ast_strdup("incominglimit") : NULL;
+	case 14:
+		return state == 0 ? ast_strdup("skills") : NULL;
 	default:
 		return NULL;
 	}
@@ -5425,8 +6754,16 @@
 "Usage: queue show\n"
 "       Provides summary information on a specified queue.\n";
 
+static char queue_skills_groups_usage[] =
+"Usage: queue skills groups [<name>]\n"
+"       Display skill groups\n";
+
+static char queue_skills_rules_usage[] =
+"Usage: queue skills rules [<name>]\n"
+"       Display skill rules\n";
+
 static char qam_cmd_usage[] =
-"Usage: queue add member <channel> to <queue> [penalty <penalty> [as <membername> [state_interface <state_interface> [incominglimit <incominglimit>]]]]\n";
+"Usage: queue add member <channel> to <queue> [penalty <penalty> [as <membername> [state_interface <state_interface> [incominglimit <incominglimit> [skills <skills>]]]]]\n";
 
 static char qrm_cmd_usage[] =
 "Usage: queue remove member <channel> from <queue>\n";
@@ -5456,6 +6793,14 @@
 	queue_show, "Show status of a specified queue",
 	queue_show_usage, complete_queue_show, &cli_show_queue_deprecated },
 
+	{ { "queue", "skills", "groups", NULL },
+	handle_queue_skills_groups, "Show information about skills groups",
+	queue_skills_groups_usage, complete_queue_skills_groups, NULL },
+
+	{ { "queue", "skills", "rules", NULL },
+	handle_queue_skills_rules, "Show information about skills rules",
+	queue_skills_rules_usage, complete_queue_skills_rules, NULL },
+
 	{ { "queue", "add", "member", NULL },
 	handle_queue_add_member, "Add a channel to a specified queue",
 	qam_cmd_usage, complete_queue_add_member, &cli_add_queue_member_deprecated },
@@ -5507,7 +6852,7 @@
 {
 	int res;
 
-	if (!reload_queues())
+	if (!reload_all())
 		return AST_MODULE_LOAD_DECLINE;
 
 	if (queue_persistent_members)
@@ -5541,7 +6886,7 @@
 
 static int reload(void)
 {
-	reload_queues();
+	reload_all();
 	return 0;
 }
 
Index: asterisk-1.4.30/configs/queueskillrules.conf.sample
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ asterisk-1.4.30/configs/queueskillrules.conf.sample	2010-04-02 15:12:47.000000000 +0200
@@ -0,0 +1,68 @@
+; This file describes skill routing rules. The Queue() application can get the
+; 'skill_ruleset' argument which is the name of one skill routing ruleset. If
+; set, a selection of queue members is defined by running these rules on each
+; member, based on skills set (see the queueskills.conf file).
+;
+; A ruleset is a list of rules. Each rule has two parts:
+;     - the first part is a dynamical condition. If its evaluation is false, the
+;       next rule is tried;
+;     - the second part is tested against queue member's skills, to define a
+;       selection.
+;
+; Operators:
+; ----------
+;
+; You can define these rules with some arithmetic and logical operators:
+;      operand1 / operand2  (division)
+;      operand1 * operand2  (multiplication)
+;      operand1 - operand2  (subtraction)
+;      operand1 + operand2  (addition)
+;      operand1 ! operand2  (is not equal)
+;      operand1 = operand2  (is equal)
+;      operand1 > operand2  (is greater than)
+;      operand1 < operand2  (is lesser than)
+;      operand1 & operand2  (both are true)
+;      operand1 | operand2  (at least one of them are true)
+;
+; '/' is the operator with the higher priority, and '|' the one with the lower
+; priority. You can use brackets '()' to overload operator priorities.
+;
+; Dynamical part:
+; ---------------
+; The first part is evaluated after create a selection of queue members with
+; the second part, and determine if we keep this rule or if we switch to the
+; next one.
+;
+; On this part, these variables can be used:
+;     EWT (Estimated Waiting Time)      The waiting time estimated for the
+;                                       current selection of members
+;     WT  (Waiting time)                The time that caller has been waited
+;
+; Skills part:
+; ------------
+; This second part is evaluated against every queue member's skills, to know
+; if it is selected or not.
+;
+; Variables are skills names, which you can check with below operators. You can
+; also use meta-variables, started with a '$', to substitute them with data set
+; on the Queue() call. For example, if you call Queue() with the skill rouleset
+; argument equal to:
+;      tech(os=linux)
+; every $os occurrence will be replaced to 'linux'.
+;
+; Examples:
+; ---------
+;
+; [tech]
+; rule => WT < 60, technic & ($os > 29 & $lang > 39 | $os > 39 & $lang > 19)
+; rule => WT < 120, technic & ($os > 19 & $lang > 39 | $os > 29 & $lang > 19)
+; rule => WT < 3600, technic & $os > 10 & $lang > 19
+; rule => technic
+;
+; [client-crappy]
+; rule => technic = 0 & (sympathy > 20 | linux > 10 & windows > 10)
+;
+; [client-cool]
+; rule => EWT < 120, technic = 0 & (sympathy > 60)
+; rule => technic = 0
+
Index: asterisk-1.4.30/configs/queueskills.conf.sample
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ asterisk-1.4.30/configs/queueskills.conf.sample	2010-03-30 16:48:31.000000000 +0200
@@ -0,0 +1,47 @@
+; Describe skills groups here to assign them to queue members. You can set
+; weight to each skills. It'll be used by skill rules to know if a queue member
+; can answer to a call.
+; See the queueskillrules.conf to get more information about these rules.
+;
+; Examples:
+;
+; [linux1]
+; technic = 1
+; linux = 50
+; windows = 10
+; french = 50
+; english = 10
+;
+; [linux2]
+; technic = 1
+; linux = 30
+; windows = 20
+; french = 50
+; english = 50
+;
+; [windows1]
+; technic = 1
+; linux = 10
+; windows = 50
+; french = 30
+; english = 30
+;
+; [windows2]
+; technic = 1
+; linux = 20
+; windows = 30
+; french = 40
+; english = 10
+;
+; [commercial1]
+; technic = 0
+; linux = 10
+; windows = 20
+; sympathy = 100
+;
+; [commercial2]
+; technic = 0
+; linux = 0
+; windows = 20
+; sympathy = 50
+
