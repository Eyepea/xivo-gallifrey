Index: asterisk-1.4.29/apps/app_queue.c
===================================================================
--- asterisk-1.4.29.orig/apps/app_queue.c	2010-01-21 11:04:19.000000000 +0100
+++ asterisk-1.4.29/apps/app_queue.c	2010-01-22 12:08:38.000000000 +0100
@@ -150,7 +150,7 @@
 static char *synopsis = "Queue a call for a call queue";
 
 static char *descrip =
-"  Queue(queuename[|options[|URL][|announceoverride][|timeout][|AGI]):\n"
+"  Queue(queuename[|options[|URL][|announceoverride][|timeout][|AGI][|skill_ruleset]):\n"
 "Queues an incoming call in a particular call queue as defined in queues.conf.\n"
 "This application will return to the dialplan if the queue does not exist, or\n"
 "any of the join options cause the caller to not enter the queue.\n"
@@ -192,7 +192,7 @@
 static char *app_aqm = "AddQueueMember" ;
 static char *app_aqm_synopsis = "Dynamically adds queue members" ;
 static char *app_aqm_descrip =
-"   AddQueueMember(queuename[|interface[|penalty[|options[|membername[|state_interface[|incominglimit]]]]]]):\n"
+"   AddQueueMember(queuename[|interface[|penalty[|options[|membername[|state_interface[|incominglimit[|skills]]]]]]]):\n"
 "Dynamically adds interface to an existing queue.\n"
 "If the interface is already in the queue and there exists an n+101 priority\n"
 "then it will then jump to this priority.  Otherwise it will return an error\n"
@@ -331,9 +331,17 @@
 	struct member *member;
 };
 
+/* holdtime is not used for now. Yes, it means that
+ * this data struct is not usefull. Yes, I know.
+ */
+struct virtual_queue {
+	char id[80];                        /*!< Argument 'ruleset' to the Queue() app. */
+	int holdtime;                       /*!< Estimated Waiting Time for this virtual queue. */
+};
 
 struct queue_ent {
 	struct call_queue *parent;          /*!< What queue is our parent */
+	struct virtual_queue *vqueue;       /*!< Virtual queue in case there is skills routing */
 	char moh[80];                       /*!< Name of musiconhold to be used */
 	char announce[80];                  /*!< Announcement to play for member when call is answered */
 	char context[AST_MAX_CONTEXT];      /*!< Context when user exits queue */
@@ -349,24 +357,109 @@
 	int handled;                        /*!< Whether our call was handled */
 	int pending;                        /*!< Non-zero if we are attempting to call a member */
 	int max_penalty;                    /*!< Limit the members that can take this call to this penalty or lower */
+	char skill_ruleset[80];             /*!< Name of the skill ruleset */
 	time_t start;                       /*!< When we started holding */
 	time_t expire;                      /*!< When this entry should expire (time out of queue) */
+	struct ao2_container *mem_selection;/*!< Members who match skill rules. */
 	struct ast_channel *chan;           /*!< Our channel */
 	struct queue_ent *next;             /*!< The next queue entry */
 };
 
+enum skill_rule_operand_type {
+	SKILL_RULE_OPERAND_UNKNOWN,
+	SKILL_RULE_OPERAND_VARIABLE,
+	SKILL_RULE_OPERAND_VALUE,
+	SKILL_RULE_OPERAND_OPERATOR,
+};
+
+struct skill_rule_operand {
+	union {
+		char var[80];
+		int value;
+		struct skill_rule_operator* operator;
+	} u;
+	enum skill_rule_operand_type type;
+	AST_LIST_ENTRY(skill_rule_operand) entry;
+};
+
+enum skill_rule_operator_type {
+	SKILL_RULE_OPERATOR_UNKNOWN,
+	SKILL_RULE_OPERATOR_DIVISION,       /*!<  op1 / op2  */
+	SKILL_RULE_OPERATOR_MULTIPLICATION, /*!<  op1 * op2  */
+	SKILL_RULE_OPERATOR_SUBTRACTION,    /*!<  op1 - op2  */
+	SKILL_RULE_OPERATOR_ADDITION,       /*!<  op1 + op2  */
+	SKILL_RULE_OPERATOR_NOTEQUAL,       /*!<  op1 ! op2  */
+	SKILL_RULE_OPERATOR_EQUAL,          /*!<  op1 = op2  */
+	SKILL_RULE_OPERATOR_GREATER,        /*!<  op1 > op2  */
+	SKILL_RULE_OPERATOR_LESSER,         /*!<  op1 < op2  */
+	SKILL_RULE_OPERATOR_AND,            /*!<  op1 & op2  */
+	SKILL_RULE_OPERATOR_OR              /*!<  op1 | op2  */
+};
+
+#define SKILL_RULE_OPERATORS_CHARS "/*-+!=><&|"
+static enum skill_rule_operator_type skill_rule_operator_type_str[] = {
+	['/'] = SKILL_RULE_OPERATOR_DIVISION,
+	['*'] = SKILL_RULE_OPERATOR_MULTIPLICATION,
+	['-'] = SKILL_RULE_OPERATOR_SUBTRACTION,
+	['+'] = SKILL_RULE_OPERATOR_ADDITION,
+	['!'] = SKILL_RULE_OPERATOR_NOTEQUAL,
+	['='] = SKILL_RULE_OPERATOR_EQUAL,
+	['>'] = SKILL_RULE_OPERATOR_GREATER,
+	['<'] = SKILL_RULE_OPERATOR_LESSER,
+	['&'] = SKILL_RULE_OPERATOR_AND,
+	['|'] = SKILL_RULE_OPERATOR_OR,
+};
+
+struct skill_rule_operator {
+	struct skill_rule_operator *parent;
+	AST_LIST_HEAD_NOLOCK(,skill_rule_operand) operands;
+	enum skill_rule_operator_type type;
+};
+
+struct skill_rule {
+	struct skill_rule_operator *headop;
+};
+
+struct skill_ruleset {
+	char name[80];
+	struct ao2_container *rules;
+	AST_LIST_ENTRY(skill_ruleset) entry;
+};
+
+static AST_LIST_HEAD_STATIC(skill_rulesets, skill_ruleset);
+
+struct rule_var {
+	char name[80];
+	char value[80];
+};
+
+struct skill {
+	char name[80];                      /*!< Name of skill */
+	int weight;                         /*!< Weight */
+};
+
+struct skills_group {
+	char name[80];
+	struct ao2_container *skills;       /*!< Head of the list of skills */
+	AST_LIST_ENTRY(skills_group) entry;
+};
+
+static AST_LIST_HEAD_STATIC(skills_groups, skills_group);
+
 struct member {
 	char interface[80];                 /*!< Technology/Location */
-	char state_interface[80];			/*!< Technology/Location from which to read device state changes */
+	char state_interface[80];           /*!< Technology/Location from which to read device state changes */
 	char membername[80];                /*!< Member name to use in queue logs */
+	char skills[80];                    /*!< Member skills */
 	int penalty;                        /*!< Are we a last resort? */
 	int calls;                          /*!< Number of calls serviced by this member */
 	int dynamic;                        /*!< Are we dynamically added? */
 	int realtime;                       /*!< Is this member realtime? */
 	int status;                         /*!< Status of queue member */
 	int paused;                         /*!< Are we paused (not accepting calls)? */
-	int current_calls;		    /*!< Number of calls this member is servicing */
-	int incominglimit;		    /*!< Maximum number of calls this member can be servicing */
+	int current_calls;                  /*!< Number of calls this member is servicing */
+	int incominglimit;                  /*!< Maximum number of calls this member can be servicing */
+	int holdtime;                       /*!< Average holdtime. */
 	time_t lastcall;                    /*!< When last successful call was hungup */
 	unsigned int dead:1;                /*!< Used to detect members deleted in realtime */
 	unsigned int delme:1;               /*!< Flag to delete entry on reload */
@@ -441,6 +534,7 @@
 	int memberdelay;                    /*!< Seconds to delay connecting member to caller */
 	int autofill;                       /*!< Ignore the head call status and ring an available agent */
 	
+	struct ao2_container *vqueues;      /*!< Virtual queues */
 	struct ao2_container *members;             /*!< Head of the list of members */
 	/*! 
 	 * \brief Number of members _logged in_
@@ -532,6 +626,696 @@
 		free_members(q, 1);
 		ao2_ref(q->members, -1);
 	}
+	if (q->vqueues) {
+		ao2_ref(q->vqueues, -1);
+	}
+}
+
+static void destroy_skills_group(void *obj)
+{
+	struct skills_group *skgrp = obj;
+	struct skill *cur;
+	struct ao2_iterator sk_iter = ao2_iterator_init(skgrp->skills, 0);
+
+	while ((cur = ao2_iterator_next(&sk_iter))) {
+		ao2_unlink(skgrp->skills, cur);
+		ao2_ref(cur, -1);
+	}
+	ao2_iterator_destroy(&sk_iter);
+	ao2_ref(skgrp->skills, -1);
+}
+
+static void destroy_operator(struct skill_rule_operator *op)
+{
+	struct skill_rule_operand *operand;
+
+	AST_LIST_TRAVERSE_SAFE_BEGIN(&op->operands, operand, entry) {
+		AST_LIST_REMOVE_CURRENT(&op->operands, entry);
+		if (operand->type == SKILL_RULE_OPERAND_OPERATOR)
+			destroy_operator(operand->u.operator);
+
+		ast_free(operand);
+	}
+	AST_LIST_TRAVERSE_SAFE_END;
+	ast_free(op);
+}
+
+static void destroy_skill_rule(void* obj)
+{
+	struct skill_rule* r = obj;
+	destroy_operator(r->headop);
+}
+
+static void destroy_skill_ruleset(void *obj)
+{
+	struct skill_ruleset *ruleset = obj;
+	struct skill_rule *cur;
+	struct ao2_iterator rule_iter = ao2_iterator_init(ruleset->rules, 0);
+
+	while ((cur = ao2_iterator_next(&rule_iter))) {
+		ao2_unlink(ruleset->rules, cur);
+		ao2_ref(cur, -1);
+	}
+	ao2_iterator_destroy(&rule_iter);
+	ao2_ref(ruleset->rules, -1);
+}
+
+static struct skill_rule_operator *create_skill_rule_operator(enum skill_rule_operator_type t, struct skill_rule_operator *parent)
+{
+	struct skill_rule_operator *op;
+	op = ast_calloc(1, sizeof(*op));
+	if (!op)
+		return NULL;
+
+	op->type = t;
+	AST_LIST_HEAD_INIT_NOLOCK(&op->operands);
+	op->parent = parent;
+
+	return op;
+}
+
+static struct skill_rule_operand *create_skill_rule_operand(enum skill_rule_operand_type t)
+{
+	struct skill_rule_operand *operand;
+	operand = ast_calloc(1, sizeof(*operand));
+	if (!operand)
+		return NULL;
+
+	operand->type = t;
+	return operand;
+}
+
+#if 0 /* used for debug */
+static char* display_operator(struct skill_rule_operator *op)
+{
+	struct skill_rule_operand *operand;
+	size_t len = 512;
+	char *str = malloc(len);
+	char *s = str;
+
+	*str = '\0';
+	AST_LIST_TRAVERSE(&op->operands, operand, entry) {
+		char t;
+		switch(op->type) {
+		case SKILL_RULE_OPERATOR_NOTEQUAL: t = '!'; break;
+		case SKILL_RULE_OPERATOR_EQUAL:    t = '='; break;
+		case SKILL_RULE_OPERATOR_GREATER:    t = '>'; break;
+		case SKILL_RULE_OPERATOR_LESSER:    t = '<'; break;
+		case SKILL_RULE_OPERATOR_AND:      t = '&'; break;
+		case SKILL_RULE_OPERATOR_OR:       t = '|'; break;
+		default:                     t = '?'; break;
+		}
+
+		if (*str != '\0')
+			ast_build_string(&s, &len, "%c", t);
+
+		switch(operand->type) {
+		case SKILL_RULE_OPERAND_VARIABLE:
+			ast_build_string(&s, &len, "%s", operand->u.var);
+			break;
+		case SKILL_RULE_OPERAND_VALUE:
+			ast_build_string(&s, &len, "%d", operand->u.value);
+			break;
+		case SKILL_RULE_OPERAND_OPERATOR:
+		{
+			char *tmp = display_operator(operand->u.operator);
+			ast_build_string(&s, &len, "(%s)", tmp);
+			free(tmp);
+			break;
+		}
+		case SKILL_RULE_OPERAND_UNKNOWN:
+			ast_build_string(&s, &len, "<unknown>");
+		}
+	}
+	return str;
+}
+#endif
+
+static struct skill_rule_operator* parse_expr(const char *expr)
+{
+	struct skill_rule_operator *op, *head;
+	struct skill_rule_operand *operand = NULL;
+	const char *ptr, *start = NULL;
+
+	op = create_skill_rule_operator(SKILL_RULE_OPERATOR_UNKNOWN, NULL);
+	if (!op)
+		return NULL;
+
+	head = op;
+	ptr = expr;
+	do {
+		if (start) {
+			/* currently parsing a variable name. */
+			if ((*ptr >= 'a' && *ptr <= 'z') ||
+			    (*ptr >= 'A' && *ptr <= 'Z') ||
+			    (*ptr >= '0' && *ptr <= '9') ||
+			    (strchr("$-_", *ptr) && *ptr != '\0')) {
+				++ptr;
+				continue;
+			}
+
+			if (operand) {
+				ast_log(LOG_ERROR, "Unable to parse rule: syntax error, missing operator.\n");
+				goto error;
+			}
+
+			operand = create_skill_rule_operand(SKILL_RULE_OPERAND_VARIABLE);
+			if (!operand) {
+				/* OOM */
+				ast_log(LOG_ERROR, "Unable to parse rule: out-of-memory.\n");
+				goto error;
+			}
+			ast_copy_string(operand->u.var, start, (ptr + 1 - start) > sizeof(operand->u.var)
+			                                                         ? sizeof(operand->u.var)
+			                                                         : (ptr + 1 - start));
+			start = NULL;
+		}
+		if ((*ptr >= 'a' && *ptr <= 'z') ||
+		    (*ptr >= 'A' && *ptr <= 'Z') ||
+		    *ptr == '$') {
+			/* starting to parse a variable name. */
+			start = ptr++;
+			continue;
+		}
+		if ((*ptr >= '0' && *ptr <= '9') || *ptr == '-') {
+			/* parsing an integer value. */
+			int value;
+			start = ptr;
+			errno = 0;
+			value = strtol(start, (char**)&ptr, 10);
+			if (start == ptr) {
+				/* no digits found */
+				ast_log(LOG_ERROR, "Unable to parse rule: syntax error, no-digits.\n");
+				goto error;
+			}
+			if ((errno == ERANGE && (value == LONG_MAX || value == LONG_MIN)) ||
+			    (errno != 0 && value == 0)) {
+				/* error */
+				ast_log(LOG_ERROR, "Unable to parse rule: strtol error: %s.\n", strerror(errno));
+				goto error;
+			}
+
+			if (operand) {
+				/* WTF syn error */
+				ast_log(LOG_ERROR, "Unable to parse rule: syntax error, missing operator.\n");
+				goto error;
+			}
+			operand = create_skill_rule_operand(SKILL_RULE_OPERAND_VALUE);
+			if (!operand) {
+				/* OOM */
+				ast_log(LOG_ERROR, "Unable to parse rule: out-of-memory.\n");
+				goto error;
+			}
+			operand->u.value = value;
+			start = NULL;
+			continue;
+		}
+		if (*ptr == '(') {
+			struct skill_rule_operator *newop;
+			char *tmp;
+
+			if (operand) {
+				ast_log(LOG_ERROR, "Unable to parse rule: missing operator before '('\n");
+				goto error;
+			}
+
+			start = ++ptr;
+			ptr += strlen(ptr);
+			while (ptr >= start && *ptr != ')')
+				--ptr;
+
+			if (ptr == start) {
+				ast_log(LOG_ERROR, "Unable to parse rule: empty expression between ()\n");
+				goto error;
+			}
+			if (ptr < start) {
+				ast_log(LOG_ERROR, "Unable to parse rule: missing ')'\n");
+				goto error;
+			}
+
+			tmp = ast_strndup(start, ptr-start);
+			newop = parse_expr(tmp);
+			ast_free(tmp);
+
+			if (!newop) {
+				/* Something failed while parsing subexpr. Do
+				 * not display any message as parse_expr()
+				 * probably dit it.
+				 */
+				goto error;
+			}
+
+			operand = create_skill_rule_operand(SKILL_RULE_OPERAND_OPERATOR);
+			if (!operand) {
+				ast_log(LOG_ERROR, "Unable to parse rule: out-of-memory\n");
+				ast_free(newop);
+				goto error;
+			}
+			operand->u.operator = newop;
+			start = NULL;
+			++ptr;
+		}
+		/* if *ptr == '\0', strchr("...", *ptr) != NULL */
+		if (strchr(SKILL_RULE_OPERATORS_CHARS, *ptr)) {
+			/* operator */
+			enum skill_rule_operator_type flag = SKILL_RULE_OPERATOR_UNKNOWN;
+
+			if (!operand) {
+				/* syntax error */
+				ast_log(LOG_ERROR, "Unable to parse rule: syntax error, no operand before '%c'.\n", *ptr ? *ptr : ';');
+				goto error;
+			}
+
+			if (*ptr != '\0')
+				flag = skill_rule_operator_type_str[(size_t)*ptr];
+			else
+				flag = op->type;
+
+			if (op->type == SKILL_RULE_OPERATOR_UNKNOWN) {
+				if (flag == SKILL_RULE_OPERATOR_UNKNOWN) {
+					/* syntax error */
+					ast_log(LOG_ERROR, "Unable to parse rule: syntax error, no operator.\n");
+					goto error;
+				}
+				op->type = flag;
+			}
+
+			if (op->type < flag) {
+				/* last operator has a greater priority than current operator. */
+				struct skill_rule_operator *parent;
+
+				/* Firstly, add the operand in the current operator. */
+				AST_LIST_INSERT_TAIL(&op->operands, operand, entry);
+				operand = NULL;
+
+				/* Then we try to jump to an upper operator, or to create one. */
+
+				/* look for a parent operator with a lower or equal priority. */
+				for(parent = op->parent; parent && parent->type < flag; parent = parent->parent)
+					op = parent;
+
+				if (!parent) {
+					/* There isn't any other operator with a lower or equal priority */
+					parent = create_skill_rule_operator(flag, NULL);
+					if (!parent) {
+						/* OOM */
+						ast_log(LOG_ERROR, "Unable to parse rule: out-of-memory.\n");
+						goto error;
+					}
+
+					operand = create_skill_rule_operand(SKILL_RULE_OPERAND_OPERATOR);
+					if (!operand) {
+						/* OOM */
+						ast_log(LOG_ERROR, "Unable to parse rule: out-of-memory.\n");
+						ast_free(parent);
+						goto error;
+					}
+					operand->u.operator = op;
+
+					op->parent = parent;
+					AST_LIST_INSERT_TAIL(&parent->operands, operand, entry);
+
+					head = parent;
+
+					operand = NULL;
+				} else if (parent->type > flag) {
+					/* There is an operator with a greater priority, so we insert this
+					 * operator between this one and his last child. */
+					struct skill_rule_operator *newop;
+					newop = create_skill_rule_operator(flag, parent);
+					if (!newop) {
+						/* OOM */
+						ast_log(LOG_ERROR, "Unable to parse rule: out-of-memory.\n");
+						goto error;
+					}
+
+					AST_LIST_TRAVERSE(&parent->operands, operand, entry) {
+						if (operand->type == SKILL_RULE_OPERAND_OPERATOR && operand->u.operator == op)
+							break;
+					}
+
+					if (!operand) {
+						/* WTF */
+						ast_free(newop);
+						ast_log(LOG_ERROR, "Unable to parse rule: internal error (unable to find operand).\n");
+						goto error;
+					}
+					op->parent = newop;
+
+					AST_LIST_REMOVE(&parent->operands, operand, entry);
+					AST_LIST_INSERT_TAIL(&newop->operands, operand, entry);
+					operand = NULL;
+
+					operand = create_skill_rule_operand(SKILL_RULE_OPERAND_OPERATOR);
+					if (!operand) {
+						/* OOM */
+						ast_free(newop);
+						ast_log(LOG_ERROR, "Unable to parse rule: out-of-memory.\n");
+						goto error;
+					}
+					operand->u.operator = newop;
+					AST_LIST_INSERT_TAIL(&parent->operands, operand, entry);
+
+					operand = NULL;
+
+					parent = newop;
+				}
+				op = parent;
+
+			} else if (op->type > flag) {
+				/* last operator has a lower priority than current operator. */
+				struct skill_rule_operator *newop;
+				newop = create_skill_rule_operator(flag, op);
+				if (!newop) {
+					/* OOM */
+					ast_log(LOG_ERROR, "Unable to parse rule: out-of-memory.\n");
+					goto error;
+				}
+
+				AST_LIST_INSERT_TAIL(&newop->operands, operand, entry);
+				operand = NULL;
+
+				operand = create_skill_rule_operand(SKILL_RULE_OPERAND_OPERATOR);
+				if (!operand) {
+					/* OOM */
+					ast_log(LOG_ERROR, "Unable to parse rule: out-of-memory.\n");
+					ast_free(newop);
+					goto error;
+				}
+				operand->u.operator = newop;
+				AST_LIST_INSERT_TAIL(&op->operands, operand, entry);
+				operand = NULL;
+
+				op = newop;
+			} else {
+				AST_LIST_INSERT_TAIL(&op->operands, operand, entry);
+				operand = NULL;
+			}
+		}
+
+		++ptr;
+	} while (*(ptr-1));
+
+	return head;
+
+error:
+	destroy_operator(head);
+	if(operand)
+		ast_free(operand);
+	return NULL;
+}
+
+static int parse_skill_rule(struct skill_rule *r, const char *line)
+{
+	r->headop = parse_expr(line);
+	return 0;
+}
+
+static int operator_eval_skills(struct skill_rule_operator *op, struct skills_group *skills, struct ao2_container *variables)
+{
+	struct skill_rule_operand *opnd = NULL;
+	int ret = 0;
+	int first = 1;
+
+	if (!op) {
+		ast_log(LOG_WARNING, "Rule is empty\n");
+		return 0;
+	}
+
+	AST_LIST_TRAVERSE(&op->operands, opnd, entry) {
+		int value = 0;
+		switch(opnd->type) {
+			case SKILL_RULE_OPERAND_VARIABLE:
+			{
+				struct rule_var *var = NULL;
+				char *name = opnd->u.var;
+
+				if (*name == '$') {
+					/* This is a meta-variable, find the value given to app to it, to
+					 * substitute it with a real skill name.
+					 */
+					struct ao2_iterator variter = ao2_iterator_init(variables, 0);
+
+					++name;
+					while ((var = ao2_iterator_next(&variter)) && strcmp(name, var->name))
+						ao2_ref(var, -1);
+
+					if (var)
+						name = var->value;
+					else
+						name = NULL;
+
+					ao2_iterator_destroy(&variter);
+				}
+
+				/* Check if the skill name has been given to app. */
+				if (name) {
+					char *endptr = name;
+					int v = strtoul(endptr, &endptr, 10);
+
+					if (endptr == '\0') {
+						/* name is an integer, so that's a value. */
+						value = v;
+					} else {
+						/* name is a skill name. */
+						struct skill* skill;
+						struct ao2_iterator iter = ao2_iterator_init(skills->skills, 0);
+						while ((skill = ao2_iterator_next(&iter)) && strcmp(skill->name, name))
+							ao2_ref(skill, -1);
+
+						if (!skill)
+							value = 0;
+						else {
+							value = skill->weight;
+							ao2_ref(skill, -1);
+						}
+						ao2_iterator_destroy(&iter);
+					}
+				}
+
+				if (var)
+					ao2_ref(var, -1);
+				break;
+			}
+			case SKILL_RULE_OPERAND_VALUE:
+				value = opnd->u.value;
+				break;
+			case SKILL_RULE_OPERAND_OPERATOR:
+				value = operator_eval_skills(opnd->u.operator, skills, variables);
+				break;
+			case SKILL_RULE_OPERAND_UNKNOWN:
+				/* WTF */
+				return 0;
+		}
+
+		if (first)
+			ret = value;
+		else {
+			switch(op->type) {
+				case SKILL_RULE_OPERATOR_DIVISION:
+					if (value != 0)
+						ret /= value;
+					else {
+						ast_log(LOG_WARNING, "Rule error: division by zero.\n");
+						return 0;
+					}
+					break;
+				case SKILL_RULE_OPERATOR_MULTIPLICATION:
+					ret *= value;
+					break;
+				case SKILL_RULE_OPERATOR_SUBTRACTION:
+					ret -= value;
+					break;
+				case SKILL_RULE_OPERATOR_ADDITION:
+					ret += value;
+					break;
+				case SKILL_RULE_OPERATOR_NOTEQUAL:
+					ret = (ret != value);
+					break;
+				case SKILL_RULE_OPERATOR_EQUAL:
+					ret = (ret == value);
+					break;
+				case SKILL_RULE_OPERATOR_GREATER:
+					ret = (ret > value);
+					break;
+				case SKILL_RULE_OPERATOR_LESSER:
+					ret = (ret < value);
+					break;
+				case SKILL_RULE_OPERATOR_AND:
+					ret = (ret && value);
+					break;
+				case SKILL_RULE_OPERATOR_OR:
+					ret = (ret || value);
+					break;
+				case SKILL_RULE_OPERATOR_UNKNOWN:
+					/* WTF */
+					return 0;
+			}
+		}
+
+		first = 0;
+	}
+
+	return ret;
+}
+
+static int get_estimated_waiting_time(struct queue_ent *qe)
+{
+	if (qe->vqueue) {
+		struct ao2_iterator iter = ao2_iterator_init(qe->parent->members, 0);
+		struct member *mem;
+		struct queue_ent *ch;
+		int sum = 0, count = 0;
+		float aht, ciqu = 0;
+		float ali;
+
+		while ((mem = ao2_iterator_next(&iter))) {
+			sum += mem->holdtime;
+			count++;
+			ao2_ref(mem, -1);
+		}
+		ao2_iterator_destroy(&iter);
+
+		ali = count > 0 ? count : 0.0001;
+		aht = sum / ali;
+
+		ch = qe->parent->head;
+		for (ch = qe->parent->head; ch; ch = ch->next) {
+			if (!ch->pending && ch->vqueue == qe->vqueue)
+				ciqu++;
+		}
+
+		return aht * ciqu / ali;
+	}
+	else
+		return qe->parent->holdtime;
+}
+
+static int get_waiting_time(struct queue_ent *qe)
+{
+	return time(NULL) - qe->start;
+}
+
+/** Syntax of a rule name with their arguments: Rule(arg1=value1^arg2=value2^...)
+ *
+ * This function returns a container of 'struct rule_var' with every variables,
+ * and rulename value is set to the real rulename.
+ */
+static struct ao2_container *get_rule_variables(struct queue_ent *qe, char **rulename)
+{
+	static const struct {
+		const char *name;
+		int (*func) (struct queue_ent *qe);
+	} static_vars[] = {
+		{ "EWT", get_estimated_waiting_time },
+		{ "WT", get_waiting_time },
+	};
+	char *ptr, *var;
+	size_t i;
+	struct rule_var *v;
+	struct ao2_container *variables = ao2_container_alloc(37, NULL, NULL);
+
+	if (!variables) {
+		return NULL;
+	}
+
+	for (i = 0; i < sizeof(static_vars) / sizeof(*static_vars) ; ++i) {
+		size_t size;
+		v = ao2_alloc(sizeof(*v), NULL);
+		if (!v)
+			break;
+		ast_copy_string(v->name, static_vars[i].name, sizeof(v->name));
+		size = sizeof(v->value);
+		ptr = v->value;
+		ast_build_string(&ptr, &size, "%d", static_vars[i].func(qe));
+		ast_log(LOG_WARNING, "BLABLABLA : %s = %s\n", v->name, v->value);
+		ao2_link(variables, v);
+		ao2_ref(v, -1);
+	}
+
+	if (!(ptr = strchr(*rulename, '(')))
+		return variables;
+
+	*ptr++ = '\0';
+	while ((var = strsep(&ptr, "^)"))) {
+		char *value = strchr(var, '=');
+
+		if (!value)
+			continue;
+
+		*value++ = '\0';
+		v = ao2_alloc(sizeof(*v), NULL);
+		if (!v)
+			break;
+		ast_copy_string(v->name, var, sizeof(v->name));
+		ast_copy_string(v->value, value, sizeof(v->value));
+		ao2_link(variables, v);
+		ao2_ref(v, -1);
+	}
+
+	return variables;
+}
+
+static int is_member_matches_skill_ruleset(struct member *mem, const char* ruleset_name, struct ao2_container *variables)
+{
+	struct skill_ruleset* rs;
+	struct skill_rule* rule;
+	struct skills_group* skills;
+	struct ao2_iterator iter;
+	int ret = 0;
+
+	AST_LIST_LOCK(&skill_rulesets);
+	AST_LIST_LOCK(&skills_groups);
+
+	AST_LIST_TRAVERSE(&skill_rulesets, rs, entry) {
+		if (!strcmp(rs->name, ruleset_name))
+			break;
+	}
+
+	if (!rs) {
+		ast_log(LOG_WARNING, "Ruleset '%s' does not exist.\n", ruleset_name);
+		goto end;
+	}
+
+	AST_LIST_TRAVERSE(&skills_groups, skills, entry) {
+		if (!strcmp(skills->name, mem->skills))
+			break;
+	}
+
+	if (!skills) {
+		ast_log(LOG_WARNING, "Skills group '%s' does not exist.\n", mem->skills);
+		goto end;
+	}
+
+	iter = ao2_iterator_init(rs->rules, 0);
+	while (!ret && (rule = ao2_iterator_next(&iter))) {
+		ret = operator_eval_skills(rule->headop, skills, variables);
+		ao2_ref(rule, -1);
+	}
+	ao2_iterator_destroy(&iter);
+
+end:
+	AST_LIST_UNLOCK(&skill_rulesets);
+	AST_LIST_UNLOCK(&skills_groups);
+
+	return ret;
+}
+static int member_is_selected(struct queue_ent *qe, struct member *mem)
+{
+	struct member *m;
+
+	/* If there isn't any queue entry or if there isn't any
+	 * selection, it's because he doesn't use the skills routing.
+	 */
+	if (!qe || !qe->mem_selection)
+		return 1;
+
+	m = ao2_find(qe->mem_selection, mem, OBJ_POINTER);
+
+	if (m)
+		ao2_ref(m, -1);
+
+	return m != NULL;
 }
 
 /*! \brief Insert the 'new' entry after the 'prev' entry of queue 'q' */
@@ -571,7 +1355,7 @@
  * is available, the function immediately returns QUEUE_NORMAL. If no members are available,
  * the appropriate reason why is returned
  */
-static enum queue_member_status get_member_status(struct call_queue *q, int max_penalty)
+static enum queue_member_status get_member_status(struct call_queue *q, int max_penalty, struct queue_ent* qe)
 {
 	struct member *member;
 	struct ao2_iterator mem_iter;
@@ -595,6 +1379,11 @@
 			continue;
 		}
 
+		if (qe && !member_is_selected(qe, member)) {
+			ao2_ref(member, -1);
+			continue;
+		}
+
 		switch (member->status) {
 		case AST_DEVICE_INVALID:
 			/* nothing to do */
@@ -662,7 +1451,8 @@
                                               "Status: %d\r\n"
                                               "Paused: %d\r\n"
                                               "IncomingLimit: %d\r\n"
-                                              "CurrentCalls: %d\r\n",
+                                              "CurrentCalls: %d\r\n"
+                                              "Skills: %s\r\n",
                                               q->name,
                                               cur->interface,
                                               cur->membername,
@@ -673,7 +1463,8 @@
                                               cur->status,
                                               cur->paused,
                                               cur->incominglimit,
-                                              cur->current_calls);
+                                              cur->current_calls,
+					      cur->skills);
 			}
 			ao2_ref(cur, -1);
 		}
@@ -798,11 +1589,12 @@
 
 	return 0;
 }
+
 /*! \brief allocate space for new queue member and set fields based on parameters passed */
-static struct member *create_queue_member(const char *interface, const char *membername, int penalty, int paused, const char *state_interface, int incominglimit)
+static struct member *create_queue_member(const char *interface, const char *membername, int penalty, int paused, const char *state_interface, int incominglimit, const char *skills)
 {
 	struct member *cur;
-	
+
 	if ((cur = ao2_alloc(sizeof(*cur), NULL))) {
 		cur->penalty = penalty;
 		cur->paused = paused;
@@ -820,6 +1612,10 @@
 			ast_log(LOG_WARNING, "No location at interface '%s'\n", interface);
 		cur->status = ast_device_state(cur->state_interface);
 		cur->incominglimit = incominglimit;
+		if (!ast_strlen_zero(skills))
+			ast_copy_string(cur->skills, skills, sizeof(cur->skills));
+		else
+			cur->skills[0] = '\0';
 	}
 
 	return cur;
@@ -1166,7 +1962,7 @@
 	}
 }
 
-static void rt_handle_member_record(struct call_queue *q, char *interface, const char *membername, const char *penalty_str, const char *paused_str, const char *state_interface, const char *incominglimit_str)
+static void rt_handle_member_record(struct call_queue *q, char *interface, const char *membername, const char *penalty_str, const char *paused_str, const char *state_interface, const char *incominglimit_str, const char *skills)
 {
 	struct member *m, tmpmem;
 	int penalty = 0;
@@ -1197,7 +1993,7 @@
 
 	/* Create a new one if not found, else update penalty and incominglimit */
 	if (!m) {
-		if ((m = create_queue_member(interface, membername, penalty, paused, state_interface, incominglimit))) {
+		if ((m = create_queue_member(interface, membername, penalty, paused, state_interface, incominglimit, skills))) {
 			m->dead = 0;
 			m->realtime = 1;
 			add_to_interfaces(m->state_interface);
@@ -1217,6 +2013,10 @@
 		}
 		m->penalty = penalty;
 		m->incominglimit = incominglimit;
+		if (!ast_strlen_zero(skills))
+			ast_copy_string(m->skills, skills, sizeof(m->skills));
+		else
+			m->skills[0] = '\0';
 		ao2_ref(m, -1);
 	}
 }
@@ -1344,7 +2144,8 @@
 			ast_variable_retrieve(member_config, interface, "penalty"),
 			ast_variable_retrieve(member_config, interface, "paused"),
 			S_OR(ast_variable_retrieve(member_config, interface, "state_interface"),interface),
-			ast_variable_retrieve(member_config, interface, "call-limit"));
+			ast_variable_retrieve(member_config, interface, "call-limit"),
+			ast_variable_retrieve(member_config, interface, "skills"));
 	}
 
 	/* Delete all realtime members that have been deleted in DB. */
@@ -1418,7 +2219,8 @@
 			ast_variable_retrieve(member_config, interface, "penalty"),
 			ast_variable_retrieve(member_config, interface, "paused"),
 			S_OR(ast_variable_retrieve(member_config, interface, "state_interface"), interface),
-			ast_variable_retrieve(member_config, interface, "call-limit"));
+			ast_variable_retrieve(member_config, interface, "call-limit"),
+			ast_variable_retrieve(member_config, interface, "skills"));
 	}
 
 	/* Delete all realtime members that have been deleted in DB. */
@@ -1488,6 +2290,37 @@
 	return q;
 }
 
+static int join_virtual_queue(struct call_queue *q, struct queue_ent *qe)
+{
+	struct virtual_queue *vq = NULL;
+
+	if (!q->vqueues) {
+		q->vqueues = ao2_container_alloc(37, NULL, NULL);
+		if (!q->vqueues)
+			return -1;
+	} else {
+		struct ao2_iterator iter;
+
+		iter = ao2_iterator_init(q->vqueues, 0);
+		while ((vq = ao2_iterator_next(&iter)) && !strcmp(vq->id, qe->skill_ruleset))
+			ao2_ref(vq, -1);
+		ao2_iterator_destroy(&iter);
+	}
+
+	if (!vq) {
+		vq = ao2_alloc(sizeof(*vq), NULL);
+		if (!vq)
+			return -1;
+		ast_copy_string(vq->id, qe->skill_ruleset, sizeof(vq->id));
+	}
+
+	ao2_link(q->vqueues, vq);
+	qe->vqueue = vq;
+	/* do not unref vq because it's keept by the queue entry. */
+
+	return 0;
+}
+
 static int join_queue(char *queuename, struct queue_ent *qe, enum queue_result *reason)
 {
 	struct call_queue *q;
@@ -1503,8 +2336,34 @@
 	AST_LIST_LOCK(&queues);
 	ao2_lock(q);
 
+	if (!ast_strlen_zero(qe->skill_ruleset)) {
+		struct member *member;
+		struct ao2_iterator mem_iter;
+		struct ao2_container *variables;
+		char* tmp = ast_strdupa(qe->skill_ruleset);
+
+		qe->parent = q;
+		if (join_virtual_queue(q, qe) == 0 &&
+		    (variables = get_rule_variables(qe, &tmp))) {
+			mem_iter = ao2_iterator_init(q->members, 0);
+			while ((member = ao2_iterator_next(&mem_iter))) {
+				if(!ast_strlen_zero(member->skills) &&
+				   is_member_matches_skill_ruleset(member, tmp, variables)) {
+					ao2_link(qe->mem_selection, member);
+					ast_log(LOG_NOTICE, "User %s is associated.\n", member->interface);
+				} else
+					ast_log(LOG_NOTICE, "User %s is NOT associated.\n", member->interface);
+				ao2_ref(member, -1);
+			}
+
+			ao2_ref(variables, -1);
+			ao2_iterator_destroy(&mem_iter);
+		}
+		qe->parent = NULL;
+	}
+
 	/* This is our one */
-	stat = get_member_status(q, qe->max_penalty);
+	stat = get_member_status(q, qe->max_penalty, qe);
 	if (!q->joinempty && (stat == QUEUE_NO_MEMBERS))
 		*reason = QUEUE_JOINEMPTY;
 	else if ((q->joinempty == QUEUE_EMPTY_STRICT) && (stat == QUEUE_NO_REACHABLE_MEMBERS || stat == QUEUE_NO_MEMBERS))
@@ -1614,7 +2473,7 @@
 
 static int say_position(struct queue_ent *qe)
 {
-	int res = 0, avgholdmins, avgholdsecs;
+	int res = 0, avgholdmins, avgholdsecs, holdtime;
 	time_t now;
 
 	/* Check to see if this is ludicrous -- if we just announced position, don't do it again*/
@@ -1646,11 +2505,12 @@
 			goto playout;
 	}
 	/* Round hold time to nearest minute */
-	avgholdmins = abs(((qe->parent->holdtime + 30) - (now - qe->start)) / 60);
+	holdtime = get_estimated_waiting_time(qe);
+	avgholdmins = abs(((holdtime + 30) - (now - qe->start)) / 60);
 
 	/* If they have specified a rounding then round the seconds as well */
 	if (qe->parent->roundingseconds) {
-		avgholdsecs = (abs(((qe->parent->holdtime + 30) - (now - qe->start))) - 60 * avgholdmins) / qe->parent->roundingseconds;
+		avgholdsecs = (abs(((holdtime + 30) - (now - qe->start))) - 60 * avgholdmins) / qe->parent->roundingseconds;
 		avgholdsecs *= qe->parent->roundingseconds;
 	} else {
 		avgholdsecs = 0;
@@ -1721,6 +2581,13 @@
 	return res;
 }
 
+static void recalc_member_holdtime(struct member *mem, int newholdtime)
+{
+	int oldvalue;
+	oldvalue = mem->holdtime;
+	mem->holdtime = (((oldvalue << 2) - oldvalue) + newholdtime) >> 2;
+}
+
 static void recalc_holdtime(struct queue_ent *qe, int newholdtime)
 {
 	int oldvalue;
@@ -1807,9 +2674,10 @@
  * \note The queue passed in should be locked prior to this function call
  *
  * \param[in] q The queue for which we are couting the number of available members
+ * \param[in] qe The queue entry for which we are counting the number of available associated members (can be NULL).
  * \return Return the number of available members in queue q
  */
-static int num_available_members(struct call_queue *q)
+static int num_available_members(struct call_queue *q, struct queue_ent* qe)
 {
 	struct member *mem;
 	int avl = 0;
@@ -1825,7 +2693,8 @@
 		case AST_DEVICE_NOT_INUSE:
 		case AST_DEVICE_UNKNOWN:
 			if (!mem->paused &&
-			    !(mem->incominglimit && mem->current_calls >= mem->incominglimit)) {
+			    !(mem->incominglimit && mem->current_calls >= mem->incominglimit) &&
+			    (!qe || member_is_selected(qe, mem))) {
 				avl++;
 			}
 			break;
@@ -1868,7 +2737,7 @@
 		if (q->count && q->members) {
 			if ((mem = ao2_find(q->members, member, OBJ_POINTER))) {
 				ast_log(LOG_DEBUG, "Found matching member %s in queue '%s'\n", mem->interface, q->name);
-				if (q->weight > rq->weight && q->count >= num_available_members(q)) {
+				if (q->weight > rq->weight && q->count >= num_available_members(q, NULL)) {
 					ast_log(LOG_DEBUG, "Queue '%s' (weight %d, calls %d) is preferred over '%s' (weight %d, calls %d)\n", q->name, q->weight, q->count, rq->name, rq->weight, rq->count);
 					found = 1;
 				}
@@ -1976,6 +2845,15 @@
 		return 0;
 	}
 
+	if (!member_is_selected(qe, tmp->member)) {
+		if (option_debug)
+			ast_log(LOG_DEBUG, "%s doesn't match ruleset '%s'\n", tmp->interface, qe->skill_ruleset);
+		if (qe->chan->cdr)
+			ast_cdr_busy(qe->chan->cdr);
+		tmp->stillgoing = 0;
+		return 0;
+	}
+
 	if (use_weight && compare_weight(qe->parent,tmp->member)) {
 		ast_log(LOG_DEBUG, "Priority queue delaying call to %s:%s\n", qe->parent->name, tmp->interface);
 		if (qe->chan->cdr)
@@ -2570,7 +3448,7 @@
 	/* This needs a lock. How many members are available to be served? */
 	ao2_lock(qe->parent);
 
-	avl = num_available_members(qe->parent);
+	avl = num_available_members(qe->parent, qe);
 
 	ch = qe->parent->head;
 
@@ -2579,7 +3457,7 @@
 	}
 
 	while ((idx < avl) && (ch) && (ch != qe)) {
-		if (!ch->pending)
+		if (!ch->pending && ch->vqueue == qe->vqueue)
 			idx++;
 		ch = ch->next;			
 	}
@@ -2626,7 +3504,7 @@
 			break;
 		}
 
-		stat = get_member_status(qe->parent, qe->max_penalty);
+		stat = get_member_status(qe->parent, qe->max_penalty, qe);
 
 		/* leave the queue if no agents, if enabled */
 		if (qe->parent->leavewhenempty && (stat == QUEUE_NO_MEMBERS)) {
@@ -3149,6 +4027,7 @@
 		member = lpeer->member;
 		/* Increment the refcount for this member, since we're going to be using it for awhile in here. */
 		ao2_ref(member, 1);
+		recalc_member_holdtime(member, (now - qe->start));
 		hangupcalls(outgoing, peer);
 		outgoing = NULL;
 		if (announce || qe->parent->reportholdtime || qe->parent->memberdelay) {
@@ -3465,7 +4344,7 @@
 
 /* Dump all members in a specific queue to the database
  *
- * <pm_family>/<queuename> = <interface>;<penalty>;<paused>;<state_interface>;<incominglimit>[|...]
+ * <pm_family>/<queuename> = <interface>;<penalty>;<paused>;<state_interface>;<incominglimit>;<skills>[|...]
  *
  */
 static void dump_queue_members(struct call_queue *pm_queue)
@@ -3488,8 +4367,9 @@
 			continue;
 		}
 
-		res = snprintf(value + value_len, sizeof(value) - value_len, "%s%s;%d;%d;%s;%s;%d",
-			value_len ? "|" : "", cur_member->interface, cur_member->penalty, cur_member->paused, cur_member->membername, cur_member->state_interface, cur_member->incominglimit);
+		res = snprintf(value + value_len, sizeof(value) - value_len, "%s%s;%d;%d;%s;%s;%d;%s",
+			value_len ? "|" : "", cur_member->interface, cur_member->penalty, cur_member->paused,
+			cur_member->membername, cur_member->state_interface, cur_member->incominglimit, cur_member->skills);
 
 		ao2_ref(cur_member, -1);
 
@@ -3561,7 +4441,7 @@
 }
 
 
-static int add_to_queue(const char *queuename, const char *interface, const char *membername, int penalty, int paused, int dump, const char *state_interface, int incominglimit)
+static int add_to_queue(const char *queuename, const char *interface, const char *membername, int penalty, int paused, int dump, const char *state_interface, int incominglimit, const char *skills)
 {
 	struct call_queue *q;
 	struct member *new_member, *old_member;
@@ -3576,7 +4456,7 @@
 
 	ao2_lock(q);
 	if ((old_member = interface_exists(q, interface)) == NULL) {
-		if ((new_member = create_queue_member(interface, membername, penalty, paused, state_interface, incominglimit))) {
+		if ((new_member = create_queue_member(interface, membername, penalty, paused, state_interface, incominglimit, skills))) {
 			add_to_interfaces(new_member->state_interface);
 			new_member->dynamic = 1;
 			ao2_link(q->members, new_member);
@@ -3679,6 +4559,7 @@
 	char *member;
 	char *interface;
 	char *membername = NULL;
+	char *skills = NULL;
 	char *state_interface;
 	char *penalty_tok;
 	int penalty = 0;
@@ -3732,6 +4613,7 @@
 			membername = strsep(&member, ";");
 			state_interface = strsep(&member,";");
 			incominglimit_tok = strsep(&member,";");
+			skills = strsep(&member, ";");
 
 			if (!penalty_tok) {
 				ast_log(LOG_WARNING, "Error parsing persistent member string for '%s' (penalty)\n", queue_name);
@@ -3767,8 +4649,8 @@
 
 			if (option_debug)
 				ast_log(LOG_DEBUG, "Reload Members: Queue: %s  Member: %s  Name: %s  Penalty: %d  Paused: %d IncomingLimit: %d\n", queue_name, interface, membername, penalty, paused, incominglimit);
-			
-			if (add_to_queue(queue_name, interface, membername, penalty, paused, 0, state_interface, incominglimit) == RES_OUTOFMEMORY) {
+
+			if (add_to_queue(queue_name, interface, membername, penalty, paused, 0, state_interface, incominglimit, skills) == RES_OUTOFMEMORY) {
 				ast_log(LOG_ERROR, "Out of Memory when reloading persistent queue member\n");
 				break;
 			}
@@ -3969,12 +4851,13 @@
 		AST_APP_ARG(membername);
 		AST_APP_ARG(state_interface);
 		AST_APP_ARG(incominglimit);
+		AST_APP_ARG(skills);
 	);
 	int penalty = 0;
 	int incominglimit = 0;
 
 	if (ast_strlen_zero(data)) {
-		ast_log(LOG_WARNING, "AddQueueMember requires an argument (queuename[|interface[|penalty[|options[|membername[|state_interface[|incominglimit]]]]]])\n");
+		ast_log(LOG_WARNING, "AddQueueMember requires an argument (queuename[|interface[|penalty[|options[|membername[|state_interface[|incominglimit[|skills]]]]]]])\n");
 		return -1;
 	}
 
@@ -4010,7 +4893,7 @@
 		}
 	}
 
-	switch (add_to_queue(args.queuename, args.interface, args.membername, penalty, 0, queue_persistent_members, args.state_interface, incominglimit)) {
+	switch (add_to_queue(args.queuename, args.interface, args.membername, penalty, 0, queue_persistent_members, args.state_interface, incominglimit, args.skills)) {
 	case RES_OKAY:
 		ast_queue_log(args.queuename, chan->uniqueid, args.interface, "ADDMEMBER", "%s", "");
 		ast_log(LOG_NOTICE, "Added interface '%s' to queue '%s'\n", args.interface, args.queuename);
@@ -4111,15 +4994,16 @@
 		AST_APP_ARG(announceoverride);
 		AST_APP_ARG(queuetimeoutstr);
 		AST_APP_ARG(agi);
+		AST_APP_ARG(skill_ruleset);
 	);
 	/* Our queue entry */
 	struct queue_ent qe = { 0 };
-	
+
 	if (ast_strlen_zero(data)) {
-		ast_log(LOG_WARNING, "Queue requires an argument: queuename[|options[|URL[|announceoverride[|timeout[|agi]]]]]\n");
+		ast_log(LOG_WARNING, "Queue requires an argument: queuename[|options[|URL[|announceoverride[|timeout[|agi[|skill_ruleset]]]]]]\n");
 		return -1;
 	}
-	
+
 	parse = ast_strdupa(data);
 	AST_STANDARD_APP_ARGS(args, parse);
 
@@ -4177,6 +5061,11 @@
 	qe.chan = chan;
 	qe.prio = prio;
 	qe.max_penalty = max_penalty;
+	if (!ast_strlen_zero(args.skill_ruleset)) {
+		ast_copy_string(qe.skill_ruleset, args.skill_ruleset, sizeof(qe.skill_ruleset));
+		if (!qe.mem_selection)
+			qe.mem_selection = ao2_container_alloc(37, member_hash_fn, member_cmp_fn);
+	}
 	qe.last_pos_said = 0;
 	qe.last_pos = 0;
 	qe.last_periodic_announce_time = time(NULL);
@@ -4254,7 +5143,7 @@
 			if (res)
 				goto stop;
 
-			stat = get_member_status(qe.parent, qe.max_penalty);
+			stat = get_member_status(qe.parent, qe.max_penalty, &qe);
 
 			/* exit after 'timeout' cycle if 'n' option enabled */
 			if (noption && tries >= qe.parent->membercount) {
@@ -4353,6 +5242,15 @@
 		set_queue_result(chan, reason);
 		res = 0;
 	}
+	if (qe.mem_selection) {
+		ao2_ref(qe.mem_selection, -1);
+	}
+	if (qe.vqueue && ao2_ref(qe.vqueue, -1) == 1 && qe.parent) {
+		/* unref vqueue, and if nobody has reference to vqueue except
+		 * the vqueues list, destroy the vqueue object by removing it
+		 * from list. */
+		ao2_unlink(qe.parent->vqueues, qe.vqueue);
+	}
 	if (qe.parent) {
 		/* every queue_ent is given a reference to it's parent call_queue when it joins the queue.
 		 * This ref must be taken away right before the queue_ent is destroyed.  In this case
@@ -4552,6 +5450,7 @@
 	char *parse;
 	char *interface, *state_interface;
 	char *membername = NULL;
+	char *skills = NULL;
 	int penalty;
 	int incominglimit;
 	AST_DECLARE_APP_ARGS(args,
@@ -4560,8 +5459,9 @@
 		AST_APP_ARG(membername);
 		AST_APP_ARG(state_interface);
 		AST_APP_ARG(incominglimit);
+		AST_APP_ARG(skills);
 	);
-	
+
 	if (!(cfg = ast_config_load("queues.conf"))) {
 		ast_log(LOG_NOTICE, "No call queueing config file (queues.conf), so no call queues\n");
 		return 0;
@@ -4657,6 +5557,10 @@
 							membername = ast_skip_blanks(args.membername);
 						}
 
+						if (!ast_strlen_zero(args.skills)) {
+							skills = ast_skip_blanks(args.skills);
+						}
+
 						if (!ast_strlen_zero(args.state_interface)) {
 							state_interface = ast_skip_blanks(args.state_interface);
 						} else {
@@ -4681,7 +5585,7 @@
 							remove_from_interfaces(cur->state_interface);
 						}
 
-						newm = create_queue_member(interface, membername, penalty, cur ? cur->paused : 0, state_interface, incominglimit);
+						newm = create_queue_member(interface, membername, penalty, cur ? cur->paused : 0, state_interface, incominglimit, skills);
 						if (!cur || (cur && strcasecmp(cur->state_interface, state_interface))) {
 							add_to_interfaces(state_interface);
 						}
@@ -4745,6 +5649,119 @@
 	}
 	AST_LIST_TRAVERSE_SAFE_END;
 	AST_LIST_UNLOCK(&queues);
+
+	return 1;
+}
+
+static int reload_skills(void)
+{
+	struct ast_config *cfg;
+	char *cat = NULL, *tmp;
+	struct ast_variable *var;
+	struct skills_group *skgrp;
+
+	if (!(cfg = ast_config_load("queueskills.conf"))) {
+		ast_log(LOG_NOTICE, "No skills groups config file (queueskills.conf), so no call queues skills\n");
+		return 0;
+	}
+	AST_LIST_LOCK(&skills_groups);
+
+	/* Clear current skills */
+	AST_LIST_TRAVERSE_SAFE_BEGIN(&skills_groups, skgrp, entry) {
+		AST_LIST_REMOVE_CURRENT(&skills_groups, entry);
+		ao2_ref(skgrp, -1);
+	}
+	AST_LIST_TRAVERSE_SAFE_END;
+
+	while ((cat = ast_category_browse(cfg, cat))) {
+		skgrp = ao2_alloc(sizeof(*skgrp), destroy_skills_group);
+
+		if (!skgrp) {
+			ast_log(LOG_WARNING, "Unable to allocate memory for skills group");
+			break;
+		}
+		ast_copy_string(skgrp->name, cat, sizeof(skgrp->name));
+		skgrp->skills = ao2_container_alloc(37, NULL, NULL);
+
+		for (var = ast_variable_browse(cfg, cat); var; var = var->next) {
+			struct skill* sk;
+			sk = ao2_alloc(sizeof(*sk), NULL);
+			if (!sk) {
+				ast_log(LOG_WARNING, "Unable to allocate memory for a skill");
+				break;
+			}
+			ast_copy_string(sk->name, var->name, sizeof(sk->name));
+			tmp = ast_skip_blanks(var->value);
+			sk->weight = atoi(tmp);
+
+			ao2_link(skgrp->skills, sk);
+			ao2_ref(sk, -1);
+		}
+
+		AST_LIST_INSERT_HEAD(&skills_groups, skgrp, entry);
+	}
+	AST_LIST_UNLOCK(&skills_groups);
+	ast_config_destroy(cfg);
+	return 1;
+}
+
+static int reload_skill_rules(void)
+{
+	struct ast_config *cfg;
+	struct ast_variable *var;
+	struct skill_ruleset *ruleset;
+	char *cat = NULL;
+
+	if (!(cfg = ast_config_load("queueskillrules.conf"))) {
+		ast_log(LOG_NOTICE, "No rules config file (queueskillrules.conf), so no call queues rules\n");
+		return 0;
+	}
+	AST_LIST_LOCK(&skill_rulesets);
+
+	/* Clear current skill_rulesets */
+	AST_LIST_TRAVERSE_SAFE_BEGIN(&skill_rulesets, ruleset, entry) {
+		AST_LIST_REMOVE_CURRENT(&skill_rulesets, entry);
+		ao2_ref(ruleset, -1);
+	}
+	AST_LIST_TRAVERSE_SAFE_END;
+
+	while ((cat = ast_category_browse(cfg, cat))) {
+		ruleset = ao2_alloc(sizeof(*ruleset), destroy_skill_ruleset);
+		if (!ruleset) {
+			ast_log(LOG_WARNING, "Unable to allocate memory for a ruleset.");
+			break;
+		}
+		ast_copy_string(ruleset->name, cat, sizeof(ruleset->name));
+		ruleset->rules = ao2_container_alloc(37, NULL, NULL);
+		for (var = ast_variable_browse(cfg, cat); var; var = var->next) {
+			struct skill_rule *r = ao2_alloc(sizeof(*r), destroy_skill_rule);
+			if (!r) {
+				ast_log(LOG_WARNING, "Unable to allocate memory for a rule.");
+				break;
+			}
+			parse_skill_rule(r, var->value);
+
+			/* check if this rule is empty. */
+			if (r->headop)
+				ao2_link(ruleset->rules, r);
+			ao2_ref(r, -1);
+		}
+
+		AST_LIST_INSERT_HEAD(&skill_rulesets, ruleset, entry);
+	}
+	AST_LIST_UNLOCK(&skill_rulesets);
+	ast_config_destroy(cfg);
+	return 1;
+}
+
+static int reload_all(void)
+{
+	if(!reload_queues())
+		return 0;
+
+	reload_skills();
+	reload_skill_rules();
+
 	return 1;
 }
 
@@ -4858,6 +5875,8 @@
 					ast_build_string(&max, &max_left, " (paused)");
 				if (mem->incominglimit && mem->current_calls >= mem->incominglimit)
 					ast_build_string(&max, &max_left, " (incoming limit reached)");
+				if (!ast_strlen_zero(mem->skills))
+					ast_build_string(&max, &max_left, " (skills: %s)", mem->skills);
 				ast_build_string(&max, &max_left, " (%s)", devstate2str(mem->status));
 				if (mem->calls) {
 					ast_build_string(&max, &max_left, " has taken %d calls (last was %ld secs ago)",
@@ -5008,6 +6027,7 @@
                                                       "Paused: %d\r\n"
                                                       "IncomingLimit: %d\r\n"
                                                       "CurrentCalls: %d\r\n"
+                                                      "Skills: %s\r\n"
                                                       "%s"
                                                       "\r\n",
                                                       q->name,
@@ -5021,6 +6041,7 @@
                                                       mem->paused,
                                                       mem->incominglimit,
                                                       mem->current_calls,
+                                                      mem->skills,
                                                       idText);
 				}
 				ao2_ref(mem, -1);
@@ -5063,7 +6084,7 @@
 
 static int manager_add_queue_member(struct mansession *s, const struct message *m)
 {
-	const char *queuename, *interface, *penalty_s, *paused_s, *membername, *state_interface, *incominglimit_s;
+	const char *queuename, *interface, *penalty_s, *paused_s, *membername, *state_interface, *incominglimit_s, *skills;
 	int paused, penalty, incominglimit = 0;
 
 	queuename = astman_get_header(m, "Queue");
@@ -5073,6 +6094,7 @@
 	membername = astman_get_header(m, "MemberName");
 	state_interface = astman_get_header(m, "StateInterface");
 	incominglimit_s = astman_get_header(m, "IncomingLimit");
+	skills = astman_get_header(m, "Skills");
 
 	if (ast_strlen_zero(queuename)) {
 		astman_send_error(s, m, "'Queue' not specified.");
@@ -5099,7 +6121,7 @@
 	else if (sscanf(incominglimit_s, "%30d", &incominglimit) != 1 || incominglimit < 0)
 		incominglimit = 0;
 
-	switch (add_to_queue(queuename, interface, membername, penalty, paused, queue_persistent_members, state_interface, incominglimit)) {
+	switch (add_to_queue(queuename, interface, membername, penalty, paused, queue_persistent_members, state_interface, incominglimit, skills)) {
 	case RES_OKAY:
 		ast_queue_log(queuename, "MANAGER", interface, "ADDMEMBER", "%s", "");
 		astman_send_ack(s, m, "Added interface to queue");
@@ -5177,10 +6199,10 @@
 
 static int handle_queue_add_member(int fd, int argc, char *argv[])
 {
-	char *queuename, *interface, *membername = NULL, *state_interface = NULL;
+	char *queuename, *interface, *membername = NULL, *state_interface = NULL, *skills = NULL;
 	int penalty, incominglimit;
 
-	if ((argc != 6) && (argc != 8) && (argc != 10) && (argc != 12) && (argc != 14)) {
+	if ((argc != 6) && (argc != 8) && (argc != 10) && (argc != 12) && (argc != 14) && (argc != 16)) {
 		return RESULT_SHOWUSAGE;
 	} else if (strcmp(argv[4], "to")) {
 		return RESULT_SHOWUSAGE;
@@ -5192,6 +6214,8 @@
 		return RESULT_SHOWUSAGE;
 	} else if ((argc == 14) && strcmp(argv[12], "incominglimit")) {
 		return RESULT_SHOWUSAGE;
+	} else if ((argc == 16) && strcmp(argv[14], "skills")) {
+		return RESULT_SHOWUSAGE;
 	}
 
 	queuename = argv[5];
@@ -5232,7 +6256,11 @@
 		incominglimit = 0;
 	}
 
-	switch (add_to_queue(queuename, interface, membername, penalty, 0, queue_persistent_members, state_interface, incominglimit)) {
+	if (argc >= 16) {
+		skills = argv[15];
+	}
+
+	switch (add_to_queue(queuename, interface, membername, penalty, 0, queue_persistent_members, state_interface, incominglimit, skills)) {
 	case RES_OKAY:
 		ast_queue_log(queuename, "CLI", interface, "ADDMEMBER", "%s", "");
 		ast_cli(fd, "Added interface '%s' to queue '%s'\n", interface, queuename);
@@ -5253,7 +6281,10 @@
 
 static char *complete_queue_add_member(const char *line, const char *word, int pos, int state)
 {
-	/* 0 - queue; 1 - add; 2 - member; 3 - <interface>; 4 - to; 5 - <queue>; 6 - penalty; 7 - <penalty>; 8 - as; 9 - <membername> - 10 state_interface; - 11 <state_interface>; - 12 incominglimit; - 13 <incominglimit>; */
+	/* 0 - queue; 1 - add; 2 - member; 3 - <interface>; 4 - to; 5 - <queue>;
+	 * 6 - penalty; 7 - <penalty>; * 8 - as; 9 - <membername> - 10 state_interface; - 11 <state_interface>;
+	 * - 12 incominglimit; - 13 <incominglimit>; - 14 skills; - 15 <skills>
+	 */
 	switch (pos) {
 	case 3:	/* Don't attempt to complete name of interface (infinite possibilities) */
 		return NULL;
@@ -5282,6 +6313,8 @@
 		return state == 0 ? ast_strdup("state_interface") : NULL;
 	case 12:
 		return state == 0 ? ast_strdup("incominglimit") : NULL;
+	case 14:
+		return state == 0 ? ast_strdup("skills") : NULL;
 	default:
 		return NULL;
 	}
@@ -5367,7 +6400,7 @@
 "       Provides summary information on a specified queue.\n";
 
 static char qam_cmd_usage[] =
-"Usage: queue add member <channel> to <queue> [penalty <penalty> [as <membername> [state_interface <state_interface> [incominglimit <incominglimit>]]]]\n";
+"Usage: queue add member <channel> to <queue> [penalty <penalty> [as <membername> [state_interface <state_interface> [incominglimit <incominglimit> [skills <skills>]]]]]\n";
 
 static char qrm_cmd_usage[] =
 "Usage: queue remove member <channel> from <queue>\n";
@@ -5447,7 +6480,7 @@
 {
 	int res;
 
-	if (!reload_queues())
+	if (!reload_all())
 		return AST_MODULE_LOAD_DECLINE;
 
 	if (queue_persistent_members)
@@ -5480,7 +6513,7 @@
 
 static int reload(void)
 {
-	reload_queues();
+	reload_all();
 	return 0;
 }
 
Index: asterisk-1.4.29/configs/queueskillrules.conf.sample
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ asterisk-1.4.29/configs/queueskillrules.conf.sample	2010-01-21 11:04:19.000000000 +0100
@@ -0,0 +1,38 @@
+; This file describes skill routing rules. The Queue() application can get the
+; 'skill_ruleset' argument which is the name of one skill routing ruleset. If
+; set, a selection of queue members is defined by running these rules on each
+; member, based on skills set (see the queueskills.conf file).
+;
+; You can define these rules with some arithmetic and logical operators:
+;      operand1 / operand2  (division)
+;      operand1 * operand2  (multiplication)
+;      operand1 - operand2  (subtraction)
+;      operand1 + operand2  (addition)
+;      operand1 ! operand2  (is not equal)
+;      operand1 = operand2  (is equal)
+;      operand1 > operand2  (is greater than)
+;      operand1 < operand2  (is lesser than)
+;      operand1 & operand2  (both are true)
+;      operand1 | operand2  (at least one of them are true)
+;
+; '/' is the operator with the higher priority, and '|' the one with the lower
+; priority. You can use brackets '()' to overload operator priorities.
+;
+; Variables are skills names, which you can check with below operators. You can
+; also use meta-variables, started with a '$', to substitute them with data set
+; on the Queue() call. For example, if you call Queue() with the skill rouleset
+; argument equal to:
+;      tech(os=linux)
+; every $os occurrence will be replaced to 'linux'.
+;
+; Examples:
+;
+; [tech]
+; rule => technic & ($os > 29 & $lang > 39 | $os > 39 & $lang > 19)
+;
+; [client-crappy]
+; rule => technic = 0 & (sympathy > 20 | linux > 10 & windows > 10)
+;
+; [client-cool]
+; rule => technic = 0
+
Index: asterisk-1.4.29/configs/queueskills.conf.sample
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ asterisk-1.4.29/configs/queueskills.conf.sample	2010-01-21 11:04:19.000000000 +0100
@@ -0,0 +1,47 @@
+; Describe skills groups here to assign them to queue members. You can set
+; weight to each skills. It'll be used by skill rules to know if a queue member
+; can answer to a call.
+; See the queueskillrules.conf to get more information about these rules.
+;
+; Examples:
+;
+; [linux1]
+; technic = 1
+; linux = 50
+; windows = 10
+; french = 50
+; english = 10
+;
+; [linux2]
+; technic = 1
+; linux = 30
+; windows = 20
+; french = 50
+; english = 50
+;
+; [windows1]
+; technic = 1
+; linux = 10
+; windows = 50
+; french = 30
+; english = 30
+;
+; [windows2]
+; technic = 1
+; linux = 20
+; windows = 30
+; french = 40
+; english = 10
+;
+; [commercial1]
+; technic = 0
+; linux = 10
+; windows = 20
+; sympathy = 100
+;
+; [commercial2]
+; technic = 0
+; linux = 0
+; windows = 20
+; sympathy = 50
+
