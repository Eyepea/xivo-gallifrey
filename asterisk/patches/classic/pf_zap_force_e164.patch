2007-11-02  Guillaume Knispel <gknispel@proformatique.com>

	pf_zap_force_e164.patch
	$Revision$
	$Date$
	New Feature

	Add a new zapata.conf "force_e164" option.
	The behavior of Asterisk is unchanged if this option is set to off
	(default)
	When this option is set to "on" for a given trunk, Asterisk will behave
	as if every incoming call was initiated with the NPI field of the SETUP
	message set to E.164. This is needed for interworking with some carrier
	ISDN switches that set NPI to "unknown" instead of the awaiting E.164
	for international calls, effectively preventing an Asterisk installation
	without this patch to properly prepend the "international prefix" before
	the caller id number.

	Patch status: known as OK, tested on 2007-10-31

Index: asterisk-classic/channels/chan_zap.c
===================================================================
--- asterisk-classic.orig/channels/chan_zap.c	2007-11-01 03:05:09.000000000 +0100
+++ asterisk-classic/channels/chan_zap.c	2007-11-01 03:09:30.000000000 +0100
@@ -314,6 +314,7 @@
 	char localprefix[20];						/*!< area access code + area code ('0'+area code for european dialplans) */
 	char privateprefix[20];						/*!< for private dialplans */
 	char unknownprefix[20];						/*!< for unknown dialplans */
+	int force_e164;							/*!< make as if every incoming calls had NPI set to E.164 */
 	int dchannels[NUM_DCHANS];					/*!< What channel are the dchannels on */
 	int trunkgroup;							/*!< What our trunkgroup is */
 	int mastertrunkgroup;						/*!< What trunk group is our master */
@@ -430,6 +431,7 @@
 	char privateprefix[20];
 	char unknownprefix[20];
 	long resetinterval;
+	int force_e164;
 #endif
 };
 
@@ -555,7 +557,8 @@
 			.privateprefix = "",
 			.unknownprefix = "",
 			/*!< How often (in seconds) to reset unused channels. Default 1 hour. */
-			.resetinterval = 3600,	
+			.resetinterval = 3600,
+			.force_e164 = 0,
 #endif
 		},
 		.context = "default",
@@ -7304,6 +7307,7 @@
 						ast_copy_string(pris[span].localprefix, chan_conf.pri.localprefix, sizeof(pris[span].localprefix));
 						ast_copy_string(pris[span].privateprefix, chan_conf.pri.privateprefix, sizeof(pris[span].privateprefix));
 						ast_copy_string(pris[span].unknownprefix, chan_conf.pri.unknownprefix, sizeof(pris[span].unknownprefix));
+						pris[span].force_e164 = chan_conf.pri.force_e164;
 						pris[span].resetinterval = chan_conf.pri.resetinterval;
 						
 						tmp->pri = &pris[span];
@@ -8282,8 +8286,13 @@
 	}
 }
 
-static void apply_plan_to_number(char *buf, size_t size, const struct zt_pri *pri, const char *number, const int plan)
+static void apply_plan_to_number(char *buf, size_t size, const struct zt_pri *pri, const char *number, int plan)
 {
+	if (pri->force_e164) {
+		plan &= 0xf0;
+		plan |= 0x01;
+	}
+
 	switch (plan) {
 	case PRI_INTERNATIONAL_ISDN:		/* Q.931 dialplan == 0x11 international dialplan => prepend international prefix digits */
 		snprintf(buf, size, "%s%s", pri->internationalprefix, number);
@@ -11062,6 +11071,8 @@
 				ast_copy_string(chan_conf.pri.privateprefix, v->value, sizeof(chan_conf.pri.privateprefix));
 			} else if (!strcasecmp(v->name, "unknownprefix")) {
 				ast_copy_string(chan_conf.pri.unknownprefix, v->value, sizeof(chan_conf.pri.unknownprefix));
+			} else if (!strcasecmp(v->name, "force_e164")) {
+				chan_conf.pri.force_e164 = ast_true(v->value);
 			} else if (!strcasecmp(v->name, "resetinterval")) {
 				if (!strcasecmp(v->value, "never"))
 					chan_conf.pri.resetinterval = -1;
