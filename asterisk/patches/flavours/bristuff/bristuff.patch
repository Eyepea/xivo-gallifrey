#! /bin/sh /usr/share/dpatch/dpatch-run
## bristuff.dpatch by Tzafrir Cohen <tzafrir.cohen@xorcom.com>
## Updated by Marc Dequ√®nes (Duck) <mdequenes@proformatique.com>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: bristuff support in asterisk: asterisk.patch from bristuff-0.3.0-PRE-1y-e
## DP: cygdef.h removed ;-)
## DP: Update by Guillaume Knispel <gknispel@proformatique.com> on 2007-10-19
## DP:   removal of some BRI unrelated mess

@DPATCH@
Index: asterisk-bristuff/apps/app_chanisavail.c
===================================================================
--- asterisk-bristuff.orig/apps/app_chanisavail.c	2005-11-29 19:24:39.000000000 +0100
+++ asterisk-bristuff/apps/app_chanisavail.c	2007-10-20 00:35:48.000000000 +0200
@@ -118,7 +118,7 @@
 				snprintf(trychan, sizeof(trychan), "%s/%s",cur,number);
 				status = inuse = ast_device_state(trychan);
 			}
-			if ((inuse <= 1) && (tempchan = ast_request(tech, chan->nativeformats, number, &status))) {
+			if ((inuse <= 1) && (tempchan = ast_request(tech, chan->nativeformats, number, &status, NULL))) {
 					pbx_builtin_setvar_helper(chan, "AVAILCHAN", tempchan->name);
 					/* Store the originally used channel too */
 					snprintf(tmp, sizeof(tmp), "%s/%s", tech, number);
Index: asterisk-bristuff/apps/app_chanspy.c
===================================================================
--- asterisk-bristuff.orig/apps/app_chanspy.c	2007-07-13 22:10:39.000000000 +0200
+++ asterisk-bristuff/apps/app_chanspy.c	2007-10-20 00:35:48.000000000 +0200
@@ -55,6 +55,7 @@
 
 static const char *synopsis = "Listen to the audio of an active channel";
 static const char *app = "ChanSpy";
+static const char *app2 = "ChanSpyChan";
 static const char *desc = 
 "  ChanSpy([chanprefix][|options]): This application is used to listen to the\n"
 "audio from an active Asterisk channel. This includes the audio coming in and\n"
@@ -142,6 +143,19 @@
 	return ret;
 }
 
+static struct ast_channel *local_get_channel_uniqueid(char *uniqueid) 
+{
+	struct ast_channel *chan = NULL;
+	if (uniqueid) {
+	    ast_mutex_lock(&modlock);
+	    if ((chan = ast_get_channel_by_uniqueid_locked(uniqueid))) {
+		ast_mutex_unlock(&chan->lock);
+	    }
+	    ast_mutex_unlock(&modlock);
+	}	
+	return chan;
+}
+
 static void *spy_alloc(struct ast_channel *chan, void *data)
 {
 	/* just store the data pointer in the channel structure */
@@ -551,11 +565,87 @@
 	ALL_DONE(u, res);
 }
 
+static int chanspychan_exec(struct ast_channel *chan, void *data)
+{
+	struct localuser *u;
+	struct ast_channel *peer=NULL;
+	char	*args,
+		*uniqueid = NULL,
+		*argv[5];
+	int res = -1,
+		volfactor = 0,
+		argc = 0,
+		oldrf = 0,
+		oldwf = 0,
+		fd = 0;
+	signed char zero_volume = 0;
+
+	if (!(args = ast_strdupa((char *)data))) {
+		ast_log(LOG_ERROR, "Out of memory!\n");
+		return -1;
+	}
+
+	LOCAL_USER_ADD(u);
+
+	oldrf = chan->readformat;
+	oldwf = chan->writeformat;
+	if (ast_set_read_format(chan, AST_FORMAT_SLINEAR) < 0) {
+		ast_log(LOG_ERROR, "Could Not Set Read Format.\n");
+		LOCAL_USER_REMOVE(u);
+		return -1;
+	}
+	
+	if (ast_set_write_format(chan, AST_FORMAT_SLINEAR) < 0) {
+		ast_log(LOG_ERROR, "Could Not Set Write Format.\n");
+		LOCAL_USER_REMOVE(u);
+		return -1;
+	}
+
+
+	if ((argc = ast_app_separate_args(args, '|', argv, sizeof(argv) / sizeof(argv[0])))) {
+		uniqueid = argv[0];
+		if (ast_strlen_zero(uniqueid)) {
+		    LOCAL_USER_REMOVE(u);
+		    return -1;
+		}
+	}
+	
+	ast_answer(chan);
+
+	ast_set_flag(chan, AST_FLAG_SPYING); /* so nobody can spy on us while we are spying */
+
+	peer = local_get_channel_uniqueid(uniqueid);
+	if (peer && (peer != chan) && !ast_check_hangup(peer) && !ast_test_flag(peer, AST_FLAG_SPYING)) {
+	    res = channel_spy(chan, peer, &volfactor, fd);
+	} else {
+	    ast_log(LOG_NOTICE, "no channel found with uniqueid %s\n", uniqueid);
+	}
+
+	if (fd > 0) {
+		close(fd);
+	}
+
+	if (oldrf && ast_set_read_format(chan, oldrf) < 0) {
+		ast_log(LOG_ERROR, "Could Not Set Read Format.\n");
+	}
+	
+	if (oldwf && ast_set_write_format(chan, oldwf) < 0) {
+		ast_log(LOG_ERROR, "Could Not Set Write Format.\n");
+	}
+
+	ast_clear_flag(chan, AST_FLAG_SPYING);
+
+	ast_channel_setoption(chan, AST_OPTION_TXGAIN, &zero_volume, sizeof(zero_volume), 0);
+
+	ALL_DONE(u, res);
+}
+
 int unload_module(void)
 {
 	int res;
 
-	res = ast_unregister_application(app);
+	ast_unregister_application(app);
+	res = ast_unregister_application(app2);
 
 	STANDARD_HANGUP_LOCALUSERS;
 
@@ -564,7 +654,8 @@
 
 int load_module(void)
 {
-	return ast_register_application(app, chanspy_exec, synopsis, desc);
+	ast_register_application(app, chanspy_exec, synopsis, desc);
+	return ast_register_application(app2, chanspychan_exec, synopsis, desc);
 }
 
 char *description(void)
Index: asterisk-bristuff/apps/app_devstate.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ asterisk-bristuff/apps/app_devstate.c	2007-10-20 00:35:48.000000000 +0200
@@ -0,0 +1,225 @@
+/*
+ * Devstate application
+ * 
+ * Since we like the snom leds so much, a little app to
+ * light the lights on the snom on demand ....
+ *
+ * Copyright (C) 2005, Druid Software
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdio.h>
+#include <asterisk/lock.h>
+#include <asterisk/file.h>
+#include <asterisk/logger.h>
+#include <asterisk/channel.h>
+#include <asterisk/pbx.h>
+#include <asterisk/module.h>
+#include <asterisk/astdb.h>
+#include <asterisk/utils.h>
+#include <asterisk/cli.h>
+#include <asterisk/manager.h>
+#include <asterisk/devicestate.h>
+
+
+static char type[] = "DS";
+static char tdesc[] = "Application for sending device state messages";
+
+static char app[] = "Devstate";
+
+static char synopsis[] = "Generate a device state change event given the input parameters";
+
+static char descrip[] = " Devstate(device|state):  Generate a device state change event given the input parameters. Returns 0. State values match the asterisk device states. They are 0 = unknown, 1 = not inuse, 2 = inuse, 3 = busy, 4 = invalid, 5 = unavailable, 6 = ringing\n";
+
+static char devstate_cli_usage[] = 
+"Usage: devstate device state\n" 
+"       Generate a device state change event given the input parameters.\n Mainly used for lighting the LEDs on the snoms.\n";
+
+static int devstate_cli(int fd, int argc, char *argv[]);
+static struct ast_cli_entry  cli_dev_state =
+        { { "devstate", NULL }, devstate_cli, "Set the device state on one of the \"pseudo devices\".", devstate_cli_usage };
+
+STANDARD_LOCAL_USER;
+
+LOCAL_USER_DECL;
+
+
+static int devstate_cli(int fd, int argc, char *argv[])
+{
+    char devName[128];
+    if ((argc != 3) && (argc != 4) && (argc != 5))
+        return RESULT_SHOWUSAGE;
+
+    if (ast_db_put("DEVSTATES", argv[1], argv[2]))
+    {
+        ast_log(LOG_DEBUG, "ast_db_put failed\n");
+    }
+    snprintf(devName, sizeof(devName), "DS/%s", argv[1]);
+    if (argc == 4) {
+        ast_log(LOG_NOTICE, "devname %s cid %s\n", devName, argv[3]);
+	ast_device_state_changed_literal(devName, argv[3], NULL);
+    } else if (argc == 5) {
+        ast_log(LOG_NOTICE, "devname %s cid %s cidname %s\n", devName, argv[3], argv[4]);
+	ast_device_state_changed_literal(devName, argv[3], argv[4]);
+    } else {
+	ast_device_state_changed_literal(devName, NULL, NULL);
+    }
+    return RESULT_SUCCESS;
+}
+
+static int devstate_exec(struct ast_channel *chan, void *data)
+{
+    struct localuser *u;
+    char *device, *state, *info;
+    char devName[128];
+    if (!(info = ast_strdupa(data))) {
+            ast_log(LOG_WARNING, "Unable to dupe data :(\n");
+            return -1;
+    }
+    LOCAL_USER_ADD(u);
+    
+    device = info;
+    state = strchr(info, '|');
+    if (state) {
+        *state = '\0';
+        state++;
+    }
+    else
+    {
+        ast_log(LOG_DEBUG, "No state argument supplied\n");
+        return -1;
+    }
+
+    if (ast_db_put("DEVSTATES", device, state))
+    {
+        ast_log(LOG_DEBUG, "ast_db_put failed\n");
+    }
+
+    snprintf(devName, sizeof(devName), "DS/%s", device);
+    ast_device_state_changed_literal(devName, NULL, NULL);
+
+    LOCAL_USER_REMOVE(u);
+    return 0;
+}
+
+
+static int ds_devicestate(void *data)
+{
+    char *dest = data;
+    char stateStr[16];
+    if (ast_db_get("DEVSTATES", dest, stateStr, sizeof(stateStr)))
+    {
+        ast_log(LOG_DEBUG, "ds_devicestate couldnt get state in astdb\n");
+        return 0;
+    }
+    else
+    {
+        ast_log(LOG_DEBUG, "ds_devicestate dev=%s returning state %d\n",
+               dest, atoi(stateStr));
+        return (atoi(stateStr));
+    }
+}
+
+static struct ast_channel_tech devstate_tech = {
+	.type = type,
+	.description = tdesc,
+	.capabilities = ((AST_FORMAT_MAX_AUDIO << 1) - 1),
+	.devicestate = ds_devicestate,
+	.requester = NULL,
+	.send_digit = NULL,
+	.send_text = NULL,
+	.call = NULL,
+	.hangup = NULL,
+	.answer = NULL,
+	.read = NULL,
+	.write = NULL,
+	.bridge = NULL,
+	.exception = NULL,
+	.indicate = NULL,
+	.fixup = NULL,
+	.setoption = NULL,
+};
+
+static char mandescr_devstate[] = 
+"Description: Put a value into astdb\n"
+"Variables: \n"
+"	Family: ...\n"
+"	Key: ...\n"
+"	Value: ...\n";
+
+static int action_devstate(struct mansession *s, struct message *m)
+{
+        char *devstate = astman_get_header(m, "Devstate");
+        char *value = astman_get_header(m, "Value");
+	char *id = astman_get_header(m,"ActionID");
+        char *cid_num = astman_get_header(m, "CallerID");
+        char *cid_name = astman_get_header(m, "CallerIDName");
+	char devName[128];
+
+	if (!strlen(devstate)) {
+		astman_send_error(s, m, "No Devstate specified");
+		return 0;
+	}
+	if (!strlen(value)) {
+		astman_send_error(s, m, "No Value specified");
+		return 0;
+	}
+
+        if (!ast_db_put("DEVSTATES", devstate, value)) {
+	    snprintf(devName, sizeof(devName), "DS/%s", devstate);
+//	    ast_device_state_changed(devName);
+	    ast_device_state_changed_literal(devName, cid_num, cid_name);
+	    ast_cli(s->fd, "Response: Success\r\n");
+	} else {
+	    ast_log(LOG_DEBUG, "ast_db_put failed\n");
+	    ast_cli(s->fd, "Response: Failed\r\n");
+	}
+	if (id && !ast_strlen_zero(id))
+		ast_cli(s->fd, "ActionID: %s\r\n",id);
+	ast_cli(s->fd, "\r\n");
+	return 0;
+}
+
+int load_module(void)
+{
+    if (ast_channel_register(&devstate_tech)) {
+        ast_log(LOG_DEBUG, "Unable to register channel class %s\n", type);
+        return -1;
+    }
+    ast_cli_register(&cli_dev_state);  
+    ast_manager_register2( "Devstate", EVENT_FLAG_CALL, action_devstate, "Change a device state", mandescr_devstate );
+    return ast_register_application(app, devstate_exec, synopsis, descrip);
+}
+
+int unload_module(void)
+{
+    int res = 0;
+    STANDARD_HANGUP_LOCALUSERS;
+    ast_manager_unregister( "Devstate");
+    ast_cli_unregister(&cli_dev_state);
+    res = ast_unregister_application(app);
+    ast_channel_unregister(&devstate_tech);    
+    return res;
+}
+
+char *description(void)
+{
+    return tdesc;
+}
+
+int usecount(void)
+{
+    int res;
+    STANDARD_USECOUNT(res);
+    return res;
+}
+
+char *key()
+{
+    return ASTERISK_GPL_KEY;
+}
Index: asterisk-bristuff/apps/app_dial.c
===================================================================
--- asterisk-bristuff.orig/apps/app_dial.c	2007-10-20 00:35:42.000000000 +0200
+++ asterisk-bristuff/apps/app_dial.c	2007-10-20 00:35:48.000000000 +0200
@@ -11,6 +11,10 @@
  * the project provides a web site, mailing lists and IRC
  * channels for your use.
  *
+ * Copyright (C) 2004, Junghanns.NET GmbH
+ *
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
  * This program is free software, distributed under the terms of
  * the GNU General Public License Version 2. See the LICENSE file
  * at the top of the source tree.
@@ -56,6 +60,7 @@
 #include "asterisk/causes.h"
 #include "asterisk/manager.h"
 #include "asterisk/privacy.h"
+#include "asterisk/transcap.h"
 
 static char *tdesc = "Dialing Application";
 
@@ -119,7 +124,8 @@
 "           action post answer options in conjunction with this option.\n" 
 "    h    - Allow the called party to hang up by sending the '*' DTMF digit.\n"
 "    H    - Allow the calling party to hang up by hitting the '*' DTMF digit.\n"
-"    j    - Jump to priority n+101 if all of the requested channels were busy.\n"
+"    j    - Jump to priority n+101 if the called party was busy.\n"
+"           Jump to priority n+201 if all of the requested channels were busy.\n"
 "    L(x[:y][:z]) - Limit the call to 'x' ms. Play a warning when 'y' ms are\n"
 "           left. Repeat the warning every 'z' ms. The following special\n"
 "           variables can be used with this option:\n"
@@ -166,8 +172,11 @@
 "           family/key is not specified.\n"
 "    r    - Indicate ringing to the calling party. Pass no audio to the calling\n"
 "           party until the called channel has answered.\n"
+"    R	  - indicate ringing to the calling party when the called party indicates\n"
+"            ringing, pass no audio until answered.\n"
 "    S(x) - Hang up the call after 'x' seconds *after* the called party has\n"
-"           answered the call.\n"  	
+"           answered the call.\n"
+"    c    - callback initiation, ring once and hangup.\n"
 "    t    - Allow the called party to transfer the calling party by sending the\n"
 "           DTMF sequence defined in features.conf.\n"
 "    T    - Allow the calling party to transfer the called party by sending the\n"
@@ -218,6 +227,8 @@
 	OPT_CALLEE_MONITOR = (1 << 21),
 	OPT_CALLER_MONITOR = (1 << 22),
 	OPT_GOTO = (1 << 23),
+	OPT_NOINBAND = (1 << 24),
+	OPT_CALLBACK_INIT = (1 << 25),
 } dial_exec_option_flags;
 
 #define DIAL_STILLGOING			(1 << 30)
@@ -256,6 +267,8 @@
 	AST_APP_OPTION('p', OPT_SCREENING),
 	AST_APP_OPTION_ARG('P', OPT_PRIVACY, OPT_ARG_PRIVACY),
 	AST_APP_OPTION('r', OPT_RINGBACK),
+	AST_APP_OPTION('R', OPT_NOINBAND),
+	AST_APP_OPTION('c', OPT_CALLBACK_INIT),
 	AST_APP_OPTION_ARG('S', OPT_DURATION_STOP, OPT_ARG_DURATION_STOP),
 	AST_APP_OPTION('t', OPT_CALLEE_TRANSFER),
 	AST_APP_OPTION('T', OPT_CALLER_TRANSFER),
@@ -393,7 +406,7 @@
 	char *context = NULL;
 	char cidname[AST_MAX_EXTENSION];
 
-	single = (outgoing && !outgoing->next && !ast_test_flag(outgoing, OPT_MUSICBACK | OPT_RINGBACK));
+	single = (outgoing && !outgoing->next && !ast_test_flag(outgoing, OPT_MUSICBACK | OPT_RINGBACK | OPT_NOINBAND));
 	
 	if (single) {
 		/* Turn off hold music, etc */
@@ -472,7 +485,7 @@
 						if (option_verbose > 2)
 							ast_verbose(VERBOSE_PREFIX_3 "Now forwarding %s to '%s/%s' (thanks to %s)\n", in->name, tech, stuff, o->chan->name);
 						/* Setup parameters */
-						o->chan = ast_request(tech, in->nativeformats, stuff, &cause);
+						o->chan = ast_request(tech, in->nativeformats, stuff, &cause, NULL);
 						if (o->chan) {
 							if (single)
 								ast_channel_make_compatible(o->chan, in);
@@ -592,17 +605,23 @@
 							HANDLE_CAUSE(AST_CAUSE_CONGESTION, in);
 							break;
 						case AST_CONTROL_RINGING:
-							if (option_verbose > 2)
-								ast_verbose( VERBOSE_PREFIX_3 "%s is ringing\n", o->chan->name);
-							if (!(*sentringing) && !ast_test_flag(outgoing, OPT_MUSICBACK)) {
-								ast_indicate(in, AST_CONTROL_RINGING);
-								(*sentringing)++;
-							}
+                                                        if (ast_test_flag(peerflags, OPT_CALLBACK_INIT)) {
+                                                            if (option_verbose > 2)
+                                                                ast_verbose( VERBOSE_PREFIX_3 "%s is ringing, hanging up.\n", o->chan->name);
+                                                            return NULL;
+                                                        } else {
+                                                            if (option_verbose > 2)
+                                                                ast_verbose( VERBOSE_PREFIX_3 "%s is ringing\n", o->chan->name);
+                                                            if (!(*sentringing) && !ast_test_flag(outgoing, OPT_MUSICBACK)) {
+                                                                ast_indicate(in, AST_CONTROL_RINGING);
+                                                                (*sentringing)++;
+                                                            }
+                                                        }
 							break;
 						case AST_CONTROL_PROGRESS:
 							if (option_verbose > 2)
 								ast_verbose ( VERBOSE_PREFIX_3 "%s is making progress passing it to %s\n", o->chan->name,in->name);
-							if (!ast_test_flag(outgoing, OPT_RINGBACK))
+							if (!ast_test_flag(outgoing, OPT_RINGBACK | OPT_NOINBAND))
 								ast_indicate(in, AST_CONTROL_PROGRESS);
 							break;
 						case AST_CONTROL_VIDUPDATE:
@@ -613,7 +632,7 @@
 						case AST_CONTROL_PROCEEDING:
 							if (option_verbose > 2)
 								ast_verbose ( VERBOSE_PREFIX_3 "%s is proceeding passing it to %s\n", o->chan->name,in->name);
-							if (!ast_test_flag(outgoing, OPT_RINGBACK))
+							if (!ast_test_flag(outgoing, OPT_RINGBACK | OPT_NOINBAND))
 								ast_indicate(in, AST_CONTROL_PROCEEDING);
 							break;
 						case AST_CONTROL_HOLD:
@@ -631,7 +650,7 @@
 							/* Ignore going off hook and flash */
 							break;
 						case -1:
-							if (!ast_test_flag(outgoing, OPT_RINGBACK | OPT_MUSICBACK)) {
+							if (!ast_test_flag(outgoing, OPT_RINGBACK | OPT_MUSICBACK | OPT_NOINBAND)) {
 								if (option_verbose > 2)
 									ast_verbose( VERBOSE_PREFIX_3 "%s stopped sounds\n", o->chan->name);
 								ast_indicate(in, -1);
@@ -779,6 +798,7 @@
 	int digit = 0, result = 0;
 	time_t start_time, answer_time, end_time;
 	struct ast_app *app = NULL;
+/* 	char *aoceunits; */
 
 	char *parse;
 	AST_DECLARE_APP_ARGS(args,
@@ -951,13 +971,13 @@
 		}
 		
 		if( privdb_val == AST_PRIVACY_DENY ) {
-			strcpy(status, "NOANSWER");
+			ast_copy_string(status, "NOANSWER", sizeof(status));
 			ast_verbose( VERBOSE_PREFIX_3  "Privacy DB reports PRIVACY_DENY for this callerid. Dial reports unavailable\n");
 			res=0;
 			goto out;
 		}
 		else if( privdb_val == AST_PRIVACY_KILL ) {
-			strcpy(status, "DONTCALL");
+			ast_copy_string(status, "DONTCALL", sizeof(status));
 			if (option_priority_jumping || ast_test_flag(&opts, OPT_PRIORITY_JUMP)) {
 				ast_goto_if_exists(chan, chan->context, chan->exten, chan->priority + 201);
 			}
@@ -965,7 +985,7 @@
 			goto out; /* Is this right? */
 		}
 		else if( privdb_val == AST_PRIVACY_TORTURE ) {
-			strcpy(status, "TORTURE");
+			ast_copy_string(status, "TORTURE", sizeof(status));
 			if (option_priority_jumping || ast_test_flag(&opts, OPT_PRIORITY_JUMP)) {
 				ast_goto_if_exists(chan, chan->context, chan->exten, chan->priority + 301);
 			}
@@ -1029,7 +1049,7 @@
 		outbound_group = pbx_builtin_getvar_helper(chan, "OUTBOUND_GROUP");
 	}
 	    
-	ast_copy_flags(peerflags, &opts, OPT_DTMF_EXIT | OPT_GO_ON | OPT_ORIGINAL_CLID | OPT_CALLER_HANGUP);
+	ast_copy_flags(peerflags, &opts, OPT_DTMF_EXIT | OPT_GO_ON | OPT_ORIGINAL_CLID | OPT_CALLER_HANGUP | OPT_CALLBACK_INIT | OPT_NOINBAND);
 	cur = args.peers;
 	do {
 		/* Remember where to start next time */
@@ -1058,7 +1078,7 @@
 				       OPT_CALLEE_TRANSFER | OPT_CALLER_TRANSFER |
 				       OPT_CALLEE_HANGUP | OPT_CALLER_HANGUP |
 				       OPT_CALLEE_MONITOR | OPT_CALLER_MONITOR |
-				       OPT_RINGBACK | OPT_MUSICBACK | OPT_FORCECLID);
+				       OPT_RINGBACK | OPT_MUSICBACK | OPT_FORCECLID | OPT_NOINBAND);
 			ast_set2_flag(tmp, args.url, DIAL_NOFORWARDHTML);	
 		}
 		ast_copy_string(numsubst, number, sizeof(numsubst));
@@ -1071,7 +1091,7 @@
 				ast_log(LOG_DEBUG, "Dialing by extension %s\n", numsubst);
 		}
 		/* Request the peer */
-		tmp->chan = ast_request(tech, chan->nativeformats, numsubst, &cause);
+		tmp->chan = ast_request(tech, chan->nativeformats, numsubst, &cause, NULL);
 		if (!tmp->chan) {
 			/* If we can't, just go on to the next call */
 			ast_log(LOG_NOTICE, "Unable to create channel of type '%s' (cause %d - %s)\n", tech, cause, ast_cause2str(cause));
@@ -1103,7 +1123,7 @@
 					ast_verbose(VERBOSE_PREFIX_3 "Now forwarding %s to '%s/%s' (thanks to %s)\n", chan->name, tech, stuff, tmp->chan->name);
 				ast_hangup(tmp->chan);
 				/* Setup parameters */
-				tmp->chan = ast_request(tech, chan->nativeformats, stuff, &cause);
+				tmp->chan = ast_request(tech, chan->nativeformats, stuff, &cause, NULL);
 				if (!tmp->chan)
 					ast_log(LOG_NOTICE, "Unable to create local channel for call forward to '%s/%s' (cause = %d)\n", tech, stuff, cause);
 				else
@@ -1218,7 +1238,7 @@
 
 	if (outgoing) {
 		/* Our status will at least be NOANSWER */
-		strcpy(status, "NOANSWER");
+		ast_copy_string(status, "NOANSWER", sizeof(status));
 		if (ast_test_flag(outgoing, OPT_MUSICBACK)) {
 			moh=1;
 			ast_indicate(chan, AST_CONTROL_PROGRESS);
@@ -1227,8 +1247,11 @@
 			ast_indicate(chan, AST_CONTROL_RINGING);
 			sentringing++;
 		}
-	} else
-		strcpy(status, "CHANUNAVAIL");
+	} else {
+		ast_copy_string(status, "CHANUNAVAIL", sizeof(status));
+		/* See if there is a special message */
+		ast_goto_if_exists(chan, chan->context, chan->exten, chan->priority + 201);
+	}
 
 	time(&start_time);
 	peer = wait_for_answer(chan, outgoing, &to, peerflags, &sentringing, status, sizeof(status), numbusy, numnochan, numcongestion, ast_test_flag(&opts, OPT_PRIORITY_JUMP), &result);
@@ -1360,7 +1383,7 @@
 					strcpy(status,"NOANSWER");
 					if (ast_test_flag(&opts, OPT_MUSICBACK)) {
 						ast_moh_stop(chan);
-					} else if (ast_test_flag(&opts, OPT_RINGBACK)) {
+					} else if (ast_test_flag(&opts, OPT_RINGBACK | OPT_NOINBAND)) {
 						ast_indicate(chan, -1);
 						sentringing=0;
 					}
@@ -1380,7 +1403,7 @@
 					res = 0;
 					if (ast_test_flag(&opts, OPT_MUSICBACK)) {
 						ast_moh_stop(chan);
-					} else if (ast_test_flag(&opts, OPT_RINGBACK)) {
+					} else if (ast_test_flag(&opts, OPT_RINGBACK | OPT_NOINBAND)) {
 						ast_indicate(chan, -1);
 						sentringing=0;
 					}
@@ -1399,7 +1422,7 @@
 					res = 0;
 					if (ast_test_flag(&opts, OPT_MUSICBACK)) {
 						ast_moh_stop(chan);
-					} else if (ast_test_flag(&opts, OPT_RINGBACK)) {
+					} else if (ast_test_flag(&opts, OPT_RINGBACK | OPT_NOINBAND)) {
 						ast_indicate(chan, -1);
 						sentringing=0;
 					}
@@ -1414,7 +1437,7 @@
 						ast_privacy_set(opt_args[OPT_ARG_PRIVACY], privcid, AST_PRIVACY_ALLOW);
 						if (ast_test_flag(&opts, OPT_MUSICBACK)) {
 							ast_moh_stop(chan);
-						} else if (ast_test_flag(&opts, OPT_RINGBACK)) {
+						} else if (ast_test_flag(&opts, OPT_RINGBACK | OPT_NOINBAND)) {
 							ast_indicate(chan, -1);
 							sentringing=0;
 						}
@@ -1432,7 +1455,7 @@
 						ast_log(LOG_NOTICE,"privacy: no valid response from the callee. Sending the caller to voicemail, the callee isn't responding\n");
 					if (ast_test_flag(&opts, OPT_MUSICBACK)) {
 						ast_moh_stop(chan);
-					} else if (ast_test_flag(&opts, OPT_RINGBACK)) {
+					} else if (ast_test_flag(&opts, OPT_RINGBACK | OPT_NOINBAND)) {
 						ast_indicate(chan, -1);
 						sentringing=0;
 					}
@@ -1443,7 +1466,7 @@
 				}
 				if (ast_test_flag(&opts, OPT_MUSICBACK)) {
 					ast_moh_stop(chan);
-				} else if (ast_test_flag(&opts, OPT_RINGBACK)) {
+				} else if (ast_test_flag(&opts, OPT_RINGBACK | OPT_NOINBAND)) {
 					ast_indicate(chan, -1);
 					sentringing=0;
 				}
@@ -1595,18 +1618,22 @@
 				ast_set_flag(&(config.features_caller), AST_FEATURE_PLAY_WARNING);
 			if (play_to_callee)
 				ast_set_flag(&(config.features_callee), AST_FEATURE_PLAY_WARNING);
-			if (ast_test_flag(peerflags, OPT_CALLEE_TRANSFER))
+
+			if ((chan->transfercapability != AST_TRANS_CAP_DIGITAL) && (chan->transfercapability != AST_TRANS_CAP_RESTRICTED_DIGITAL)) {
+			    /* only non-digital calls are allowed to go through userspace */
+			    if (ast_test_flag(peerflags, OPT_CALLEE_TRANSFER))
 				ast_set_flag(&(config.features_callee), AST_FEATURE_REDIRECT);
-			if (ast_test_flag(peerflags, OPT_CALLER_TRANSFER))
+			    if (ast_test_flag(peerflags, OPT_CALLER_TRANSFER))
 				ast_set_flag(&(config.features_caller), AST_FEATURE_REDIRECT);
-			if (ast_test_flag(peerflags, OPT_CALLEE_HANGUP))
+			    if (ast_test_flag(peerflags, OPT_CALLEE_HANGUP))
 				ast_set_flag(&(config.features_callee), AST_FEATURE_DISCONNECT);
-			if (ast_test_flag(peerflags, OPT_CALLER_HANGUP))
+			    if (ast_test_flag(peerflags, OPT_CALLER_HANGUP))
 				ast_set_flag(&(config.features_caller), AST_FEATURE_DISCONNECT);
-			if (ast_test_flag(peerflags, OPT_CALLEE_MONITOR))
+			    if (ast_test_flag(peerflags, OPT_CALLEE_MONITOR))
 				ast_set_flag(&(config.features_callee), AST_FEATURE_AUTOMON);
-			if (ast_test_flag(peerflags, OPT_CALLER_MONITOR)) 
+			    if (ast_test_flag(peerflags, OPT_CALLER_MONITOR)) 
 				ast_set_flag(&(config.features_caller), AST_FEATURE_AUTOMON);
+			}
 
 			config.timelimit = timelimit;
 			config.play_warning = play_warning;
@@ -1642,7 +1669,15 @@
 		}
 		snprintf(toast, sizeof(toast), "%ld", (long)(end_time - start_time));
 		pbx_builtin_setvar_helper(chan, "DIALEDTIME", toast);
-		
+
+		/* forward AOC-E units from peer, if possible */
+/*		aoceunits = pbx_builtin_getvar_helper(peer, "AOCEUNITS");
+
+		if (aoceunits) {
+		    snprintf(toast, sizeof(toast), "%d", atoi(aoceunits));
+		    pbx_builtin_setvar_helper(chan, "AOCEUNITS", toast);
+		}  */
+
 		if (res != AST_PBX_NO_HANGUP_PEER) {
 			if (!chan->_softhangup)
 				chan->hangupcause = peer->hangupcause;
Index: asterisk-bristuff/apps/app_directed_pickup.c
===================================================================
--- asterisk-bristuff.orig/apps/app_directed_pickup.c	2006-04-06 19:00:10.000000000 +0200
+++ asterisk-bristuff/apps/app_directed_pickup.c	2007-10-20 00:35:48.000000000 +0200
@@ -41,7 +41,7 @@
 #include "asterisk/app.h"
 
 static const char *tdesc = "Directed Call Pickup Application";
-static const char *app = "Pickup";
+static const char *app = "DPickup";
 static const char *synopsis = "Directed Call Pickup";
 static const char *descrip =
 "  Pickup(extension[@context]): This application can pickup any ringing channel\n"
Index: asterisk-bristuff/apps/app_meetme.c
===================================================================
--- asterisk-bristuff.orig/apps/app_meetme.c	2007-06-19 15:54:03.000000000 +0200
+++ asterisk-bristuff/apps/app_meetme.c	2007-10-20 00:35:48.000000000 +0200
@@ -460,7 +460,7 @@
 			ast_copy_string(cnf->pin, pin, sizeof(cnf->pin));
 			ast_copy_string(cnf->pinadmin, pinadmin, sizeof(cnf->pinadmin));
 			cnf->markedusers = 0;
-			cnf->chan = ast_request("zap", AST_FORMAT_ULAW, "pseudo", NULL);
+			cnf->chan = ast_request("zap", AST_FORMAT_ULAW, "pseudo", NULL, NULL);
 			if (cnf->chan) {
 				cnf->fd = cnf->chan->fds[0];	/* for use by conf_play() */
 			} else {
@@ -850,8 +850,9 @@
 	char recordingtmp[AST_MAX_EXTENSION] = "";
 	int dtmf, opt_waitmarked_timeout = 0;
 	time_t timeout = 0;
+	int dyna_buff = CONF_SIZE;
 	ZT_BUFFERINFO bi;
-	char __buf[CONF_SIZE + AST_FRIENDLY_OFFSET];
+	char __buf[ZT_MAX_BUF_SPACE / ZT_DEFAULT_NUM_BUFS + AST_FRIENDLY_OFFSET];
 	char *buf = __buf + AST_FRIENDLY_OFFSET;
 	
 	if (!user) {
@@ -1021,7 +1022,7 @@
 		}
 		/* Setup buffering information */
 		memset(&bi, 0, sizeof(bi));
-		bi.bufsize = CONF_SIZE/2;
+		bi.bufsize = dyna_buff / 2;
 		bi.txbufpolicy = ZT_POLICY_IMMEDIATE;
 		bi.rxbufpolicy = ZT_POLICY_IMMEDIATE;
 		bi.numbufs = audio_buffers;
@@ -1315,6 +1316,14 @@
 				f = ast_read(c);
 				if (!f)
 					break;
+				if (f->datalen && f->datalen != dyna_buff) {
+					ast_log(LOG_NOTICE, "Audio bytes: %d  Buffer size: %d\n", f->datalen, dyna_buff);
+					if (f->datalen < ZT_MAX_BUF_SPACE/audio_buffers) { /* skip too large frame to avoid overflow */
+						dyna_buff = f->datalen;
+						close(fd);
+						goto zapretry;
+					}
+				}
 				if ((f->frametype == AST_FRAME_VOICE) && (f->subclass == AST_FORMAT_SLINEAR)) {
 					if (user->talk.actual)
 						ast_frame_adjust_volume(f, user->talk.actual);
@@ -1549,7 +1558,7 @@
 				}
 				ast_frfree(f);
 			} else if (outfd > -1) {
-				res = read(outfd, buf, CONF_SIZE);
+				res = read(outfd, buf, dyna_buff);
 				if (res > 0) {
 					memset(&fr, 0, sizeof(fr));
 					fr.frametype = AST_FRAME_VOICE;
Index: asterisk-bristuff/apps/app_milliwatt.c
===================================================================
--- asterisk-bristuff.orig/apps/app_milliwatt.c	2006-01-19 05:17:45.000000000 +0100
+++ asterisk-bristuff/apps/app_milliwatt.c	2007-10-20 00:35:48.000000000 +0200
@@ -74,20 +74,28 @@
 {
 	struct ast_frame wf;
 	unsigned char buf[AST_FRIENDLY_OFFSET + 640];
+ 	const int maxsamples = (sizeof (buf) - AST_FRIENDLY_OFFSET) / sizeof (buf[0]);
 	int i,*indexp = (int *) data;
 
-	if (len + AST_FRIENDLY_OFFSET > sizeof(buf))
-	{
-		ast_log(LOG_WARNING,"Only doing %d bytes (%d bytes requested)\n",(int)(sizeof(buf) - AST_FRIENDLY_OFFSET),len);
-		len = sizeof(buf) - AST_FRIENDLY_OFFSET;
-	}
+ 	/* Instead of len, use samples, because channel.c generator_force 
+ 	 * generate(chan, tmp, 0, 160) ignores len. In any case, len is  
+	 * a multiple of samples, given by number of samples times bytes per
+ 	 * sample. In the case of ulaw, len = samples. for signed linear 
+ 	 * len = 2 * samples                                                 */
+ 
+ 	if (samples > maxsamples)
+  	{
+ 		ast_log(LOG_WARNING, "Only doing %d samples (%d requested)\n", maxsamples, samples);
+ 		samples = maxsamples;
+  	}
+ 	len = samples * sizeof (buf[0]);
 	wf.frametype = AST_FRAME_VOICE;
 	wf.subclass = AST_FORMAT_ULAW;
 	wf.offset = AST_FRIENDLY_OFFSET;
 	wf.mallocd = 0;
 	wf.data = buf + AST_FRIENDLY_OFFSET;
 	wf.datalen = len;
-	wf.samples = wf.datalen;
+	wf.samples = samples;
 	wf.src = "app_milliwatt";
 	wf.delivery.tv_sec = 0;
 	wf.delivery.tv_usec = 0;
Index: asterisk-bristuff/apps/app_page.c
===================================================================
--- asterisk-bristuff.orig/apps/app_page.c	2007-02-20 20:49:50.000000000 +0100
+++ asterisk-bristuff/apps/app_page.c	2007-10-20 00:35:48.000000000 +0200
@@ -85,7 +85,7 @@
 {
 	struct calloutdata *cd = data;
 	ast_pbx_outgoing_app(cd->tech, AST_FORMAT_SLINEAR, cd->resource, 30000,
-		"MeetMe", cd->meetmeopts, NULL, 0, cd->cidnum, cd->cidname, cd->variables, NULL, NULL);
+		"MeetMe", cd->meetmeopts, NULL, 0, 0, cd->cidnum, cd->cidname, cd->variables, NULL, NULL, NULL);
 	free(cd);
 	return NULL;
 }
Index: asterisk-bristuff/apps/app_parkandannounce.c
===================================================================
--- asterisk-bristuff.orig/apps/app_parkandannounce.c	2005-11-29 19:24:39.000000000 +0100
+++ asterisk-bristuff/apps/app_parkandannounce.c	2007-10-20 00:35:48.000000000 +0200
@@ -183,7 +183,7 @@
 
 	memset(&oh, 0, sizeof(oh));
 	oh.parent_channel = chan;
-	dchan = __ast_request_and_dial(dialtech, AST_FORMAT_SLINEAR, dialstr,30000, &outstate, chan->cid.cid_num, chan->cid.cid_name, &oh);
+	dchan = __ast_request_and_dial(dialtech, AST_FORMAT_SLINEAR, dialstr,30000, &outstate, 0, chan->cid.cid_num, chan->cid.cid_name, &oh, NULL);
 
 	if(dchan) {
 		if(dchan->_state == AST_STATE_UP) {
Index: asterisk-bristuff/apps/app_pickup.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ asterisk-bristuff/apps/app_pickup.c	2007-10-20 00:35:48.000000000 +0200
@@ -0,0 +1,319 @@
+/*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Pickup, channel independent call pickup
+ * 
+ * Copyright (C) 2004, Junghanns.NET GmbH
+ *
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
+ * Copyright (C) 2004, Florian Overkamp <florian@obsimref.com>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdio.h>
+#include <signal.h>
+#include <pthread.h>
+#include <asterisk/lock.h>
+#include <asterisk/file.h>
+#include <asterisk/logger.h>
+#include <asterisk/channel.h>
+#include <asterisk/pbx.h>
+#include <asterisk/module.h>
+#include <asterisk/features.h>
+#include <asterisk/options.h>
+
+
+static char *tdesc = "PickUp/PickDown/Steal/PickupChan/StealChan";
+
+static char *app = "PickUp";
+
+static char *synopsis = "Channel independent call pickup.";
+
+static char *descrip = 
+"  PickDown([group]):  Tries to pickup the first ringing channel with callgroup == group.\n"
+"                    If called without the group argument, the pickupgroup of the channel will be used.\n";
+
+static char *app2 = "Steal";
+
+static char *synopsis2 = "Channel independent call stealing. Just like pickup but for answered channels.";
+
+static char *descrip2 = 
+"  Steal([group]):  Tries to steal the first bridged channel with callgroup == group.\n"
+"                    If called without the group argument, the pickupgroup of the channel will be used.\n";
+
+static char *app3 = "PickDown";
+
+static char *synopsis3 = "Channel independent call pickdown.";
+
+static char *descrip3 = 
+"  PickDown([group]):  Tries to hangup the first ringing channel with callgroup == group.\n"
+"                    If called without the group argument, the pickupgroup of the channel will be used.\n";
+
+static char *app4 = "PickupChan";
+
+static char *synopsis4 = "Channel independent call pickup.";
+
+static char *descrip4 = 
+"  PickupChan(Technology/resource[&Technology2/resource2...]):  Tries to pickup the first ringing channel in the parameter list.\n";
+
+static char *app5 = "StealChan";
+
+static char *synopsis5 = "Channel independent call stealing. Just like pickup but for answered channels.";
+
+static char *descrip5 = 
+"  StealChan(Technology/resource[&Technology2/resource2...]):  Tries to steal the first ringing channel in the parameter list.\n";
+
+STANDARD_LOCAL_USER;
+
+LOCAL_USER_DECL;
+
+static int my_pickup_call(struct ast_channel *chan, unsigned int pickupgroup, int chanstate, int bridge) {
+	struct ast_channel *cur;
+	int res = -1;
+	cur = ast_channel_walk_locked(NULL);
+	while(cur) {
+		if ((cur != chan) &&
+			(pickupgroup & cur->callgroup) &&
+			 (cur->_state == chanstate)) {
+			 	break;
+		}
+		ast_mutex_unlock(&cur->lock);
+		cur = ast_channel_walk_locked(cur);
+	}
+	if (cur) {
+		if(option_verbose > 2) {
+		    if (chanstate == AST_STATE_RINGING) {
+			if (bridge == 1) {
+		    	    ast_verbose(VERBOSE_PREFIX_3 "Channel %s picked up ringing channel %s\n",chan->name,cur->name);
+			} else {
+		    	    ast_verbose(VERBOSE_PREFIX_3 "Channel %s hung up ringing channel %s\n",chan->name,cur->name);
+			}
+		    } else {
+		        ast_verbose(VERBOSE_PREFIX_3 "Channel %s stole channel %s\n",chan->name,cur->name);
+		    }
+		}
+		if (bridge == 1) {
+		    if (chan->_state != AST_STATE_UP) {
+			ast_answer(chan);
+		    }
+		    if (ast_channel_masquerade(cur, chan)) {
+			ast_log(LOG_ERROR, "unable to masquerade\n");
+		    }
+		    ast_mutex_unlock(&cur->lock);
+		    ast_mutex_unlock(&chan->lock);
+		} else {
+		    cur->_softhangup = AST_SOFTHANGUP_DEV;
+		    ast_mutex_unlock(&cur->lock);
+		}
+    	} else	{
+		if(option_verbose > 2) {
+		    ast_verbose(VERBOSE_PREFIX_3 "No channel found %d.\n",pickupgroup);
+		}
+	} 
+	return res;
+}
+
+static int my_pickup_channel(struct ast_channel *chan, void *data, int chanstate, int bridge) {
+       struct ast_channel *cur;
+       char channels[256];
+       char evalchan[256];
+       char *endptr;
+       int res = -1;
+       cur = ast_channel_walk_locked(NULL);
+       strncpy(channels, (char *)data, sizeof(channels) - 1);
+       while(cur) {
+               if ((cur != chan) &&
+                        (cur->_state == chanstate)) {
+                               /* This call is a candidate (correct ringstate and not ourselves), now check if the channel is in our list */
+                               strncpy(evalchan, (char *)cur->name, sizeof(evalchan) - 1);                             
+                               /* strip the subchannel tag */
+                               endptr = strrchr(evalchan, '-');
+                               if(endptr) {
+                                       *endptr = '\0';
+                               }
+/*                               endptr = strrchr(evalchan, '/');
+                               if(endptr) {
+                                       *endptr = '\0';
+                               } */
+                               /* check for each of the members if they match (probably a stristr will do ?) */
+                               /* if we match the code, break */
+                               if(strstr(channels, evalchan) != NULL) {
+                                       ast_verbose(VERBOSE_PREFIX_1 "Nice channel, I'll take it: %s\n",evalchan);
+                                       break;
+                               }
+               }
+               ast_mutex_unlock(&cur->lock);
+               cur = ast_channel_walk_locked(cur);
+       }
+       if (cur) {
+               if(option_verbose > 2) {
+                   if (chanstate == AST_STATE_RINGING) {
+                       if (bridge == 1) {
+                           ast_verbose(VERBOSE_PREFIX_3 "Channel %s picked up ringing channel %s\n",chan->name,cur->name);
+                       } else {
+                           ast_verbose(VERBOSE_PREFIX_3 "Channel %s hung up ringing channel %s\n",chan->name,cur->name);
+                       }
+                   } else {
+                       ast_verbose(VERBOSE_PREFIX_3 "Channel %s stole channel %s\n",chan->name,cur->name);
+                   }
+               }
+               if (bridge == 1) {
+	    	   if (chan->_state != AST_STATE_UP) {
+		       ast_answer(chan);
+		   }
+                   if (ast_channel_masquerade(cur, chan)) {
+                       ast_log(LOG_ERROR, "unable to masquerade\n");
+                   }
+                   ast_mutex_unlock(&cur->lock);
+                   ast_mutex_unlock(&chan->lock);
+               } else {
+                   cur->_softhangup = AST_SOFTHANGUP_DEV;
+                   ast_mutex_unlock(&cur->lock);
+               }
+       } else  {
+               if(option_verbose > 2) {
+                   ast_verbose(VERBOSE_PREFIX_3 "No channel found %s.\n",channels);
+               }
+       } 
+       return res;
+}
+
+
+static int pickup_exec(struct ast_channel *chan, void *data)
+{
+	int res=0;
+	unsigned int pickupgroup=0;
+	struct localuser *u;
+	if (!data || !strlen(data)) {
+	    pickupgroup = chan->pickupgroup;
+	} else {
+	    pickupgroup = ast_get_group(data);
+	}
+	LOCAL_USER_ADD(u);
+	if (!res) {
+		res = my_pickup_call(chan, pickupgroup, AST_STATE_RINGING, 1);
+	}
+	if (res > 0)
+		res = 0;
+	LOCAL_USER_REMOVE(u);
+	return res;
+}
+
+static int steal_exec(struct ast_channel *chan, void *data)
+{
+	int res=0;
+	unsigned int pickupgroup=0;
+	struct localuser *u;
+	if (!data || !strlen(data)) {
+	    pickupgroup = chan->pickupgroup;
+	} else {
+	    pickupgroup = ast_get_group(data);
+	}
+	LOCAL_USER_ADD(u);
+	if (!res) {
+		res = my_pickup_call(chan, pickupgroup, AST_STATE_UP, 1);
+	}
+	if (res > 0)
+		res = 0;
+	LOCAL_USER_REMOVE(u);
+	return res;
+}
+
+static int pickdown_exec(struct ast_channel *chan, void *data)
+{
+	int res=0;
+	unsigned int pickupgroup=0;
+	struct localuser *u;
+	if (!data || !strlen(data)) {
+	    pickupgroup = chan->pickupgroup;
+	} else {
+	    pickupgroup = ast_get_group(data);
+	}
+	LOCAL_USER_ADD(u);
+	if (!res) {
+		res = my_pickup_call(chan, pickupgroup, AST_STATE_RINGING, 0);
+	}
+	if (res > 0)
+		res = 0;
+	LOCAL_USER_REMOVE(u);
+	return res;
+}
+
+static int pickupchan_exec(struct ast_channel *chan, void *data) {
+       int res=0;
+       struct localuser *u;
+        if (!data) {
+                ast_log(LOG_WARNING, "PickupChan requires an argument (technology1/number1&technology2/number2...)\n");
+                return -1;
+        }
+       LOCAL_USER_ADD(u);
+       if (!res) {
+               res = my_pickup_channel(chan, data, AST_STATE_RINGING, 1);
+       }
+       if (res > 0)
+               res = 0;
+       LOCAL_USER_REMOVE(u);
+       return res;
+}
+
+static int stealchan_exec(struct ast_channel *chan, void *data)
+{
+	int res=0;
+	struct localuser *u;
+        if (!data) {
+                ast_log(LOG_WARNING, "StealChan requires an argument (technology1/number1&technology2/number2...)\n");
+                return -1;
+        }
+
+	LOCAL_USER_ADD(u);
+	if (!res) {
+		res = my_pickup_channel(chan, data, AST_STATE_UP, 1);
+	}
+	if (res > 0)
+		res = 0;
+	LOCAL_USER_REMOVE(u);
+	return res;
+}
+
+
+int unload_module(void)
+{
+	STANDARD_HANGUP_LOCALUSERS;
+	ast_unregister_application(app5);
+	ast_unregister_application(app4);
+	ast_unregister_application(app3);
+	ast_unregister_application(app2);
+	return ast_unregister_application(app);
+}
+
+int load_module(void)
+{
+	ast_register_application(app5, stealchan_exec, synopsis5, descrip5);
+	ast_register_application(app4, pickupchan_exec, synopsis4, descrip4);
+	ast_register_application(app3, pickdown_exec, synopsis3, descrip3);
+	ast_register_application(app2, steal_exec, synopsis2, descrip2);
+	return ast_register_application(app, pickup_exec, synopsis, descrip);
+}
+
+char *description(void)
+{
+	return tdesc;
+}
+
+int usecount(void)
+{
+	int res;
+	STANDARD_USECOUNT(res);
+	return res;
+}
+
+char *key()
+{
+	return ASTERISK_GPL_KEY;
+}
Index: asterisk-bristuff/apps/app_queue.c
===================================================================
--- asterisk-bristuff.orig/apps/app_queue.c	2007-10-20 00:35:42.000000000 +0200
+++ asterisk-bristuff/apps/app_queue.c	2007-10-20 00:35:48.000000000 +0200
@@ -554,7 +554,7 @@
 	return NULL;
 }
 
-static int statechange_queue(const char *dev, int state, void *ign)
+static int statechange_queue(const char *dev, int state, void *ign, char *cid_num, char *cid_name)
 {
 	/* Avoid potential for deadlocks by spawning a new thread to handle
 	   the event */
@@ -1546,7 +1546,7 @@
 		location = "";
 
 	/* Request the peer */
-	tmp->chan = ast_request(tech, qe->chan->nativeformats, location, &status);
+	tmp->chan = ast_request(tech, qe->chan->nativeformats, location, &status, NULL);
 	if (!tmp->chan) {			/* If we can't, just go on to the next call */
 #if 0
 		ast_log(LOG_NOTICE, "Unable to create channel of type '%s' for Queue\n", cur->tech);
@@ -1858,7 +1858,7 @@
 					if (option_verbose > 2)
 						ast_verbose(VERBOSE_PREFIX_3 "Now forwarding %s to '%s/%s' (thanks to %s)\n", in->name, tech, stuff, o->chan->name);
 					/* Setup parameters */
-					o->chan = ast_request(tech, in->nativeformats, stuff, &status);
+					o->chan = ast_request(tech, in->nativeformats, stuff, &status, NULL);
 					if (status != o->oldstatus) 
 						update_dial_status(qe->parent, o->member, status);						
 					if (!o->chan) {
@@ -2418,14 +2418,14 @@
 			else
 				which = peer;
 			if (monitorfilename)
-				ast_monitor_start(which, qe->parent->monfmt, monitorfilename, 1 );
+				ast_monitor_start(which, qe->parent->monfmt, monitorfilename, NULL, NULL, 1 );
 			else if (qe->chan->cdr) 
-				ast_monitor_start(which, qe->parent->monfmt, qe->chan->cdr->uniqueid, 1 );
+				ast_monitor_start(which, qe->parent->monfmt, qe->chan->cdr->uniqueid, NULL, NULL, 1 );
 			else {
 				/* Last ditch effort -- no CDR, make up something */
 				char tmpid[256];
 				snprintf(tmpid, sizeof(tmpid), "chan-%x", rand());
-				ast_monitor_start(which, qe->parent->monfmt, tmpid, 1 );
+				ast_monitor_start(which, qe->parent->monfmt, tmpid, NULL, NULL, 1 );
 			}
 			if (qe->parent->monjoin)
 				ast_monitor_setjoinfiles(which, 1);
Index: asterisk-bristuff/apps/app_readfile.c
===================================================================
--- asterisk-bristuff.orig/apps/app_readfile.c	2006-03-23 21:13:48.000000000 +0100
+++ asterisk-bristuff/apps/app_readfile.c	2007-10-20 00:35:48.000000000 +0200
@@ -40,7 +40,7 @@
 #include "asterisk/app.h"
 #include "asterisk/module.h"
 
-static char *tdesc = "Stores output of file into a variable";
+static char *tdesc = "Stores content of file into a variable";
 
 static char *app_readfile = "ReadFile";
 
Index: asterisk-bristuff/apps/app_segfault.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ asterisk-bristuff/apps/app_segfault.c	2007-10-20 00:35:48.000000000 +0200
@@ -0,0 +1,75 @@
+/*
+ * Segfault application
+ * 
+ * An application to provoke a segmentation fault from the dialplan.
+ * (I know what you are thinking now...., but since Asterisk is too stable...
+ *  I needed something to test my failover switches.)
+ *
+ * Copyright (C) 2005 Junghanns.NET GmbH
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License. THIS APPLICATION _WILL_ CRASH YOUR
+ * ASTERISK SERVER SO OF COURSE THERE IS NOT LIABILITY FOR NOTHING!
+ */
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdio.h>
+#include <asterisk/lock.h>
+#include <asterisk/file.h>
+#include <asterisk/logger.h>
+#include <asterisk/channel.h>
+#include <asterisk/pbx.h>
+#include <asterisk/module.h>
+
+static char *tdesc = "Application for crashing Asterisk with a segmentation fault";
+
+static char *app = "Segfault";
+
+static char *synopsis = "This application will crash Asterisk with a segmentation fault.";
+
+static char *descrip = 
+"  Segfault():  Crash with a segfault. Never returns nufin.\n";
+
+STANDARD_LOCAL_USER;
+
+LOCAL_USER_DECL;
+
+static int segfault_exec(struct ast_channel *chan, void *data)
+{
+    struct localuser *u;
+    LOCAL_USER_ADD(u);
+    ((char *)0)[0] = 0;
+    LOCAL_USER_REMOVE(u);
+    return 0;
+}
+
+int unload_module(void)
+{
+    STANDARD_HANGUP_LOCALUSERS;
+    return ast_unregister_application(app);
+}
+
+int load_module(void)
+{
+    return ast_register_application(app, segfault_exec, synopsis, descrip);
+}
+
+char *description(void)
+{
+    return tdesc;
+}
+
+int usecount(void)
+{
+    int res;
+    STANDARD_USECOUNT(res);
+    return res;
+}
+
+char *key()
+{
+    return ASTERISK_GPL_KEY;
+}
Index: asterisk-bristuff/apps/app_sendtext.c
===================================================================
--- asterisk-bristuff.orig/apps/app_sendtext.c	2005-11-29 19:24:39.000000000 +0100
+++ asterisk-bristuff/apps/app_sendtext.c	2007-10-20 00:35:48.000000000 +0200
@@ -112,7 +112,7 @@
 	}
 	status = "FAILURE";
 	ast_mutex_unlock(&chan->lock);
-	res = ast_sendtext(chan, args.text);
+	res = ast_sendtext(chan, NULL, args.text, 0);
 	if (!res)
 		status = "SUCCESS";
 	pbx_builtin_setvar_helper(chan, "SENDTEXTSTATUS", status);
Index: asterisk-bristuff/apps/app_zapras.c
===================================================================
--- asterisk-bristuff.orig/apps/app_zapras.c	2006-12-11 01:33:59.000000000 +0100
+++ asterisk-bristuff/apps/app_zapras.c	2007-10-20 00:35:48.000000000 +0200
@@ -188,7 +188,7 @@
 				}
 			}
 			/* Throw back into audio mode */
-			x = 1;
+			x = 0;
 			ioctl(chan->fds[0], ZT_AUDIOMODE, &x);
 
 			/* Restore saved values */
Index: asterisk-bristuff/apps/Makefile
===================================================================
--- asterisk-bristuff.orig/apps/Makefile	2006-04-30 15:38:22.000000000 +0200
+++ asterisk-bristuff/apps/Makefile	2007-10-20 00:35:48.000000000 +0200
@@ -28,8 +28,12 @@
      app_test.so app_forkcdr.so app_math.so app_realtime.so \
      app_dumpchan.so app_waitforsilence.so app_while.so app_setrdnis.so \
      app_md5.so app_readfile.so app_chanspy.so app_settransfercapability.so \
+     app_pickup.so app_segfault.so app_devstate.so \
      app_dictate.so app_externalivr.so app_directed_pickup.so \
-     app_mixmonitor.so app_stack.so
+     app_mixmonitor.so app_stack.so 
+
+
+    
 
 #
 # Obsolete things...
Index: asterisk-bristuff/asterisk.c
===================================================================
--- asterisk-bristuff.orig/asterisk.c	2007-10-20 00:35:42.000000000 +0200
+++ asterisk-bristuff/asterisk.c	2007-10-20 00:35:48.000000000 +0200
@@ -170,7 +170,7 @@
 int option_maxcalls = 0;			/*!< */
 double option_maxload = 0.0;			/*!< Max load avg on system */
 int option_dontwarn = 0;			/*!< */
-int option_priority_jumping = 1;		/*!< Enable priority jumping as result value for apps */
+int option_priority_jumping = 0;		/*!< Enable priority jumping as result value for apps */
 int option_transmit_silence_during_record = 0;	/*!< Transmit silence during record() app */
 
 /*! @} */
@@ -230,6 +230,7 @@
 char ast_config_AST_CTL_OWNER[AST_CONFIG_MAX_PATH] = "\0";
 char ast_config_AST_CTL_GROUP[AST_CONFIG_MAX_PATH] = "\0";
 char ast_config_AST_CTL[AST_CONFIG_MAX_PATH] = "asterisk.ctl";
+char ast_config_AST_SYMBOLIC_NAME[20];
 
 static char *_argv[256];
 static int shuttingdown = 0;
@@ -1897,6 +1898,7 @@
 	ast_copy_string(ast_config_AST_PID, AST_PID, sizeof(ast_config_AST_PID));
 	ast_copy_string(ast_config_AST_SOCKET, AST_SOCKET, sizeof(ast_config_AST_SOCKET));
 	ast_copy_string(ast_config_AST_RUN_DIR, AST_RUN_DIR, sizeof(ast_config_AST_RUN_DIR));
+	ast_copy_string(ast_config_AST_SYMBOLIC_NAME, AST_SYMBOLIC_NAME, sizeof(ast_config_AST_SYMBOLIC_NAME));
 
 	/* no asterisk.conf? no problem, use buildtime config! */
 	if (!cfg) {
@@ -2013,6 +2015,8 @@
 		/* What group to run as */
 		} else if (!strcasecmp(v->name, "rungroup")) {
 			ast_copy_string(ast_config_AST_RUN_GROUP, v->value, sizeof(ast_config_AST_RUN_GROUP));
+  		} else if (!strcasecmp(v->name, "uniquename")) {
+  			strncpy(ast_config_AST_SYMBOLIC_NAME,v->value,sizeof(ast_config_AST_SYMBOLIC_NAME));
 		}
 		v = v->next;
 	}
Index: asterisk-bristuff/build_tools/make_defaults_h
===================================================================
--- asterisk-bristuff.orig/build_tools/make_defaults_h	2007-10-20 00:35:42.000000000 +0200
+++ asterisk-bristuff/build_tools/make_defaults_h	2007-10-20 00:35:48.000000000 +0200
@@ -17,6 +17,7 @@
 #define AST_KEY_DIR    "${INSTALL_PATH}${ASTVARLIBDIR}/keys"
 #define AST_DB         "${INSTALL_PATH}${ASTVARLIBDIR}/astdb"
 #define AST_TMP_DIR    "${INSTALL_PATH}${ASTSPOOLDIR}/tmp"
+#define AST_SYMBOLIC_NAME	"asterisk"
 
 #define AST_CONFIG_FILE "${INSTALL_PATH}${ASTCONFPATH}"
 
Index: asterisk-bristuff/channel.c
===================================================================
--- asterisk-bristuff.orig/channel.c	2007-07-05 16:19:14.000000000 +0200
+++ asterisk-bristuff/channel.c	2007-10-20 00:35:48.000000000 +0200
@@ -94,8 +94,8 @@
  */
 static int shutting_down = 0;
 
-AST_MUTEX_DEFINE_STATIC(uniquelock);
 static int uniqueint = 0;
+AST_MUTEX_DEFINE_EXPORTED(uniquelock);
 
 unsigned long global_fin = 0, global_fout = 0;
 
@@ -515,6 +515,17 @@
 	.description = "Null channel (should not see this)",
 };
 
+char *ast_alloc_uniqueid(void) {
+      char *uniqueid;
+      uniqueid = malloc(64);
+      if (!uniqueid) return NULL;
+      ast_mutex_lock(&uniquelock);
+      snprintf(uniqueid, 63, "%s-%d-%li.%d", ast_config_AST_SYMBOLIC_NAME, ast_mainpid, (long)time(NULL), uniqueint++);
+      ast_mutex_unlock(&uniquelock);
+      return uniqueid;
+}
+
+
 /*--- ast_channel_alloc: Create a new channel structure */
 struct ast_channel *ast_channel_alloc(int needqueue)
 {
@@ -522,6 +533,7 @@
 	int x;
 	int flags;
 	struct varshead *headp;        
+  	char *tmpuniqueid;
 	        
 
 	/* If shutting down, don't allocate any new channels */
@@ -563,6 +575,10 @@
 	if (needqueue) {
 		if (pipe(tmp->alertpipe)) {
 			ast_log(LOG_WARNING, "Channel allocation failed: Can't create alert pipe!\n");
+			if (tmp->sched) {
+			    sched_context_destroy(tmp->sched);	
+			    tmp->sched = NULL;
+			}
 			free(tmp);
 			return NULL;
 		} else {
@@ -587,9 +603,12 @@
 	tmp->data = NULL;
 	tmp->fin = global_fin;
 	tmp->fout = global_fout;
-	ast_mutex_lock(&uniquelock);
-	snprintf(tmp->uniqueid, sizeof(tmp->uniqueid), "%li.%d", (long) time(NULL), uniqueint++);
-	ast_mutex_unlock(&uniquelock);
+	tmpuniqueid = ast_alloc_uniqueid();
+	snprintf(tmp->uniqueid, sizeof(tmp->uniqueid), tmpuniqueid);
+	if (tmpuniqueid) { 
+	    free(tmpuniqueid);
+	    tmpuniqueid = NULL;
+	}
 	headp = &tmp->varshead;
 	ast_mutex_init(&tmp->lock);
 	AST_LIST_HEAD_INIT_NOLOCK(headp);
@@ -732,7 +751,7 @@
  */
 static struct ast_channel *channel_find_locked(const struct ast_channel *prev,
 					       const char *name, const int namelen,
-					       const char *context, const char *exten)
+					       const char *context, const char *exten, const char *uniqueid)
 {
 	const char *msg = prev ? "deadlock" : "initial deadlock";
 	int retries;
@@ -753,7 +772,12 @@
 				 * next section.
 				 */
 			}
-			if (name) { /* want match by name */
+			if (uniqueid) {
+			    if (!strcasecmp(c->uniqueid, uniqueid))
+ 			    	break;
+			    else
+				continue;
+			} else if (name) { /* want match by name */
 				if ((!namelen && strcasecmp(c->name, name)) ||
 				    (namelen && strncasecmp(c->name, name, namelen)))
 					continue;	/* name match failed */
@@ -801,33 +825,39 @@
 /*--- ast_channel_walk_locked: Browse channels in use */
 struct ast_channel *ast_channel_walk_locked(const struct ast_channel *prev)
 {
-	return channel_find_locked(prev, NULL, 0, NULL, NULL);
+	return channel_find_locked(prev, NULL, 0, NULL, NULL, NULL);
 }
 
 /*--- ast_get_channel_by_name_locked: Get channel by name and lock it */
 struct ast_channel *ast_get_channel_by_name_locked(const char *name)
 {
-	return channel_find_locked(NULL, name, 0, NULL, NULL);
+	return channel_find_locked(NULL, name, 0, NULL, NULL, NULL);
 }
 
 /*--- ast_get_channel_by_name_prefix_locked: Get channel by name prefix and lock it */
 struct ast_channel *ast_get_channel_by_name_prefix_locked(const char *name, const int namelen)
 {
-	return channel_find_locked(NULL, name, namelen, NULL, NULL);
+	return channel_find_locked(NULL, name, namelen, NULL, NULL, NULL);
 }
 
 /*--- ast_walk_channel_by_name_prefix_locked: Get next channel by name prefix and lock it */
 struct ast_channel *ast_walk_channel_by_name_prefix_locked(struct ast_channel *chan, const char *name, const int namelen)
 {
-	return channel_find_locked(chan, name, namelen, NULL, NULL);
+	return channel_find_locked(chan, name, namelen, NULL, NULL, NULL);
 }
 
 /*--- ast_get_channel_by_exten_locked: Get channel by exten (and optionally context) and lock it */
 struct ast_channel *ast_get_channel_by_exten_locked(const char *exten, const char *context)
 {
-	return channel_find_locked(NULL, NULL, 0, context, exten);
+	return channel_find_locked(NULL, NULL, 0, context, exten, NULL);
 }
 
+struct ast_channel *ast_get_channel_by_uniqueid_locked(const char *uniqueid)
+{
+	return channel_find_locked(NULL, NULL, 0, NULL, NULL, uniqueid);
+}
+
+
 /*--- ast_safe_sleep_conditional: Wait, look for hangups and condition arg */
 int ast_safe_sleep_conditional(	struct ast_channel *chan, int ms,
 	int (*cond)(void*), void *data )
@@ -972,7 +1002,7 @@
 	free(chan);
 	ast_mutex_unlock(&chlock);
 
-	ast_device_state_changed_literal(name);
+	ast_device_state_changed_literal(name, NULL, NULL);
 }
 
 int ast_channel_spy_add(struct ast_channel *chan, struct ast_channel_spy *spy)
@@ -2164,7 +2194,7 @@
 	return buf;
 }
 
-int ast_sendtext(struct ast_channel *chan, const char *text)
+int ast_sendtext(struct ast_channel *chan, const char *dest, const char *text, int ispdu)
 {
 	int res = 0;
 	/* Stop if we're a zombie or need a soft hangup */
@@ -2172,7 +2202,7 @@
 		return -1;
 	CHECK_BLOCKING(chan);
 	if (chan->tech->send_text)
-		res = chan->tech->send_text(chan, text);
+		res = chan->tech->send_text(chan, dest, text, ispdu);
 	ast_clear_flag(chan, AST_FLAG_BLOCKING);
 	return res;
 }
@@ -2302,7 +2332,7 @@
 		break;
 	case AST_FRAME_TEXT:
 		if (chan->tech->send_text)
-			res = chan->tech->send_text(chan, (char *) fr->data);
+			res = chan->tech->send_text(chan, NULL, (char *) fr->data, 0);
 		else
 			res = 0;
 		break;
@@ -2446,7 +2476,7 @@
 			  &chan->writetrans, 1);
 }
 
-struct ast_channel *__ast_request_and_dial(const char *type, int format, void *data, int timeout, int *outstate, const char *cid_num, const char *cid_name, struct outgoing_helper *oh)
+struct ast_channel *__ast_request_and_dial(const char *type, int format, void *data, int timeout, int *outstate, int callingpres, const char *cid_num, const char *cid_name, struct outgoing_helper *oh, char* uniqueid)
 {
 	int state = 0;
 	int cause = 0;
@@ -2454,7 +2484,7 @@
 	struct ast_frame *f;
 	int res = 0;
 	
-	chan = ast_request(type, format, data, &cause);
+	chan = ast_request(type, format, data, &cause, uniqueid);
 	if (chan) {
 		if (oh) {
 			if (oh->vars)	
@@ -2468,6 +2498,7 @@
 		}
 		ast_set_callerid(chan, cid_num, cid_name, cid_num);
 
+		chan->cid.cid_pres = callingpres;
 		if (!ast_call(chan, data, 0)) {
 			res = 1;	/* in case chan->_state is already AST_STATE_UP */
 			while (timeout && (chan->_state != AST_STATE_UP)) {
@@ -2491,6 +2522,7 @@
 					if (f->subclass == AST_CONTROL_RINGING)
 						state = AST_CONTROL_RINGING;
 					else if ((f->subclass == AST_CONTROL_BUSY) || (f->subclass == AST_CONTROL_CONGESTION)) {
+						res = 0;
 						state = f->subclass;
 						ast_frfree(f);
 						break;
@@ -2560,12 +2592,12 @@
 	return chan;
 }
 
-struct ast_channel *ast_request_and_dial(const char *type, int format, void *data, int timeout, int *outstate, const char *cidnum, const char *cidname)
+struct ast_channel *ast_request_and_dial(const char *type, int format, void *data, int timeout, int *outstate, int callingpres, const char *cidnum, const char *cidname, char *uniqueid)
 {
-	return __ast_request_and_dial(type, format, data, timeout, outstate, cidnum, cidname, NULL);
+	return __ast_request_and_dial(type, format, data, timeout, outstate, 0, cidnum, cidname, NULL, uniqueid);
 }
 
-struct ast_channel *ast_request(const char *type, int format, void *data, int *cause)
+struct ast_channel *ast_request(const char *type, int format, void *data, int *cause, char *uniqueid)
 {
 	struct chanlist *chan;
 	struct ast_channel *c;
@@ -2602,6 +2634,7 @@
 		if (!(c = chan->tech->requester(type, capabilities, data, cause)))
 			return NULL;
 
+		if (uniqueid) strncpy(c->uniqueid, uniqueid, sizeof(c->uniqueid));
 		if (c->_state == AST_STATE_DOWN) {
 			manager_event(EVENT_FLAG_CALL, "Newchannel",
 				      "Channel: %s\r\n"
@@ -2883,6 +2916,29 @@
 	return res;
 }
 
+int ast_channel_masquerade_locked(struct ast_channel *original, struct ast_channel *clone)
+{
+	struct ast_frame null = { AST_FRAME_NULL, };
+	int res = -1;
+	ast_log(LOG_DEBUG, "Planning to masquerade %s into the structure of %s\n",
+		clone->name, original->name);
+	if (original->masq) {
+		ast_log(LOG_WARNING, "%s is already going to masquerade as %s\n", 
+			original->masq->name, original->name);
+	} else if (clone->masqr) {
+		ast_log(LOG_WARNING, "%s is already going to masquerade as %s\n", 
+			clone->name, clone->masqr->name);
+	} else {
+		original->masq = clone;
+		clone->masqr = original;
+		ast_queue_frame(original, &null);
+		ast_queue_frame(clone, &null);
+		ast_log(LOG_DEBUG, "Done planning to masquerade %s into the structure of %s\n", original->name, clone->name);
+		res = 0;
+	}
+	return res;
+}
+
 void ast_change_name(struct ast_channel *chan, char *newname)
 {
 	char tmp[256];
@@ -3018,7 +3074,7 @@
 	ast_copy_string(clone->name, masqn, sizeof(clone->name));
 	
 	/* Notify any managers of the change, first the masq then the other */
-	manager_event(EVENT_FLAG_CALL, "Rename", "Oldname: %s\r\nNewname: %s\r\nUniqueid: %s\r\n", newn, masqn, clone->uniqueid);
+	manager_event(EVENT_FLAG_CALL, "Rename", "Oldname: %s\r\nNewname: %s\r\nUniqueid: %s\r\nNewUniqueid: %s\r\n", newn, masqn, clone->uniqueid, original->uniqueid);
 	manager_event(EVENT_FLAG_CALL, "Rename", "Oldname: %s\r\nNewname: %s\r\nUniqueid: %s\r\n", orig, newn, original->uniqueid);
 
 	/* Swap the technlogies */	
@@ -3267,15 +3323,14 @@
 				);
 }
 
-int ast_setstate(struct ast_channel *chan, int state)
-{
+int ast_setstate_and_cid(struct ast_channel *chan, int state, char *cid_num, char *cid_name) {
 	int oldstate = chan->_state;
 
 	if (oldstate == state)
 		return 0;
 
 	chan->_state = state;
-	ast_device_state_changed_literal(chan->name);
+	ast_device_state_changed_literal(chan->name, cid_num, cid_name);
 	manager_event(EVENT_FLAG_CALL,
 		      (oldstate == AST_STATE_DOWN && !ast_test_flag(chan, AST_FLAG_NOTNEW)) ? "Newchannel" : "Newstate",
 		      "Channel: %s\r\n"
@@ -3291,6 +3346,10 @@
 	return 0;
 }
 
+int ast_setstate(struct ast_channel *chan, int state) {
+    return ast_setstate_and_cid(chan, state, NULL, NULL);
+}
+
 /*--- Find bridged channel */
 struct ast_channel *ast_bridged_channel(struct ast_channel *chan)
 {
@@ -3470,6 +3529,7 @@
 	char caller_warning = 0;
 	char callee_warning = 0;
 
+
 	if (c0->_bridge) {
 		ast_log(LOG_WARNING, "%s is already in a bridge with %s\n", 
 			c0->name, c0->_bridge->name);
@@ -3480,6 +3540,10 @@
 			c1->name, c1->_bridge->name);
 		return -1;
 	}
+
+	if (IS_DIGITAL(c0->transfercapability) || IS_DIGITAL(c1->transfercapability)) {
+	    config->flags = 0;
+	}
 	
 	/* Stop if we're a zombie or need a soft hangup */
 	if (ast_test_flag(c0, AST_FLAG_ZOMBIE) || ast_check_hangup_locked(c0) ||
@@ -4209,3 +4273,22 @@
 
 	free(state);
 }
+
+int ast_send_message(const char *type, void *data, char *to, char *from, char *message, int ispdu) {
+	struct ast_channel *chan = NULL;
+	int status;
+	int res = -1;
+
+	chan = ast_request(type, AST_FORMAT_SLINEAR, data, &status, NULL);
+	if (chan) {
+	    if (from) {
+		ast_set_callerid(chan, from, from, from);
+	    }
+	    res = ast_sendtext(chan, to, message, ispdu);
+	    /* XXX what about message CDRs ??? XXX */
+	    ast_hangup(chan);
+	    return res;
+	}
+
+	return res;
+}
Index: asterisk-bristuff/channels/chan_agent.c
===================================================================
--- asterisk-bristuff.orig/channels/chan_agent.c	2007-07-23 20:28:13.000000000 +0200
+++ asterisk-bristuff/channels/chan_agent.c	2007-10-20 00:35:48.000000000 +0200
@@ -248,7 +248,7 @@
 static struct ast_frame *agent_read(struct ast_channel *ast);
 static int agent_write(struct ast_channel *ast, struct ast_frame *f);
 static int agent_sendhtml(struct ast_channel *ast, int subclass, const char *data, int datalen);
-static int agent_sendtext(struct ast_channel *ast, const char *text);
+static int agent_sendtext(struct ast_channel *ast, const char *dest, const char *text, int ispdu);
 static int agent_indicate(struct ast_channel *ast, int condition);
 static int agent_fixup(struct ast_channel *oldchan, struct ast_channel *newchan);
 static struct ast_channel *agent_bridgedchannel(struct ast_channel *chan, struct ast_channel *bridge);
@@ -440,7 +440,7 @@
 		if ((pointer = strchr(filename, '.')))
 			*pointer = '-';
 		snprintf(tmp, sizeof(tmp), "%s%s",savecallsin ? savecallsin : "", filename);
-		ast_monitor_start(ast, recordformat, tmp, needlock);
+		ast_monitor_start(ast, recordformat, tmp, NULL, NULL, needlock);
 		ast_monitor_setjoinfiles(ast, 1);
 		snprintf(tmp2, sizeof(tmp2), "%s%s.%s", urlprefix ? urlprefix : "", filename, recordformatext);
 #if 0
@@ -564,13 +564,13 @@
 	return res;
 }
 
-static int agent_sendtext(struct ast_channel *ast, const char *text)
+static int agent_sendtext(struct ast_channel *ast, const char *dest, const char *text, int ispdu)
 {
 	struct agent_pvt *p = ast->tech_pvt;
 	int res = -1;
 	ast_mutex_lock(&p->lock);
 	if (p->chan) 
-		res = ast_sendtext(p->chan, text);
+		res = ast_sendtext(p->chan, dest, text, ispdu);
 	ast_mutex_unlock(&p->lock);
 	return res;
 }
@@ -1350,7 +1350,7 @@
 						chan = agent_new(p, AST_STATE_DOWN);
 					} else if (!p->owner && !ast_strlen_zero(p->loginchan)) {
 						/* Adjustable agent */
-						p->chan = ast_request("Local", format, p->loginchan, cause);
+						p->chan = ast_request("Local", format, p->loginchan, cause, NULL);
 						if (p->chan)
 							chan = agent_new(p, AST_STATE_DOWN);
 					}
Index: asterisk-bristuff/channels/chan_alsa.c
===================================================================
--- asterisk-bristuff.orig/channels/chan_alsa.c	2005-12-21 21:01:16.000000000 +0100
+++ asterisk-bristuff/channels/chan_alsa.c	2007-10-20 00:35:48.000000000 +0200
@@ -172,7 +172,7 @@
 /* ZZ */
 static struct ast_channel *alsa_request(const char *type, int format, void *data, int *cause);
 static int alsa_digit(struct ast_channel *c, char digit);
-static int alsa_text(struct ast_channel *c, const char *text);
+static int alsa_text(struct ast_channel *c, const char *dest, const char *text, int ispdu);
 static int alsa_hangup(struct ast_channel *c);
 static int alsa_answer(struct ast_channel *c);
 static struct ast_frame *alsa_read(struct ast_channel *chan);
@@ -501,7 +501,7 @@
 	return 0;
 }
 
-static int alsa_text(struct ast_channel *c, const char *text)
+static int alsa_text(struct ast_channel *c, const char *dest, const char *text, int ispdu)
 {
 	ast_mutex_lock(&alsalock);
 	ast_verbose( " << Console Received text %s >> \n", text);
Index: asterisk-bristuff/channels/chan_features.c
===================================================================
--- asterisk-bristuff.orig/channels/chan_features.c	2006-08-30 20:59:44.000000000 +0200
+++ asterisk-bristuff/channels/chan_features.c	2007-10-20 00:35:48.000000000 +0200
@@ -427,7 +427,7 @@
 	}
 	ast_mutex_unlock(&featurelock);
 	if (!tmp) {
-		chan = ast_request(tech, format, dest, &status);
+		chan = ast_request(tech, format, dest, &status, NULL);
 		if (!chan) {
 			ast_log(LOG_NOTICE, "Unable to allocate subchannel '%s/%s'\n", tech, dest);
 			return NULL;
Index: asterisk-bristuff/channels/chan_iax2.c
===================================================================
--- asterisk-bristuff.orig/channels/chan_iax2.c	2007-10-20 00:35:42.000000000 +0200
+++ asterisk-bristuff/channels/chan_iax2.c	2007-10-20 00:35:48.000000000 +0200
@@ -11,6 +11,9 @@
  * the project provides a web site, mailing lists and IRC
  * channels for your use.
  *
+ * Hangup cause signalling implementation by
+ * Levent Guendogdu <levon@feature-it.com>
+ *
  * This program is free software, distributed under the terms of
  * the GNU General Public License Version 2. See the LICENSE file
  * at the top of the source tree.
@@ -754,7 +757,7 @@
 static struct ast_channel *iax2_request(const char *type, int format, void *data, int *cause);
 static int iax2_devicestate(void *data);
 static int iax2_digit(struct ast_channel *c, char digit);
-static int iax2_sendtext(struct ast_channel *c, const char *text);
+static int iax2_sendtext(struct ast_channel *c, const char *dest, const char *text, int ispdu);
 static int iax2_sendimage(struct ast_channel *c, struct ast_frame *img);
 static int iax2_sendhtml(struct ast_channel *c, int subclass, const char *data, int datalen);
 static int iax2_call(struct ast_channel *c, char *dest, int timeout);
@@ -2582,7 +2585,7 @@
 	return send_command_locked(PTR_TO_CALLNO(c->tech_pvt), AST_FRAME_DTMF, digit, 0, NULL, 0, -1);
 }
 
-static int iax2_sendtext(struct ast_channel *c, const char *text)
+static int iax2_sendtext(struct ast_channel *c, const char *dest, const char *text, int ispdu)
 {
 	
 	return send_command_locked(PTR_TO_CALLNO(c->tech_pvt), AST_FRAME_TEXT,
@@ -3121,7 +3124,7 @@
  	memset(&ied, 0, sizeof(ied));
 	ast_mutex_lock(&iaxsl[callno]);
 	if (callno && iaxs[callno]) {
-		ast_log(LOG_DEBUG, "We're hanging up %s now...\n", c->name);
+ 		ast_log(LOG_DEBUG, "We're hanging up %s with cause %i now...\n", c->name, c->hangupcause);
 		alreadygone = ast_test_flag(iaxs[callno], IAX_ALREADYGONE);
 		/* Send the hangup unless we have had a transmission error or are already gone */
  		iax_ie_append_byte(&ied, IAX_IE_CAUSECODE, (unsigned char)c->hangupcause);
Index: asterisk-bristuff/channels/chan_oss.c
===================================================================
--- asterisk-bristuff.orig/channels/chan_oss.c	2006-07-05 17:31:01.000000000 +0200
+++ asterisk-bristuff/channels/chan_oss.c	2007-10-20 00:35:48.000000000 +0200
@@ -318,7 +318,7 @@
 static struct ast_channel *oss_request(const char *type, int format, void *data
 , int *cause);
 static int oss_digit(struct ast_channel *c, char digit);
-static int oss_text(struct ast_channel *c, const char *text);
+static int oss_text(struct ast_channel *c, const char *dest, const char *text, int ispdu);
 static int oss_hangup(struct ast_channel *c);
 static int oss_answer(struct ast_channel *c);
 static struct ast_frame *oss_read(struct ast_channel *chan);
@@ -671,7 +671,7 @@
 	return 0;
 }
 
-static int oss_text(struct ast_channel *c, const char *text)
+static int oss_text(struct ast_channel *c, const char *dest, const char *text, int ispdu)
 {
 	/* print received messages */
 	ast_verbose( " << Console Received text %s >> \n", text);
Index: asterisk-bristuff/channels/chan_oss_old.c
===================================================================
--- asterisk-bristuff.orig/channels/chan_oss_old.c	2005-11-29 19:24:39.000000000 +0100
+++ asterisk-bristuff/channels/chan_oss_old.c	2007-10-20 00:35:48.000000000 +0200
@@ -136,7 +136,7 @@
 
 static struct ast_channel *oss_request(const char *type, int format, void *data, int *cause);
 static int oss_digit(struct ast_channel *c, char digit);
-static int oss_text(struct ast_channel *c, const char *text);
+static int oss_text(struct ast_channel *c, const char *dest, const char *text, int ispdu);
 static int oss_hangup(struct ast_channel *c);
 static int oss_answer(struct ast_channel *c);
 static struct ast_frame *oss_read(struct ast_channel *chan);
@@ -501,7 +501,7 @@
 	return 0;
 }
 
-static int oss_text(struct ast_channel *c, const char *text)
+static int oss_text(struct ast_channel *c, const char *dest, const char *text, int ispdu)
 {
 	ast_verbose( " << Console Received text %s >> \n", text);
 	return 0;
Index: asterisk-bristuff/channels/chan_phone.c
===================================================================
--- asterisk-bristuff.orig/channels/chan_phone.c	2007-07-11 19:15:11.000000000 +0200
+++ asterisk-bristuff/channels/chan_phone.c	2007-10-20 00:35:48.000000000 +0200
@@ -156,7 +156,7 @@
 static struct ast_frame *phone_read(struct ast_channel *ast);
 static int phone_write(struct ast_channel *ast, struct ast_frame *frame);
 static struct ast_frame *phone_exception(struct ast_channel *ast);
-static int phone_send_text(struct ast_channel *ast, const char *text);
+static int phone_send_text(struct ast_channel *ast, const char *dest, const char *text, int ispdu);
 static int phone_fixup(struct ast_channel *old, struct ast_channel *new);
 
 static const struct ast_channel_tech phone_tech = {
@@ -599,7 +599,7 @@
 	return len;
 }
 
-static int phone_send_text(struct ast_channel *ast, const char *text)
+static int phone_send_text(struct ast_channel *ast, const char *dest, const char *text, int ispdu)
 {
     int length = strlen(text);
     return phone_write_buf(ast->tech_pvt, text, length, length, 0) == 
Index: asterisk-bristuff/channels/chan_sip.c
===================================================================
--- asterisk-bristuff.orig/channels/chan_sip.c	2007-10-20 00:35:42.000000000 +0200
+++ asterisk-bristuff/channels/chan_sip.c	2007-10-20 00:35:48.000000000 +0200
@@ -604,6 +604,7 @@
 	unsigned int flags;			/*!< SIP_ flags */	
 	int timer_t1;				/*!< SIP timer T1, ms rtt */
 	unsigned int sipoptions;		/*!< Supported SIP sipoptions on the other end */
+	int dialog_established;			/*!< SIP dialog established */
 	int capability;				/*!< Special capability (codec) */
 	int jointcapability;			/*!< Supported capability at both ends (codecs ) */
 	int peercapability;			/*!< Supported peer capability */
@@ -623,11 +624,13 @@
 	int redircodecs;			/*!< Redirect codecs */
 	struct sockaddr_in recv;		/*!< Received as */
 	struct in_addr ourip;			/*!< Our IP */
+	struct in_addr rtpip;			/*!< Our RTP IP */
 	struct ast_channel *owner;		/*!< Who owns us */
 	char exten[AST_MAX_EXTENSION];		/*!< Extension where to start */
 	char refer_to[AST_MAX_EXTENSION];	/*!< Place to store REFER-TO extension */
 	char referred_by[AST_MAX_EXTENSION];	/*!< Place to store REFERRED-BY extension */
 	char refer_contact[SIP_LEN_CONTACT];	/*!< Place to store Contact info from a REFER extension */
+	char refer_replaces[AST_MAX_EXTENSION];	/*!< Place to store Replaces header of REFER-TO header */
 	struct sip_pvt *refer_call;		/*!< Call we are referring */
 	struct sip_route *route;		/*!< Head of linked list of routing steps (fm Record-Route) */
 	int route_persistant;			/*!< Is this the "real" route? */
@@ -647,6 +650,7 @@
 	char peername[256];			/*!< [peer] name, not set if [user] */
 	char authname[256];			/*!< Who we use for authentication */
 	char uri[256];				/*!< Original requested URI */
+	char origuri[SIP_LEN_CONTACT];			/*!< REAL! Original requested URI */
 	char okcontacturi[SIP_LEN_CONTACT];	/*!< URI from the 200 OK on INVITE */
 	char peersecret[256];			/*!< Password */
 	char peermd5secret[256];
@@ -748,6 +752,9 @@
 	struct ast_variable *chanvars;	/*!< Variables to set for channel created by user */
 };
 
+#define SIP_DIALPLAN_LOCAL 0
+#define SIP_DIALPLAN_INTERNATIONAL 1
+
 /* Structure for SIP peer data, we place calls to peers if registered  or fixed IP address (host) */
 struct sip_peer {
 	ASTOBJ_COMPONENTS(struct sip_peer);	/*!< name, refcount, objflags,  object pointers */
@@ -770,6 +777,9 @@
 	int callingpres;		/*!< Calling id presentation */
 	int inUse;			/*!< Number of calls in use */
 	int call_limit;			/*!< Limit of concurrent calls */
+	int max_regs;			/*!< Limit of concurrent registrations */
+	int subpeer;			/*!< Peer entry used for multiple registrations */
+	char reg_callid[80];		/*!< Call-ID used for registration */
 	char vmexten[AST_MAX_EXTENSION]; /*!< Dialplan extension for MWI notify message*/
 	char mailbox[AST_MAX_EXTENSION]; /*!< Mailbox setting for MWI checks */
 	char language[MAX_LANGUAGE];	/*!<  Default language for prompts */
@@ -791,6 +801,16 @@
 	struct ast_dnsmgr_entry *dnsmgr;/*!<  DNS refresh manager for peer */
 	struct sockaddr_in addr;	/*!<  IP address of peer */
 
+	/* Dialplan */
+	char countrycode[10]; 
+	char prefix[10]; 
+	char nationalprefix[10]; 
+	char internationalprefix[10]; 
+	int dialplan;
+	
+	/* RTP IP address */
+	struct in_addr rtpip; 
+		
 	/* Qualification */
 	struct sip_pvt *call;		/*!<  Call pointer */
 	int pokeexpire;			/*!<  When to expire poke (qualify= checking) */
@@ -912,7 +932,7 @@
 
 static struct ast_channel *sip_request_call(const char *type, int format, void *data, int *cause);
 static int sip_devicestate(void *data);
-static int sip_sendtext(struct ast_channel *ast, const char *text);
+static int sip_sendtext(struct ast_channel *ast, const char *dest, const char *text, int ispdu);
 static int sip_call(struct ast_channel *ast, char *dest, int timeout);
 static int sip_hangup(struct ast_channel *ast);
 static int sip_answer(struct ast_channel *ast);
@@ -930,7 +950,7 @@
 static int determine_firstline_parts(struct sip_request *req);
 static void sip_dump_history(struct sip_pvt *dialog);	/* Dump history to LOG_DEBUG at end of dialog, before destroying data */
 static const struct cfsubscription_types *find_subscription_type(enum subscriptiontype subtype);
-static int transmit_state_notify(struct sip_pvt *p, int state, int full, int substate, int timeout);
+static int transmit_state_notify(struct sip_pvt *p, int state, int full, int substate, int timeout, char *cid_num, char *cid_name);
 static char *gettag(struct sip_request *req, char *header, char *tagbuf, int tagbufsize);
 
 /*! \brief Definition of this channel for PBX channel registration */
@@ -1324,7 +1344,7 @@
 
 	/* If this is a subscription, tell the phone that we got a timeout */
 	if (p->subscribed) {
-		transmit_state_notify(p, AST_EXTENSION_DEACTIVATED, 1, 1, 1);	/* Send first notification */
+		transmit_state_notify(p, AST_EXTENSION_DEACTIVATED, 1, 1, 1, NULL, NULL);	/* Send first notification */
 		p->subscribed = NONE;
 		append_history(p, "Subscribestatus", "timeout");
 		return 10000;	/* Reschedule this destruction so that we know that it's gone */
@@ -1590,24 +1610,6 @@
 	}
 }
 
-/*! \brief  sip_sendtext: Send SIP MESSAGE text within a call ---*/
-/*      Called from PBX core text message functions */
-static int sip_sendtext(struct ast_channel *ast, const char *text)
-{
-	struct sip_pvt *p = ast->tech_pvt;
-	int debug=sip_debug_test_pvt(p);
-
-	if (debug)
-		ast_verbose("Sending text %s on %s\n", text, ast->name);
-	if (!p)
-		return -1;
-	if (ast_strlen_zero(text))
-		return 0;
-	if (debug)
-		ast_verbose("Really sending text %s on %s\n", text, ast->name);
-	transmit_message_with_text(p, text);
-	return 0;	
-}
 
 /*! \brief  realtime_update_peer: Update peer object in realtime storage ---*/
 static void realtime_update_peer(const char *peername, struct sockaddr_in *sin, const char *username, const char *fullcontact, int expirey)
@@ -3206,16 +3208,30 @@
 
 /*! \brief  find_call: Connect incoming SIP message to current dialog or create new dialog structure */
 /*               Called by handle_request, sipsock_read */
-static struct sip_pvt *find_call(struct sip_request *req, struct sockaddr_in *sin, const int intended_method)
+static struct sip_pvt *find_call(struct sip_request *req, struct sockaddr_in *sin, const int intended_method, const int replaces_callid)
 {
 	struct sip_pvt *p = NULL;
 	char *callid;
 	char *tag = "";
+	char *replaces;
 	char totag[128];
 	char fromtag[128];
+	char *c;
 
 	callid = get_header(req, "Call-ID");
 
+	if (replaces_callid) {
+	    replaces = get_header(req, "Replaces");
+	    c = strchr(replaces, ';');
+	    if (c)
+		*c = '\0';
+	    if (!ast_strlen_zero(replaces)) {
+		callid = replaces;
+	    } else {
+		return NULL;
+	    }
+	}
+
 	if (pedanticsipchecking) {
 		/* In principle Call-ID's uniquely identify a call, but with a forking SIP proxy
 		   we need more to identify a branch - so we have to check branch, from
@@ -4233,6 +4249,7 @@
 	if (sipmethod == SIP_CANCEL) {
 		c = p->initreq.rlPart2;	/* Use original URI */
 	} else if (sipmethod == SIP_ACK) {
+// XXX+	} else if (!strcasecmp(msg, "ACK") && !p->dialog_established) {
 		/* Use URI from Contact: in 200 OK (if INVITE) 
 		(we only have the contacturi on INVITEs) */
 		if (!ast_strlen_zero(p->okcontacturi))
@@ -4584,6 +4601,10 @@
 		dest.sin_addr = p->redirip.sin_addr;
 		if (p->redircodecs)
 			capability = p->redircodecs;
+	} else if (p->rtpip.s_addr) {
+		if (option_verbose > 3) ast_log(LOG_NOTICE, "setting RTP IP to %s\n", ast_inet_ntoa(iabuf, sizeof(iabuf), p->rtpip));
+		dest.sin_addr = p->rtpip;
+		dest.sin_port = sin.sin_port;
 	} else {
 		dest.sin_addr = p->ourip;
 		dest.sin_port = sin.sin_port;
@@ -5046,13 +5067,15 @@
 		ast_build_string(&invite, &invite_max, ";%s", p->options->uri_options);
 
 	ast_copy_string(p->uri, invite_buf, sizeof(p->uri));
+	ast_copy_string(p->origuri, invite, sizeof(p->origuri));
 
 	if (sipmethod == SIP_NOTIFY && !ast_strlen_zero(p->theirtag)) { 
 		/* If this is a NOTIFY, use the From: tag in the subscribe (RFC 3265) */
 		snprintf(to, sizeof(to), "<sip:%s>;tag=%s", p->uri, p->theirtag);
 	} else if (p->options && p->options->vxml_url) {
 		/* If there is a VXML URL append it to the SIP URL */
-		snprintf(to, sizeof(to), "<%s>;%s", p->uri, p->options->vxml_url);
+//		snprintf(to, sizeof(to), "<%s>;%s", p->uri, p->options->vxml_url);
+		snprintf(to, sizeof(to), "<%s;%s>", p->uri, p->options->vxml_url);
 	} else {
 		snprintf(to, sizeof(to), "<%s>", p->uri);
 	}
@@ -5084,6 +5107,45 @@
 		add_header(req, "Remote-Party-ID", p->rpid);
 }
 
+static int transmit_sip_request(struct sip_pvt *p,struct sip_request *req);
+
+/*! \brief  sip_sendtext: Send SIP MESSAGE text within a call ---*/
+/*      Called from PBX core text message functions */
+static int sip_sendtext(struct ast_channel *ast, const char *dest, const char *text, int ispdu)
+{
+	struct sip_request req;
+	struct sip_pvt *p = ast->tech_pvt;
+	int debug=sip_debug_test_pvt(p);
+
+	if (debug)
+		ast_verbose("Sending text %s on %s\n", text, ast->name);
+	if (!p)
+		return -1;
+	if (ast_strlen_zero(text))
+		return 0;
+	if (ispdu) {
+		ast_log(LOG_WARNING, "Don't know how to send PDU on channel of type SIP\n");
+		return -1;
+	}
+
+	if (debug)
+		ast_verbose("Really sending text %s on %s\n", text, ast->name);
+
+	if ((ast->_state != AST_STATE_DOWN) && (ast->_state != AST_STATE_RESERVED)) {
+	    transmit_message_with_text(p, text);
+	} else {
+	    initreqprep(&req, p, SIP_MESSAGE);
+	    if (ast_sip_ouraddrfor(&p->sa.sin_addr, &p->ourip))
+		memcpy(&p->ourip, &__ourip, sizeof(p->ourip));
+	    build_via(p, p->via, sizeof(p->via));
+	    build_callid(p->callid, sizeof(p->callid), p->ourip, p->fromdomain);
+	    add_text(&req, text);
+	    transmit_sip_request(p, &req);
+	    sip_scheddestroy(p, 15000);
+	}
+	return 0;	
+}
+
 /*! \brief  transmit_invite: Build REFER/INVITE/OPTIONS message and transmit it ---*/
 static int transmit_invite(struct sip_pvt *p, int sipmethod, int sdp, int init)
 {
@@ -5110,6 +5172,11 @@
 		if (!ast_strlen_zero(p->referred_by))
 			add_header(&req, "Referred-By", p->referred_by);
 	}
+	if (sipmethod == SIP_INVITE) {
+	    if (!ast_strlen_zero(p->refer_replaces)) {
+		add_header(&req, "Replaces", p->refer_replaces);
+	    }
+	}
 #ifdef OSP_SUPPORT
 	if ((req.method != SIP_OPTIONS) && p->options && !ast_strlen_zero(p->options->osptoken)) {
 		ast_log(LOG_DEBUG,"Adding OSP Token: %s\n", p->options->osptoken);
@@ -5184,7 +5251,7 @@
 }
 
 /*! \brief  transmit_state_notify: Used in the SUBSCRIBE notification subsystem ----*/
-static int transmit_state_notify(struct sip_pvt *p, int state, int full, int substate, int timeout)
+static int transmit_state_notify(struct sip_pvt *p, int state, int full, int substate, int timeout, char *cid_num, char *cid_name)
 {
 	char tmp[4000], from[256], to[256];
 	char *t = tmp, *c, *a, *mfrom, *mto;
@@ -6214,8 +6281,10 @@
 		p->expire = -1;
 	pvt->expiry = expiry;
 	snprintf(data, sizeof(data), "%s:%d:%d:%s:%s", ast_inet_ntoa(iabuf, sizeof(iabuf), p->addr.sin_addr), ntohs(p->addr.sin_port), expiry, p->username, p->fullcontact);
-	if (!ast_test_flag((&p->flags_page2), SIP_PAGE2_RT_FROMCONTACT)) 
+	if (!ast_test_flag((&p->flags_page2), SIP_PAGE2_RT_FROMCONTACT)) {
+	//	ast_log(LOG_NOTICE, "updating SIP/Registry for peer %s with data %s\n", p->name, data);
 		ast_db_put("SIP/Registry", p->name, data);
+	}
 	manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "Peer: SIP/%s\r\nPeerStatus: Registered\r\n", p->name);
 	if (inaddrcmp(&p->addr, &oldsin)) {
 		sip_poke_peer(p);
@@ -6606,7 +6675,7 @@
 /*! \brief  cb_extensionstate: Callback for the devicestate notification (SUBSCRIBE) support subsystem ---*/
 /*    If you add an "hint" priority to the extension in the dial plan,
       you will get notifications on device state changes */
-static int cb_extensionstate(char *context, char* exten, int state, void *data)
+static int cb_extensionstate(char *context, char* exten, int state, void *data, char *cid_num, char *cid_name)
 {
 	struct sip_pvt *p = data;
 
@@ -6627,7 +6696,7 @@
 		p->laststate = state;
 		break;
 	}
-	transmit_state_notify(p, state, 1, 1, 0);
+	transmit_state_notify(p, state, 1, 1, 0, cid_num, cid_name);
 
 	if (option_verbose > 1)
 		ast_verbose(VERBOSE_PREFIX_1 "Extension Changed %s new state %s for Notify User %s\n", exten, ast_extension_state2str(state), p->username);
@@ -6656,7 +6725,13 @@
 	char *name, *c;
 	char *t;
 	char *domain;
-
+	char *callid;
+	struct sip_peer *clone;
+	char clone_name[256];
+	int found = 0;
+	struct sip_peer *recycle_peer = NULL;
+	char peer_name[256];
+	
 	/* Terminate URI */
 	t = uri;
 	while(*t && (*t > 32) && (*t != ';'))
@@ -6709,9 +6784,68 @@
 			ast_log(LOG_ERROR, "Peer '%s' is trying to register, but not configured as host=dynamic\n", peer->name);
 			res = -5;
 		} else {
+			callid = get_header(req, "Call-ID");
+			ast_copy_string(peer_name, peer->name, sizeof(peer_name));
+			if (peer->max_regs > 1) {
+			    int i = 0;
+			    /* check if peer matches callid */
+			    if ((peer->expire > -1) && (!strncmp(peer->reg_callid, callid, strlen(callid)))) {
+			//	ast_log(LOG_NOTICE, "peer->reg_callid %s, req->callid %s found in peer\n", peer->reg_callid, callid);
+				found++;
+			    } else {
+				/* otherwise check subpeers for callid */
+				for (i=0; i<peer->max_regs - 1; i++) {
+				    snprintf(clone_name, sizeof(clone_name), "%s@%d", peer->name, i);
+				//    ast_log(LOG_NOTICE, "checking subpeer %s\n", clone_name);
+				    clone = find_peer(clone_name, NULL, 1);
+				    if (clone && (clone->expire > -1)) {
+					if (!strncmp(clone->reg_callid, callid, strlen(callid))) {
+					//    ast_log(LOG_NOTICE, "clone->reg_callid %s, req->callid %s found in subpeer\n", clone->reg_callid, callid);
+					    found++;
+					    peer = clone;
+					    break;
+					}
+				    }
+				}
+			    }
+			    if (!found) {
+			//	ast_log(LOG_NOTICE, "did not find callid in peer or subpeer\n");
+				/* choose the next best peer or subpeer (that means: find the peer with the smalles expiry time */
+				if (peer->expire == -1) {
+				    recycle_peer = peer;
+			//	    ast_log(LOG_NOTICE, "peer %s expiry %d\n", peer->name, peer->expire);
+				} else {
+				    for (i=0; i<peer->max_regs - 1; i++) {
+					snprintf(clone_name, sizeof(clone_name), "%s@%d", peer->name, i);
+					clone = find_peer(clone_name, NULL, 1);
+				        if (clone) {
+					    if (clone->expire == -1) {
+						recycle_peer = clone;
+					        break;
+					    }
+			//		ast_log(LOG_NOTICE, "clone %s expiry %d\n", clone->name, clone->expire);
+					}
+				    }	
+				}
+				if (recycle_peer) {
+				    peer = recycle_peer;
+				    ast_copy_string(peer_name, peer->name, sizeof(peer_name));
+				//    ast_log(LOG_NOTICE, "recycling peer %s\n", peer->name);
+				    if (peer->subpeer) {
+					i = strchr(peer_name, '@') - peer_name;
+				        if (i < sizeof(peer_name))
+					    peer_name[i] = '\0';
+				//	ast_log(LOG_NOTICE, "i = %d\n", i);
+				    }
+				} else {
+				    /* deny registration */
+				    peer_name[0] = '\0';
+				}
+			    }
+			}
 			ast_copy_flags(p, peer, SIP_NAT);
 			transmit_response(p, "100 Trying", req);
-			if (!(res = check_auth(p, req, p->randdata, sizeof(p->randdata), peer->name, peer->secret, peer->md5secret, SIP_REGISTER, uri, 0, ignore))) {
+			if (!(res = check_auth(p, req, p->randdata, sizeof(p->randdata), peer_name, peer->secret, peer->md5secret, SIP_REGISTER, uri, 0, ignore))) {
 				sip_cancel_destroy(p);
 
 				switch (parse_register_contact(p, peer, req)) {
@@ -6732,6 +6866,7 @@
 					transmit_response_with_date(p, "200 OK", req);
 					peer->lastmsgssent = -1;
 					res = 0;
+					ast_copy_string(peer->reg_callid, callid, sizeof(peer->reg_callid));
 					break;
 				}
 			} 
@@ -7099,6 +7234,11 @@
 			/* XXX The refer_to could contain a call on an entirely different machine, requiring an 
 	    		  INVITE with a replaces header -anthm XXX */
 			/* The only way to find out is to use the dialplan - oej */
+			ast_copy_string(sip_pvt->refer_to, refer_to, sizeof(sip_pvt->refer_to));
+			ast_copy_string(sip_pvt->referred_by, referred_by, sizeof(sip_pvt->referred_by));
+			ast_copy_string(sip_pvt->refer_contact, h_contact, sizeof(sip_pvt->refer_contact));
+			ast_copy_string(sip_pvt->refer_replaces, replace_callid, sizeof(sip_pvt->referred_by));
+			return 2;
 		}
 	} else if (ast_exists_extension(NULL, *transfercontext, refer_to, 1, NULL) || !strcmp(refer_to, ast_parking_ext())) {
 		/* This is an unsupervised transfer (blind transfer) */
@@ -7829,6 +7969,8 @@
 	int peers_offline = 0;
 	char *id;
 	char idtext[256] = "";
+	char *tmp;
+	int i = 0;
 
 	if (s) {	/* Manager - get ActionID */
 		id = astman_get_header(m,"ActionID");
@@ -7871,6 +8013,7 @@
 		else
 			ast_copy_string(name, iterator->name, sizeof(name));
 
+	if ((iterator->expire != -1) || (iterator->subpeer != 1)) {
 		pstatus = peer_status(iterator, status, sizeof(status));
 		if (pstatus) 	
 			peers_online++;
@@ -7887,14 +8030,24 @@
 			}
 		}			
 		
-		snprintf(srch, sizeof(srch), FORMAT, name,
+	}	
+		/* multiple registration, peer used ? */
+		if ((iterator->expire != -1) || (iterator->subpeer != 1)) {
+		    snprintf(srch, sizeof(srch), FORMAT, name,
 			iterator->addr.sin_addr.s_addr ? ast_inet_ntoa(iabuf, sizeof(iabuf), iterator->addr.sin_addr) : "(Unspecified)",
 			ast_test_flag(&iterator->flags_page2, SIP_PAGE2_DYNAMIC) ? " D " : "   ", 	/* Dynamic or not? */
 			(ast_test_flag(iterator, SIP_NAT) & SIP_NAT_ROUTE) ? " N " : "   ",	/* NAT=yes? */
 			iterator->ha ? " A " : "   ", 	/* permit/deny */
 			ntohs(iterator->addr.sin_port), status);
+		}
 
 		if (!s)  {/* Normal CLI list */
+		    if ((iterator->expire != -1) || (iterator->subpeer != 1)) {
+			if (iterator->subpeer == 1) {
+			    tmp = strchr(name, '@');
+			    i = tmp - name;
+			    name[i] = '\0';
+			}
 			ast_cli(fd, FORMAT, name, 
 			iterator->addr.sin_addr.s_addr ? ast_inet_ntoa(iabuf, sizeof(iabuf), iterator->addr.sin_addr) : "(Unspecified)",
 			ast_test_flag(&iterator->flags_page2, SIP_PAGE2_DYNAMIC) ? " D " : "   ",  /* Dynamic or not? */
@@ -7902,6 +8055,7 @@
 			iterator->ha ? " A " : "   ",       /* permit/deny */
 			
 			ntohs(iterator->addr.sin_port), status);
+		    }
 		} else {	/* Manager format */
 			/* The names here need to be the same as other channels */
 			ast_cli(fd, 
@@ -7927,7 +8081,9 @@
 
 		ASTOBJ_UNLOCK(iterator);
 
-		total_peers++;
+		if ((iterator->expire != -1) || (iterator->subpeer != 1)) {
+		    total_peers++;
+		}
 	} while(0) );
 
 	if (!s) {
@@ -8963,7 +9119,8 @@
 	char buf[1024];
 	unsigned int event;
 	char * c = NULL;
-	
+	struct ast_call_feature *feature;
+
 	if (sip_debug_test_pvt(p))
 		ast_log(LOG_NOTICE, "Receiving INFO from %s\n", p->callid);
 
@@ -9029,6 +9186,19 @@
 			ast_queue_control(p->owner, AST_CONTROL_VIDUPDATE);
 		transmit_response(p, "200 OK", req);
 		return;
+	} else if ((c = get_header(req, "Record"))) {
+		feature = ast_find_builtin_feature("automon");
+		if (feature && (!ast_strlen_zero(feature->exten))) {
+		    int i = 0;
+//		    ast_log(LOG_NOTICE, "feature exten %s\n", feature->exten);
+		    for (i=0; i<strlen(feature->exten); i++) {
+			struct ast_frame f = { AST_FRAME_DTMF, feature->exten[i] };
+			ast_queue_frame(p->owner, &f); 
+		    }
+		} else {
+		    ast_log(LOG_NOTICE, "Feature \"One Touch Monitor\" not configured in features.conf.\n");
+		}
+		return;
 	} else if ((c = get_header(req, "X-ClientCode"))) {
 		/* Client code (from SNOM phone) */
 		if (ast_test_flag(p, SIP_USECLIENTCODE)) {
@@ -9128,12 +9298,63 @@
 	return RESULT_SUCCESS;
 }
 
+
+/*! \brief  sip_notify: Send SIP notify to peer */
+static int sip_send_notify(int fd, char *notify_type, char *peer)
+{
+	struct ast_variable *varlist;
+	struct sip_pvt *p;
+	struct sip_request req;
+	struct ast_variable *var;
+
+	varlist = ast_variable_browse(notify_types, notify_type);
+
+	if (!varlist) {
+		if (fd > 0)
+		    ast_cli(fd, "Unable to find notify type '%s'\n", notify_type);
+		return RESULT_FAILURE;
+	}
+
+	p = sip_alloc(NULL, NULL, 0, SIP_NOTIFY);
+	if (!p) {
+		ast_log(LOG_WARNING, "Unable to build sip pvt data for notify\n");
+		return RESULT_FAILURE;
+	}
+
+	if (create_addr(p, peer)) {
+		/* Maybe they're not registered, etc. */
+		sip_destroy(p);
+		if (fd > 0)
+		    ast_cli(fd, "Could not create address for '%s'\n", peer);
+		return RESULT_FAILURE;
+	}
+
+	initreqprep(&req, p, SIP_NOTIFY);
+
+	for (var = varlist; var; var = var->next)
+		add_header(&req, var->name, var->value);
+
+	add_blank_header(&req);
+	/* Recalculate our side, and recalculate Call ID */
+	if (ast_sip_ouraddrfor(&p->sa.sin_addr, &p->ourip))
+		memcpy(&p->ourip, &__ourip, sizeof(p->ourip));
+	build_via(p, p->via, sizeof(p->via));
+	build_callid(p->callid, sizeof(p->callid), p->ourip, p->fromdomain);
+	if (fd > 0)
+	    ast_cli(fd, "Sending NOTIFY of type '%s' to '%s'\n", notify_type, peer);
+	transmit_sip_request(p, &req);
+	sip_scheddestroy(p, 15000);
+
+	return RESULT_SUCCESS;
+}
+
 /*! \brief  sip_notify: Send SIP notify to peer */
 static int sip_notify(int fd, int argc, char *argv[])
 {
 	struct ast_variable *varlist;
 	int i;
-
+	int res = RESULT_SUCCESS;
+	
 	if (argc < 4)
 		return RESULT_SHOWUSAGE;
 
@@ -9150,41 +9371,13 @@
 	}
 
 	for (i = 3; i < argc; i++) {
-		struct sip_pvt *p;
-		struct sip_request req;
-		struct ast_variable *var;
-
-		p = sip_alloc(NULL, NULL, 0, SIP_NOTIFY);
-		if (!p) {
-			ast_log(LOG_WARNING, "Unable to build sip pvt data for notify\n");
-			return RESULT_FAILURE;
-		}
-
-		if (create_addr(p, argv[i])) {
-			/* Maybe they're not registered, etc. */
-			sip_destroy(p);
-			ast_cli(fd, "Could not create address for '%s'\n", argv[i]);
-			continue;
-		}
-
-		initreqprep(&req, p, SIP_NOTIFY);
-
-		for (var = varlist; var; var = var->next)
-			add_header(&req, var->name, var->value);
+		if (sip_send_notify(fd, argv[2], argv[i]) == RESULT_FAILURE) 
+		    res = RESULT_FAILURE;
+    	}
+	return res;
+}
 
-		add_blank_header(&req);
-		/* Recalculate our side, and recalculate Call ID */
-		if (ast_sip_ouraddrfor(&p->sa.sin_addr, &p->ourip))
-			memcpy(&p->ourip, &__ourip, sizeof(p->ourip));
-		build_via(p, p->via, sizeof(p->via));
-		build_callid(p->callid, sizeof(p->callid), p->ourip, p->fromdomain);
-		ast_cli(fd, "Sending NOTIFY of type '%s' to '%s'\n", argv[2], argv[i]);
-		transmit_sip_request(p, &req);
-		sip_scheddestroy(p, 15000);
-	}
 
-	return RESULT_SUCCESS;
-}
 /*! \brief  sip_do_history: Enable SIP History logging (CLI) ---*/
 static int sip_do_history(int fd, int argc, char *argv[])
 {
@@ -9852,7 +10045,7 @@
 		if (!ignore && p->owner) {
 			ast_queue_control(p->owner, AST_CONTROL_RINGING);
 			if (p->owner->_state != AST_STATE_UP)
-				ast_setstate(p->owner, AST_STATE_RINGING);
+				ast_setstate_and_cid(p->owner, AST_STATE_RINGING, p->owner->cid.cid_num, p->owner->cid.cid_name);
 		}
 		if (find_sdp(req)) {
 			process_sdp(p, req);
@@ -10562,6 +10755,8 @@
 static int attempt_transfer(struct sip_pvt *p1, struct sip_pvt *p2)
 {
 	int res = 0;
+	struct sip_request req;
+	struct sip_pvt *p = NULL;
 	struct ast_channel 
 		*chana = NULL,
 		*chanb = NULL,
@@ -10571,6 +10766,9 @@
 		*peerb = NULL,
 		*peerc = NULL,
 		*peerd = NULL;
+/*	char tmp[500];
+	char *t = tmp;
+	size_t maxbytes = sizeof(tmp); */
 
 	if (!p1->owner || !p2->owner) {
 		ast_log(LOG_WARNING, "Transfer attempted without dual ownership?\n");
@@ -10599,6 +10797,12 @@
 		ast_quiet_chan(peerc);
 		ast_quiet_chan(peerd);
 
+/*		ast_log(LOG_NOTICE, "channel a %s -> callerid %s\n", peera->name, peera->cid.cid_num);
+		ast_log(LOG_NOTICE, "channel b %s -> callerid %s\n", peerb->name, peerb->cid.cid_num);
+		ast_log(LOG_NOTICE, "channel c %s -> callerid %s\n", peerc->name, peerc->cid.cid_num);
+		ast_log(LOG_NOTICE, "channel d %s -> callerid %s\n", peerd->name, peerd->cid.cid_num); 
+		p = peerd->tech_pvt;  */
+
 		if (peera->cdr && peerb->cdr) {
 			peerb->cdr = ast_cdr_append(peerb->cdr, peera->cdr);
 		} else if (peera->cdr) {
@@ -10617,6 +10821,13 @@
 			ast_log(LOG_WARNING, "Failed to masquerade %s into %s\n", peerb->name, peerc->name);
 			res = -1;
 		}
+/*		reqprep(&req, p, SIP_INFO, 0, 1);
+		add_header(&req, "Content-Type", "message/sipfrag");
+		ast_build_string(&t, &maxbytes, "From: \"%s\"\r\n", peerd->cid.cid_num);
+		ast_build_string(&t, &maxbytes, "To: \"%s\"\r\n", peerc->cid.cid_num);
+		add_header_contentLength(&req, strlen(tmp));
+		add_line(&req, tmp);
+		send_request(p, &req, 0, p->ocseq); */
 		return res;
 	} else {
 		ast_log(LOG_NOTICE, "Transfer attempted with no appropriate bridged calls to transfer\n");
@@ -10628,7 +10839,6 @@
 	}
 	return 0;
 }
-
 /*! \brief  gettag: Get tag from packet */
 static char *gettag(struct sip_request *req, char *header, char *tagbuf, int tagbufsize) 
 {
@@ -10981,6 +11191,7 @@
 	int res;
 	struct ast_channel *transfer_to;
 	char *transfercontext = NULL;
+	struct sip_pvt *rp; /* replace call */
 
 	if (option_debug > 2)
 		ast_log(LOG_DEBUG, "SIP call transfer received for call %s (REFER)!\n", p->callid);
@@ -10991,9 +11202,73 @@
 		transfercontext = p->context;
 	if (res < 0)
 		transmit_response(p, "603 Declined", req);
-	else if (res > 0)
+	else if (res == 1)
 		transmit_response(p, "484 Address Incomplete", req);
-	else {
+	else if (res == 2) {
+		transmit_response(p, "202 Accepted", req);
+		rp = sip_alloc(NULL, NULL, 0, SIP_INVITE);
+		if (!rp) {
+		    return -1;
+		}
+		rp->capability = global_capability;
+
+		build_route(rp, req, 0);
+		if (option_verbose > 3)
+		    ast_log(LOG_NOTICE, "got REFER for callid %s TO %s CONTACT %s replacing callid %s (tohost %s, p->route %s, rp->route %s)\n", p->callid, p->refer_to, p->refer_contact, p->refer_replaces, p->tohost, p->route->hop, rp->route->hop);
+		    if (create_addr(rp, p->tohost)) {
+	    	        sip_destroy(rp);
+			return -1;
+		    }
+
+		if (ast_sip_ouraddrfor(&rp->sa.sin_addr,&rp->ourip)) {
+		    memcpy(&rp->ourip, &__ourip, sizeof(rp->ourip));
+		}
+		build_via(rp, rp->via, sizeof(rp->via));
+		build_callid(rp->callid, sizeof(rp->callid) - 1, rp->ourip, rp->fromdomain);
+ 	
+	    ast_log(LOG_NOTICE, "1\n");
+		rp->prefcodec = p->prefcodec;
+		rp->jointcapability = rp->capability;
+		rp->rtp = p->rtp;
+		p->rtp = NULL;
+		if (!ast_strlen_zero(p->refer_to)) {
+		    ast_copy_string(rp->username, p->refer_to, sizeof(rp->username));
+		    rp->fullcontact[0] = '\0';
+		}
+		if (!ast_strlen_zero(p->refer_replaces)) {
+		    ast_copy_string(rp->refer_replaces, p->refer_replaces, sizeof(rp->refer_replaces));
+		}
+	    ast_log(LOG_NOTICE, "2\n");
+			ast_set_flag(rp, SIP_OUTGOING);
+			
+	    ast_log(LOG_NOTICE, "3\n");
+
+			if (p->owner) {
+			    c = p->owner;
+//			    ast_copy_string(rp->cid_num, c->cid.cid_num, sizeof(rp->cid_num));
+//			    ast_copy_string(rp->cid_name, c->cid.cid_name, sizeof(rp->cid_name));
+	    ast_log(LOG_NOTICE, "4\n");
+			    c->tech_pvt = rp;
+			    rp->owner = c;
+	    ast_log(LOG_NOTICE, "5\n");
+			    ast_mutex_unlock(&c->lock);
+			}
+			p->owner = NULL;
+	    ast_log(LOG_NOTICE, "6\n");
+
+			transmit_invite(rp, SIP_INVITE, 1, 2);
+			if (rp->maxtime) {
+			    /* Initialize auto-congest time */
+			    rp->initid = ast_sched_add(sched, rp->maxtime * 4, auto_congest, rp);
+			}
+
+ 			transmit_notify_with_sipfrag(p, seqno);
+
+			/* Always increment on a BYE */
+			transmit_request_with_auth(p, SIP_BYE, 0, 1, 1);
+			ast_set_flag(p, SIP_ALREADYGONE);
+			return 0;
+	} else { /* res == 0 */
 		int nobye = 0;
 		if (!ignore) {
 			if (p->refer_call) {
@@ -11356,7 +11631,7 @@
 			struct sip_pvt *p_old;
 
 			transmit_response(p, "200 OK", req);
-			transmit_state_notify(p, firststate, 1, 1, 0);	/* Send first notification */
+			transmit_state_notify(p, firststate, 1, 1, 0, NULL, NULL);	/* Send first notification */
 			append_history(p, "Subscribestatus", ast_extension_state2str(firststate));
 
 			/* remove any old subscription from this peer for the same exten/context,
@@ -11571,6 +11846,8 @@
 		res = handle_request_options(p, req, debug);
 		break;
 	case SIP_INVITE:
+		/* XXX quick fix for xfers */
+		ast_copy_string(p->tohost, ast_inet_ntoa(iabuf, sizeof(iabuf), sin->sin_addr), sizeof(p->tohost));
 		res = handle_request_invite(p, req, debug, ignore, seqno, sin, recount, e);
 		break;
 	case SIP_REFER:
@@ -11696,7 +11973,7 @@
 	/* Process request, with netlock held */
 retrylock:
 	ast_mutex_lock(&netlock);
-	p = find_call(&req, &sin, req.method);
+	p = find_call(&req, &sin, req.method, 0);
 	if (p) {
 		/* Go ahead and lock the owner if it has one -- we may need it */
 		if (p->owner && ast_mutex_trylock(&p->owner->lock)) {
@@ -12048,6 +12325,52 @@
 	return 0;
 }
 
+static char mandescr_sip_notify[] = 
+"Description: Send a NOTIFY message to one or more SIP peers.\n"
+"Variables: \n"
+"  Peer: <name>           The peer name you want to send a NOTIFY to.\n"
+"  Type: <name>           The notify type (see sip_notify.conf).\n"
+"  ActionID: <id>	  Optional action ID for this AMI transaction.\n";
+
+/*! \brief  manager_sip_notify: Send a notify (see sip_notify.conf) to a peer ---*/
+static int manager_sip_notify(struct mansession *s, struct message *m)
+{
+	char *id = astman_get_header(m,"ActionID");
+	char *peer;
+	char *notify_type;
+	int res = 0;
+
+	peer = astman_get_header(m,"Peer");
+	if (ast_strlen_zero(peer)) {
+		astman_send_error(s, m, "Peer: <name> missing.\n");
+		return 0;
+	}
+	notify_type = astman_get_header(m,"Type");
+	if (ast_strlen_zero(notify_type)) {
+		astman_send_error(s, m, "Type: <name> missing.\n");
+		return 0;
+	}
+
+	res = sip_send_notify(-1, notify_type, peer);
+	if (res != RESULT_SUCCESS) {
+	    ast_cli(s->fd, "Response: SIPNotify Failure\r\n"
+			"Peer: %s\r\n"
+			"Type: %s\r\n"
+			"ActionID: %s\r\n"
+			"\r\n",
+			peer, notify_type, id);
+	} else {
+	    ast_cli(s->fd, "Response: SIPNotify Success\r\n"
+			"Peer: %s\r\n"
+			"Type: %s\r\n"
+			"ActionID: %s\r\n"
+			"\r\n",
+			peer, notify_type, id);
+	}
+	return res;
+}
+
+
 /*! \brief  sip_devicestate: Part of PBX channel interface ---*/
 
 /* Return values:---
@@ -12119,9 +12442,13 @@
 {
 	int oldformat;
 	struct sip_pvt *p;
+	struct sip_peer *peer = NULL;
 	struct ast_channel *tmpc = NULL;
 	char *ext, *host;
 	char tmp[256];
+	char *number = NULL;
+	int strip = 0;
+	int ton = 0; /* 0 local, 1 national, 2 international */
 	char *dest = data;
 
 	oldformat = format;
@@ -12184,6 +12511,54 @@
 	if (ext) {
 		ast_copy_string(p->username, ext, sizeof(p->username));
 		p->fullcontact[0] = 0;	
+		peer = find_peer(host, NULL, 1);
+		if (peer) {
+		    if (peer->dialplan != SIP_DIALPLAN_LOCAL) {
+			/* do the dialplan thingie */
+			if (!ast_strlen_zero(peer->internationalprefix)) {
+			    number = strstr(p->username, peer->internationalprefix);
+			    if (number == p->username) {
+				strip += strlen(peer->internationalprefix);
+				if (option_verbose > 4) ast_log(LOG_NOTICE, "found int prefix, rest is %s\n",number+strip); 
+			    }
+			    ton = 2;
+			}
+			if (!ast_strlen_zero(peer->nationalprefix)) {
+			    number = strstr(p->username + strip, peer->nationalprefix);
+			    if (number == p->username + strip) {
+				strip += strlen(peer->nationalprefix);
+			        if (option_verbose > 4) ast_log(LOG_NOTICE, "found national prefix, rest is %s\n",number+strip); 
+			    }
+			    ton += 1;
+			}
+			if (peer->dialplan == SIP_DIALPLAN_INTERNATIONAL) {
+			    if (ton == 1) {
+				char tmp[128];
+				/* add countrycode */
+				snprintf(tmp, sizeof(tmp) - 1, "%s%s", peer->countrycode, p->username + strip);
+				ast_copy_string(p->username, tmp, sizeof(p->username));
+			    } else {
+				snprintf(tmp, sizeof(tmp) - 1, "%s", p->username + strip);
+				ast_copy_string(p->username, tmp, sizeof(p->username));
+			    }
+			}
+			if (option_verbose > 4) ast_log(LOG_NOTICE, "calling %s\n", p->username);
+		    }
+		    if (!ast_strlen_zero(peer->prefix)) {
+			char tmp[128];
+			snprintf(tmp, sizeof(tmp) - 1, "%s%s", peer->prefix, p->username);
+			ast_copy_string(p->username, tmp, sizeof(p->username));
+			if (option_verbose > 4) ast_log(LOG_NOTICE, "calling %s (prefix %s)\n", p->username, peer->prefix);
+		    }
+		    if (peer->rtpip.s_addr) {
+			memcpy(&p->rtpip, &peer->rtpip, sizeof(p->rtpip)); 
+			if (p->rtp) {
+			    ast_rtp_destroy(p->rtp);
+			}
+			p->rtp = ast_rtp_new_with_bindaddr(sched, io, 1, 0, p->rtpip);
+		    }
+		    
+		}
 	}
 #if 0
 	printf("Setting up to call extension '%s' at '%s'\n", ext ? ext : "<none>", host);
@@ -12582,6 +12957,7 @@
 
 	peer->expire = -1;
 	peer->pokeexpire = -1;
+	peer->max_regs = 1;
 	ast_copy_string(peer->name, name, sizeof(peer->name));
 	ast_copy_flags(peer, &global_flags, SIP_FLAGS_TO_COPY);
 	strcpy(peer->context, default_context);
@@ -12610,6 +12986,8 @@
 	int obproxyfound=0;
 	int found=0;
 	int format=0;		/* Ama flags */
+	struct ast_hostent ahp;
+	struct hostent *hp;
 	time_t regseconds;
 	char *varname = NULL, *varval = NULL;
 	struct ast_variable *tmpvar = NULL;
@@ -12627,7 +13005,9 @@
 
 	if (peer) {
 		/* Already in the list, remove it and it will be added back (or FREE'd)  */
-		found = 1;
+		if (peer->max_regs == 1) {
+		    found = 1;
+		}
  	} else {
 		peer = malloc(sizeof(*peer));
 		if (peer) {
@@ -12639,6 +13019,7 @@
 			ASTOBJ_INIT(peer);
 			peer->expire = -1;
 			peer->pokeexpire = -1;
+			peer->max_regs = 1;
 		} else {
 			ast_log(LOG_WARNING, "Can't allocate SIP peer memory\n");
 		}
@@ -12787,6 +13168,10 @@
 			peer->call_limit = atoi(v->value);
 			if (peer->call_limit < 0)
 				peer->call_limit = 0;
+		} else if (!strcasecmp(v->name, "registrations")) {
+			peer->max_regs = atoi(v->value);
+			if (peer->max_regs < 0)
+				peer->max_regs = 0;
 		} else if (!strcasecmp(v->name, "amaflags")) {
 			format = ast_cdr_amaflags2int(v->value);
 			if (format < 0) {
@@ -12845,6 +13230,26 @@
 				ast_log(LOG_WARNING, "Qualification of peer '%s' should be 'yes', 'no', or a number of milliseconds at line %d of sip.conf\n", peer->name, v->lineno);
 				peer->maxms = 0;
 			}
+		} else if (!strcasecmp(v->name, "prefix")) {
+			ast_copy_string(peer->prefix, v->value, sizeof(peer->prefix));
+		} else if (!strcasecmp(v->name, "nationalprefix")) {
+			ast_copy_string(peer->nationalprefix, v->value, sizeof(peer->nationalprefix));
+		} else if (!strcasecmp(v->name, "internationalprefix")) {
+			ast_copy_string(peer->internationalprefix, v->value, sizeof(peer->internationalprefix));
+		} else if (!strcasecmp(v->name, "countrycode")) {
+			ast_copy_string(peer->countrycode, v->value, sizeof(peer->countrycode));
+		} else if (!strcasecmp(v->name, "dialplan")) {
+			if (!strcasecmp(v->value, "international")) {
+			    peer->dialplan = SIP_DIALPLAN_INTERNATIONAL;
+			} else {
+			    peer->dialplan = SIP_DIALPLAN_LOCAL;
+			}
+		} else if (!strcasecmp(v->name, "rtpip")) {
+			if (!(hp = ast_gethostbyname(v->value, &ahp))) {
+				ast_log(LOG_WARNING, "Invalid address: %s\n", v->value);
+			} else {
+				memcpy(&peer->rtpip, hp->h_addr, sizeof(peer->rtpip));
+			}
 		}
 		v = v->next;
 	}
@@ -13177,9 +13582,25 @@
 				if (!strcasecmp(utype, "peer") || !strcasecmp(utype, "friend")) {
 					peer = build_peer(cat, ast_variable_browse(cfg, cat), 0);
 					if (peer) {
-						ast_device_state_changed("SIP/%s", peer->name);
-						ASTOBJ_CONTAINER_LINK(&peerl,peer);
-						ASTOBJ_UNREF(peer, sip_destroy_peer);
+					    if (peer->max_regs > 1) {
+						int i = 0;
+						int clones = peer->max_regs - 1;
+						struct sip_peer *clone = NULL;
+						char clone_name[sizeof(clone->name)];
+						/* clone clone clone */
+						for (i=0;i<clones;i++) {
+						    snprintf(clone_name, sizeof(clone_name), "%s@%d", cat, i);
+						    clone = build_peer(clone_name, ast_variable_browse(cfg, cat), 0);
+						    if (clone) {
+							clone->subpeer = 1;
+							ast_device_state_changed("SIP/%s", peer->name);
+							ASTOBJ_CONTAINER_LINK(&peerl,clone);
+							ASTOBJ_UNREF(clone, sip_destroy_peer);
+						    }
+						}
+					    }
+					    ASTOBJ_CONTAINER_LINK(&peerl,peer);
+					    ASTOBJ_UNREF(peer, sip_destroy_peer);
 					}
 				} else if (strcasecmp(utype, "user")) {
 					ast_log(LOG_WARNING, "Unknown type '%s' for '%s' in %s\n", utype, cat, "sip.conf");
@@ -13781,6 +14202,8 @@
 			"List SIP peers (text format)", mandescr_show_peers);
 	ast_manager_register2("SIPshowpeer", EVENT_FLAG_SYSTEM, manager_sip_show_peer,
 			"Show SIP peer (text format)", mandescr_show_peer);
+	ast_manager_register2("SIPNotify", EVENT_FLAG_SYSTEM, manager_sip_notify,
+			"Send NOTIFY to peer", mandescr_sip_notify);
 
 	sip_poke_all_peers();	
 	sip_send_all_registers();
@@ -13811,6 +14234,7 @@
 
 	ast_rtp_proto_unregister(&sip_rtp);
 
+	ast_manager_unregister("SIPNotify");
 	ast_manager_unregister("SIPpeers");
 	ast_manager_unregister("SIPshowpeer");
 
Index: asterisk-bristuff/channels/chan_zap.c
===================================================================
--- asterisk-bristuff.orig/channels/chan_zap.c	2007-10-20 00:35:42.000000000 +0200
+++ asterisk-bristuff/channels/chan_zap.c	2007-10-20 00:35:48.000000000 +0200
@@ -11,6 +11,10 @@
  * the project provides a web site, mailing lists and IRC
  * channels for your use.
  *
+ * Copyright (C) 2003-2006 Junghanns.NET GmbH
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
+ *
  * This program is free software, distributed under the terms of
  * the GNU General Public License Version 2. See the LICENSE file
  * at the top of the source tree.
@@ -65,6 +69,9 @@
 #ifdef ZAPATA_R2
 #include <libmfcr2.h>
 #endif
+#ifdef ZAPATA_GSM
+#include <libgsmat.h>
+#endif
 
 #include "asterisk.h"
 
@@ -96,6 +103,7 @@
 #include "asterisk/term.h"
 #include "asterisk/utils.h"
 #include "asterisk/transcap.h"
+#include "asterisk/devicestate.h"
 
 #ifndef ZT_SIG_EM_E1
 #error "Your zaptel is too old.  please cvs update"
@@ -173,6 +181,7 @@
 #define SIG_FXOGS	ZT_SIG_FXOGS
 #define SIG_FXOKS	ZT_SIG_FXOKS
 #define SIG_PRI		ZT_SIG_CLEAR
+#define SIG_GSM		(0x100000 | ZT_SIG_CLEAR)
 #define SIG_R2		ZT_SIG_CAS
 #define	SIG_SF		ZT_SIG_SF
 #define SIG_SFWINK 	(0x0100000 | ZT_SIG_SF)
@@ -183,7 +192,7 @@
 #define SIG_GR303FXOKS	(0x0100000 | ZT_SIG_FXOKS)
 #define SIG_GR303FXSKS	(0x0100000 | ZT_SIG_FXSKS)
 
-#define NUM_SPANS 		32
+#define NUM_SPANS 		128	/*!<"32 spans", muahahaha, us alaws like to have some more... */
 #define NUM_DCHANS		4	/*!< No more than 4 d-channels */
 #define MAX_CHANNELS	672		/*!< No more than a DS3 per trunk group */
 
@@ -198,6 +207,11 @@
 static char defaultcic[64] = "";
 static char defaultozz[64] = "";
 
+static char nocid[256] = "No CID available";
+static char withheldcid[256] = "CID withheld";
+static char gsm_modem_pin[20];
+static char gsm_modem_exten[AST_MAX_EXTENSION];
+
 static char language[MAX_LANGUAGE] = "";
 static char progzone[10]= "";
 
@@ -210,8 +224,6 @@
 #ifdef PRI_GETSET_TIMERS
 static int pritimers[PRI_MAX_TIMERS];
 #endif
-static int pridebugfd = -1;
-static char pridebugfilename[1024]="";
 #endif
 
 /*! \brief Wait up to 16 seconds for first digit (FXO logic) */
@@ -232,10 +244,6 @@
 
 static int ifcount = 0;
 
-#ifdef ZAPATA_PRI
-AST_MUTEX_DEFINE_STATIC(pridebugfdlock);
-#endif
-
 /*! \brief Protect the monitoring thread, so only one process can kill or start it, and not
    when it's doing something critical. */
 AST_MUTEX_DEFINE_STATIC(monlock);
@@ -248,7 +256,7 @@
 
 static enum ast_bridge_result zt_bridge(struct ast_channel *c0, struct ast_channel *c1, int flags, struct ast_frame **fo, struct ast_channel **rc, int timeoutms);
 
-static int zt_sendtext(struct ast_channel *c, const char *text);
+static int zt_sendtext(struct ast_channel *c, const char *dest, const char *text, int ispdu);
 
 /*! \brief Avoid the silly zt_getevent which ignores a bunch of events */
 static inline int zt_get_event(int fd)
@@ -282,6 +290,19 @@
 
 struct zt_pvt;
 
+#ifdef ZAPATA_GSM
+struct zt_gsm {
+	pthread_t master;
+	ast_mutex_t lock;		/* Mutex */
+	int fd;
+	int span;
+	struct gsm_modul *modul;
+	char pin[256];
+	int available;
+	char exten[AST_MAX_EXTENSION];		/* Where to idle extra calls */
+	struct zt_pvt *pvt;
+};
+#endif
 
 #ifdef ZAPATA_R2
 static int r2prot = -1;
@@ -296,6 +317,28 @@
 #define PRI_SPAN(p) (((p) >> 8) & 0xff)
 #define PRI_EXPLICIT(p) (((p) >> 16) & 0x01)
 
+struct zt_suspended_call {
+	ast_mutex_t lock;		/* Mutex */
+	char msn[AST_MAX_EXTENSION];	/* the MSN to which this parked call belongs */
+	char callid[10];			/* the callID provided by the user */
+	int parked_at;			/* extension in the call parking context */
+	struct zt_suspended_call *next;
+};
+
+struct zt_holded_call {
+	ast_mutex_t lock;		/* Mutex */
+	char msn[AST_MAX_EXTENSION];	/* the MSN to which this parked call belongs */
+	char uniqueid[AST_MAX_EXTENSION];	/* unique id of the onhold channel */
+	int tei;
+	int cref;
+	int alreadyhungup;
+	struct ast_channel *channel;
+	struct ast_channel *bridge;
+	q931_call *call;	/* this also covers tei mumbojumbo */
+	struct zt_holded_call *next;
+};
+
+
 struct zt_pri {
 	pthread_t master;						/*!< Thread of master */
 	ast_mutex_t lock;						/*!< Mutex */
@@ -309,6 +352,8 @@
 	int nsf;							/*!< Network-Specific Facilities */
 	int dialplan;							/*!< Dialing plan */
 	int localdialplan;						/*!< Local dialing plan */
+ 	char nocid[256];
+ 	char withheldcid[256];
 	char internationalprefix[10];					/*!< country access code ('00' for european dialplans) */
 	char nationalprefix[10];					/*!< area access code ('0' for european dialplans) */
 	char localprefix[20];						/*!< area access code + area code ('0'+area code for european dialplans) */
@@ -320,6 +365,7 @@
 	int prilogicalspan;						/*!< Logical span number within trunk group */
 	int numchans;							/*!< Num of channels we represent */
 	int overlapdial;						/*!< In overlap dialing mode */
+	int usercid;
 	int facilityenable;						/*!< Enable facility IEs */
 	struct pri *dchans[NUM_DCHANS];					/*!< Actual d-channels */
 	int dchanavail[NUM_DCHANS];					/*!< Whether each channel is available */
@@ -335,6 +381,9 @@
 	struct zt_pvt *pvts[MAX_CHANNELS];				/*!< Member channel pvt structs */
 	struct zt_pvt *crvs;						/*!< Member CRV structs */
 	struct zt_pvt *crvend;						/*!< Pointer to end of CRV structs */
+ 	struct zt_suspended_call *suspended_calls; /* Calls parked with SUSPEND messages */
+ 	struct zt_holded_call *holded_calls; /* Calls on hold */
+	int debugfd;
 };
 
 
@@ -430,6 +479,11 @@
 	char privateprefix[20];
 	char unknownprefix[20];
 	long resetinterval;
+	int usercid;
+	int priindication_oob;
+	int pritransfer;
+ 	char nocid[256];
+ 	char withheldcid[256];
 #endif
 };
 
@@ -535,6 +589,7 @@
 	int sendcalleridafter;
 
 	int priindication_oob;
+	int pritransfer;
 	int radio;
 };
 
@@ -548,6 +603,7 @@
 			.idleext = "",
 			.idledial = "",
 			.overlapdial = 0,
+			.usercid = 0,
 			.facilityenable = 0,
 			.internationalprefix = "",
 			.nationalprefix = "",
@@ -660,6 +716,7 @@
 		.sendcalleridafter = DEFAULT_CIDRINGS,
 
 		.priindication_oob = 0,
+		.pritransfer = 0,
 
 		/* Add fields above this comment. "radio" will be 
 		 * kept as the one without the comma. for the moment, 
@@ -712,6 +769,8 @@
 	unsigned int echocanbridged:1;
 	unsigned int echocanon:1;
 	unsigned int faxhandled:1;			/*!< Has a fax tone already been handled? */
+ 							/*!< KPJ: i will abuse this flag to implement a zapata option for dialing out
+ 							    on a zap channel with EC to be off no matter what happens. */
 	unsigned int firstradio:1;
 	unsigned int hanguponpolarityswitch:1;
 	unsigned int hardwaredtmf:1;
@@ -724,7 +783,8 @@
 	unsigned int overlapdial:1;
 	unsigned int permcallwaiting:1;
 	unsigned int permhidecallerid:1;		/*!< Whether to hide our outgoing caller ID or not */
-	unsigned int priindication_oob:1;
+	unsigned int priindication_oob:2;
+	unsigned int pritransfer:2;
 	unsigned int priexclusive:1;
 	unsigned int pulse:1;
 	unsigned int pulsedial:1;			/*!< whether a pulse dial phone is detected */
@@ -763,6 +823,7 @@
 #endif
 	char cid_num[AST_MAX_EXTENSION];
 	int cid_ton;					/*!< Type Of Number (TON) */
+	int cid_pres;					/*!< Calling Presentation */
 	char cid_name[AST_MAX_EXTENSION];
 	char lastcid_num[AST_MAX_EXTENSION];
 	char lastcid_name[AST_MAX_EXTENSION];
@@ -823,10 +884,15 @@
 	int polarityonanswerdelay;
 	struct timeval polaritydelaytv;
 	int sendcalleridafter;
+#ifdef ZAPATA_GSM
+	struct zt_gsm gsm;
+#endif
 #ifdef ZAPATA_PRI
 	struct zt_pri *pri;
 	struct zt_pvt *bearer;
 	struct zt_pvt *realcall;
+	int tei;					/* channel in use by this tei */
+	q931_call *holdedcall;
 	q931_call *call;
 	int prioffset;
 	int logicalspan;
@@ -842,7 +908,7 @@
 
 static struct ast_channel *zt_request(const char *type, int format, void *data, int *cause);
 static int zt_digit(struct ast_channel *ast, char digit);
-static int zt_sendtext(struct ast_channel *c, const char *text);
+static int zt_sendtext(struct ast_channel *c, const char *dest, const char *text, int ispdu);
 static int zt_call(struct ast_channel *ast, char *rdest, int timeout);
 static int zt_hangup(struct ast_channel *ast);
 static int zt_answer(struct ast_channel *ast);
@@ -852,11 +918,14 @@
 static int zt_indicate(struct ast_channel *chan, int condition);
 static int zt_fixup(struct ast_channel *oldchan, struct ast_channel *newchan);
 static int zt_setoption(struct ast_channel *chan, int option, void *data, int datalen);
+static int zt_devicestate(void *data);
+static void disable_dtmf_detect(struct zt_pvt *p);
+static void enable_dtmf_detect(struct zt_pvt *p);
 
 static const struct ast_channel_tech zap_tech = {
 	.type = type,
 	.description = tdesc,
-	.capabilities = AST_FORMAT_SLINEAR | AST_FORMAT_ULAW,
+	.capabilities = AST_FORMAT_SLINEAR | AST_FORMAT_ULAW | AST_FORMAT_ALAW,
 	.requester = zt_request,
 	.send_digit = zt_digit,
 	.send_text = zt_sendtext,
@@ -870,6 +939,7 @@
 	.indicate = zt_indicate,
 	.fixup = zt_fixup,
 	.setoption = zt_setoption,
+	.devicestate = zt_devicestate
 };
 
 #ifdef ZAPATA_PRI
@@ -881,6 +951,13 @@
 struct zt_pvt *round_robin[32];
 
 #ifdef ZAPATA_PRI
+struct app_tmp {
+	char app[256];
+	char data[256];
+	struct ast_channel *chan;
+	pthread_t t;
+};
+
 static inline int pri_grab(struct zt_pvt *pvt, struct zt_pri *pri)
 {
 	int res;
@@ -928,6 +1005,112 @@
 #define CANBUSYDETECT(p) (ISTRUNK(p) || (p->sig & (SIG_EM | SIG_EM_E1 | SIG_SF)) /* || (p->sig & __ZT_SIG_FXO) */)
 #define CANPROGRESSDETECT(p) (ISTRUNK(p) || (p->sig & (SIG_EM | SIG_EM_E1 | SIG_SF)) /* || (p->sig & __ZT_SIG_FXO) */)
 
+static int zt_devicestate(void *data)
+{
+	int groupmatch = 0;
+	int channelmatch = 0;
+	struct zt_pvt *p;
+	char *dest=NULL;
+	int x,d;
+	char *s;
+	char opt=0;
+	int res, y=0;
+	struct zt_pvt *exit, *start, *end;
+	ast_mutex_t *lock;
+
+//	ast_log(LOG_NOTICE, "data = %s\n", (char *)data);
+	return AST_DEVICE_UNKNOWN;
+	
+	/* Assume we're locking the iflock */
+	lock = &iflock;
+	start = iflist;
+	end = ifend;
+
+	if (data) {
+		dest = ast_strdupa((char *)data);
+	} else {
+		ast_log(LOG_WARNING, "Channel requested with no data\n");
+		return AST_DEVICE_INVALID;
+	}
+	if (toupper(dest[0]) == 'G' || toupper(dest[0])=='R') {
+		/* Retrieve the group number */
+		char *stringp=NULL;
+		stringp=dest + 1;
+		s = strsep(&stringp, "/");
+		if ((res = sscanf(s, "%d%c%d", &x, &opt, &y)) < 1) {
+			ast_log(LOG_WARNING, "Unable to determine group for data %s\n", (char *)data);
+			return AST_DEVICE_INVALID;
+		}
+		groupmatch = 1 << x;
+	} else {
+		char *stringp=NULL;
+		stringp=dest;
+		s = strsep(&stringp, "/");
+		p = iflist;
+		if (!strcasecmp(s, "pseudo")) {
+			/* Special case for pseudo */
+			x = CHAN_PSEUDO;
+			channelmatch = x;
+			/* bail out */
+			return AST_DEVICE_INVALID;
+		} 
+
+		else if ((res = sscanf(s, "%d%c%d", &x, &opt, &y)) < 1) {
+			ast_log(LOG_WARNING, "Unable to determine channel for data %s\n", (char *)data);
+			return AST_DEVICE_INVALID;
+		} else {
+			channelmatch = x;
+			ast_log(LOG_NOTICE, "channelmatch = %d\n", channelmatch);
+		}
+	}
+	/* Search for an unowned channel */
+	if (ast_mutex_lock(lock)) {
+		ast_log(LOG_ERROR, "Unable to lock interface list???\n");
+		return AST_DEVICE_INVALID;
+	}
+	p = iflist;
+	exit = iflist;
+	res = AST_DEVICE_INVALID; /* start pessimistic */
+	while(p) {
+		if (p) {
+		    ast_mutex_lock(&p->lock);
+		    if ((groupmatch && ((p->group & groupmatch) != 0)) || (channelmatch && (p->channel == channelmatch))) {
+#ifdef ZAPATA_PRI
+			if (p->pri) {
+			    for(d=0;d<NUM_DCHANS;d++) {
+				if (p->pri->dchanavail[d] & DCHAN_UP) {
+			    	    res = AST_DEVICE_UNKNOWN;
+				}
+			    }
+			}
+#endif
+			if ((!ast_strlen_zero(p->cid_num) && (strncasecmp(p->cid_num, dest, strlen(p->cid_num)))) || (!ast_strlen_zero(p->dnid) && (strncasecmp(p->dnid, dest, strlen(p->dnid))))) {
+			    res = AST_DEVICE_UNKNOWN;
+			    if (p->owner) {
+				    if ((p->owner->_state == AST_STATE_RINGING) && (p->outgoing)) {
+			    		res = AST_DEVICE_RINGING;
+				    }
+				    if (((p->owner->_state == AST_STATE_RINGING) && (!p->outgoing)) || (p->owner->_state == AST_STATE_UP) || (p->owner->_state == AST_STATE_DIALING) || (p->owner->_state == AST_STATE_RESERVED) || (p->owner->_state == AST_STATE_RING)){
+			    		res = AST_DEVICE_INUSE;
+				    }
+			    }
+			    if ((res == AST_DEVICE_INUSE) || (res == AST_DEVICE_RINGING)) {
+				/* stop searching now, one non-idle channel is sufficient */
+				ast_mutex_unlock(&p->lock);
+				break;
+			    }
+			}
+		    }
+		    ast_mutex_unlock(&p->lock);
+		}	
+		p = p->next;
+	}
+	ast_mutex_unlock(lock);
+
+	return res;
+
+}
+
 static int zt_get_index(struct ast_channel *ast, struct zt_pvt *p, int nullok)
 {
 	int res;
@@ -1338,6 +1521,8 @@
 		return "GR-303 Signalling with FXOKS";
 	case SIG_GR303FXSKS:
 		return "GR-303 Signalling with FXSKS";
+	case SIG_GSM:
+		return "GSM Signalling";
 	case 0:
 		return "Pseudo Signalling";
 	default:
@@ -1538,12 +1723,16 @@
 	int res;
 	if (!p)
 		return;
+ 	if (p->faxhandled)  {
+ 		ast_log(LOG_DEBUG, "Not enabling echo cancellation on a fax/modem call\n");
+		return;
+ 	}
 	if (p->echocanon) {
 		ast_log(LOG_DEBUG, "Echo cancellation already on\n");
 		return;
 	}
 	if (p->digital) {
-		ast_log(LOG_DEBUG, "Echo cancellation isn't required on digital connection\n");
+		ast_log(LOG_DEBUG, "Echo cancellation does not make any sense on digital connections!\n");
 		return;
 	}
 	if (p->echocancel) {
@@ -1569,7 +1758,7 @@
 {
 	int x;
 	int res;
-	if (p && p->echocancel && p->echotraining) {
+	if (p && p->echocancel && p->echotraining && (!p->digital) && (!p->faxhandled)) {
 		x = p->echotraining;
 		res = ioctl(p->subs[SUB_REAL].zfd, ZT_ECHOTRAIN, &x);
 		if (res) 
@@ -1752,7 +1941,7 @@
 {
 	int x, y, res;
 	x = muted;
-	if (p->sig == SIG_PRI) {
+	if ((p->sig == SIG_PRI) || (p->sig == SIG_GSM)) {
 		y = 1;
 		res = ioctl(p->subs[SUB_REAL].zfd, ZT_AUDIOMODE, &y);
 		if (res)
@@ -1934,7 +2123,12 @@
 		ast_log(LOG_WARNING, "Unable to flush input on channel %d\n", p->channel);
 	p->outgoing = 1;
 
-	set_actual_gain(p->subs[SUB_REAL].zfd, 0, p->rxgain, p->txgain, p->law);
+	if (IS_DIGITAL(ast->transfercapability)) {
+	    set_actual_gain(p->subs[SUB_REAL].zfd, 0, 0, 0, p->law);
+	} else {
+	    set_actual_gain(p->subs[SUB_REAL].zfd, 0, p->rxgain, p->txgain, p->law);
+	}
+
 
 	switch(p->sig) {
 	case SIG_FXOLS:
@@ -2158,6 +2352,26 @@
 	case SIG_PRI:
 		/* We'll get it in a moment -- but use dialdest to store pre-setup_ack digits */
 		p->dialdest[0] = '\0';
+		disable_dtmf_detect(p);
+		break;
+	case SIG_GSM:
+#ifdef ZAPATA_GSM
+		if (p->gsm.modul) {
+		    c = strchr(dest, '/');
+		    if (c)
+			c++;
+		    else
+			c = dest;
+		    ast_mutex_lock(&p->gsm.lock);
+		    if (gsm_dial(p->gsm.modul, p->use_callingpres ? ast->cid.cid_pres : 0, c)) {
+			ast_log(LOG_WARNING, "dialing failed on channel %d\n", p->channel);
+			ast_mutex_unlock(&p->gsm.lock);
+			ast_mutex_unlock(&p->lock);
+			return -1;
+		    }
+		    ast_mutex_unlock(&p->gsm.lock);
+		}
+#endif
 		break;
 	default:
 		ast_log(LOG_DEBUG, "not yet implemented\n");
@@ -2176,6 +2390,12 @@
 		int ldp_strip;
 		int exclusive;
 
+ 		if ((p->pri->nodetype == BRI_NETWORK_PTMP) || (p->pri->nodetype == BRI_NETWORK)) {
+ 		    // pass NO audio when ringing an isdn phone
+ 		    p->dialing = 1;
+ 		    // maybe we could allow passing audio when calling a p2p PBX, but well... ;-)
+ 		}
+
 		c = strchr(dest, '/');
 		if (c)
 			c++;
@@ -2193,6 +2413,7 @@
 			ast_mutex_unlock(&p->lock);
 			return -1;
 		}
+		strncpy(p->dnid, (c + p->stripmsd), sizeof(p->dnid)-1);
 		if (p->sig != SIG_FXSKS) {
 			p->dop.op = ZT_DIAL_OP_REPLACE;
 			s = strchr(c + p->stripmsd, 'w');
@@ -2216,6 +2437,8 @@
 			pri_rel(p->pri);
 			ast_mutex_unlock(&p->lock);
 			return -1;
+		} else {
+		//	ast_log(LOG_NOTICE, "call %d\n", p->call);
 		}
 		if (!(sr = pri_sr_new())) {
 			ast_log(LOG_WARNING, "Failed to allocate setup request channel %d\n", p->channel);
@@ -2245,7 +2468,7 @@
 		pri_sr_set_channel(sr, p->bearer ? PVT_TO_CHANNEL(p->bearer) : PVT_TO_CHANNEL(p), exclusive, 1);
 		pri_sr_set_bearer(sr, p->digital ? PRI_TRANS_CAP_DIGITAL : ast->transfercapability, 
 					(p->digital ? -1 : 
-						((p->law == ZT_LAW_ALAW) ? PRI_LAYER_1_ALAW : PRI_LAYER_1_ULAW)));
+						((p->law == ZT_LAW_ALAW) ? PRI_LAYER_1_ALAW : PRI_LAYER_1_ULAW)), ast->lowlayercompat);
 		if (p->pri->facilityenable)
 			pri_facility_enable(p->pri->pri);
 
@@ -2446,8 +2669,10 @@
 	}
 	if (newslot < 0) {
 		newslot = 0;
-		ast_log(LOG_WARNING, "No D-channels available!  Using Primary channel %d as D-channel anyway!\n",
+		if (pri->nodetype != BRI_CPE_PTMP) {
+		    ast_log(LOG_WARNING, "No D-channels available!  Using Primary channel %d as D-channel anyway!\n",
 			pri->dchannels[newslot]);
+		}
 	}
 	if (old && (oldslot != newslot))
 		ast_log(LOG_NOTICE, "Switching from from d-channel %d to channel %d!\n",
@@ -2503,8 +2728,7 @@
 
 	ast_log(LOG_DEBUG, "Hangup: channel: %d index = %d, normal = %d, callwait = %d, thirdcall = %d\n",
 		p->channel, index, p->subs[SUB_REAL].zfd, p->subs[SUB_CALLWAIT].zfd, p->subs[SUB_THREEWAY].zfd);
-	p->ignoredtmf = 0;
-	
+
 	if (index > -1) {
 		/* Real channel, do some fixup */
 		p->subs[index].owner = NULL;
@@ -2601,6 +2825,7 @@
 
 
 	if (!p->subs[SUB_REAL].owner && !p->subs[SUB_CALLWAIT].owner && !p->subs[SUB_THREEWAY].owner) {
+		int outgoing = p->outgoing;
 		p->owner = NULL;
 		p->ringt = 0;
 		p->distinctivering = 0;
@@ -2637,19 +2862,61 @@
 			if (p->call && (!p->bearer || (p->bearer->call == p->call))) {
 				if (!pri_grab(p, p->pri)) {
 					if (p->alreadyhungup) {
+/*						char *aoc = pbx_builtin_getvar_helper(ast,"AOCEUNITS");
+						int iaoc = aoc ? atoi(aoc) : -1;
+						char *aocpm = pbx_builtin_getvar_helper(ast,"AOCEUNITSPERMIN");
+						int iaocpm = aocpm ? atoi(aocpm) : -1;
+
+						if (iaocpm > -1) {
+						    if (ast->cdr) {
+						    long bill_sec = ast->cdr->billsec;
+						    long bill_min = 0;
+						    if (bill_sec > 0) {
+							bill_min = bill_sec / 60;
+							if (bill_min < 1) bill_min = 1;
+						    }
+						    iaoc = bill_min * iaocpm;
+						    } else {
+							ast_log(LOG_NOTICE, "no cdr \n");
+						    }
+						} else {
+							ast_log(LOG_NOTICE, "iaocpm %d \n", iaocpm);
+						}
+*/
 						ast_log(LOG_DEBUG, "Already hungup...  Calling hangup once, and clearing call\n");
 
 #ifdef SUPPORT_USERUSER
 						pri_call_set_useruser(p->call, useruser);
 #endif
 
-						pri_hangup(p->pri->pri, p->call, -1);
+						pri_hangup(p->pri->pri, p->call, -1, -1);
 						p->call = NULL;
 						if (p->bearer) 
 							p->bearer->call = NULL;
 					} else {
 						char *cause = pbx_builtin_getvar_helper(ast,"PRI_CAUSE");
 						int icause = ast->hangupcause ? ast->hangupcause : -1;
+/*						char *aoc = pbx_builtin_getvar_helper(ast,"AOCEUNITS");
+						int iaoc = aoc ? atoi(aoc) : -1;
+						char *aocpm = pbx_builtin_getvar_helper(ast,"AOCEUNITSPERMIN");
+						int iaocpm = aocpm ? atoi(aocpm) : -1;
+
+						if (iaocpm > -1) {
+						    if (ast->cdr) {
+						    long bill_sec = ast->cdr->billsec;
+						    long bill_min = 0;
+						    if (bill_sec > 0) {
+							bill_min = bill_sec / 60;
+							if (bill_min < 1) bill_min = 1;
+						    }
+						    iaoc = bill_min * iaocpm;
+						    } else {
+							ast_log(LOG_NOTICE, "no cdr \n");
+						    }
+						} else {
+							ast_log(LOG_NOTICE, "iaocpm %d \n", iaocpm);
+						}
+*/
 						ast_log(LOG_DEBUG, "Not yet hungup...  Calling hangup once with icause, and clearing call\n");
 
 #ifdef SUPPORT_USERUSER
@@ -2663,7 +2930,28 @@
 							if (atoi(cause))
 								icause = atoi(cause);
 						}
-						pri_hangup(p->pri->pri, p->call, icause);
+
+						pri_hangup(p->pri->pri, p->call, icause, -1);
+
+						/* if we send a rel9999ease complete we wont ge no hangup event, so clear the call here */
+						if (icause == 34 || icause == 44 || icause == 82 || icause == 1 || icause == 81 || icause == 17) {
+						    if ((ast->_state == AST_STATE_RING) || (ast->_state == AST_STATE_RINGING) || (ast->_state == AST_STATE_DIALING)) {
+							p->call = NULL;
+						    } else {
+							ast_log(LOG_ERROR, "What is wrong with you? You cannot use cause %d number when in state %d!\n", icause, ast->_state);
+							icause = 16; /* Note, in pri_hangup() libpri will already override the cause */
+						    }
+						} 
+						
+						if (p->pri->nodetype == BRI_NETWORK_PTMP) {
+						    if ((icause == 16 || icause == -1) && (ast->_state != AST_STATE_UP)) {
+							if (outgoing) {
+							    p->call = NULL;
+							}
+						    }
+						}
+						
+						
 					}
 					if (res < 0) 
 						ast_log(LOG_WARNING, "pri_disconnect failed\n");
@@ -2691,7 +2979,13 @@
 
 		}
 #endif
-		if (p->sig && (p->sig != SIG_PRI) && (p->sig != SIG_R2))
+#ifdef ZAPATA_GSM
+		if (p->gsm.modul) {
+		    if (!p->alreadyhungup)
+			gsm_hangup(p->gsm.modul);
+		}
+#endif
+		if (p->sig && (p->sig != SIG_PRI) && (p->sig != SIG_R2) && (p->sig != SIG_GSM))
 			res = zt_set_hook(p->subs[SUB_REAL].zfd, ZT_ONHOOK);
 		if (res < 0) {
 			ast_log(LOG_WARNING, "Unable to hangup line %s\n", ast->name);
@@ -2860,10 +3154,14 @@
 			p->proceeding = 1;
 			res = pri_answer(p->pri->pri, p->call, 0, !p->digital);
 			pri_rel(p->pri);
+			/* stop ignoring inband dtmf */
+			enable_dtmf_detect(p);
 		} else {
 			ast_log(LOG_WARNING, "Unable to grab PRI on span %d\n", p->span);
 			res= -1;
 		}
+		/* the audio path is complete now, train the echo canceler */
+		zt_train_ec(p);
 		break;
 #endif
 #ifdef ZAPATA_R2
@@ -2873,6 +3171,13 @@
 			ast_log(LOG_WARNING, "R2 Answer call failed :( on %s\n", ast->name);
 		break;
 #endif			
+#ifdef ZAPATA_GSM
+	case SIG_GSM:
+		if (p->gsm.modul) {
+		    gsm_answer(p->gsm.modul);
+		}
+		break;
+#endif
 	case 0:
 		ast_mutex_unlock(&p->lock);
 		return 0;
@@ -3439,6 +3744,15 @@
 {
 	struct zt_pvt *p = newchan->tech_pvt;
 	int x;
+ 	if (newchan && newchan->tech_pvt) {
+ 	    p = newchan->tech_pvt;
+ 	}
+ 	if (!p) {
+ 	    if (newchan) {
+ 		ast_log(LOG_ERROR, "channel %s has no tech_pvt structure\n", newchan->name);
+ 	    }
+ 	    return 0;
+ 	}
 	ast_mutex_lock(&p->lock);
 	ast_log(LOG_DEBUG, "New owner for channel %d is %s\n", p->channel, newchan->name);
 	if (p->owner == oldchan) {
@@ -3710,8 +4024,10 @@
 					pbx_builtin_setvar_helper(ast, "FAXEXTEN", ast->exten);
 					if (ast_async_goto(ast, target_context, "fax", 1))
 						ast_log(LOG_WARNING, "Failed to async goto '%s' into fax of '%s'\n", ast->name, target_context);
-				} else
-					ast_log(LOG_NOTICE, "Fax detected, but no fax extension\n");
+ 				} else {
+ 				    if (option_verbose > 2)
+ 					ast_verbose(VERBOSE_PREFIX_3 "Fax detected, but no fax extension\n");
+ 				}
 			} else
 				ast_log(LOG_DEBUG, "Already in a fax extension, not redirecting\n");
 		} else
@@ -3866,7 +4182,7 @@
 			if (p->call) {
 				if (p->pri && p->pri->pri) {
 					if (!pri_grab(p, p->pri)) {
-						pri_hangup(p->pri->pri, p->call, -1);
+						pri_hangup(p->pri->pri, p->call, -1, -1);
 						pri_destroycall(p->pri->pri, p->call);
 						p->call = NULL;
 						pri_rel(p->pri);
@@ -4832,7 +5148,7 @@
 		p->subs[index].f.data = NULL;
 		p->subs[index].f.datalen= 0;
 	}
-	if (p->dsp && (!p->ignoredtmf || p->callwaitcas || p->busydetect  || p->callprogress) && !index) {
+	if (p->dsp && (!p->ignoredtmf || p->callwaitcas || p->busydetect || p->callprogress) && !index) {
 		/* Perform busy detection. etc on the zap line */
 		f = ast_dsp_process(ast, p->dsp, &p->subs[index].f);
 		if (f) {
@@ -4844,8 +5160,9 @@
 				}
 			} else if (f->frametype == AST_FRAME_DTMF) {
 #ifdef ZAPATA_PRI
-				if (!p->proceeding && p->sig==SIG_PRI && p->pri && p->pri->overlapdial) {
-					/* Don't accept in-band DTMF when in overlap dial mode */
+				if (p->sig==SIG_PRI && p->pri && p->pri->overlapdial && p->ignoredtmf) {
+					/* Don't accept in-band DTMF when in overlap dial mode 
+					   or when in non-overlap overlapdialing mode ... */
 					f->frametype = AST_FRAME_NULL;
 					f->subclass = 0;
 				}
@@ -4920,7 +5237,9 @@
 #endif
 	/* Write a frame of (presumably voice) data */
 	if (frame->frametype != AST_FRAME_VOICE) {
-		if (frame->frametype != AST_FRAME_IMAGE)
+		if (frame->frametype == AST_FRAME_TEXT) {
+			ast_log(LOG_NOTICE, "text\n");
+		} else if (frame->frametype != AST_FRAME_IMAGE)
 			ast_log(LOG_WARNING, "Don't know what to do with frame type '%d'\n", frame->frametype);
 		return 0;
 	}
@@ -4991,7 +5310,7 @@
 		switch(condition) {
 		case AST_CONTROL_BUSY:
 #ifdef ZAPATA_PRI
-			if (p->priindication_oob && p->sig == SIG_PRI) {
+			if ((p->priindication_oob == 1) && p->sig == SIG_PRI) {
 				chan->hangupcause = AST_CAUSE_USER_BUSY;
 				chan->_softhangup |= AST_SOFTHANGUP_DEV;
 				res = 0;
@@ -5072,7 +5391,7 @@
 		case AST_CONTROL_CONGESTION:
 			chan->hangupcause = AST_CAUSE_CONGESTION;
 #ifdef ZAPATA_PRI
-			if (p->priindication_oob && p->sig == SIG_PRI) {
+			if ((p->priindication_oob == 1) && p->sig == SIG_PRI) {
 				chan->hangupcause = AST_CAUSE_SWITCH_CONGESTION;
 				chan->_softhangup |= AST_SOFTHANGUP_DEV;
 				res = 0;
@@ -5259,8 +5578,12 @@
 		if (state == AST_STATE_RING)
 			tmp->rings = 1;
 		tmp->tech_pvt = i;
-		if ((i->sig == SIG_FXOKS) || (i->sig == SIG_FXOGS) || (i->sig == SIG_FXOLS)) {
-			/* Only FXO signalled stuff can be picked up */
+#ifdef ZAPATA_PRI
+		if ((i->sig == SIG_FXOKS) || (i->sig == SIG_FXOGS) || (i->sig == SIG_FXOLS) || (i->sig == SIG_PRI)) {
+#else
+ 		if ((i->sig == SIG_FXOKS) || (i->sig == SIG_FXOGS) || (i->sig == SIG_FXOLS)) {
+#endif
+		/* Only FXO signalled stuff can be picked up */ /* i dont think so, mr. ulaw! we alaws like to pick up BRIs/PRIs */
 			tmp->callgroup = i->callgroup;
 			tmp->pickupgroup = i->pickupgroup;
 		}
@@ -5402,6 +5725,7 @@
 	int len = 0;
 	int res;
 	int index;
+ 	int network;
 
 	/* in the bizarre case where the channel has become a zombie before we
 	   even get started here, abort safely
@@ -5430,10 +5754,17 @@
 		len = strlen(exten);
 		res = 0;
 		while((len < AST_MAX_EXTENSION-1) && ast_matchmore_extension(chan, chan->context, exten, 1, p->cid_num)) {
-			if (len && !ast_ignore_pattern(chan->context, exten))
+			if (len && !ast_ignore_pattern(chan->context, exten)) {
 				tone_zone_play_tone(p->subs[index].zfd, -1);
-			else
-				tone_zone_play_tone(p->subs[index].zfd, ZT_TONE_DIALTONE);
+			} else {
+				network = p->pri->nodetype == PRI_NETWORK || p->pri->nodetype == BRI_NETWORK || p->pri->nodetype == BRI_NETWORK_PTMP;
+				if (network) {
+				    tone_zone_play_tone(p->subs[index].zfd, ZT_TONE_DIALTONE);
+				} else {
+				    /* cpe be quiet */
+				    tone_zone_play_tone(p->subs[index].zfd, -1);
+				}
+			}
 			if (ast_exists_extension(chan, chan->context, exten, 1, p->cid_num))
 				timeout = matchdigittimeout;
 			else
@@ -6644,18 +6975,44 @@
 		break;
 	case ZT_EVENT_NOALARM:
 		i->inalarm = 0;
+#ifdef ZAPATA_PRI
+		if (i->pri) {
+		    if ((i->pri->nodetype == BRI_CPE_PTMP) || (i->pri->nodetype == BRI_CPE_PTMP)) {
+			/* dont annoy BRI TE mode users with layer2layer alarms */
+		    } else {
+			ast_log(LOG_NOTICE, "Alarm cleared on channel %d\n", i->channel);
+			manager_event(EVENT_FLAG_SYSTEM, "AlarmClear",
+		              "Channel: %d\r\n", i->channel);
+		    }
+		}
+#else
 		ast_log(LOG_NOTICE, "Alarm cleared on channel %d\n", i->channel);
 		manager_event(EVENT_FLAG_SYSTEM, "AlarmClear",
 		              "Channel: %d\r\n", i->channel);
+#endif
 		break;
 	case ZT_EVENT_ALARM:
 		i->inalarm = 1;
 		res = get_alarms(i);
+#ifdef ZAPATA_PRI
+		if (i->pri) {
+		    if ((i->pri->nodetype == BRI_CPE_PTMP) || (i->pri->nodetype == BRI_CPE_PTMP)) {
+			/* dont annoy BRI TE mode users with layer2layer alarms */
+		    } else {
+			ast_log(LOG_WARNING, "Detected alarm on channel %d: %s\n", i->channel, alarm2str(res));
+			manager_event(EVENT_FLAG_SYSTEM, "Alarm",
+		              "Alarm: %s\r\n"
+		              "Channel: %d\r\n",
+		              alarm2str(res), i->channel);
+		    }
+		}
+#else
 		ast_log(LOG_WARNING, "Detected alarm on channel %d: %s\n", i->channel, alarm2str(res));
 		manager_event(EVENT_FLAG_SYSTEM, "Alarm",
 		              "Alarm: %s\r\n"
 		              "Channel: %d\r\n",
 		              alarm2str(res), i->channel);
+#endif
 		/* fall thru intentionally */
 	case ZT_EVENT_ONHOOK:
 		if (i->radio) break;
@@ -6695,8 +7052,10 @@
 			zt_set_hook(i->subs[SUB_REAL].zfd, ZT_ONHOOK);
 			break;
 		case SIG_PRI:
-			zt_disable_ec(i);
-			res = tone_zone_play_tone(i->subs[SUB_REAL].zfd, -1);
+			if (event != ZT_EVENT_ALARM) {
+			    zt_disable_ec(i);
+			    res = tone_zone_play_tone(i->subs[SUB_REAL].zfd, -1);
+			}
 			break;
 		default:
 			ast_log(LOG_WARNING, "Don't know how to handle on hook with signalling %s on channel %d\n", sig2str(i->sig), i->channel);
@@ -7016,6 +7375,8 @@
 		} else {
 			if (si->totalchans == 31) { /* if it's an E1 */
 				pris[*span].dchannels[0] = 16 + offset;
+			} else if (si->totalchans == 3) { /* if it's an S0 ZAPBRI */
+				pris[*span].dchannels[0] = 3 + offset;
 			} else {
 				pris[*span].dchannels[0] = 24 + offset;
 			}
@@ -7103,6 +7464,10 @@
 
 #endif
 
+#ifdef ZAPATA_GSM
+static void *gsm_dchannel(void *vgsm);
+#endif
+
 static struct zt_pvt *mkintf(int channel, struct zt_chan_conf chan_conf, struct zt_pri *pri, int reloading)
 {
 	/* Make a zt_pvt structure for this interface (or CRV if "pri" is specified) */
@@ -7266,6 +7631,11 @@
 							destroy_zt_pvt(&tmp);
 							return NULL;
 						}
+                                         	if ((pris[span].localdialplan) && (pris[span].localdialplan != localdialplan)) {
+ 							ast_log(LOG_ERROR, "Span %d is already a %s local dialing plan\n", span + 1, dialplan2str(pris[span].localdialplan));
+ 							destroy_zt_pvt(&tmp);
+                                                 	return NULL;
+  						}
 						if (!ast_strlen_zero(pris[span].idleext) && strcmp(pris[span].idleext, chan_conf.pri.idleext)) {
 							ast_log(LOG_ERROR, "Span %d already has idleext '%s'.\n", span + 1, chan_conf.pri.idleext);
 							destroy_zt_pvt(&tmp);
@@ -7288,6 +7658,17 @@
 							return NULL;
 						}
 						pris[span].nodetype = pritype;
+// XXX
+						if (pritype == BRI_NETWORK_PTMP) {
+						    pris[span].dchanavail[0] =  DCHAN_AVAILABLE;
+						    pri_find_dchan(&pris[span]);
+						}
+// XXX tuev
+
+//						if ((pritype == BRI_CPE) || (pritype == BRI_CPE_PTMP)) {
+//						    pris[span].dchanavail[0] =  DCHAN_AVAILABLE;
+//						    pri_find_dchan(&pris[span]);
+//						}
 						pris[span].switchtype = myswitchtype;
 						pris[span].nsf = nsf;
 						pris[span].dialplan = dialplan;
@@ -7296,9 +7677,14 @@
 						pris[span].minunused = chan_conf.pri.minunused;
 						pris[span].minidle = chan_conf.pri.minidle;
 						pris[span].overlapdial = chan_conf.pri.overlapdial;
+   						pris[span].usercid = chan_conf.pri.usercid;
+   						pris[span].suspended_calls = NULL;
+   						pris[span].holded_calls = NULL;
 						pris[span].facilityenable = chan_conf.pri.facilityenable;
 						ast_copy_string(pris[span].idledial, chan_conf.pri.idledial, sizeof(pris[span].idledial));
 						ast_copy_string(pris[span].idleext, chan_conf.pri.idleext, sizeof(pris[span].idleext));
+  						ast_copy_string(pris[span].nocid, nocid, sizeof(pris[span].nocid) - 1);
+  						ast_copy_string(pris[span].withheldcid, withheldcid, sizeof(pris[span].withheldcid) - 1);
 						ast_copy_string(pris[span].internationalprefix, chan_conf.pri.internationalprefix, sizeof(pris[span].internationalprefix));
 						ast_copy_string(pris[span].nationalprefix, chan_conf.pri.nationalprefix, sizeof(pris[span].nationalprefix));
 						ast_copy_string(pris[span].localprefix, chan_conf.pri.localprefix, sizeof(pris[span].localprefix));
@@ -7319,6 +7705,37 @@
 				tmp->prioffset = 0;
 			}
 #endif
+#ifdef ZAPATA_GSM
+		if (chan_conf.signalling == SIG_GSM) {
+		    struct zt_bufferinfo bi;
+		    ast_mutex_init(&tmp->gsm.lock);
+		    strncpy(tmp->gsm.pin, gsm_modem_pin, sizeof(tmp->gsm.pin) - 1);
+		    strncpy(tmp->gsm.exten, gsm_modem_exten, sizeof(tmp->gsm.exten) - 1);
+		    tmp->gsm.available = 0;
+		    snprintf(fn, sizeof(fn), "%d", channel + 1);
+		    /* Open non-blocking */
+		    tmp->gsm.fd = zt_open(fn);
+		    bi.txbufpolicy = ZT_POLICY_IMMEDIATE;
+		    bi.rxbufpolicy = ZT_POLICY_IMMEDIATE;
+		    bi.numbufs = 16;
+		    bi.bufsize = 1024;
+		    if (ioctl(tmp->gsm.fd, ZT_SET_BUFINFO, &bi)) {
+			ast_log(LOG_ERROR, "Unable to set buffer info on channel '%s': %s\n", fn, strerror(errno));
+			return NULL;
+		    }
+		    tmp->gsm.pvt = tmp;
+		    tmp->gsm.span = tmp->span;
+		    tmp->gsm.modul = gsm_new(tmp->gsm.fd, 0, tmp->gsm.pin, tmp->span, tmp->channel);
+		    if (ioctl(tmp->subs[SUB_REAL].zfd, ZT_AUDIOMODE, tmp->channel)) {
+			ast_log(LOG_ERROR, "Unable to set clear mode on clear channel %d: %s\n", tmp->channel, strerror(errno));
+			destroy_zt_pvt(&tmp);
+			return NULL;
+		    }
+		    if (ast_pthread_create(&tmp->gsm.master, NULL, gsm_dchannel, &tmp->gsm)) {
+			zt_close(tmp->gsm.fd);
+		    }
+		}
+#endif
 #ifdef ZAPATA_R2
 			if (chan_conf.signalling == SIG_R2) {
 				if (r2prot < 0) {
@@ -7452,6 +7869,7 @@
 		tmp->restrictcid = chan_conf.restrictcid;
 		tmp->use_callingpres = chan_conf.use_callingpres;
 		tmp->priindication_oob = chan_conf.priindication_oob;
+ 		tmp->pritransfer = chan_conf.pritransfer;
 		tmp->priexclusive = chan_conf.priexclusive;
 		if (tmp->usedistinctiveringdetection) {
 			if (!tmp->use_callerid) {
@@ -7604,6 +8022,12 @@
 				return 1;
 		}
 #endif
+#ifdef ZAPATA_GSM
+		if (p->gsm.modul) {
+		    return gsm_available(p->gsm.modul);
+		}
+
+#endif
 #ifdef ZAPATA_R2
 		/* Trust R2 as well */
 		if (p->r2) {
@@ -7725,7 +8149,7 @@
 			break;
 		if (!backwards && (x >= pri->numchans))
 			break;
-		if (pri->pvts[x] && !pri->pvts[x]->inalarm && !pri->pvts[x]->owner) {
+		if (pri->pvts[x] && !pri->pvts[x]->inalarm && !pri->pvts[x]->owner && !pri->pvts[x]->call) {
 			ast_log(LOG_DEBUG, "Found empty available channel %d/%d\n", 
 				pri->pvts[x]->logicalspan, pri->pvts[x]->prioffset);
 			return x;
@@ -7772,7 +8196,7 @@
 	end = ifend;
 	/* We do signed linear */
 	oldformat = format;
-	format &= (AST_FORMAT_SLINEAR | AST_FORMAT_ULAW);
+	format &= (AST_FORMAT_SLINEAR | AST_FORMAT_ULAW | AST_FORMAT_ALAW);
 	if (!format) {
 		ast_log(LOG_NOTICE, "Asked to get a channel of unsupported format '%d'\n", oldformat);
 		return NULL;
@@ -7932,6 +8356,11 @@
 					p->digital = 1;
 					if (tmp)
 						tmp->transfercapability = AST_TRANS_CAP_DIGITAL;
+				} else if (opt == 'm') {
+					/* If this is a modem/fax call, pretend to have the fax handled and dont do EC */
+					p->faxhandled = 1;
+					if (tmp)
+					    tmp->transfercapability = AST_TRANS_CAP_3_1K_AUDIO;
 				} else {
 					ast_log(LOG_WARNING, "Unknown option '%c' in '%s'\n", opt, (char *)data);
 				}
@@ -7965,12 +8394,242 @@
 				*cause = AST_CAUSE_BUSY;
 		} else if (groupmatched) {
 			*cause = AST_CAUSE_CONGESTION;
+		} else {
+			*cause = AST_CAUSE_CONGESTION;
 		}
 	}
 		
 	return tmp;
 }
 
+#ifdef ZAPATA_GSM
+static int zt_reset_span(int span, int sleep) {
+	int ctl;
+	int res;
+
+	ctl = open("/dev/zap/ctl", O_RDWR);
+	if (ctl < 0) {
+		ast_log(LOG_WARNING, "Unable to open /dev/zap/ctl: %s\n", strerror(errno));
+		return -1;
+	}
+	ast_verbose(VERBOSE_PREFIX_2 "Shutting down span %d. Please wait...\n", span);
+	res = ioctl(ctl, ZT_SHUTDOWN, &span);
+	if (res) {
+		ast_log(LOG_WARNING, "error shutting down span %d\n", span);
+		return -1;
+	}
+	usleep(sleep * 1000);
+	ast_verbose(VERBOSE_PREFIX_2 "Starting up span %d. Please wait...\n", span);
+	res = ioctl(ctl, ZT_STARTUP, &span);
+	if (res) {
+		ast_log(LOG_WARNING, "error starting up span %d\n", span);
+		return -1;
+	}
+	ast_verbose(VERBOSE_PREFIX_2 "Reset of span %d completed.\n", span);
+	return 0;
+}
+
+
+static void handle_gsm_event(struct zt_gsm *gsm, gsm_event *e)
+{
+	struct ast_channel *c = NULL;
+	int law = ZT_LAW_ALAW;
+	int res = 0;
+
+	switch(e->e) {
+	case GSM_EVENT_DCHAN_UP:
+		if (option_verbose > 2)
+		    ast_verbose(VERBOSE_PREFIX_3 "GSM Span %d registered to network!\n", gsm->span);
+		gsm->available = 1;
+		break;
+	case GSM_EVENT_DCHAN_DOWN:
+		if (option_verbose > 2)
+		    ast_verbose(VERBOSE_PREFIX_3 "GSM Span %d unregistered from network!\n", gsm->span);
+		gsm->available = 0;
+/*		ast_mutex_lock(&gsm->pvt->lock);
+		gsm->pvt->alreadyhungup = 1;
+		if (gsm->pvt->owner) {
+		    gsm->pvt->owner->_softhangup |= AST_SOFTHANGUP_DEV;
+		}
+		ast_mutex_unlock(&gsm->pvt->lock); */
+		break;
+	case GSM_EVENT_RING:
+		ast_mutex_lock(&gsm->pvt->lock);
+		if (!ast_strlen_zero(e->ring.callingnum)) {
+		    strncpy(gsm->pvt->cid_num, e->ring.callingnum, sizeof(gsm->pvt->cid_num) - 1);
+		} else {
+		    strncpy(gsm->pvt->cid_name, withheldcid, sizeof(gsm->pvt->cid_name));
+		}
+		if (!ast_strlen_zero(gsm->exten)) {
+		    strncpy(gsm->pvt->exten, gsm->exten, sizeof(gsm->pvt->exten) - 1);
+		} else {
+		    gsm->pvt->exten[0] = 's';
+		    gsm->pvt->exten[1] = '\0';
+		}
+		c = zt_new(gsm->pvt, AST_STATE_RING, 1, SUB_REAL, ZT_LAW_ALAW, AST_TRANS_CAP_SPEECH);
+		if (c) {
+		    if (option_verbose > 2)
+			ast_verbose(VERBOSE_PREFIX_3 "Ring on channel %d (from %s to %s)\n", e->ring.channel, e->ring.callingnum, gsm->exten);
+		    gsm->pvt->owner = c;
+		    if (ioctl(gsm->pvt->subs[SUB_REAL].zfd, ZT_AUDIOMODE, &law) == -1)
+			ast_log(LOG_WARNING, "Unable to set audio mode on channel %d to %d\n", gsm->pvt->channel, law);
+		    res = zt_setlaw(gsm->pvt->subs[SUB_REAL].zfd, law);
+		    res = set_actual_gain(gsm->pvt->subs[SUB_REAL].zfd, 0, gsm->pvt->rxgain, gsm->pvt->txgain, law);
+		    if (res < 0) {
+ 		        ast_log(LOG_WARNING, "Unable to set gains on channel %d\n", gsm->pvt->channel);
+//		    } else {
+//		        ast_log(LOG_NOTICE, "tx gain %f rx gain %f law %d pvt->law %d\n", gsm->pvt->txgain, gsm->pvt->rxgain, law, gsm->pvt->law);
+		    }
+		}
+		ast_mutex_unlock(&gsm->pvt->lock);
+		break;
+	case GSM_EVENT_HANGUP:
+		ast_verbose(VERBOSE_PREFIX_3 "Got hang up on channel %d\n", e->hangup.channel);
+		ast_mutex_lock(&gsm->pvt->lock);
+		gsm->pvt->alreadyhungup = 1;
+		if (gsm->pvt->owner) {
+		    gsm->pvt->owner->hangupcause = e->hangup.cause;
+		    gsm->pvt->owner->_softhangup |= AST_SOFTHANGUP_DEV;
+		}
+		ast_mutex_unlock(&gsm->pvt->lock);
+		break;
+	case GSM_EVENT_ERROR:
+		ast_log(LOG_WARNING, "Got error on channel\n");
+		ast_mutex_lock(&gsm->pvt->lock);
+		gsm->pvt->alreadyhungup = 1;
+		if (gsm->pvt->owner) {
+		    gsm->pvt->owner->hangupcause = e->error.cause;
+		    gsm->pvt->owner->_softhangup |= AST_SOFTHANGUP_DEV;
+		}
+		ast_mutex_unlock(&gsm->pvt->lock);
+		if (e->error.hard) {
+//		    gsm_poweroff(gsm->modul);
+		    zt_reset_span(gsm->span, 8000);
+//		    gsm_restart(gsm->modul, 10000);
+		} else {
+//		    gsm_poweroff(gsm->modul);
+		    zt_reset_span(gsm->span, 8000);
+//		    gsm_restart(gsm->modul, 10000);
+		}
+		break;
+	case GSM_EVENT_ALERTING:
+		ast_mutex_lock(&gsm->pvt->lock);
+		gsm->pvt->subs[SUB_REAL].needringing =1;
+		ast_mutex_unlock(&gsm->pvt->lock);
+		break;
+	case GSM_EVENT_ANSWER:
+		ast_mutex_lock(&gsm->pvt->lock);
+		gsm->pvt->dialing = 0;
+		gsm->pvt->subs[SUB_REAL].needanswer =1;
+		gsm->pvt->ignoredtmf = 0;
+		ast_mutex_unlock(&gsm->pvt->lock);
+		break;
+	case GSM_EVENT_PIN_REQUIRED:
+		gsm_send_pin(gsm->modul, gsm->pin);
+		break;
+	case GSM_EVENT_SM_RECEIVED:
+		ast_verbose(VERBOSE_PREFIX_3 "SMS from %s received on span %d. (Text: %s) (PDU: %s)\n", e->sm_received.sender, gsm->span, e->sm_received.text, e->sm_received.pdu);
+		manager_event(EVENT_FLAG_CALL, "Message received",
+			"Span: %d\r\n"
+		  	"Sender: %s\r\n"
+		  	"SMSC: %s\r\n"
+		      	"Length: %d\r\n"
+		  	"Text: %s\r\n"
+		  	"PDU: %s\r\n",
+			gsm->span, 
+			e->sm_received.sender,
+			e->sm_received.smsc,
+			e->sm_received.len,
+			e->sm_received.text,
+			e->sm_received.pdu);
+		break;
+	default:
+		ast_log(LOG_WARNING,"!! Unknown GSM event %d !!\n", e->e);
+	}
+}
+
+static void *gsm_dchannel(void *vgsm)
+{
+	struct zt_gsm *gsm = vgsm;
+	gsm_event *e;
+	struct timeval tv = {0,0}, *next;
+	fd_set rfds, efds;
+	int res,x;
+
+	if (!gsm) return NULL;
+
+	if (!gsm->modul) {
+		fprintf(stderr, "No gsm_mod\n");
+		return NULL;
+	}
+	gsm_set_debug(gsm->modul, GSM_DEBUG_NONE);
+	for (;;) {
+		
+		/* Run the D-Channel */
+		FD_ZERO(&rfds);
+		FD_ZERO(&efds);
+		FD_SET(gsm->fd, &rfds);
+		FD_SET(gsm->fd, &efds);
+
+		if ((next = gsm_schedule_next(gsm->modul))) {
+			gettimeofday(&tv, NULL);
+			tv.tv_sec = next->tv_sec - tv.tv_sec;
+			tv.tv_usec = next->tv_usec - tv.tv_usec;
+			if (tv.tv_usec < 0) {
+				tv.tv_usec += 1000000;
+				tv.tv_sec -= 1;
+			}
+			if (tv.tv_sec < 0) {
+				tv.tv_sec = 0;
+				tv.tv_usec = 0;
+			}
+		}
+		res = select(gsm->fd + 1, &rfds, NULL, &efds, next ? &tv : NULL);
+		e = NULL;
+
+		ast_mutex_lock(&gsm->lock);
+		if (!res) {
+			e = gsm_schedule_run(gsm->modul);
+		} else if (res > 0) {
+			e = gsm_check_event(gsm->modul, 1);
+		} else if (errno == ELAST) {
+			res = ioctl(gsm->fd, ZT_GETEVENT, &x);
+			printf("Got Zaptel event: %d\n", x);
+		} else if (errno != EINTR) 
+			fprintf(stderr, "Error (%d) on select: %s\n", ELAST, strerror(errno));
+
+		if (!e) {
+		    e = gsm_check_event(gsm->modul, 0);
+		}
+
+		if (e) {
+			handle_gsm_event(gsm, e);
+		}
+		ast_mutex_unlock(&gsm->lock);
+
+		res = ioctl(gsm->fd, ZT_GETEVENT, &x);
+
+		if (!res && x) {
+			switch (x) {
+			    case ZT_EVENT_NOALARM:
+				ast_log(LOG_NOTICE, "Alarm cleared on span %d\n", gsm->span);
+				usleep(1000);
+				gsm_restart(gsm->modul, 10000);
+			    break;
+			    case ZT_EVENT_ALARM:
+				ast_log(LOG_NOTICE, "Alarm detected on span %d\n", gsm->span);
+			    break;
+			    default:
+				fprintf(stderr, "Got event on GSM interface: %d\n", x);
+			}
+		}
+
+
+	}
+	return NULL;
+}
+
+#endif
 
 #ifdef ZAPATA_PRI
 static struct zt_pvt *pri_find_crv(struct zt_pri *pri, int crv)
@@ -7985,17 +8644,68 @@
 	return NULL;
 }
 
-
-static int pri_find_principle(struct zt_pri *pri, int channel)
+static int pri_find_tei(struct zt_pri *pri, q931_call *c, int tei)
 {
-	int x;
-	int span = PRI_SPAN(channel);
-	int spanfd;
-	ZT_PARAMS param;
-	int principle = -1;
-	int explicit = PRI_EXPLICIT(channel);
-	span = PRI_SPAN(channel);
-	channel = PRI_CHANNEL(channel);
+	int x=0;
+	for (x=0;x<pri->numchans;x++) {
+		if (!pri->pvts[x]) continue;
+		if ((pri->pvts[x]->tei == tei) && (pri->pvts[x]-> call != c)) {
+		    return x;
+		}
+	}
+	return -1;
+}
+
+static struct zt_holded_call *pri_get_callonhold(struct zt_pri *pri, int cref, int tei) {
+	struct zt_holded_call *zhc = pri->holded_calls;
+	struct zt_holded_call *zhctemp = NULL;
+
+	while (zhc) {
+	    if ((zhc->tei == tei) && ((zhc->cref == cref) || (cref == -1))) {
+		return zhc;
+	    }			
+	    zhctemp = zhc;
+	    if (zhc) zhc = zhc->next;
+	}
+	return NULL;	
+}
+
+static int pri_destroy_callonhold(struct zt_pri *pri, struct zt_holded_call *onhold) {
+	struct zt_holded_call *zhc = pri->holded_calls;
+	struct zt_holded_call *zhctemp = NULL;
+
+	while (zhc) {
+	    if (zhc == onhold) {
+		if (zhctemp) {
+		    zhctemp->next = zhc->next;
+		    zhc = zhctemp;
+		} else {
+		    pri->holded_calls = zhc->next;
+		    zhc = pri->holded_calls;
+		    zhctemp = NULL;
+		}
+	    }			
+	    zhctemp = zhc;
+	    if (zhc) zhc = zhc->next;
+	}
+	if (onhold) {
+	    free(onhold);
+	    onhold = NULL;
+	    return 1;	
+	}
+	return 0;	
+}
+
+static int pri_find_principle(struct zt_pri *pri, int channel)
+{
+	int x;
+	int span = PRI_SPAN(channel);
+	int spanfd;
+	ZT_PARAMS param;
+	int principle = -1;
+	int explicit = PRI_EXPLICIT(channel);
+	span = PRI_SPAN(channel);
+	channel = PRI_CHANNEL(channel);
 
 	if (!explicit) {
 		spanfd = pri_active_dchan_fd(pri);
@@ -8017,7 +8727,9 @@
 static int pri_fixup_principle(struct zt_pri *pri, int principle, q931_call *c)
 {
 	int x;
+	int res = 0;
 	struct zt_pvt *crv;
+	char tmpname[256];
 	if (!c) {
 		if (principle < 0)
 			return -1;
@@ -8031,6 +8743,7 @@
 	/* First, check for other bearers */
 	for (x=0;x<pri->numchans;x++) {
 		if (!pri->pvts[x]) continue;
+// ast_log(LOG_NOTICE, "principle %d channel %d call %d channel[x]->call %d\n",principle, x, c, pri->pvts[x]->call);
 		if (pri->pvts[x]->call == c) {
 			/* Found our call */
 			if (principle != x) {
@@ -8044,19 +8757,56 @@
 				}
 				/* Fix it all up now */
 				pri->pvts[principle]->owner = pri->pvts[x]->owner;
+ 				pri->pvts[principle]->outgoing = pri->pvts[x]->outgoing;
 				if (pri->pvts[principle]->owner) {
 					snprintf(pri->pvts[principle]->owner->name, sizeof(pri->pvts[principle]->owner->name), 
 						"Zap/%d:%d-%d", pri->trunkgroup, pri->pvts[principle]->channel, 1);
 					pri->pvts[principle]->owner->tech_pvt = pri->pvts[principle];
 					pri->pvts[principle]->owner->fds[0] = pri->pvts[principle]->subs[SUB_REAL].zfd;
 					pri->pvts[principle]->subs[SUB_REAL].owner = pri->pvts[x]->subs[SUB_REAL].owner;
-				} else
+				} else {
 					ast_log(LOG_WARNING, "Whoa, there's no  owner, and we're having to fix up channel %d to channel %d\n", pri->pvts[x]->channel, pri->pvts[principle]->channel);
+				}
 				pri->pvts[principle]->call = pri->pvts[x]->call;
+  				pri->pvts[principle]->dsp = pri->pvts[x]->dsp;
+  				pri->pvts[principle]->alreadyhungup = pri->pvts[x]->alreadyhungup;
+				pri->pvts[principle]->digital = pri->pvts[x]->digital;
+  				pri->pvts[principle]->faxhandled = pri->pvts[x]->faxhandled;
+  
+  				if ((pri->nodetype == BRI_CPE_PTMP) || (pri->nodetype == BRI_CPE)) { 
+  				    /* this might also apply for other pri types! */
+  				    pri->pvts[principle]->law = pri->pvts[x]->law;
+  				    if (ioctl(pri->pvts[principle]->subs[SUB_REAL].zfd, ZT_AUDIOMODE, &pri->pvts[principle]->law) == -1)
+  					ast_log(LOG_WARNING, "Unable to set audio mode on channel %d to %d\n", pri->pvts[principle]->channel, pri->pvts[principle]->law);
+  				    res = zt_setlaw(pri->pvts[principle]->subs[SUB_REAL].zfd, pri->pvts[principle]->law);
+  				    if (res < 0) 
+  					ast_log(LOG_WARNING, "Unable to set law on channel %d\n", pri->pvts[principle]->channel);
+				    if (!pri->pvts[principle]->digital) {
+  					res = set_actual_gain(pri->pvts[principle]->subs[SUB_REAL].zfd, 0, pri->pvts[principle]->rxgain, pri->pvts[principle]->txgain, pri->pvts[principle]->law);
+  				    } else {
+  					res = set_actual_gain(pri->pvts[principle]->subs[SUB_REAL].zfd, 0, 0, 0, pri->pvts[principle]->law);
+				    }
+				    if (res < 0) 
+  					ast_log(LOG_WARNING, "Unable to set gains on channel %d\n", pri->pvts[principle]->channel);
+  				    zt_confmute(pri->pvts[x], 0);
+  				    update_conf(pri->pvts[x]);
+  				    reset_conf(pri->pvts[x]);
+  				    restore_gains(pri->pvts[x]);
+  				    zt_disable_ec(pri->pvts[x]);
+  				    zt_setlinear(pri->pvts[x]->subs[SUB_REAL].zfd, 0);
+  				}
+  
+  				if (pri->pvts[principle]->owner) {
+  				    snprintf(tmpname, sizeof(tmpname), "Zap/%d-1", pri->pvts[principle]->channel);
+  				    ast_change_name(pri->pvts[principle]->owner, tmpname);
+  				}
+
+
 				/* Free up the old channel, now not in use */
 				pri->pvts[x]->subs[SUB_REAL].owner = NULL;
 				pri->pvts[x]->owner = NULL;
 				pri->pvts[x]->call = NULL;
+ 				pri->pvts[x]->dsp = NULL;
 			}
 			return principle;
 		}
@@ -8085,7 +8835,9 @@
 		}
 		crv = crv->next;
 	}
-	ast_log(LOG_WARNING, "Call specified, but not found?\n");
+	if ((pri->nodetype != BRI_NETWORK_PTMP) && (pri->nodetype != BRI_NETWORK)) {
+	    ast_log(LOG_WARNING, "Call specified, but not found?\n");
+	}
 	return -1;
 }
 
@@ -8144,86 +8896,33 @@
 #ifndef PRI_RESTART
 #error "Upgrade your libpri"
 #endif
-static void zt_pri_message(struct pri *pri, char *s)
+static void zt_pri_message(char *s, int span)
 {
-	int x, y;
-	int dchan = -1, span = -1;
-	int dchancount = 0;
-
-	if (pri) {
-		for (x = 0; x < NUM_SPANS; x++) {
-			for (y = 0; y < NUM_DCHANS; y++) {
-				if (pris[x].dchans[y])
-					dchancount++;
-
-				if (pris[x].dchans[y] == pri)
-					dchan = y;
-			}
-			if (dchan >= 0) {
-				span = x;
-				break;
-			}
-			dchancount = 0;
-		}
-		if ((dchan >= 0) && (span >= 0)) {
-			if (dchancount > 1)
-				ast_verbose("[Span %d D-Channel %d]%s", span, dchan, s);
-			else
-				ast_verbose("%s", s);
-		} else
-			ast_verbose("PRI debug error: could not find pri associated it with debug message output\n");
-	} else
-		ast_verbose("%s", s);
-
-	ast_mutex_lock(&pridebugfdlock);
-
-	if (pridebugfd >= 0)
-		write(pridebugfd, s, strlen(s));
-
-	ast_mutex_unlock(&pridebugfdlock);
+	ast_verbose("%d %s", span, s);
 }
 
-static void zt_pri_error(struct pri *pri, char *s)
+static void zt_pri_error(char *s, int span)
 {
-	int x, y;
-	int dchan = -1, span = -1;
-	int dchancount = 0;
-
-	if (pri) {
-		for (x = 0; x < NUM_SPANS; x++) {
-			for (y = 0; y < NUM_DCHANS; y++) {
-				if (pris[x].dchans[y])
-					dchancount++;
-
-				if (pris[x].dchans[y] == pri)
-					dchan = y;
-			}
-			if (dchan >= 0) {
-				span = x;
-				break;
-			}
-			dchancount = 0;
-		}
-		if ((dchan >= 0) && (span >= 0)) {
-			if (dchancount > 1)
-				ast_log(LOG_WARNING, "[Span %d D-Channel %d] PRI: %s", span, dchan, s);
-			else
-				ast_verbose("%s", s);
-		} else
-			ast_verbose("PRI debug error: could not find pri associated it with debug message output\n");
-	} else
-		ast_log(LOG_WARNING, "%s", s);
-
-	ast_mutex_lock(&pridebugfdlock);
+	ast_log(LOG_WARNING, "%d %s", span, s);
+}
 
-	if (pridebugfd >= 0)
-		write(pridebugfd, s, strlen(s));
+#ifdef ZAPATA_GSM
+static void zt_gsm_message(char *s, int channel)
+{
+	ast_verbose("GSM %d: %s", channel, s);
+}
 
-	ast_mutex_unlock(&pridebugfdlock);
+static void zt_gsm_error(char *s, int channel)
+{
+	ast_log(LOG_WARNING, "GSM %d: %s", channel, s);
 }
+#endif
 
 static int pri_check_restart(struct zt_pri *pri)
 {
+	if ((pri->nodetype != PRI_NETWORK) && (pri->nodetype != PRI_CPE)) {
+	    return 0;
+	}
 	do {
 		pri->resetpos++;
 	} while((pri->resetpos < pri->numchans) &&
@@ -8306,6 +9005,32 @@
 	}
 }
 
+static void pri_make_callerid(struct zt_pri *pri, char *callerid, int callerid_len, char *callingnum, int callingnum_len, int callingplan, int callingpres, int stripmsd) {
+    if (callingnum && (callingnum_len > stripmsd)) {
+	callingnum += stripmsd;
+    }
+    switch (callingplan) {
+	case PRI_INTERNATIONAL_ISDN:
+	    snprintf(callerid, callerid_len, "%s%s", pri->internationalprefix, callingnum);
+	    break;
+	case PRI_NATIONAL_ISDN:
+	    snprintf(callerid, callerid_len, "%s%s", pri->nationalprefix, callingnum);
+	    break;
+	case PRI_LOCAL_ISDN:
+	    snprintf(callerid, callerid_len, "%s%s", pri->localprefix, callingnum);
+	    break;
+	case PRI_PRIVATE:
+	    snprintf(callerid, callerid_len, "%s%s", pri->privateprefix, callingnum);
+	    break;
+	case PRI_UNKNOWN:
+	    snprintf(callerid, callerid_len, "%s%s", pri->unknownprefix, callingnum);
+	    break;
+	default:
+	    snprintf(callerid, callerid_len, "%s", callingnum);
+	    break;
+    }
+}
+
 static void *pri_dchannel(void *vpri)
 {
 	struct zt_pri *pri = vpri;
@@ -8483,15 +9208,44 @@
 					/* Check for an event */
 					x = 0;
 					res = ioctl(pri->fds[which], ZT_GETEVENT, &x);
-					if (x) 
+					if ((pri->nodetype != BRI_CPE) && (pri->nodetype != BRI_CPE_PTMP)) {
+					    /* dont annoy BRI TE mode users with layer2layer alarms */
+					    if (x)
 						ast_log(LOG_NOTICE, "PRI got event: %s (%d) on %s D-channel of span %d\n", event2str(x), x, pri_order(which), pri->span);
+					}
 					/* Keep track of alarm state */	
 					if (x == ZT_EVENT_ALARM) {
 						pri->dchanavail[which] &= ~(DCHAN_NOTINALARM | DCHAN_UP);
 						pri_find_dchan(pri);
+						if ((pri->nodetype == BRI_CPE) || (pri->nodetype == BRI_CPE_PTMP)) {
+						    if (pri->pri) {
+							for (i=0; i<pri->numchans; i++) {
+							    struct zt_pvt *p = pri->pvts[i];
+							    if (p) {
+								if (p->call) {
+								    if (p->pri && p->pri->pri) {
+								    	pri_destroycall(p->pri->pri, p->call);
+									p->call = NULL;
+									p->tei = -1;
+								    } else
+									ast_log(LOG_WARNING, "The PRI Call have not been destroyed\n");
+								}
+								if (p->owner)
+								    p->owner->_softhangup |= AST_SOFTHANGUP_DEV;
+								p->inalarm = 1;
+							    }
+							}
+							pri_shutdown(pri->pri);
+						    }
+						}
 					} else if (x == ZT_EVENT_NOALARM) {
-						pri->dchanavail[which] |= DCHAN_NOTINALARM;
-						pri_restart(pri->dchans[which]);
+						if ((pri->nodetype == BRI_CPE) || (pri->nodetype == BRI_CPE_PTMP)) {
+						    pri->dchanavail[which] |= DCHAN_NOTINALARM;
+						//    pri->dchanavail[which] |= DCHAN_UP;
+						} else {
+						    pri->dchanavail[which] |= DCHAN_NOTINALARM;
+						    pri_restart(pri->dchans[which]);
+						}
 					}
 				
 					if (option_debug)
@@ -8503,8 +9257,7 @@
 					break;
 			}
 		} else if (errno != EINTR)
-			ast_log(LOG_WARNING, "pri_event returned error %d (%s)\n", errno, strerror(errno));
-
+ 			ast_log(LOG_WARNING, "pri_event returned error %d (%s) on span %d\n", errno, strerror(errno), pri->span);
 		if (e) {
 			if (pri->debug)
 				pri_dump_event(pri->dchans[which], e);
@@ -8517,32 +9270,102 @@
 
 			switch(e->e) {
 			case PRI_EVENT_DCHAN_UP:
-				if (option_verbose > 1) 
-					ast_verbose(VERBOSE_PREFIX_2 "%s D-Channel on span %d up\n", pri_order(which), pri->span);
-				pri->dchanavail[which] |= DCHAN_UP;
-				if (!pri->pri) pri_find_dchan(pri);
-
-				/* Note presense of D-channel */
-				time(&pri->lastreset);
-
-				/* Restart in 5 seconds */
-				if (pri->resetinterval > -1) {
-					pri->lastreset -= pri->resetinterval;
-					pri->lastreset += 5;
-				}
-				pri->resetting = 0;
-				/* Take the channels from inalarm condition */
-				for (i=0; i<pri->numchans; i++)
-					if (pri->pvts[i]) {
-						pri->pvts[i]->inalarm = 0;
-					}
+  				if (pri->nodetype == BRI_NETWORK_PTMP) {
+  				    if (option_verbose > 3) 
+  					ast_verbose(VERBOSE_PREFIX_2 "%s D-Channel on span %d up for TEI %d\n", pri_order(which), pri->span, e->gen.tei);
+  				    pri->dchanavail[which] |= (DCHAN_PROVISIONED | DCHAN_NOTINALARM | DCHAN_UP);
+  				    pri_find_dchan(pri);
+  
+  				    /* Note presense of D-channel */
+  				    time(&pri->lastreset);
+  
+  				    pri->resetting = 0;
+  				    /* Take the channels from inalarm condition */
+  				    for (i=0; i<pri->numchans; i++)
+  					if (pri->pvts[i]) {
+  						pri->pvts[i]->inalarm = 0;
+  					}
+  				} else {
+  				    if (pri->nodetype == BRI_CPE_PTMP) {
+  					if (option_verbose > 3) 
+  					    ast_verbose(VERBOSE_PREFIX_2 "%s D-Channel on span %d up\n", pri_order(which), pri->span);
+  				    } else {
+  					if (option_verbose > 1) 
+  					    ast_verbose(VERBOSE_PREFIX_2 "%s D-Channel on span %d up\n", pri_order(which), pri->span);
+  				    }
+  				    pri->dchanavail[which] |= (DCHAN_PROVISIONED | DCHAN_NOTINALARM | DCHAN_UP);
+  				    pri_find_dchan(pri);
+  
+  				    /* Note presense of D-channel */
+  				    time(&pri->lastreset);
+  
+  				    /* Restart in 5 seconds */
+  				    pri->lastreset -= pri->resetinterval;
+  				    pri->lastreset += 5;
+  				    pri->resetting = 0;
+  				    /* Take the channels from inalarm condition */
+  				    for (i=0; i<pri->numchans; i++) {
+ 					struct zt_pvt *p = pri->pvts[i];
+   					if (p) {
+   					    p->inalarm = 0;
+ 					    /* hang up calls that are not bridged yet, dont touch bridged calls */
+ 					    if (p->call) {
+ 						if (p->pri && p->pri->pri) {
+ 						    if (p->owner) {
+ 							if (p->owner->_state != AST_STATE_UP) {
+ 							    p->owner->_softhangup |= AST_SOFTHANGUP_DEV;
+ 							    pri_destroycall(p->pri->pri, p->call);
+ 							    p->call = NULL;
+ 							}
+ 						    } else {
+ 							pri_destroycall(p->pri->pri, p->call);
+ 							p->call = NULL;
+ 						    }
+ 						}
+ 					    }
+   					}
+ 				    }
+  				}
 				break;
 			case PRI_EVENT_DCHAN_DOWN:
-				if (option_verbose > 1) 
-					ast_verbose(VERBOSE_PREFIX_2 "%s D-Channel on span %d down\n", pri_order(which), pri->span);
-				pri->dchanavail[which] &= ~DCHAN_UP;
-				pri_find_dchan(pri);
-				if (!pri_is_up(pri)) {
+  				if (pri->nodetype == BRI_NETWORK_PTMP) {
+  				    if (option_verbose > 3) 
+  					ast_verbose(VERBOSE_PREFIX_2 "%s D-Channel on span %d down for TEI %d\n", pri_order(which), pri->span, e->gen.tei);
+  				    // PTMP BRIs have N dchans, handled by libpri
+  				    if (e->gen.tei == 0) break;
+  				    /* Hangup active channels */
+  				    for (i=0; i<pri->numchans; i++) {
+  				    	struct zt_pvt *p = pri->pvts[i];
+ 					if (p) {
+  			//		ast_log(LOG_NOTICE, "chan %d tei %d\n",i,p->tei);
+  					    if (p->tei == e->gen.tei) {
+  						if (p->call) {
+  							if (p->pri && p->pri->pri) {
+  							//	pri_hangup(p->pri->pri, p->call, -1);
+  								pri_destroycall(p->pri->pri, p->call);
+  								p->tei = -1;
+  								p->call = NULL;
+  							} else
+  								ast_log(LOG_WARNING, "The PRI Call have not been destroyed\n");
+  						}
+  						if (p->owner)
+  						    p->owner->_softhangup |= AST_SOFTHANGUP_DEV;
+  						p->inalarm = 1;
+  						p->tei = -1;
+  					    }
+  					}
+  				    } 
+  				} else {
+  				    if (pri->nodetype == BRI_CPE_PTMP) {
+  					if (option_verbose > 3) 
+  					    ast_verbose(VERBOSE_PREFIX_2 "%s D-Channel on span %d down\n", pri_order(which), pri->span);
+  				    } else {
+  					if (option_verbose > 1) 
+  					    ast_verbose(VERBOSE_PREFIX_2 "%s D-Channel on span %d down\n", pri_order(which), pri->span);
+  				    }
+  				    pri->dchanavail[which] &= ~DCHAN_UP;
+  				    pri_find_dchan(pri);
+  				    if (!pri_is_up(pri)) {
 					pri->resetting = 0;
 					/* Hangup active channels and put them in alarm mode */
 					for (i=0; i<pri->numchans; i++) {
@@ -8550,19 +9373,29 @@
 						if (p) {
 							if (p->call) {
 								if (p->pri && p->pri->pri) {
-									pri_hangup(p->pri->pri, p->call, -1);
-									pri_destroycall(p->pri->pri, p->call);
-									p->call = NULL;
+								    if (p->owner) {
+									if (p->owner->_state != AST_STATE_UP) {
+								//	    pri_hangup(p->pri->pri, p->call, -1);
+									    pri_destroycall(p->pri->pri, p->call);
+									    p->call = NULL;
+									    p->owner->_softhangup |= AST_SOFTHANGUP_DEV;
+									    p->inalarm = 1;
+									}
+								    } else {
+									    pri_destroycall(p->pri->pri, p->call);
+									    p->call = NULL;
+									    p->inalarm = 1;
+								    }
 								} else
 									ast_log(LOG_WARNING, "The PRI Call have not been destroyed\n");
 							}
 							if (p->realcall) {
-								pri_hangup_all(p->realcall, pri);
-							} else if (p->owner)
-								p->owner->_softhangup |= AST_SOFTHANGUP_DEV;
-							p->inalarm = 1;
+							    pri_hangup_all(p->realcall, pri);
+							    p->inalarm = 1;
+							} 
 						}
 					}
+				    }
 				}
 				break;
 			case PRI_EVENT_RESTART:
@@ -8597,8 +9430,8 @@
 								pri_destroycall(pri->pri, pri->pvts[x]->call);
 								pri->pvts[x]->call = NULL;
 							}
-							if (pri->pvts[chanpos]->realcall) 
-								pri_hangup_all(pri->pvts[chanpos]->realcall, pri);
+							if (pri->pvts[x]->realcall) 
+								pri_hangup_all(pri->pvts[x]->realcall, pri);
  							else if (pri->pvts[x]->owner)
 								pri->pvts[x]->owner->_softhangup |= AST_SOFTHANGUP_DEV;
 							ast_mutex_unlock(&pri->pvts[x]->lock);
@@ -8632,7 +9465,6 @@
 					}
 				}
 				break;
-				
 			case PRI_EVENT_INFO_RECEIVED:
 				chanpos = pri_find_principle(pri, e->ring.channel);
 				if (chanpos < 0) {
@@ -8641,9 +9473,11 @@
 				} else {
 					chanpos = pri_fixup_principle(pri, chanpos, e->ring.call);
 					if (chanpos > -1) {
+//					ast_log(LOG_NOTICE, "INFO received on  channel %d/%d span %d\n", 
+//						PRI_SPAN(e->ring.channel), PRI_CHANNEL(e->ring.channel), pri->span);
 						ast_mutex_lock(&pri->pvts[chanpos]->lock);
 						/* queue DTMF frame if the PBX for this call was already started (we're forwarding INFORMATION further on */
-						if (pri->overlapdial && pri->pvts[chanpos]->call==e->ring.call && pri->pvts[chanpos]->owner) {
+						if (pri->pvts[chanpos]->call==e->ring.call && pri->pvts[chanpos]->owner) {
 							/* how to do that */
 							int digitlen = strlen(e->ring.callednum);
 							char digit;
@@ -8655,6 +9489,14 @@
 									zap_queue_frame(pri->pvts[chanpos], &f, pri);
 								}
 							}
+							if (!pri->overlapdial) {
+							    strncat(pri->pvts[chanpos]->exten, e->ring.callednum, sizeof(pri->pvts[chanpos]->exten));
+							    if (!ast_ignore_pattern(pri->pvts[chanpos]->context, pri->pvts[chanpos]->exten + 1)) {
+								tone_zone_play_tone(pri->pvts[chanpos]->subs[SUB_REAL].zfd, -1);
+							    } else {
+								tone_zone_play_tone(pri->pvts[chanpos]->subs[SUB_REAL].zfd, ZT_TONE_DIALTONE);
+							    }
+							} 
 						}
 						ast_mutex_unlock(&pri->pvts[chanpos]->lock);
 					}
@@ -8662,36 +9504,59 @@
 				break;
 			case PRI_EVENT_RING:
 				crv = NULL;
-				if (e->ring.channel == -1)
+ 				if (e->ring.channel == -1) {
+ 					/* if no channel specified find one empty */
 					chanpos = pri_find_empty_chan(pri, 1);
-				else
+				} else {
 					chanpos = pri_find_principle(pri, e->ring.channel);
+				}
 				/* if no channel specified find one empty */
 				if (chanpos < 0) {
-					ast_log(LOG_WARNING, "Ring requested on unconfigured channel %d/%d span %d\n", 
-						PRI_SPAN(e->ring.channel), PRI_CHANNEL(e->ring.channel), pri->span);
+ 					/* no channel specified and no free channel. this is a callwating SETUP */
+ 					if (e->ring.channel == -1) {
+ 					    if (option_verbose > 2)
+ 						ast_verbose(VERBOSE_PREFIX_3 "Ignoring callwaiting SETUP on channel %d/%d span %d %d\n", PRI_SPAN(e->ring.channel), PRI_CHANNEL(e->ring.channel), pri->span, e->ring.channel);
+ 					    pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_USER_BUSY, -1);
+ 					    break;
+ 					}
 				} else {
+					/* ok, we got a b channel for this call, lock it */
 					ast_mutex_lock(&pri->pvts[chanpos]->lock);
 					if (pri->pvts[chanpos]->owner) {
-						if (pri->pvts[chanpos]->call == e->ring.call) {
-							ast_log(LOG_WARNING, "Duplicate setup requested on channel %d/%d already in use on span %d\n", 
+					    /* safety check, for messed up retransmissions? */
+					    if (pri->pvts[chanpos]->call == e->ring.call) {
+						ast_log(LOG_WARNING, "Duplicate setup requested on channel %d/%d already in use on span %d\n", 
 								PRI_SPAN(e->ring.channel), PRI_CHANNEL(e->ring.channel), pri->span);
-							break;
+						ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+						chanpos = -1;
+						break;
+					    } else {
+ 						ast_log(LOG_WARNING, "Ring requested on channel %d/%d already in use on span %d. Hanging up owner.\n", 
+						PRI_SPAN(e->ring.channel), PRI_CHANNEL(e->ring.channel), pri->span);
+						if (pri->pvts[chanpos]->realcall) {
+ 							pri_hangup_all(pri->pvts[chanpos]->realcall, pri);
 						} else {
-							/* This is where we handle initial glare */
-							ast_log(LOG_DEBUG, "Ring requested on channel %d/%d already in use or previously requested on span %d.  Attempting to renegotiating channel.\n", 
-							PRI_SPAN(e->ring.channel), PRI_CHANNEL(e->ring.channel), pri->span);
-							ast_mutex_unlock(&pri->pvts[chanpos]->lock);
-							chanpos = -1;
+							pri->pvts[chanpos]->owner->_softhangup |= AST_SOFTHANGUP_DEV;
+							/* XXX destroy the call here, so we can accept the retransmission as a new call */
+							pri_destroycall(pri->pri, e->ring.call);
 						}
-					}
-					if (chanpos > -1)
 						ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+						chanpos = -1;
+						break;
+					    }
+					}
+ 					if (chanpos > -1) {
+						/* everything is ok with the b channel */
+					    ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+					}
 				}
-				if ((chanpos < 0) && (e->ring.flexible))
-					chanpos = pri_find_empty_chan(pri, 1);
+ 				/* actually, we already got a valid channel by now */
 				if (chanpos > -1) {
 					ast_mutex_lock(&pri->pvts[chanpos]->lock);
+					/* dont detect dtmfs before the signalling is done */
+					disable_dtmf_detect(pri->pvts[chanpos]);
+					/* this channel is owned by this TEI */
+					pri->pvts[chanpos]->tei = e->ring.tei;
 					if (pri->switchtype == PRI_SWITCH_GR303_TMC) {
 						/* Should be safe to lock CRV AFAIK while bearer is still locked */
 						crv = pri_find_crv(pri, pri_get_crv(pri->pri, e->ring.call, NULL));
@@ -8705,13 +9570,14 @@
 								ast_log(LOG_WARNING, "Call received for busy CRV %d on span %d\n", pri_get_crv(pri->pri, e->ring.call, NULL), pri->span);
 							} else
 								ast_log(LOG_NOTICE, "Call received for unconfigured CRV %d on span %d\n", pri_get_crv(pri->pri, e->ring.call, NULL), pri->span);
-							pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_INVALID_CALL_REFERENCE);
+							pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_INVALID_CALL_REFERENCE, -1);
 							if (crv)
 								ast_mutex_unlock(&crv->lock);
 							ast_mutex_unlock(&pri->pvts[chanpos]->lock);
 							break;
 						}
 					}
+  					/* assign call to b channel */
 					pri->pvts[chanpos]->call = e->ring.call;
 					apply_plan_to_number(plancallingnum, sizeof(plancallingnum), pri, e->ring.callingnum, e->ring.callingplan);
 					if (pri->pvts[chanpos]->use_callerid) {
@@ -8736,29 +9602,78 @@
 					}
 					apply_plan_to_number(pri->pvts[chanpos]->rdnis, sizeof(pri->pvts[chanpos]->rdnis), pri,
 							     e->ring.redirectingnum, e->ring.callingplanrdnis);
+  					/* get callingpres */
+  					pri->pvts[chanpos]->cid_pres = e->ring.callingpres;
+					switch (e->ring.callingpres) {
+					    case PRES_PROHIB_USER_NUMBER_NOT_SCREENED:
+					    case PRES_PROHIB_USER_NUMBER_PASSED_SCREEN:
+					    case PRES_PROHIB_USER_NUMBER_FAILED_SCREEN:
+					    case PRES_PROHIB_NETWORK_NUMBER:
+						strncpy(pri->pvts[chanpos]->cid_name, pri->withheldcid, sizeof(pri->pvts[chanpos]->cid_name));
+						break;
+					    case PRES_NUMBER_NOT_AVAILABLE:
+						strncpy(pri->pvts[chanpos]->cid_name, pri->nocid, sizeof(pri->pvts[chanpos]->cid_name));
+						break;
+					}
 					/* If immediate=yes go to s|1 */
 					if (pri->pvts[chanpos]->immediate) {
 						if (option_verbose > 2)
 							ast_verbose(VERBOSE_PREFIX_3 "Going to extension s|1 because of immediate=yes\n");
 						pri->pvts[chanpos]->exten[0] = 's';
 						pri->pvts[chanpos]->exten[1] = '\0';
-					}
-					/* Get called number */
-					else if (!ast_strlen_zero(e->ring.callednum)) {
-						ast_copy_string(pri->pvts[chanpos]->exten, e->ring.callednum, sizeof(pri->pvts[chanpos]->exten));
-						ast_copy_string(pri->pvts[chanpos]->dnid, e->ring.callednum, sizeof(pri->pvts[chanpos]->dnid));
-					} else
-						pri->pvts[chanpos]->exten[0] = '\0';
-					/* Set DNID on all incoming calls -- even immediate */
-					if (!ast_strlen_zero(e->ring.callednum))
-						ast_copy_string(pri->pvts[chanpos]->dnid, e->ring.callednum, sizeof(pri->pvts[chanpos]->dnid));
-					/* No number yet, but received "sending complete"? */
-					if (e->ring.complete && (ast_strlen_zero(e->ring.callednum))) {
+  					} else if (ast_strlen_zero(e->ring.callednum)) {
+  					    /* called party number is empty */
+  					    if ((pri->nodetype == BRI_NETWORK_PTMP) || (pri->nodetype == BRI_NETWORK)) {
+  						if (!pri->overlapdial) {
+  						    // be able to set digittimeout for BRI phones
+  						    pri->pvts[chanpos]->exten[0] = 's';
+  						    pri->pvts[chanpos]->exten[1] = '\0';
+  						    tone_zone_play_tone(pri->pvts[chanpos]->subs[SUB_REAL].zfd, ZT_TONE_DIALTONE);
+  						} else {
+  						    pri->pvts[chanpos]->exten[0] = '\0';
+  						}
+  					    } else {
+  						if (pri->nodetype == BRI_CPE) { 
+  						    /* fix for .at p2p bri lines */
+  						    pri->pvts[chanpos]->exten[0] = 's';
+  						    pri->pvts[chanpos]->exten[1] = '\0';
+  						} else {
+  						    pri->pvts[chanpos]->exten[0] = '\0';
+  						}
+  					    }
+  					    /* No number yet, but received "sending complete"? */
+   					    if (e->ring.complete) {
 						if (option_verbose > 2)
 							ast_verbose(VERBOSE_PREFIX_3 "Going to extension s|1 because of Complete received\n");
 						pri->pvts[chanpos]->exten[0] = 's';
 						pri->pvts[chanpos]->exten[1] = '\0';
-					}
+ 					    }
+  					} else {
+  						/* Get called number */
+  						pri_make_callerid(pri, pri->pvts[chanpos]->dnid, sizeof(pri->pvts[chanpos]->dnid), e->ring.callednum, sizeof(e->ring.callednum),  e->ring.calledplan, 0, pri->pvts[chanpos]->stripmsd);
+  						pri_make_callerid(pri, pri->pvts[chanpos]->exten, sizeof(pri->pvts[chanpos]->exten), e->ring.callednum, sizeof(e->ring.callednum), e->ring.calledplan, 0, pri->pvts[chanpos]->stripmsd);
+  						if ((pri->nodetype == BRI_NETWORK_PTMP) || (pri->nodetype == BRI_NETWORK)) {
+  						    /* if we get the next digit we should stop the dialtone */
+  						    if (!pri->overlapdial) {
+  							// with overlapdial=no the exten is always prefixed by "s"
+  							if (!ast_ignore_pattern(pri->pvts[chanpos]->context, pri->pvts[chanpos]->exten + 1)) {
+  							    tone_zone_play_tone(pri->pvts[chanpos]->subs[SUB_REAL].zfd, -1);
+  							} else {
+  							    tone_zone_play_tone(pri->pvts[chanpos]->subs[SUB_REAL].zfd, ZT_TONE_DIALTONE);
+  							}
+  						    } else {
+  							if (!ast_ignore_pattern(pri->pvts[chanpos]->context, pri->pvts[chanpos]->exten)) {
+  							    tone_zone_play_tone(pri->pvts[chanpos]->subs[SUB_REAL].zfd, -1);
+  							} else {
+  							    tone_zone_play_tone(pri->pvts[chanpos]->subs[SUB_REAL].zfd, ZT_TONE_DIALTONE);
+  							}
+  						    }
+  						}
+					}
+  					/* Part 3: create channel, setup audio... */
+ 					/* Set DNID on all incoming calls -- even immediate */
+ 					if (!ast_strlen_zero(e->ring.callednum))
+ 						strncpy(pri->pvts[chanpos]->dnid, e->ring.callednum, sizeof(pri->pvts[chanpos]->dnid) - 1);
 					/* Make sure extension exists (or in overlap dial mode, can exist) */
 					if ((pri->overlapdial && ast_canmatch_extension(NULL, pri->pvts[chanpos]->context, pri->pvts[chanpos]->exten, 1, pri->pvts[chanpos]->cid_num)) ||
 						ast_exists_extension(NULL, pri->pvts[chanpos]->context, pri->pvts[chanpos]->exten, 1, pri->pvts[chanpos]->cid_num)) {
@@ -8777,19 +9692,36 @@
 						res = zt_setlaw(pri->pvts[chanpos]->subs[SUB_REAL].zfd, law);
 						if (res < 0) 
 							ast_log(LOG_WARNING, "Unable to set law on channel %d\n", pri->pvts[chanpos]->channel);
-						res = set_actual_gain(pri->pvts[chanpos]->subs[SUB_REAL].zfd, 0, pri->pvts[chanpos]->rxgain, pri->pvts[chanpos]->txgain, law);
+ 						if (IS_DIGITAL(e->ring.ctype)) {
+						    res = set_actual_gain(pri->pvts[chanpos]->subs[SUB_REAL].zfd, 0, 0, 0, pri->pvts[chanpos]->law);
+						} else {
+ 						    res = set_actual_gain(pri->pvts[chanpos]->subs[SUB_REAL].zfd, 0, pri->pvts[chanpos]->rxgain, pri->pvts[chanpos]->txgain, law);
+ 						}
 						if (res < 0)
 							ast_log(LOG_WARNING, "Unable to set gains on channel %d\n", pri->pvts[chanpos]->channel);
-						if (e->ring.complete || !pri->overlapdial) {
+ 						if ((pri->nodetype != BRI_NETWORK_PTMP) && (pri->nodetype != BRI_NETWORK)) {
+  						    if (e->ring.complete || !pri->overlapdial) {
 							/* Just announce proceeding */
 							pri->pvts[chanpos]->proceeding = 1;
 							pri_proceeding(pri->pri, e->ring.call, PVT_TO_CHANNEL(pri->pvts[chanpos]), 0);
-						} else  {
+						    } else  {
 							if (pri->switchtype != PRI_SWITCH_GR303_TMC) 
 								pri_need_more_info(pri->pri, e->ring.call, PVT_TO_CHANNEL(pri->pvts[chanpos]), 1);
 							else
 								pri_answer(pri->pri, e->ring.call, PVT_TO_CHANNEL(pri->pvts[chanpos]), 1);
-						}
+						    }
+ 						} else {
+ 							/* BRI_NETWORK | BRI_NETWORK_PTMP */
+ 							if (pri->overlapdial || (!strcasecmp(pri->pvts[chanpos]->exten, "s"))) {
+ 							    /* send a SETUP_ACKNOWLEDGE */
+ 							    pri_need_more_info(pri->pri, e->ring.call, PVT_TO_CHANNEL(pri->pvts[chanpos]), 1);
+ 							} else {
+  							    /* send an ALERTING ??? wtf */
+ 							//    pri_acknowledge(pri->pri, e->ring.call, PVT_TO_CHANNEL(pri->pvts[chanpos]), 1);
+ 							    pri_proceeding(pri->pri, e->ring.call, PVT_TO_CHANNEL(pri->pvts[chanpos]), 0);
+ 							}
+  						}
+ 						/* overlapdial = yes  and the extension can be valid */
 						/* Get the use_callingpres state */
 						pri->pvts[chanpos]->callingpres = e->ring.callingpres;
 					
@@ -8801,14 +9733,31 @@
 								/* Set bearer and such */
 								pri_assign_bearer(crv, pri, pri->pvts[chanpos]);
 								c = zt_new(crv, AST_STATE_RESERVED, 0, SUB_REAL, law, e->ring.ctype);
+								if (c && (e->ring.lowlayercompat[0] > 0)) {
+								    memcpy(c->lowlayercompat, e->ring.lowlayercompat, sizeof(c->lowlayercompat));
+								}
 								pri->pvts[chanpos]->owner = &inuse;
 								ast_log(LOG_DEBUG, "Started up crv %d:%d on bearer channel %d\n", pri->trunkgroup, crv->channel, crv->bearer->channel);
 							} else {
 								c = zt_new(pri->pvts[chanpos], AST_STATE_RESERVED, 0, SUB_REAL, law, e->ring.ctype);
+								if (c && (e->ring.lowlayercompat[0] > 0)) {
+								    memcpy(c->lowlayercompat, e->ring.lowlayercompat, sizeof(c->lowlayercompat));
+								}
+ 								zt_enable_ec(pri->pvts[chanpos]);
 							}
 							if (!ast_strlen_zero(e->ring.callingsubaddr)) {
 								pbx_builtin_setvar_helper(c, "CALLINGSUBADDR", e->ring.callingsubaddr);
 							}
+ 					    		if (!ast_strlen_zero(e->ring.callingnum)) {
+ 							    char tmpstr[256];
+ 							    pri_make_callerid(pri, tmpstr, sizeof(tmpstr), e->ring.callingnum, sizeof(e->ring.callingnum), e->ring.callingplan, e->ring.callingpres, 0);
+ 							    pbx_builtin_setvar_helper(c, "PRI_NETWORK_CID", tmpstr);
+ 							}
+ 							if (!ast_strlen_zero(e->ring.callingani)) {
+ 							    char tmpstr[256];
+ 							    pri_make_callerid(pri, tmpstr, sizeof(tmpstr), e->ring.callingani, sizeof(e->ring.callingani), e->ring.callingplanuser, e->ring.callingpresuser, 0);
+ 							    pbx_builtin_setvar_helper(c, "PRI_USER_CID", tmpstr);
+ 							}
 							if(e->ring.ani2 >= 0) {
 								snprintf(ani2str, 5, "%.2d", e->ring.ani2);
 								pbx_builtin_setvar_helper(c, "ANI2", ani2str);
@@ -8830,8 +9779,8 @@
 							pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
 							if (c && !ast_pthread_create(&threadid, &attr, ss_thread, c)) {
 								if (option_verbose > 2)
-									ast_verbose(VERBOSE_PREFIX_3 "Accepting overlap call from '%s' to '%s' on channel %d/%d, span %d\n",
-										plancallingnum, !ast_strlen_zero(pri->pvts[chanpos]->exten) ? pri->pvts[chanpos]->exten : "<unspecified>", 
+									ast_verbose(VERBOSE_PREFIX_3 "Accepting overlap %s call from '%s' to '%s' on channel %d/%d, span %d\n",
+										pri->pvts[chanpos]->digital ? "data" : "voice", plancallingnum, !ast_strlen_zero(pri->pvts[chanpos]->exten) ? pri->pvts[chanpos]->exten : "<unspecified>", 
 										pri->pvts[chanpos]->logicalspan, pri->pvts[chanpos]->prioffset, pri->span);
 							} else {
 								ast_log(LOG_WARNING, "Unable to start PBX on channel %d/%d, span %d\n", 
@@ -8839,15 +9788,19 @@
 								if (c)
 									ast_hangup(c);
 								else {
-									pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_SWITCH_CONGESTION);
+									pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_SWITCH_CONGESTION, -1);
 									pri->pvts[chanpos]->call = NULL;
 								}
 							}
 							pthread_attr_destroy(&attr);
 						} else  {
+							/* overlapdial = no */    
 							ast_mutex_unlock(&pri->lock);
 							/* Release PRI lock while we create the channel */
 							c = zt_new(pri->pvts[chanpos], AST_STATE_RING, 1, SUB_REAL, law, e->ring.ctype);
+							if (c && (e->ring.lowlayercompat[0] > 0)) {
+							    memcpy(c->lowlayercompat, e->ring.lowlayercompat, sizeof(c->lowlayercompat));
+							}
 							ast_mutex_lock(&pri->lock);
 							if (c) {
 								char calledtonstr[10];
@@ -8868,23 +9821,40 @@
 								snprintf(calledtonstr, sizeof(calledtonstr)-1, "%d", e->ring.calledplan);
 								pbx_builtin_setvar_helper(c, "CALLEDTON", calledtonstr);
 								if (option_verbose > 2)
-									ast_verbose(VERBOSE_PREFIX_3 "Accepting call from '%s' to '%s' on channel %d/%d, span %d\n",
-										plancallingnum, pri->pvts[chanpos]->exten, 
+ 									ast_verbose(VERBOSE_PREFIX_3 "Accepting %s call from '%s' to '%s' on channel %d/%d, span %d\n",
+ 										pri->pvts[chanpos]->digital ? "data" : "voice", e->ring.callingnum, pri->pvts[chanpos]->exten, 
 											pri->pvts[chanpos]->logicalspan, pri->pvts[chanpos]->prioffset, pri->span);
 								zt_enable_ec(pri->pvts[chanpos]);
+ 							    if(!ast_strlen_zero(e->ring.callingsubaddr)) {
+ 								pbx_builtin_setvar_helper(c, "CALLINGSUBADDR", e->ring.callingsubaddr);
+ 							    }
+ 					    		    if (!ast_strlen_zero(e->ring.callingnum)) {
+ 								char tmpstr[256];
+ 							        pri_make_callerid(pri, tmpstr, sizeof(tmpstr), e->ring.callingnum, sizeof(e->ring.callingnum), e->ring.callingplan, e->ring.callingpres, 0);
+ 							        pbx_builtin_setvar_helper(c, "PRI_NETWORK_CID", tmpstr);
+ 							    }
+ 							    if (!ast_strlen_zero(e->ring.callingani)) {
+ 								char tmpstr[256];
+ 							        pri_make_callerid(pri, tmpstr,sizeof(tmpstr),  e->ring.callingani, sizeof(e->ring.callingani), e->ring.callingplanuser, e->ring.callingpresuser, 0);
+ 							        pbx_builtin_setvar_helper(c, "PRI_USER_CID", e->ring.callednum);
+ 							    }
+							    if (!ast_strlen_zero(e->ring.useruserinfo)) {
+							        pbx_builtin_setvar_helper(c, "UUI", e->ring.useruserinfo);
+							    }
 							} else {
 								ast_log(LOG_WARNING, "Unable to start PBX on channel %d/%d, span %d\n", 
 									pri->pvts[chanpos]->logicalspan, pri->pvts[chanpos]->prioffset, pri->span);
-								pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_SWITCH_CONGESTION);
+								pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_SWITCH_CONGESTION, -1);
 								pri->pvts[chanpos]->call = NULL;
 							}
 						}
 					} else {
+					/* invalid extension */
 						if (option_verbose > 2)
 							ast_verbose(VERBOSE_PREFIX_3 "Extension '%s' in context '%s' from '%s' does not exist.  Rejecting call on channel %d/%d, span %d\n",
 								pri->pvts[chanpos]->exten, pri->pvts[chanpos]->context, pri->pvts[chanpos]->cid_num, pri->pvts[chanpos]->logicalspan, 
 									pri->pvts[chanpos]->prioffset, pri->span);
-						pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_UNALLOCATED);
+						pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_UNALLOCATED, -1);
 						pri->pvts[chanpos]->call = NULL;
 						pri->pvts[chanpos]->exten[0] = '\0';
 					}
@@ -8893,9 +9863,9 @@
 					ast_mutex_unlock(&pri->pvts[chanpos]->lock);
 				} else {
 					if (e->ring.flexible)
-						pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_NORMAL_CIRCUIT_CONGESTION);
+						pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_NORMAL_CIRCUIT_CONGESTION, -1);
 					else
-						pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_REQUESTED_CHAN_UNAVAIL);
+						pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_REQUESTED_CHAN_UNAVAIL, -1);
 				}
 				break;
 			case PRI_EVENT_RINGING:
@@ -8914,7 +9884,7 @@
 					} else {
 						ast_mutex_lock(&pri->pvts[chanpos]->lock);
 						if (ast_strlen_zero(pri->pvts[chanpos]->dop.dialstr)) {
-							zt_enable_ec(pri->pvts[chanpos]);
+						// XXX	zt_enable_ec(pri->pvts[chanpos]);
 							pri->pvts[chanpos]->subs[SUB_REAL].needringing = 1;
 							pri->pvts[chanpos]->alerting = 1;
 						} else
@@ -8943,9 +9913,16 @@
 				}
 				break;
 			case PRI_EVENT_PROGRESS:
-				/* Get chan value if e->e is not PRI_EVNT_RINGING */
+				/* Get chan value if e->e is not PRI_EVENT_RINGING */
 				chanpos = pri_find_principle(pri, e->proceeding.channel);
 				if (chanpos > -1) {
+				    if ((pri->pvts[chanpos]->priindication_oob == 2) && (e->proceeding.cause == PRI_CAUSE_USER_BUSY)) {
+					/* received PROGRESS with cause BUSY, no inband callprogress wanted => hang up! */
+					if (pri->pvts[chanpos]->owner) {
+					    pri->pvts[chanpos]->owner->hangupcause = AST_CAUSE_USER_BUSY;
+					    pri->pvts[chanpos]->owner->_softhangup |= AST_SOFTHANGUP_DEV;
+					}
+				    } else {
 #ifdef PRI_PROGRESS_MASK
 					if ((!pri->pvts[chanpos]->progress) || (e->proceeding.progressmask & PRI_PROG_INBAND_AVAILABLE)) {
 #else
@@ -8992,6 +9969,12 @@
 			case PRI_EVENT_PROCEEDING:
 				chanpos = pri_find_principle(pri, e->proceeding.channel);
 				if (chanpos > -1) {
+ 				    chanpos = pri_fixup_principle(pri, chanpos, e->proceeding.call);
+ 				    if (chanpos < 0) {
+ 					ast_log(LOG_WARNING, "Received PROCEEDING on channel %d/%d not in use on span %d\n", 
+						PRI_SPAN(e->proceeding.channel), PRI_CHANNEL(e->proceeding.channel), pri->span);
+ 					chanpos = -1;
+ 				    } else {
 					if (!pri->pvts[chanpos]->proceeding) {
 						struct ast_frame f = { AST_FRAME_CONTROL, AST_CONTROL_PROCEEDING, };
 						
@@ -9042,6 +10025,295 @@
 					}
 				}
 				break;				
+			case PRI_EVENT_SUSPEND_REQ:
+				if ((pri->nodetype != BRI_NETWORK_PTMP) && (pri->nodetype != BRI_NETWORK)) {
+				    pri_suspend_reject(pri->pri, e->suspend_req.call, "");
+				    break;
+				}
+				chanpos = pri_find_principle(pri, e->suspend_req.channel);
+				if (chanpos < 0)  {
+					ast_log(LOG_WARNING, "Suspend requested on unconfigured channel %d span %d\n", chanpos, pri->span);
+					chanpos = -1;
+				}
+
+				if (chanpos > -1) {
+				    ast_mutex_lock(&pri->pvts[chanpos]->lock);
+				    if (pri->pvts[chanpos]->owner) {
+					if (ast_bridged_channel(pri->pvts[chanpos]->owner)) {
+					    struct zt_suspended_call *zpc;
+					    char tmpstr[256];
+					    zpc = malloc(sizeof(struct zt_suspended_call));
+					    if (!zpc) {
+						ast_log(LOG_ERROR, "unable to malloc zt_suspended_call\n");
+						break;
+					    }
+					    strncpy(zpc->msn,  pri->pvts[chanpos]->cid_num, sizeof(zpc->msn));
+					    strncpy(zpc->callid,  e->suspend_req.callid, sizeof(zpc->callid));
+					    ast_masq_park_call(ast_bridged_channel(pri->pvts[chanpos]->owner), NULL, 0, &zpc->parked_at);
+					    zpc->next = pri->suspended_calls;
+					    pri->suspended_calls = zpc;
+					    snprintf(tmpstr, sizeof(tmpstr), "Parked at %d", zpc->parked_at);
+					    pri_suspend_acknowledge(pri->pri, e->suspend_req.call,tmpstr);
+					    pri->pvts[chanpos]->call = NULL;
+					    pri->pvts[chanpos]->tei = -1;
+					    pri->pvts[chanpos]->owner->_softhangup |= AST_SOFTHANGUP_DEV;
+					} else {
+					    pri_suspend_reject(pri->pri, e->suspend_req.call, "cant park a non-bridge");
+					    ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+					    break;
+					}
+				    } else {
+					pri_suspend_reject(pri->pri, e->suspend_req.call, "");
+				    }
+				    ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+				}
+				break;
+			case PRI_EVENT_RESUME_REQ:
+				if ((pri->nodetype != BRI_NETWORK_PTMP) && (pri->nodetype != BRI_NETWORK)) {
+				    break;
+				}
+				chanpos = pri_find_empty_chan(pri, 1);
+				if (chanpos < 0) { 
+					pri_resume_reject(pri->pri, e->resume_req.call,"All channels busy");
+					ast_log(LOG_WARNING, "Resume requested on odd channel number %d span %d\n", chanpos, pri->span);
+					chanpos = -1;
+				} else if (!pri->pvts[chanpos]) {
+					pri_resume_reject(pri->pri, e->resume_req.call,"General protection fault in module 0x0BRI");
+					chanpos = -1;
+				}
+
+				if (chanpos > -1) {
+ 				    ast_mutex_lock(&pri->pvts[chanpos]->lock);
+				    if (!pri->pvts[chanpos]->owner) {
+					struct zt_suspended_call *zpc, *zpcl;
+					int unparked=0;
+					char extenstr[255], temp[255];
+					zpc = NULL;
+					zpcl = pri->suspended_calls;
+					while (zpcl) {
+					//    ast_log(LOG_NOTICE, "zpc->parked_at %d zpcl->callid %s\n",zpcl->parked_at, zpcl->callid);
+					    if (((strlen(zpcl->callid) == 0) && (strlen(e->resume_req.callid)==0)) || (!strcmp(zpcl->callid,e->resume_req.callid))) {
+						int law;
+						// found a parked call
+						snprintf(extenstr, sizeof(extenstr), "%d", zpcl->parked_at);
+						strncpy(pri->pvts[chanpos]->exten, extenstr, sizeof(pri->pvts[chanpos]->exten));
+					//	strncpy(pri->pvts[chanpos]->context, ast_parking_con(), sizeof(pri->pvts[chanpos]->context));
+					        pri->pvts[chanpos]->call = e->resume_req.call;
+ 					        law = 1;
+					        if (ioctl(pri->pvts[chanpos]->subs[SUB_REAL].zfd, ZT_AUDIOMODE, &law) == -1)
+					    	    ast_log(LOG_WARNING, "Unable to set audio mode on channel %d to %d\n", PVT_TO_CHANNEL(pri->pvts[chanpos]), law);
+					// uhh ohh...what shall we do without the bearer cap???
+						law = ZT_LAW_ALAW;
+						res = zt_setlaw(pri->pvts[chanpos]->subs[SUB_REAL].zfd, law);
+						if (res < 0) 
+						    ast_log(LOG_WARNING, "Unable to set law on channel %d\n", PVT_TO_CHANNEL(pri->pvts[chanpos]));
+						if (!pri->pvts[chanpos]->digital) {
+						    res = set_actual_gain(pri->pvts[chanpos]->subs[SUB_REAL].zfd, 0, pri->pvts[chanpos]->rxgain, pri->pvts[chanpos]->txgain, law);
+  						} else {
+  						    res = set_actual_gain(pri->pvts[chanpos]->subs[SUB_REAL].zfd, 0, 0, 0, pri->pvts[chanpos]->law);
+						}
+						if (res < 0)
+						    ast_log(LOG_WARNING, "Unable to set gains on channel %d\n", PVT_TO_CHANNEL(pri->pvts[chanpos]));
+						/* Start PBX */
+						c = zt_new(pri->pvts[chanpos], AST_STATE_UP, 1, SUB_REAL, law, PRI_TRANS_CAP_SPEECH);
+						if (c) {
+						    pri->pvts[chanpos]->owner = c;
+						    pri->pvts[chanpos]->call = e->resume_req.call;
+						    zt_enable_ec(pri->pvts[chanpos]);
+						    zt_train_ec(pri->pvts[chanpos]);
+						} else {
+						    ast_log(LOG_ERROR, "unable to start pbx\n");
+						}
+
+						if (zpc) {
+						    zpc->next = zpcl->next;
+						    free(zpcl);
+						    zpcl = zpc->next;
+						} else {
+						    // remove head
+						    pri->suspended_calls = zpcl->next;
+						    free(zpcl);
+						    zpcl = pri->suspended_calls;
+						    zpc = NULL;
+						}
+						unparked = 1;
+						snprintf(temp, sizeof(temp), "Unparked %s", extenstr);
+						pri_resume_acknowledge(pri->pri, e->resume_req.call, chanpos + 1, temp);
+					        break;
+					    }
+					    zpc = zpcl;
+					    if (zpcl) zpcl = zpcl->next;
+					}
+					if (!unparked)
+					    pri_resume_reject(pri->pri, e->resume_req.call,"No suspended call to unpark!");
+				    } else {
+					pri_resume_reject(pri->pri, e->resume_req.call,"No suspended call to unpark!");
+				    }
+				    ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+				}
+				break;
+			case PRI_EVENT_HOLD_REQ:
+				if ((pri->nodetype != BRI_NETWORK_PTMP) && (pri->nodetype != BRI_NETWORK)) {
+				    pri_hold_reject(pri->pri, e->hold_req.call);
+				    break;
+				}
+				chanpos = pri_find_principle(pri, e->hold_req.channel);
+				if (chanpos < 0)  {
+					ast_log(LOG_WARNING, "Hold requested on unconfigured channel %d span %d\n", chanpos, pri->span);
+					chanpos = -1;
+				}
+				if (chanpos > -1) {
+				//    ast_log(LOG_NOTICE, "Hold request for channel number %d span %d\n", chanpos, pri->span);
+				    ast_mutex_lock(&pri->pvts[chanpos]->lock);
+ 				    if (pri->pvts[chanpos]->owner) {
+					struct zt_pvt *p = pri->pvts[chanpos];
+					struct zt_holded_call *zhc;
+					int holdacked=0;
+					
+//					ast_log(LOG_NOTICE,"HOLD request from channel %s tei %d\n",p->owner->name, e->hold_req.tei);
+				    	if (ast_bridged_channel(p->owner)) {
+					    zhc = malloc(sizeof(struct zt_holded_call));
+					    if (!zhc) {
+						ast_log(LOG_ERROR, "unable to malloc zt_holded_call\n");
+						break;
+					    }
+					    memset(zhc, 0, sizeof(zhc));
+					    strncpy(zhc->msn,  pri->pvts[chanpos]->cid_num, sizeof(zhc->msn));
+					    strncpy(zhc->uniqueid,  ast_bridged_channel(p->owner)->uniqueid, sizeof(zhc->uniqueid));
+					    zhc->tei = e->hold_req.tei;
+					    zhc->cref = e->hold_req.cref;
+					    zhc->call = e->hold_req.call;
+					    zhc->channel = p->owner;
+					    zhc->alreadyhungup = 0;
+					    zhc->bridge = ast_bridged_channel(p->owner);
+					    zhc->next = pri->holded_calls;
+					    pri->holded_calls = zhc;
+
+					    /* put channel on hold */
+					    ast_masq_hold_call(ast_bridged_channel(p->owner), p->owner);
+
+					    pri_hold_acknowledge(pri->pri, e->hold_req.call);
+					    holdacked = 1;
+					    p->call = NULL; // free the bchannel withouth destroying the call
+					    p->tei = -1;
+					} else {
+					    // cant hold a non-bridge,...yet
+					    
+					    // make a fake channel
+					    
+					    // masquerade
+					    
+					    // put on hold
+					    pri_hold_reject(pri->pri, e->hold_req.call);
+					}
+				    } else {
+					    pri_hold_reject(pri->pri, e->hold_req.call);
+				    }
+				    ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+				} else {
+					pri_hold_reject(pri->pri, e->hold_req.call);
+				}
+				break; 
+			case PRI_EVENT_RETRIEVE_REQ:
+				if ((pri->nodetype != BRI_NETWORK_PTMP) && (pri->nodetype != BRI_NETWORK)) {
+				    pri_retrieve_reject(pri->pri, e->retrieve_req.call);
+				    break;
+				}
+				chanpos = pri_find_empty_chan(pri, 1);
+				if (chanpos < 0) { 
+					pri_retrieve_reject(pri->pri, e->retrieve_req.call);
+					ast_log(LOG_WARNING, "Retrieve requested on odd channel number %d span %d\n", chanpos, pri->span);
+					chanpos = -1;
+					break;
+				} else if (!pri->pvts[chanpos]) {
+					ast_log(LOG_WARNING, "Retrieve requested on unconfigured channel number %d span %d\n", chanpos, pri->span);
+					pri_retrieve_reject(pri->pri, e->retrieve_req.call);
+					chanpos = -1;
+					break;
+				}
+				if (chanpos > -1) {
+				    struct zt_holded_call *onhold = NULL;
+				    int retrieved = 0;
+				    int res = -1;
+				    struct app_tmp *tmp;
+				    pthread_attr_t attr;
+				    int law;
+
+				    onhold = pri_get_callonhold(pri, e->retrieve_req.cref, e->retrieve_req.tei);
+
+				    if (!onhold) {
+					pri_retrieve_reject(pri->pri, e->retrieve_req.call);
+					break;
+				    }
+				    ast_mutex_lock(&pri->pvts[chanpos]->lock);
+					// found a parked call
+ 					law = 1;
+					if (ioctl(pri->pvts[chanpos]->subs[SUB_REAL].zfd, ZT_AUDIOMODE, &law) == -1)
+					    ast_log(LOG_WARNING, "Unable to set audio mode on channel %d to %d\n", PVT_TO_CHANNEL(pri->pvts[chanpos]), law);
+					// uhh ohh...what shall we do without the bearer cap???
+					law = ZT_LAW_ALAW;
+					res = zt_setlaw(pri->pvts[chanpos]->subs[SUB_REAL].zfd, law);
+					if (res < 0) 
+					    ast_log(LOG_WARNING, "Unable to set law on channel %d\n", PVT_TO_CHANNEL(pri->pvts[chanpos]));
+					res = set_actual_gain(pri->pvts[chanpos]->subs[SUB_REAL].zfd, 0, pri->pvts[chanpos]->rxgain, pri->pvts[chanpos]->txgain, law);
+					if (res < 0)
+					    ast_log(LOG_WARNING, "Unable to set gains on channel %d\n", PVT_TO_CHANNEL(pri->pvts[chanpos]));
+					/* Start PBX */
+					c = zt_new(pri->pvts[chanpos], AST_STATE_UP, 0, SUB_REAL, law, PRI_TRANS_CAP_SPEECH);
+					if (c) {
+					    pri->pvts[chanpos]->owner = c;
+					    pri->pvts[chanpos]->outgoing = 1; /* for not sending proceedings... */
+					    pri->pvts[chanpos]->call = e->retrieve_req.call;
+					    pri->pvts[chanpos]->tei = e->retrieve_req.tei;
+				    	    zt_enable_ec(pri->pvts[chanpos]);
+				    	    zt_train_ec(pri->pvts[chanpos]);
+					} else {
+					    ast_log(LOG_ERROR, "unable to start pbx\n");
+					}
+
+					retrieved = 1;
+				//	ast_log(LOG_NOTICE, "sending RETRIEVE ACK on channel %d, span %d for tei %d cref %d\n",chanpos,pri->span, e->retrieve_req.tei,  e->retrieve_req.cref);
+					pri_retrieve_acknowledge(pri->pri, e->retrieve_req.call, chanpos + 1);
+
+					// the magic begins here: ....
+					tmp = malloc(sizeof(struct app_tmp));
+					if (tmp) {
+					    memset(tmp, 0, sizeof(struct app_tmp));
+					    strncpy(tmp->app, "holdedcall", sizeof(tmp->app) - 1);
+					    strncpy(tmp->data, onhold->uniqueid, sizeof(tmp->data) - 1);
+					    tmp->chan = c;
+					}
+					pri_destroy_callonhold(pri, onhold);
+					onhold = NULL;
+
+					ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+					pthread_attr_init(&attr);
+					pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+					if (ast_pthread_create(&tmp->t, &attr, ast_pbx_run_app, tmp)) {
+ 					    ast_log(LOG_WARNING, "Unable to spawn execute thread on %s: %s\n", c->name, strerror(errno));
+					    free(tmp);
+					    ast_hangup(c);
+					    retrieved = 0;
+					}
+
+				    if (!retrieved) {
+					pri_retrieve_reject(pri->pri, e->retrieve_req.call);
+				    }
+				}
+ 				break; 
+			case PRI_EVENT_DISPLAY_RECEIVED:
+				ast_log(LOG_NOTICE, "DISPLAY IE: [ %s ] received\n",e->display.text);
+				chanpos = pri_find_principle(pri, e->display.channel);
+				if (chanpos < 0) {
+				    ast_log(LOG_WARNING, "odd channel number %d span %d\n", chanpos, pri->span);
+				    chanpos = -1;
+				} 
+				if (chanpos > -1) {
+				    if (pri->pvts[chanpos]->owner) {
+			//		ast_sendtext(pri->pvt[chanpos]->owner, e->display.text);
+				    }
+				}				
+				break;
 			case PRI_EVENT_ANSWER:
 				chanpos = pri_find_principle(pri, e->answer.channel);
 				if (chanpos < 0) {
@@ -9057,6 +10329,7 @@
 						chanpos = -1;
 					} else {
 						ast_mutex_lock(&pri->pvts[chanpos]->lock);
+  						pri->pvts[chanpos]->tei = e->answer.tei;
 						/* Now we can do call progress detection */
 
 						/* We changed this so it turns on the DSP no matter what... progress or no progress.
@@ -9086,11 +10359,16 @@
 								ast_log(LOG_DEBUG, "Sent deferred digit string: %s\n", pri->pvts[chanpos]->dop.dialstr);
 							pri->pvts[chanpos]->dop.dialstr[0] = '\0';
 						} else if (pri->pvts[chanpos]->confirmanswer) {
-							ast_log(LOG_DEBUG, "Waiting on answer confirmation on channel %d!\n", pri->pvts[chanpos]->channel);
+							ast_log(LOG_DEBUG, "Waiting for answer confirmation on channel %d!\n", pri->pvts[chanpos]->channel);
+							enable_dtmf_detect(pri->pvts[chanpos]);
 						} else {
+							pri->pvts[chanpos]->dialing = 0;
 							pri->pvts[chanpos]->subs[SUB_REAL].needanswer =1;
 							/* Enable echo cancellation if it's not on already */
 							zt_enable_ec(pri->pvts[chanpos]);
+							zt_train_ec(pri->pvts[chanpos]);
+							/* stop ignoring inband dtmf */
+							enable_dtmf_detect(pri->pvts[chanpos]);
 						}
 
 #ifdef SUPPORT_USERUSER
@@ -9146,20 +10424,29 @@
 								ast_verbose(VERBOSE_PREFIX_3 "Channel %d/%d, span %d got hangup, cause %d\n", 
 									pri->pvts[chanpos]->logicalspan, pri->pvts[chanpos]->prioffset, pri->span, e->hangup.cause);
 						} else {
-							pri_hangup(pri->pri, pri->pvts[chanpos]->call, e->hangup.cause);
+							pri_hangup(pri->pri, pri->pvts[chanpos]->call, e->hangup.cause, -1);
 							pri->pvts[chanpos]->call = NULL;
+ 							pri->pvts[chanpos]->tei = -1;
 						}
 						if (e->hangup.cause == PRI_CAUSE_REQUESTED_CHAN_UNAVAIL) {
-							if (option_verbose > 2)
-								ast_verbose(VERBOSE_PREFIX_3 "Forcing restart of channel %d/%d on span %d since channel reported in use\n", 
-									PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
-							pri_reset(pri->pri, PVT_TO_CHANNEL(pri->pvts[chanpos]));
-							pri->pvts[chanpos]->resetting = 1;
-						}
-						if (e->hangup.aoc_units > -1)
-							if (option_verbose > 2)
-								ast_verbose(VERBOSE_PREFIX_3 "Channel %d/%d, span %d received AOC-E charging %d unit%s\n",
-									pri->pvts[chanpos]->logicalspan, pri->pvts[chanpos]->prioffset, pri->span, (int)e->hangup.aoc_units, (e->hangup.aoc_units == 1) ? "" : "s");
+  							if ((pri->nodetype != BRI_CPE_PTMP) && (pri->nodetype != BRI_NETWORK_PTMP)) {
+ 							    if (option_verbose > 2)
+  								ast_verbose(VERBOSE_PREFIX_3 "Forcing restart of channel %d/%d on span %d since channel reported in use\n", 
+  									PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
+ 							    pri_reset(pri->pri, PVT_TO_CHANNEL(pri->pvts[chanpos]));
+ 							    pri->pvts[chanpos]->resetting = 1;
+ 							}
+						}
+     						if (e->hangup.aoc_units > -1) {
+ 							if (pri->pvts[chanpos]->owner) {
+ 							    char tmpstr[256];
+ 							    snprintf(tmpstr, sizeof(tmpstr), "%d", (int)e->hangup.aoc_units);
+ 							    pbx_builtin_setvar_helper(pri->pvts[chanpos]->owner, "AOCEUNITS", tmpstr);
+ 							}
+  							if (option_verbose > 2)
+  								ast_verbose(VERBOSE_PREFIX_3 "Channel %d/%d, span %d received AOC-E charging %d unit%s\n",
+  									pri->pvts[chanpos]->logicalspan, pri->pvts[chanpos]->prioffset, pri->span, (int)e->hangup.aoc_units, (e->hangup.aoc_units == 1) ? "" : "s");
+ 						}		
 
 #ifdef SUPPORT_USERUSER
 						if (!ast_strlen_zero(e->hangup.useruserinfo)) {
@@ -9169,8 +10456,20 @@
 
 						ast_mutex_unlock(&pri->pvts[chanpos]->lock);
 					} else {
-						ast_log(LOG_WARNING, "Hangup on bad channel %d/%d on span %d\n", 
-							PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
+ 						struct zt_holded_call *onhold = NULL;
+						/* check calls on hold */
+ 						onhold = pri_get_callonhold(pri, e->hangup.cref, e->hangup.tei);
+ 						
+ 						if (onhold) {
+ 						    // ast_log(LOG_NOTICE, "hangup, found cref %d, tei %d\n",e->hangup.cref, e->hangup.tei);
+ 						    pri_hangup(pri->pri, onhold->call, e->hangup.cause, -1);
+ 						    pri_destroy_callonhold(pri, onhold);
+ 						    onhold = NULL;
+ 						} else {
+ 						    ast_log(LOG_NOTICE, "Hangup, did not find cref %d, tei %d\n",e->hangup.cref, e->hangup.tei);
+ 						    ast_log(LOG_WARNING, "Hangup on bad channel %d/%d on span %d\n", 
+  							PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
+ 						}
 					}
 				} 
 				break;
@@ -9180,17 +10479,25 @@
 			case PRI_EVENT_HANGUP_REQ:
 				chanpos = pri_find_principle(pri, e->hangup.channel);
 				if (chanpos < 0) {
-					ast_log(LOG_WARNING, "Hangup REQ requested on unconfigured channel %d/%d span %d\n", 
-						PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
+					if (pri->nodetype == BRI_NETWORK_PTMP) {
+					    pri_hangup(pri->pri, e->hangup.call, e->hangup.cause, -1);
+					} else {
+					    ast_log(LOG_WARNING, "Hangup REQ requested on unconfigured channel %d/%d span %d\n", 
+  						PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
+					}
 					chanpos = -1;
 				}
-				if (chanpos > -1) {
+				/* dont hang up if we want to hear inband call progress */
+				if ((chanpos > -1) && ((pri->pvts[chanpos]->priindication_oob != 2) || (!e->hangup.inband_progress) || (!pri->pvts[chanpos]->outgoing))){
 					chanpos = pri_fixup_principle(pri, chanpos, e->hangup.call);
 					if (chanpos > -1) {
 						ast_mutex_lock(&pri->pvts[chanpos]->lock);
 						if (pri->pvts[chanpos]->realcall) 
 							pri_hangup_all(pri->pvts[chanpos]->realcall, pri);
 						else if (pri->pvts[chanpos]->owner) {
+							char tmpstr[256];
+							snprintf(tmpstr, sizeof(tmpstr), "%d", e->hangup.cause);
+							pbx_builtin_setvar_helper(pri->pvts[chanpos]->owner, "PRI_CAUSE", tmpstr);
 							pri->pvts[chanpos]->owner->hangupcause = e->hangup.cause;
 							if (pri->pvts[chanpos]->owner->_state == AST_STATE_UP)
 								pri->pvts[chanpos]->owner->_softhangup |= AST_SOFTHANGUP_DEV;
@@ -9213,21 +10520,88 @@
 							}
 							if (option_verbose > 2) 
 								ast_verbose(VERBOSE_PREFIX_3 "Channel %d/%d, span %d got hangup request, cause %d\n", PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span, e->hangup.cause);
-							if (e->hangup.aoc_units > -1)
-								if (option_verbose > 2)
-									ast_verbose(VERBOSE_PREFIX_3 "Channel %d/%d, span %d received AOC-E charging %d unit%s\n",
-										pri->pvts[chanpos]->logicalspan, pri->pvts[chanpos]->prioffset, pri->span, (int)e->hangup.aoc_units, (e->hangup.aoc_units == 1) ? "" : "s");
-						} else {
-							pri_hangup(pri->pri, pri->pvts[chanpos]->call, e->hangup.cause);
-							pri->pvts[chanpos]->call = NULL;
-						}
-						if (e->hangup.cause == PRI_CAUSE_REQUESTED_CHAN_UNAVAIL) {
-							if (option_verbose > 2)
-								ast_verbose(VERBOSE_PREFIX_3 "Forcing restart of channel %d/%d span %d since channel reported in use\n", 
-									PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
-							pri_reset(pri->pri, PVT_TO_CHANNEL(pri->pvts[chanpos]));
-							pri->pvts[chanpos]->resetting = 1;
-						}
+ 							if (e->hangup.aoc_units > -1) {
+ 							    if (pri->pvts[chanpos]->owner) {
+ 								char tmpstr[256];
+ 								snprintf(tmpstr, sizeof(tmpstr), "%d", (int)e->hangup.aoc_units);
+ 								pbx_builtin_setvar_helper(pri->pvts[chanpos]->owner, "AOCEUNITS", tmpstr);
+ 							    }
+ 							    if (option_verbose > 2)
+ 							    	ast_verbose(VERBOSE_PREFIX_3 "Channel %d/%d, span %d received AOC-E charging %d unit%s\n",
+ 									pri->pvts[chanpos]->logicalspan, pri->pvts[chanpos]->prioffset, pri->span, (int)e->hangup.aoc_units, (e->hangup.aoc_units == 1) ? "" : "s");
+ 							}
+  							if (pri->nodetype == BRI_NETWORK_PTMP) {
+  							    // check for bri transfers, not everybody uses ECT...
+  							    if (pri->pvts[chanpos]->owner) {
+  								// find on hold call
+  								struct zt_holded_call *onhold = NULL;
+  								struct ast_channel *transferee = NULL;
+ 								int transfer_ok = 0;
+  
+  								onhold = pri_get_callonhold(pri, -1, e->hangup.tei);
+  
+  								if (onhold) {
+ 								    if (pri->pvts[chanpos]->pritransfer == 2) {
+  									if (((pri->pvts[chanpos]->owner->_state != AST_STATE_RING) && (pri->pvts[chanpos]->owner->_state != AST_STATE_RESERVED)) || ((!ast_strlen_zero(pri->pvts[chanpos]->exten)) && (strncasecmp(pri->pvts[chanpos]->exten, "s", sizeof(pri->pvts[chanpos]->exten))))) {
+  								    	    transferee = ast_get_holded_call(onhold->uniqueid);
+  
+  									    if (transferee) {
+  										if (pri->pvts[chanpos]->owner->_state == AST_STATE_RINGING) {
+  									    	    ast_indicate(transferee, AST_CONTROL_RINGING);
+  										}
+  
+  										pri->pvts[chanpos]->owner->_softhangup &= ~AST_SOFTHANGUP_DEV;
+   
+   									        ast_mutex_unlock(&transferee->lock);
+  										if (ast_channel_masquerade(pri->pvts[chanpos]->owner, transferee)) {
+  										    ast_log(LOG_WARNING, "unable to masquerade\n");
+  									        } else { 
+  									    	    /* beware of zombies!!! */
+ 										    ast_set_flag(transferee, AST_FLAG_ZOMBIE);
+  										    pri->pvts[chanpos]->owner = NULL;
+  										    pri->pvts[chanpos]->tei = -1;
+ 										    transfer_ok = 1;
+  										}
+  									    }
+ 									}	
+  								    } else if (pri->pvts[chanpos]->pritransfer == 0) {
+ 									ast_log(LOG_NOTICE, "killing channel %s \n", onhold->uniqueid);
+  									ast_retrieve_call_to_death(onhold->uniqueid);
+ 									transfer_ok = 1;
+  								    } else if (pri->pvts[chanpos]->pritransfer == 1) {
+ 									/* we use ECT transfers, so just ignore this */
+ 									transfer_ok = 0;
+ 								    }
+ 							
+ 								    if (transfer_ok) {
+  									onhold->alreadyhungup = 1;	
+  									pri_hangup(pri->pri, onhold->call, e->hangup.cause, -1);
+  									onhold = NULL;
+ 								    }
+  								    ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+  								    break;
+                                                                } else {
+                                                                        pri_hangup(pri->pri, pri->pvts[chanpos]->call, e->hangup.cause, -1);
+                                                                        pri->pvts[chanpos]->call = NULL;
+                                                                        pri->pvts[chanpos]->tei = -1;
+                                                                }
+  							    }
+  							}
+  						} else {
+ 							pri_hangup(pri->pri, pri->pvts[chanpos]->call, e->hangup.cause, -1);
+  							pri->pvts[chanpos]->call = NULL;
+  							pri->pvts[chanpos]->tei = -1;
+  						}
+  						if (e->hangup.cause == PRI_CAUSE_REQUESTED_CHAN_UNAVAIL) {
+  							if ((pri->nodetype != BRI_CPE_PTMP) && (pri->nodetype != BRI_NETWORK_PTMP)) {
+  							    if (option_verbose > 2)
+   								ast_verbose(VERBOSE_PREFIX_3 "Forcing restart of channel %d/%d span %d since channel reported in use\n", 
+   									PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
+ 							    pri_reset(pri->pri, PVT_TO_CHANNEL(pri->pvts[chanpos]));
+ 							    pri->pvts[chanpos]->resetting = 1;
+ 							}
+ 
+  						}
 
 #ifdef SUPPORT_USERUSER
 						if (!ast_strlen_zero(e->hangup.useruserinfo)) {
@@ -9237,9 +10611,39 @@
 
 						ast_mutex_unlock(&pri->pvts[chanpos]->lock);
 					} else {
-						ast_log(LOG_WARNING, "Hangup REQ on bad channel %d/%d on span %d\n", PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
+ 						if (pri->nodetype != BRI_NETWORK_PTMP) {
+  						    ast_log(LOG_WARNING, "Hangup REQ on bad channel %d/%d on span %d\n", PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
+ 						} else {
+ 						    // check holded_calls!!!
+ 						    struct zt_holded_call *onhold = NULL;
+ 
+ 						    onhold = pri_get_callonhold(pri, e->hangup.cref, e->hangup.tei);
+ 
+ 						    if (onhold) {
+ 							    pri_hangup(pri->pri, e->hangup.call, e->hangup.cause, -1);
+ 							    ast_retrieve_call_to_death(onhold->uniqueid);
+ 							    pri_destroy_callonhold(pri, onhold);
+ 							    onhold = NULL;
+ 						    } else {
+ 							ast_log(LOG_WARNING, "Hangup REQ on bad channel %d/%d on span %d\n", PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
+ 						    }
+ 						}
 					}
 				} 
+				if ((chanpos > -1) && (pri->pvts[chanpos]->owner) && (pri->pvts[chanpos]->priindication_oob == 2) && (e->hangup.inband_progress) && (pri->pvts[chanpos]->outgoing)) {
+				    ast_mutex_lock(&pri->pvts[chanpos]->lock);
+					if (e->hangup.aoc_units > -1) {
+					    char tmpstr[256];
+					    snprintf(tmpstr, sizeof(tmpstr), "%d", (int)e->hangup.aoc_units);
+					    pbx_builtin_setvar_helper(pri->pvts[chanpos]->owner, "AOCEUNITS", tmpstr);
+					    if (option_verbose > 2)
+						ast_verbose(VERBOSE_PREFIX_3 "Channel %d/%d, span %d received AOC-E charging %d unit%s\n",
+						    pri->pvts[chanpos]->logicalspan, pri->pvts[chanpos]->prioffset, pri->span, (int)e->hangup.aoc_units, (e->hangup.aoc_units == 1) ? "" : "s");
+					}
+					pri->pvts[chanpos]->owner->hangupcause = e->hangup.cause;
+					ast_channel_setwhentohangup(pri->pvts[chanpos]->owner, 5);
+				    ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+				}
 				break;
 			case PRI_EVENT_HANGUP_ACK:
 				chanpos = pri_find_principle(pri, e->hangup.channel);
@@ -9253,6 +10657,7 @@
 					if (chanpos > -1) {
 						ast_mutex_lock(&pri->pvts[chanpos]->lock);
 						pri->pvts[chanpos]->call = NULL;
+						pri->pvts[chanpos]->tei = -1;
 						pri->pvts[chanpos]->resetting = 0;
 						if (pri->pvts[chanpos]->owner) {
 							if (option_verbose > 2) 
@@ -9266,7 +10671,9 @@
 #endif
 
 						ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+					    }
 					}
+				    }
 				}
 				break;
 			case PRI_EVENT_CONFIG_ERR:
@@ -9358,10 +10765,22 @@
 					ast_mutex_lock(&pri->pvts[chanpos]->lock);
 					switch(e->notify.info) {
 					case PRI_NOTIFY_REMOTE_HOLD:
+						if ((pri->nodetype == BRI_NETWORK_PTMP) || (pri->nodetype == BRI_NETWORK)) {
+						    ast_log(LOG_DEBUG, "Received REMOTE_HOLD notification on NETWORK channel. Starting MoH\n");
+						    ast_moh_start(ast_bridged_channel(pri->pvts[chanpos]->owner), NULL);
+						} else {
+						    ast_log(LOG_DEBUG, "Received REMOTE_HOLD notification on CPE channel. Not Starting MoH\n");
+						}
 						f.subclass = AST_CONTROL_HOLD;
 						zap_queue_frame(pri->pvts[chanpos], &f, pri);
 						break;
 					case PRI_NOTIFY_REMOTE_RETRIEVAL:
+						if ((pri->nodetype == BRI_NETWORK_PTMP) || (pri->nodetype == BRI_NETWORK)) {
+						    ast_log(LOG_DEBUG, "Received REMOTE_RETRIEVAL notification on NETWORK channel. Stopping MoH\n");
+						    ast_moh_stop(ast_bridged_channel(pri->pvts[chanpos]->owner));
+						} else {
+						    ast_log(LOG_DEBUG, "Received REMOTE_RETRIEVAL notification on CPE channel.\n");
+						}
 						f.subclass = AST_CONTROL_UNHOLD;
 						zap_queue_frame(pri->pvts[chanpos], &f, pri);
 						break;
@@ -9369,6 +10788,77 @@
 					ast_mutex_unlock(&pri->pvts[chanpos]->lock);
 				}
 				break;
+ 			case PRI_EVENT_FACILITY:
+ 				    if (e->facility.operation == 0x06) {
+ 					struct ast_channel *chan = NULL;
+ 					struct zt_holded_call *onhold = NULL;
+ 					if (option_verbose > 2) {
+ 					    ast_verbose(VERBOSE_PREFIX_3 "ECT requested by TEI %d for cref %d\n", e->facility.tei, e->facility.cref);
+ 					}
+ 					/* search for cref/tei in held calls */
+ 					onhold = pri_get_callonhold(pri, e->facility.cref, e->facility.tei);
+ 					if (onhold) {
+ 					    chan = ast_get_holded_call(onhold->uniqueid);
+ 					    onhold->alreadyhungup = 1;
+ 					    onhold = NULL;
+ 					    if (!chan) {
+ 						/* hang up */
+ 					        pri_hangup(pri->pri, e->facility.call, 16, -1);
+ 						break;
+ 					    }
+ 					} else {
+ 					    /* unknown cref/tei */
+ 					    ast_log(LOG_WARNING, "did not find call on hold for cref %d tei %d\n", e->facility.tei, e->facility.cref);
+ 					    /* hang up */
+ 					    pri_hangup(pri->pri, e->facility.call, 16, -1);
+ 					    break;
+ 					}
+ 
+ 					/* find an active call for the same tei */
+ 					chanpos = pri_find_tei(pri, e->facility.call, e->facility.tei);
+ 					if (chanpos < 0) {
+ 					    /* did not find active call, hangup call on hold */
+ 					    if (chan) {
+ 						ast_hangup(chan);
+ 						chan = NULL;
+ 					    }
+ 					} else {
+ 					    ast_mutex_lock(&pri->pvts[chanpos]->lock);
+ 					    /* transfer */
+ 					    if (pri->pvts[chanpos]->owner) {
+ 						if (option_verbose > 3) {
+ 						    ast_verbose(VERBOSE_PREFIX_3 "ECT: found %s on channel %d for tei %d\n", pri->pvts[chanpos]->owner->name ,chanpos, e->facility.tei);
+ 						}
+ 						/* pass callprogress if the channel is not up yet */
+ 						if (pri->pvts[chanpos]->owner->_state == AST_STATE_RINGING) {
+ 						    ast_indicate(chan, AST_CONTROL_RINGING);
+ 						}
+ 						/* unlock the channel we removed from hold */
+ 						ast_mutex_unlock(&chan->lock);
+ 						if (ast_channel_masquerade(pri->pvts[chanpos]->owner, chan)) {
+ 					    	    ast_log(LOG_WARNING, "unable to masquerade\n");
+ 						} else {
+ 						    /* beware of zombies !!! */
+						    ast_set_flag(chan, AST_FLAG_ZOMBIE);
+ 						//    chan->zombie = 1;
+ 						}
+ 					    }
+ 					    ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+ 					}
+					/* disconnect */
+ 					pri_hangup(pri->pri, e->facility.call, 16, -1);
+ 				    } else if (e->facility.operation == 0x0D) {
+ 					ast_log(LOG_NOTICE, "call deflection to %s requested.\n", e->facility.forwardnum);
+ 					ast_mutex_lock(&pri->pvts[chanpos]->lock);
+ 					    /* transfer */
+ 					    if (pri->pvts[chanpos]->owner) {
+						snprintf(pri->pvts[chanpos]->owner->call_forward, sizeof(pri->pvts[chanpos]->owner->call_forward), "Local/%s@%s", e->facility.forwardnum, pri->pvts[chanpos]->owner->context);
+ 					    }
+ 					ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+ 				    } else {
+ 					ast_log(LOG_WARNING, "Unknown facility operation %#x requested.\n", e->facility.operation);
+ 				    }
+ 				break;
 			default:
 				ast_log(LOG_DEBUG, "Event: %d\n", e->e);
 			}
@@ -9430,7 +10920,7 @@
 			pri->fds[i] = -1;
 			return -1;
 		}
-		pri->dchans[i] = pri_new(pri->fds[i], pri->nodetype, pri->switchtype);
+		pri->dchans[i] = pri_new(pri->fds[i], pri->nodetype, pri->switchtype, pri->span);
 		/* Force overlap dial if we're doing GR-303! */
 		if (pri->switchtype == PRI_SWITCH_GR303_TMC)
 			pri->overlapdial = 1;
@@ -9499,39 +10989,77 @@
 
 static int handle_pri_set_debug_file(int fd, int argc, char **argv)
 {
-	int myfd;
+ 	int myfd, x, d;
+ 	int span;
+ 
+ 	if (argc < 6) 
+ 		return RESULT_SHOWUSAGE;
 
 	if (!strncasecmp(argv[1], "set", 3)) {
-		if (argc < 5) 
+		if (argc < 7) 
 			return RESULT_SHOWUSAGE;
 
-		if (ast_strlen_zero(argv[4]))
+		if (!argv[4] || ast_strlen_zero(argv[4]))
 			return RESULT_SHOWUSAGE;
 
+ 		if (!argv[5])
+ 			return RESULT_SHOWUSAGE;
+ 
+ 		if (!argv[6] || ast_strlen_zero(argv[6]))
+ 			return RESULT_SHOWUSAGE;
+ 
+ 		span = atoi(argv[6]);
+ 		if ((span < 1) && (span > NUM_SPANS)) {
+ 			return RESULT_SUCCESS;
+ 		}
+ 		
+
 		myfd = open(argv[4], O_CREAT|O_WRONLY);
 		if (myfd < 0) {
-			ast_cli(fd, "Unable to open '%s' for writing\n", argv[4]);
-			return RESULT_SUCCESS;
+ 		    ast_cli(fd, "Unable to open '%s' for writing\n", argv[4]);
+ 		    return RESULT_SUCCESS;
 		}
-
-		ast_mutex_lock(&pridebugfdlock);
-
-		if (pridebugfd >= 0)
-			close(pridebugfd);
-
-		pridebugfd = myfd;
-		ast_copy_string(pridebugfilename,argv[4],sizeof(pridebugfilename));
-		
-		ast_mutex_unlock(&pridebugfdlock);
-
-		ast_cli(fd, "PRI debug output will be sent to '%s'\n", argv[4]);
+ 		for (x=0; x < NUM_SPANS; x++) {
+ 	    	    ast_mutex_lock(&pris[x].lock);
+ 		    
+ 		    if (pris[x].span == span) {
+ 			if (pris[x].debugfd >= 0)
+ 			    close(pris[x].debugfd);
+ 			pris[x].debugfd = myfd;
+ 			for (d=0; d < NUM_DCHANS; d++) {
+ 			    if (pris[x].dchans[d])
+ 				pri_set_debug_fd(pris[x].dchans[d], myfd);
+ 			}
+ 		    }
+ 	    	    ast_mutex_unlock(&pris[x].lock);
+ 		}
+  
+ 		ast_cli(fd, "PRI debug output for span %d will be sent to '%s'\n", span, argv[4]);
 	} else {
+ 		if (!argv[5] || ast_strlen_zero(argv[5]))
+ 			return RESULT_SHOWUSAGE;
 		/* Assume it is unset */
-		ast_mutex_lock(&pridebugfdlock);
-		close(pridebugfd);
-		pridebugfd = -1;
-		ast_cli(fd, "PRI debug output to file disabled\n");
-		ast_mutex_unlock(&pridebugfdlock);
+		span = atoi(argv[5]);
+ 		if ((span < 1) && (span > NUM_SPANS)) {
+ 			return RESULT_SUCCESS;
+ 		}
+ 
+ 		for (x=0; x < NUM_SPANS; x++) {
+ 	    	    ast_mutex_lock(&pris[x].lock);
+ 		    
+ 		    if (pris[x].span == span) {
+ 			if (pris[x].debugfd >= 0)
+ 			    close(pris[x].debugfd);
+ 			pris[x].debugfd = -1;
+ 			for (d=0; d < NUM_DCHANS; d++) {
+ 			    if (pris[x].dchans[d])
+ 				pri_set_debug_fd(pris[x].dchans[d], -1);
+ 			}
+ 		    }
+ 	    	    ast_mutex_unlock(&pris[x].lock);
+ 		}
+ 
+ 		ast_cli(fd, "PRI debug output to file for span %d disabled\n", span);
 	}
 
 	return RESULT_SUCCESS;
@@ -9563,6 +11091,7 @@
 
 
 
+
 static int handle_pri_no_debug(int fd, int argc, char *argv[])
 {
 	int span;
@@ -9669,36 +11198,6 @@
 	return RESULT_SUCCESS;
 }
 
-static int handle_pri_show_debug(int fd, int argc, char *argv[])
-{
-	int x;
-	int span;
-	int count=0;
-	int debug=0;
-
-	for(span=0;span<NUM_SPANS;span++) {
-	        if (pris[span].pri) {
-			for(x=0;x<NUM_DCHANS;x++) {
-				debug=0;
-	        		if (pris[span].dchans[x]) {
-	        			debug = pri_get_debug(pris[span].dchans[x]);
-					ast_cli(fd, "Span %d: Debug: %s\tIntense: %s\n", span+1, (debug&PRI_DEBUG_Q931_STATE)? "Yes" : "No" ,(debug&PRI_DEBUG_Q921_RAW)? "Yes" : "No" );
-					count++;
-				}
-			}
-		}
-
-	}
-	ast_mutex_lock(&pridebugfdlock);
-	if (pridebugfd >= 0) 
-		ast_cli(fd, "Logging PRI debug to file %s\n", pridebugfilename);
-	ast_mutex_unlock(&pridebugfdlock);
-	    
-	if (!count) 
-		ast_cli(fd, "No debug set or no PRI running\n");
-	return RESULT_SUCCESS;
-}
-
 static char pri_debug_help[] = 
 	"Usage: pri debug span <span>\n"
 	"       Enables debugging on a given PRI span\n";
@@ -9715,6 +11214,18 @@
 	"Usage: pri show span <span>\n"
 	"       Displays PRI Information\n";
 
+static char bri_debug_help[] = 
+	"Usage: bri debug span <span>\n"
+	"       Enables debugging on a given BRI span\n";
+	
+static char bri_no_debug_help[] = 
+	"Usage: bri no debug span <span>\n"
+	"       Disables debugging on a given BRI span\n";
+
+static char bri_really_debug_help[] = 
+	"Usage: bri intensive debug span <span>\n"
+	"       Enables debugging down to the Q.921 level\n";
+
 static struct ast_cli_entry zap_pri_cli[] = {
 	{ { "pri", "debug", "span", NULL }, handle_pri_debug,
 	  "Enables PRI debugging on a span", pri_debug_help, complete_span_4 },
@@ -9722,18 +11233,327 @@
 	  "Disables PRI debugging on a span", pri_no_debug_help, complete_span_5 },
 	{ { "pri", "intense", "debug", "span", NULL }, handle_pri_really_debug,
 	  "Enables REALLY INTENSE PRI debugging", pri_really_debug_help, complete_span_5 },
+	{ { "bri", "debug", "span", NULL }, handle_pri_debug,
+	  "Enables BRI debugging on a span", bri_debug_help, complete_span_4 },
+	{ { "bri", "no", "debug", "span", NULL }, handle_pri_no_debug,
+	  "Disables BRI debugging on a span", bri_no_debug_help, complete_span_5 },
+	{ { "bri", "intense", "debug", "span", NULL }, handle_pri_really_debug,
+	  "Enables REALLY INTENSE BRI debugging", bri_really_debug_help, complete_span_5 },
 	{ { "pri", "show", "span", NULL }, handle_pri_show_span,
 	  "Displays PRI Information", pri_show_span_help, complete_span_4 },
-	{ { "pri", "show", "debug", NULL }, handle_pri_show_debug,
-	  "Displays current PRI debug settings" },
 	{ { "pri", "set", "debug", "file", NULL }, handle_pri_set_debug_file,
 	  "Sends PRI debug output to the specified file" },
-	{ { "pri", "unset", "debug", "file", NULL }, handle_pri_set_debug_file,
+	{ { "pri", "unset", "debug", "file", "span", NULL }, handle_pri_set_debug_file,
 	  "Ends PRI debug output to file" },
 };
 
+static char *zapCD_tdesc = "Call Deflection";
+static char *zapCD_app = "zapCD";
+static char *zapCD_synopsis = "Call Deflection";
+
+static int app_zapCD(struct ast_channel *chan, void *data)
+{
+    struct zt_pvt *p = chan->tech_pvt;
+
+    if((!p->pri) || (!p->pri->pri)) {
+	return -1;
+    }
+
+    if(!data) {
+        ast_log(LOG_WARNING, "zapCD wants a number to deflect to\n");
+	return -1;
+    }
+    return pri_deflect(p->pri->pri, p->call, data);
+}
+
+static char *zapInband_tdesc = "Inband Call Progress (pre-answer)";
+static char *zapInband_app = "zapInband";
+static char *zapInband_synopsis = "Inband Call Progress";
+
+static int app_zapInband(struct ast_channel *chan, void *data)
+{
+    struct zt_pvt *p = chan->tech_pvt;
+
+    return pri_acknowledge(p->pri->pri, p->call, PVT_TO_CHANNEL(p), 1);
+}
 #endif /* ZAPATA_PRI */
 
+#ifdef ZAPATA_GSM
+static int handle_zap_reset_span(int fd, int argc, char *argv[])
+{
+	int span;
+	int sleep = 5000;
+	if (argc < 4)
+		return RESULT_SHOWUSAGE;
+	span = atoi(argv[3]);
+	if ((span < 1) || (span > NUM_SPANS)) {
+		ast_cli(fd, "Invalid span '%s'.  Should be a number from %d to %d\n", argv[3], 1, NUM_SPANS);
+		return RESULT_SUCCESS;
+	}
+	if (zt_reset_span(span, sleep)) {
+	    return RESULT_FAILURE;
+	}
+	return RESULT_SUCCESS;
+}
+
+static int handle_gsm_debug_helper(int fd, int channel, int debug)
+{
+/* gsm debug channel <channel> */
+	struct zt_pvt *pvt = NULL;
+	if (channel < 1) {
+		ast_cli(fd, "Invalid channel %d.  Should be a number.\n", channel);
+		return RESULT_SUCCESS;
+	}
+	pvt = iflist;
+	while (pvt) {
+	    if (pvt->channel == channel) {
+		ast_mutex_lock(&pvt->lock);
+		gsm_set_debug(pvt->gsm.modul, debug);
+		ast_mutex_unlock(&pvt->lock);
+		ast_cli(fd, "%s debugging on channel %d\n", debug ? "Enabled":"Disabled", channel);
+		return RESULT_SUCCESS;
+	    }
+	    pvt = pvt->next;
+	}
+	
+	ast_cli(fd, "No GSM running on channel %d\n", channel);
+	return RESULT_SUCCESS;
+}
+
+
+
+static int handle_gsm_debug(int fd, int argc, char *argv[])
+{
+/* gsm debug channel <channel> */
+    int channel;
+    if (argc < 4) {
+    	return RESULT_SHOWUSAGE;
+    }
+    channel = atoi(argv[3]);
+    return handle_gsm_debug_helper(fd, channel, GSM_DEBUG_AT);
+}
+
+static int handle_gsm_no_debug(int fd, int argc, char *argv[])
+{
+/* gsm no debug channel <channel> */
+    int channel;
+    if (argc < 5) {
+    	return RESULT_SHOWUSAGE;
+    }
+    channel = atoi(argv[4]);
+    return handle_gsm_debug_helper(fd, channel, GSM_DEBUG_NONE);
+}
+
+static char zap_reset_help[] = 
+	"Usage: zap reset span <span>\n"
+	"       Reset/Restart a zaptel span\n";
+
+static char gsm_debug_help[] = 
+	"Usage: gsm debug channel <channel>\n"
+	"       Enables debugging on a given GSM channel\n";
+	
+static char gsm_no_debug_help[] = 
+	"Usage: gsm no debug channel <channel>\n"
+	"       Disables debugging on a given GSM channel\n";
+
+static struct ast_cli_entry zap_gsm_cli[] = {
+	{ { "zap", "reset", "span", NULL }, handle_zap_reset_span,
+	  "Restart a zaptel span", zap_reset_help, complete_span_4 },
+	{ { "gsm", "debug", "channel", NULL }, handle_gsm_debug,
+	  "Enables GSM debugging on a channel", gsm_debug_help },
+	{ { "gsm", "no", "debug", "channel", NULL }, handle_gsm_no_debug,
+	  "Disables GSM debugging on a channel", gsm_no_debug_help},
+};
+
+
+
+static char gsm_send_pdu_help[] = 
+	"Usage: gsm send pdu <channel> <pdu>\n"
+	"       Sends a PDU on a GSM channel\n";
+
+
+
+static int handle_gsm_send_pdu(int fd, int argc, char *argv[])
+{
+/* gsm send sms <channel> <destination> <message> */
+	int channel;
+	struct zt_pvt *pvt = NULL;
+	if (argc < 5) {
+		return RESULT_SHOWUSAGE;
+	}
+	channel = atoi(argv[3]);
+	if (channel < 1) {
+		ast_cli(fd, "Invalid channel %s.  Should be a number.\n", argv[3]);
+		return RESULT_SUCCESS;
+	}
+	pvt = iflist;
+	while (pvt) {
+	    if (pvt->channel == channel) {
+		if (pvt->owner) {
+		    ast_cli(fd, "Channel in use.\n");
+		    return RESULT_FAILURE;
+		} else {
+		    ast_mutex_lock(&pvt->lock);
+		    gsm_sms_send_pdu(pvt->gsm.modul, argv[4]);
+		    ast_mutex_unlock(&pvt->lock);
+		    return RESULT_SUCCESS;
+		}
+	    }
+	    pvt = pvt->next;
+	}
+	
+	return RESULT_SUCCESS;
+}
+
+static struct ast_cli_entry gsm_send_pdu = {
+	{ "gsm", "send", "pdu", NULL }, handle_gsm_send_pdu, "Sends a SM on a GSM channel", gsm_send_pdu_help, complete_span_4 };
+
+
+static char gsm_send_sms_help[] = 
+	"Usage: gsm send sms <channel> <destination> <message>\n"
+	"       Sends a SM on a GSM channel\n";
+
+
+static int handle_gsm_send_sms(int fd, int argc, char *argv[])
+{
+/* gsm send sms <channel> <destination> <message> */
+	int channel;
+	struct zt_pvt *pvt = NULL;
+	if (argc < 6) {
+		return RESULT_SHOWUSAGE;
+	}
+	channel = atoi(argv[3]);
+	if (channel < 1) {
+		ast_cli(fd, "Invalid channel %s.  Should be a number.\n", argv[3]);
+		return RESULT_SUCCESS;
+	}
+	pvt = iflist;
+	while (pvt) {
+	    if (pvt->channel == channel) {
+		if (pvt->owner) {
+		    ast_cli(fd, "Channel in use.\n");
+		    return RESULT_FAILURE;
+		} else {
+		    ast_mutex_lock(&pvt->lock);
+		    gsm_sms_send_text(pvt->gsm.modul, argv[4], argv[5]);
+		    ast_mutex_unlock(&pvt->lock);
+		    return RESULT_SUCCESS;
+		}
+	    }
+	    pvt = pvt->next;
+	}
+	
+	return RESULT_SUCCESS;
+}
+
+static int zt_gsm_sendtext(struct ast_channel *chan, const char * dest, const char *text, int ispdu) {
+    struct zt_pvt *pvt = NULL;
+    char *c = NULL;
+    pvt = chan->tech_pvt;
+    
+    if (!pvt) return -1;
+    
+    /* parse dialstring */
+    c = strrchr(dest, '/');
+    if (c)
+	c++;
+    else
+	c = (char *)dest;
+
+    ast_mutex_lock(&pvt->lock);
+	if (ispdu) {
+    	    gsm_sms_send_pdu(pvt->gsm.modul, (char *)text);
+	} else {
+    	    gsm_sms_send_text(pvt->gsm.modul, c, (char *)text);
+	}
+    ast_mutex_unlock(&pvt->lock);
+    gsm_wait(pvt->gsm.modul);
+    return 0;
+}
+
+static struct ast_cli_entry gsm_send_sms = {
+	{ "gsm", "send", "sms", NULL }, handle_gsm_send_sms, "Sends a SM on a GSM channel", gsm_send_sms_help, complete_span_4 };
+
+static char gsm_show_status_help[] = 
+	"Usage: gsm show status <channel>>\n"
+	"       Displays status information about the GSM channel.\n";
+
+
+static int handle_gsm_show_status(int fd, int argc, char *argv[])
+{
+	int channel;
+	struct zt_pvt *pvt = NULL;
+	if (argc < 4) {
+		return RESULT_SHOWUSAGE;
+	}
+	channel = atoi(argv[3]);
+	if (channel < 1) {
+		ast_cli(fd, "Invalid channel %s.  Should be a number.\n", argv[3]);
+		return RESULT_SUCCESS;
+	}
+	pvt = iflist;
+	while (pvt) {
+	    if (pvt->channel == channel) {
+		if (pvt->owner) {
+		    ast_cli(fd, "Channel in use.\n");
+		    return RESULT_FAILURE;
+		} else {
+		    ast_mutex_lock(&pvt->lock);
+		    gsm_request_status(pvt->gsm.modul);
+		    ast_mutex_unlock(&pvt->lock);
+		    return RESULT_SUCCESS;
+		}
+	    }
+	    pvt = pvt->next;
+	}
+	
+	return RESULT_SUCCESS;
+}
+
+static struct ast_cli_entry gsm_show_status = {
+	{ "gsm", "show", "status", NULL }, handle_gsm_show_status, "Displays status information about the GSM channel.", gsm_show_status_help, complete_span_4 };
+
+#endif /* ZAPATA_GSM */
+
+static int app_zapEC(struct ast_channel *chan, void *data)
+{
+ int res=-1;
+ struct zt_pvt *p = NULL;
+
+ if (!data) {
+	ast_log(LOG_WARNING, "zapEC requires one argument (on | off)\n");
+ }
+ if (chan && !strcasecmp("ZAP",chan->type)) {
+	p = chan->tech_pvt;
+	if (!p) return res;
+	if (!strcasecmp("on",(char *)data)) {
+	    zt_enable_ec(p);
+	    res = 0;
+	    if (option_verbose > 3) {
+		ast_verbose(VERBOSE_PREFIX_3 "Enabled echo cancelation on channel %s.\n", chan->name);
+	    }
+	} else if (!strcasecmp("off",(char *)data)) {
+	    zt_disable_ec(p);
+	    res = 0;
+	    if (option_verbose > 3) {
+		ast_verbose(VERBOSE_PREFIX_3 "Disabled echo cancelation on channel %s.\n", chan->name);
+	    }
+	} else {
+ 	    ast_log(LOG_WARNING, "Unknown argument %s to zapEC\n", (char *)data);
+	}
+ } else {
+     ast_log(LOG_WARNING, "zapNoEC only works on ZAP channels, check your extensions.conf!\n");
+     res = 0;
+ }
+
+ return res;
+}
+
+static char *zapEC_tdesc = "Enable/disable Echo cancelation";
+static char *zapEC_app = "zapEC";
+static char *zapEC_synopsis = "Enable/Disable Echo Cancelation on a Zap channel";
+
+
 
 #ifdef ZAPATA_R2
 static int handle_r2_no_debug(int fd, int argc, char *argv[])
@@ -10393,6 +12213,14 @@
 			pthread_cancel(pris[i].master);
 	}
 	ast_cli_unregister_multiple(zap_pri_cli, sizeof(zap_pri_cli) / sizeof(zap_pri_cli[0]));
+	ast_unregister_application(zapCD_app);
+	ast_unregister_application(zapInband_app);
+#endif
+#ifdef ZAPATA_GSM
+	ast_cli_unregister_multiple(zap_gsm_cli, sizeof(zap_gsm_cli) / sizeof(zap_gsm_cli[0]));
+	ast_cli_unregister(&gsm_send_sms);
+	ast_cli_unregister(&gsm_send_pdu);
+	ast_cli_unregister(&gsm_show_status);
 #endif
 #ifdef ZAPATA_R2
 	ast_cli_unregister_multiple(zap_r2_cli, sizeof(zap_r2_cli) / sizeof(zap_r2_cli[0]));
@@ -10404,6 +12232,7 @@
 	ast_manager_unregister( "ZapDNDoff" );
 	ast_manager_unregister( "ZapDNDon" );
 	ast_manager_unregister("ZapShowChannels");
+	ast_unregister_application(zapEC_app);
 	ast_channel_unregister(&zap_tech);
 	if (!ast_mutex_lock(&iflock)) {
 		/* Hangup all interfaces if they have an owner */
@@ -10764,8 +12593,8 @@
 			}
 		} else if (!strcasecmp(v->name, "echotraining")) {
 			if (sscanf(v->value, "%d", &y) == 1) {
-				if ((y < 10) || (y > 4000)) {
-					ast_log(LOG_WARNING, "Echo training time must be within the range of 10 to 2000 ms at line %d\n", v->lineno);					
+				if ((y < 10) || (y > 1000)) {
+					ast_log(LOG_WARNING, "Echo training time must be within the range of 10 to 1000 ms at line %d\n", v->lineno);					
 				} else {
 					chan_conf.echotraining = y;
 				}
@@ -10959,12 +12788,33 @@
 					chan_conf.signalling = SIG_GR303FXSKS;
 					chan_conf.radio = 0;
 					pritype = PRI_CPE;
+ 				} else if (!strcasecmp(v->value, "bri_net_ptmp")) {
+ 					chan_conf.radio = 0;
+ 					chan_conf.signalling = SIG_PRI;
+ 					pritype = BRI_NETWORK_PTMP;
+ 				} else if (!strcasecmp(v->value, "bri_cpe_ptmp")) {
+ 					chan_conf.signalling = SIG_PRI;
+ 					chan_conf.radio = 0;
+ 					pritype = BRI_CPE_PTMP;
+ 				} else if (!strcasecmp(v->value, "bri_net")) {
+ 					chan_conf.radio = 0;
+ 					chan_conf.signalling = SIG_PRI;
+ 					pritype = BRI_NETWORK;
+ 				} else if (!strcasecmp(v->value, "bri_cpe")) {
+ 					chan_conf.signalling = SIG_PRI;
+ 					chan_conf.radio = 0;
+ 					pritype = BRI_CPE;
 #endif
 #ifdef ZAPATA_R2
 				} else if (!strcasecmp(v->value, "r2")) {
 					chan_conf.signalling = SIG_R2;
 					chan_conf.radio = 0;
 #endif			
+#ifdef ZAPATA_GSM
+				} else if (!strcasecmp(v->value, "gsm")) {
+					chan_conf.signalling = SIG_GSM;
+					chan_conf.radio = 0;
+#endif				
 				} else {
 					ast_log(LOG_ERROR, "Unknown signalling method '%s'\n", v->value);
 				}
@@ -11047,9 +12897,21 @@
 					chan_conf.priindication_oob = 1;
 				else if (!strcasecmp(v->value, "inband"))
 					chan_conf.priindication_oob = 0;
+				else if (!strcasecmp(v->value, "passthrough"))
+					chan_conf.pri.priindication_oob = 2;
 				else
-					ast_log(LOG_WARNING, "'%s' is not a valid pri indication value, should be 'inband' or 'outofband' at line %d\n",
+					ast_log(LOG_WARNING, "'%s' is not a valid pri indication value, should be 'inband', 'passthrough' or 'outofband' at line %d\n",
 						v->value, v->lineno);
+			} else if (!strcasecmp(v->name, "pritransfer")) {
+				if (!strcasecmp(v->value, "no"))
+					chan_conf.pri.pritransfer = 0;
+				else if (!strcasecmp(v->value, "ect"))
+					chan_conf.pri.pritransfer = 1;
+				else if (!strcasecmp(v->value, "hangup"))
+					chan_conf.pri.pritransfer = 2;
+  				else
+ 					ast_log(LOG_WARNING, "'%s' is not a valid pri transfer value, should be 'no' , 'ect' or 'hangup' at line %d\n",
+  						v->value, v->lineno);
 			} else if (!strcasecmp(v->name, "priexclusive")) {
 				chan_conf.priexclusive = ast_true(v->value);
 			} else if (!strcasecmp(v->name, "internationalprefix")) {
@@ -11062,6 +12924,14 @@
 				ast_copy_string(chan_conf.pri.privateprefix, v->value, sizeof(chan_conf.pri.privateprefix));
 			} else if (!strcasecmp(v->name, "unknownprefix")) {
 				ast_copy_string(chan_conf.pri.unknownprefix, v->value, sizeof(chan_conf.pri.unknownprefix));
+ 			} else if (!strcasecmp(v->name, "nocid")) {
+  				ast_copy_string(chan_conf.pri.nocid, v->value, sizeof(chan_conf.pri.nocid) - 1);
+  			} else if (!strcasecmp(v->name, "withheldcid")) {
+  				ast_copy_string(chan_conf.pri.withheldcid, v->value, sizeof(chan_conf.pri.withheldcid) - 1);
+			} else if (!strcasecmp(v->name, "pin")) {
+				ast_copy_string(gsm_modem_pin, v->value, sizeof(gsm_modem_pin) - 1);
+			} else if (!strcasecmp(v->name, "exten")) {
+				ast_copy_string(gsm_modem_exten, v->value, sizeof(gsm_modem_exten) - 1);
 			} else if (!strcasecmp(v->name, "resetinterval")) {
 				if (!strcasecmp(v->value, "never"))
 					chan_conf.pri.resetinterval = -1;
@@ -11078,6 +12948,8 @@
 				ast_copy_string(chan_conf.pri.idleext, v->value, sizeof(chan_conf.pri.idleext));
 			} else if (!strcasecmp(v->name, "idledial")) {
 				ast_copy_string(chan_conf.pri.idledial, v->value, sizeof(chan_conf.pri.idledial));
+  			} else if (!strcasecmp(v->name, "pritrustusercid")) {
+  				chan_conf.pri.usercid = ast_true(v->value);
 			} else if (!strcasecmp(v->name, "overlapdial")) {
 				chan_conf.pri.overlapdial = ast_true(v->value);
 			} else if (!strcasecmp(v->name, "pritimer")) {
@@ -11255,6 +13127,7 @@
 #ifdef ZAPATA_PRI
 	if (!reload) {
 		for (x=0;x<NUM_SPANS;x++) {
+			pris[x].debugfd = -1;
 			if (pris[x].pvts[0]) {
 				if (start_pri(pris + x)) {
 					ast_log(LOG_ERROR, "Unable to start D-channel on span %d\n", x + 1);
@@ -11287,6 +13160,10 @@
 	pri_set_error(zt_pri_error);
 	pri_set_message(zt_pri_message);
 #endif
+#ifdef ZAPATA_GSM
+	gsm_set_error(zt_gsm_error);
+	gsm_set_message(zt_gsm_message);
+#endif
 	res = setup_zap(0);
 	/* Make sure we can register our Zap channel type */
 	if(res) {
@@ -11304,6 +13181,12 @@
 	ast_cli_register_multiple(zap_r2_cli, sizeof(zap_r2_cli) / sizeof(zap_r2_cli[0]));
 #endif	
 	ast_cli_register_multiple(zap_cli, sizeof(zap_cli) / sizeof(zap_cli[0]));
+#ifdef ZAPATA_GSM
+	ast_cli_register(&gsm_send_sms);
+	ast_cli_register(&gsm_send_pdu);
+	ast_cli_register(&gsm_show_status);
+	ast_cli_register_multiple(zap_gsm_cli, sizeof(zap_gsm_cli) / sizeof(zap_gsm_cli[0]));
+#endif
 	
 	memset(round_robin, 0, sizeof(round_robin));
 	ast_manager_register( "ZapTransfer", 0, action_transfer, "Transfer Zap Channel" );
@@ -11312,11 +13195,56 @@
 	ast_manager_register( "ZapDNDon", 0, action_zapdndon, "Toggle Zap channel Do Not Disturb status ON" );
 	ast_manager_register( "ZapDNDoff", 0, action_zapdndoff, "Toggle Zap channel Do Not Disturb status OFF" );
 	ast_manager_register("ZapShowChannels", 0, action_zapshowchannels, "Show status zapata channels");
-
+	ast_register_application(zapEC_app, app_zapEC, zapEC_synopsis, zapEC_tdesc);
+#ifdef ZAPATA_PRI
+        ast_register_application(zapCD_app, app_zapCD, zapCD_synopsis, zapCD_tdesc);
+        ast_register_application(zapInband_app, app_zapInband, zapInband_synopsis, zapInband_tdesc);
+#endif
 	return res;
 }
 
-static int zt_sendtext(struct ast_channel *c, const char *text)
+#ifdef ZAPATA_PRI
+static int zt_tdd_sendtext(struct ast_channel *c, const char *text);
+
+static int zt_pri_sendtext(struct ast_channel *c, const char *text) {
+    struct zt_pvt *p = c->tech_pvt;
+    if (!p) return -1;
+    if (!p->pri) return -1;
+	    if (strlen(text)) {
+		if (p->pri) {		
+		    if (!pri_grab(p, p->pri)) {
+		//	ast_log(LOG_NOTICE, "Sending Display IE  '%s'\n", text);
+			pri_information_display(p->pri->pri,p->call,(char *)text);
+			pri_rel(p->pri);
+	    	    } else ast_log(LOG_WARNING, "Unable to grab PRI on span %d\n", p->span);
+		}
+	    }
+    return 0;
+}
+#endif
+
+static int zt_sendtext(struct ast_channel *c, const char *dest, const char *text, int ispdu) {
+    struct zt_pvt *p = c->tech_pvt;
+    if (!p) return -1;
+    if (p->sig == SIG_PRI) {
+#ifdef ZAPATA_PRI
+	if (ispdu) {
+	    ast_log(LOG_WARNING, "Dont know how to send PDU on ZAP ISDN channel\n");
+	    return -1;
+	}
+	return zt_pri_sendtext(c, text);
+#endif
+    } else if (p->sig == SIG_GSM) {
+#ifdef ZAPATA_GSM
+        return zt_gsm_sendtext(c, dest, text, ispdu);
+#endif
+    } else {
+	return zt_tdd_sendtext(c, text);
+    }
+    return -1;
+}
+
+static int zt_tdd_sendtext(struct ast_channel *c, const char *text)
 {
 #define	END_SILENCE_LEN 400
 #define	HEADER_MS 50
@@ -11335,6 +13263,7 @@
 	float scont = 0.0;
 	int index;
 
+
 	index = zt_get_index(c, p, 0);
 	if (index < 0) {
 		ast_log(LOG_WARNING, "Huh?  I don't exist?\n");
Index: asterisk-bristuff/channels/Makefile
===================================================================
--- asterisk-bristuff.orig/channels/Makefile	2007-10-20 00:35:42.000000000 +0200
+++ asterisk-bristuff/channels/Makefile	2007-10-20 00:36:33.000000000 +0200
@@ -107,6 +107,11 @@
   ZAPPRI=-lpri
 endif
 
+ifneq ($(wildcard $(CROSS_COMPILE_TARGET)/usr/lib/libgsmat.so.1)$(wildcard $(CROSS_COMPILE_TARGET)/usr/local/lib/libgsmat.so.1),)
+  CFLAGS+=-DZAPATA_GSM
+  ZAPGSM=-lgsmat
+endif
+
 ALSA_SRC=chan_alsa.c
 
 ifneq ($(wildcard alsa-monitor.h),)
@@ -210,7 +215,7 @@
 	$(CC) -c $(CFLAGS) -o chan_zap.o chan_zap.c
 
 chan_zap.so: chan_zap.o
-	$(CC) $(SOLINK) -o $@ $<  $(ZAPPRI) $(ZAPR2) -ltonezone
+	$(CC) $(SOLINK) -o $@ $<  $(ZAPPRI) $(ZAPGSM) $(ZAPR2) -ltonezone
 
 chan_sip.so: chan_sip.o
 	$(CC) $(SOLINK) -o $@ ${CYGSOLINK} chan_sip.o ${CYGSOLIB}
@@ -226,6 +231,9 @@
 chan_nbs.so: chan_nbs.o
 	$(CC) $(SOLINK) -o $@ $< -lnbs
 
+chan_capi.so: chan_capi.o
+	$(CC) $(SOLINK) -o $@ $< -lcapi20
+
 chan_vpb.o: chan_vpb.c
 	$(CXX) -c $(CFLAGS) -o $@ chan_vpb.c
 
Index: asterisk-bristuff/configs/esel.conf.sample
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ asterisk-bristuff/configs/esel.conf.sample	2007-10-20 00:35:48.000000000 +0200
@@ -0,0 +1,12 @@
+;
+; Configuration file for res_esel
+;
+
+;[asterisk-2]
+;host = 192.168.0.1
+;port = 5038
+;username = manager
+;secret = donkey
+
+; export the extension snom in context phones to DS/100 on asterisk-2
+;export => snom@phones,100
Index: asterisk-bristuff/configs/modules.conf.sample
===================================================================
--- asterisk-bristuff.orig/configs/modules.conf.sample	2005-11-29 19:24:39.000000000 +0100
+++ asterisk-bristuff/configs/modules.conf.sample	2007-10-20 00:35:48.000000000 +0200
@@ -46,8 +46,12 @@
 ;
 noload => chan_alsa.so
 ;noload => chan_oss.so
+
+; remove the next line to test drive res_esel
+noload => res_esel.so
 ;
 ; Module names listed in "global" section will have symbols globally
 ; exported to modules loaded after them.
 ;
 [global]
+chan_capi.so=yes
Index: asterisk-bristuff/configs/sip.conf.sample
===================================================================
--- asterisk-bristuff.orig/configs/sip.conf.sample	2006-11-30 18:55:23.000000000 +0100
+++ asterisk-bristuff/configs/sip.conf.sample	2007-10-20 00:35:48.000000000 +0200
@@ -329,7 +329,16 @@
 ;call-limit=5				; permit only 5 simultaneous outgoing calls to this peer
 ;outboundproxy=proxy.provider.domain	; send outbound signaling to this proxy, not directly to the peer
 ;port=80				; The port number we want to connect to on the remote side
-
+;nationalprefix=0
+;internationalprefix=00
+;countrycode=49
+;areacode=30
+;dialplan=international			; convert 123456 to 004930123456
+;dialplan=national			; convert 123456 to 030123456
+;dialplan=local				; do not change the dialed number, default behaviour.
+;prefix=666				
+;rtpip=192.168.1.1			; if RTP should go to asterisk you can configure the
+					; used IP address here (for multihomed machines)
 ;------------------------------------------------------------------------------
 ; Definitions of locally connected SIP phones
 ;
Index: asterisk-bristuff/configs/zapata.conf.sample
===================================================================
--- asterisk-bristuff.orig/configs/zapata.conf.sample	2006-09-18 17:05:56.000000000 +0200
+++ asterisk-bristuff/configs/zapata.conf.sample	2007-10-20 00:35:48.000000000 +0200
@@ -123,9 +123,20 @@
 ; 
 ; outofband:      Signal Busy/Congestion out of band with RELEASE/DISCONNECT
 ; inband:         Signal Busy/Congestion using in-band tones
+; passthrough:	  Listen to the telco
 ;
 ; priindication = outofband
 ;
+; PRI/BRI transfers (HOLD -> SETUP -> ECT/Hangup)
+;
+; Configure how transfers are initiated. ECT should be preferred
+;
+; no:		no transfers allowed (results in hangup)
+; ect:  	use ECT (facility)
+: hangup:	transfer on hangup (if your phones dont support ECT)
+;
+; pritransfer = ect
+;
 ; If you need to override the existing channels selection routine and force all
 ; PRI channels to be marked as exclusively selected, set this to yes.
 ; priexclusive = yes
Index: asterisk-bristuff/db.c
===================================================================
--- asterisk-bristuff.orig/db.c	2007-06-24 19:32:21.000000000 +0200
+++ asterisk-bristuff/db.c	2007-10-20 00:35:48.000000000 +0200
@@ -516,11 +516,18 @@
 struct ast_cli_entry cli_database_deltree =
 { { "database", "deltree", NULL }, database_deltree, "Removes database keytree/values", database_deltree_usage };
 
+static char mandescr_dbput[] = 
+"Description: Put a value into astdb\n"
+"Variables: \n"
+"	Family: ...\n"
+"	Key: ...\n"
+"	Value: ...\n";
+
 static int manager_dbput(struct mansession *s, struct message *m)
 {
 	char *family = astman_get_header(m, "Family");
 	char *key = astman_get_header(m, "Key");
-	char *val = astman_get_header(m, "Val");
+	char *val = astman_get_header(m, "Value");
 	int res;
 
 	if (!strlen(family)) {
@@ -541,6 +548,12 @@
 	return 0;
 }
 
+static char mandescr_dbget[] = 
+"Description: Get a value from astdb\n"
+"Variables: \n"
+"	Family: ...\n"
+"	Key: ...\n";
+
 static int manager_dbget(struct mansession *s, struct message *m)
 {
 	char *id = astman_get_header(m,"ActionID");
@@ -570,7 +583,7 @@
 		ast_cli(s->fd, "Event: DBGetResponse\r\n"
 				"Family: %s\r\n"
 				"Key: %s\r\n"
-				"Val: %s\r\n"
+				"Value: %s\r\n"
 				"%s"
 				"\r\n",
 				family, key, tmp, idText);
@@ -578,6 +591,39 @@
 	return 0;
 }
 
+static char mandescr_dbdel[] = 
+"Description: remove value from astdb\n"
+"Variables: \n"
+"	Family: ...\n"
+"	Key: ...\n";
+
+static int manager_dbdel(struct mansession *s, struct message *m)
+{
+        char *family = astman_get_header(m, "Family");
+        char *key = astman_get_header(m, "Key");
+	char *id = astman_get_header(m,"ActionID");
+
+	if (!strlen(family)) {
+		astman_send_error(s, m, "No family specified");
+		return 0;
+	}
+	if (!strlen(key)) {
+		astman_send_error(s, m, "No key specified");
+		return 0;
+	}
+
+	if (ast_db_del(family, key)) {
+	    ast_cli(s->fd, "Response: Failed\r\n");
+	} else {
+	    ast_cli(s->fd, "Response: Success\r\n");
+	}
+	if (id && !ast_strlen_zero(id))
+		ast_cli(s->fd, "ActionID: %s\r\n",id);
+	ast_cli(s->fd, "\r\n");
+
+	return 0;
+}
+
 int astdb_init(void)
 {
 	dbinit();
@@ -587,7 +633,8 @@
 	ast_cli_register(&cli_database_put);
 	ast_cli_register(&cli_database_del);
 	ast_cli_register(&cli_database_deltree);
-	ast_manager_register("DBGet", EVENT_FLAG_SYSTEM, manager_dbget, "Get DB Entry");
-	ast_manager_register("DBPut", EVENT_FLAG_SYSTEM, manager_dbput, "Put DB Entry");
+	ast_manager_register("DBget", EVENT_FLAG_SYSTEM, manager_dbget, mandescr_dbget);
+	ast_manager_register("DBput", EVENT_FLAG_SYSTEM, manager_dbput, mandescr_dbput);
+	ast_manager_register("DBdel", EVENT_FLAG_SYSTEM, manager_dbdel, mandescr_dbdel);
 	return 0;
 }
Index: asterisk-bristuff/devicestate.c
===================================================================
--- asterisk-bristuff.orig/devicestate.c	2007-06-06 14:18:36.000000000 +0200
+++ asterisk-bristuff/devicestate.c	2007-10-20 00:35:48.000000000 +0200
@@ -62,6 +62,8 @@
 
 struct state_change {
 	AST_LIST_ENTRY(state_change) list;
+	char cid_num[AST_MAX_EXTENSION];
+	char cid_name[AST_MAX_EXTENSION];
 	char device[1];
 };
 
@@ -177,7 +179,7 @@
 }
 
 /*--- do_state_change: Notify callback watchers of change, and notify PBX core for hint updates */
-static void do_state_change(const char *device)
+static void do_state_change(const char *device, char *cid_num, char *cid_name)
 {
 	int state;
 	struct devstate_cb *devcb;
@@ -188,13 +190,13 @@
 
 	AST_LIST_LOCK(&devstate_cbs);
 	AST_LIST_TRAVERSE(&devstate_cbs, devcb, list)
-		devcb->callback(device, state, devcb->data);
+		devcb->callback(device, state, devcb->data, cid_num, cid_name);
 	AST_LIST_UNLOCK(&devstate_cbs);
 
-	ast_hint_state_changed(device);
+	ast_hint_state_changed(device, cid_num, cid_name);
 }
 
-static int __ast_device_state_changed_literal(char *buf)
+static int __ast_device_state_changed_literal(char *buf, char *cid_num, char *cid_name)
 {
 	char *device;
 	struct state_change *change = NULL;
@@ -212,10 +214,16 @@
 	if (!change) {
 		/* we could not allocate a change struct, or */
 		/* there is no background thread, so process the change now */
-		do_state_change(device);
+		do_state_change(device, cid_num, cid_name);
 	} else {
 		/* queue the change */
 		strcpy(change->device, device);
+		if (cid_num && (!ast_strlen_zero(cid_num))) {
+		    strncpy(change->cid_num, cid_num, sizeof(change->cid_num) - 1);
+		}
+		if (cid_name && (!ast_strlen_zero(cid_name))) {
+		    strncpy(change->cid_name, cid_name, sizeof(change->cid_name) - 1);
+		}
 		AST_LIST_LOCK(&state_changes);
 		AST_LIST_INSERT_TAIL(&state_changes, change, list);
 		if (AST_LIST_FIRST(&state_changes) == change)
@@ -227,11 +235,17 @@
 	return 1;
 }
 
-int ast_device_state_changed_literal(const char *dev)
+int ast_device_state_changed_literal(const char *dev, const char *cid_num, const char *cid_name)
 {
 	char *buf;
+	char *buf2 = NULL;
+	char *buf3 = NULL;
 	buf = ast_strdupa(dev);
-	return __ast_device_state_changed_literal(buf);
+	if (cid_num)
+	    buf2 = ast_strdupa(cid_num);
+	if (cid_name)
+	    buf3 = ast_strdupa(cid_name);
+	return __ast_device_state_changed_literal(buf, buf2, buf3);
 }
 
 /*--- ast_device_state_changed: Accept change notification, add it to change queue */
@@ -243,7 +257,7 @@
 	va_start(ap, fmt);
 	vsnprintf(buf, sizeof(buf), fmt, ap);
 	va_end(ap);
-	return __ast_device_state_changed_literal(buf);
+	return __ast_device_state_changed_literal(buf, NULL, NULL);
 }
 
 /*--- do_devstate_changes: Go through the dev state change queue and update changes in the dev state thread */
@@ -258,7 +272,7 @@
 		if (cur) {
 			/* we got an entry, so unlock the list while we process it */
 			AST_LIST_UNLOCK(&state_changes);
-			do_state_change(cur->device);
+			do_state_change(cur->device, cur->cid_num, cur->cid_name);
 			free(cur);
 			AST_LIST_LOCK(&state_changes);
 		} else {
Index: asterisk-bristuff/doc/README.asterisk.conf
===================================================================
--- asterisk-bristuff.orig/doc/README.asterisk.conf	2005-11-29 19:24:39.000000000 +0100
+++ asterisk-bristuff/doc/README.asterisk.conf	2007-10-20 00:35:48.000000000 +0200
@@ -62,6 +62,7 @@
 maxcalls = 255					; The maximum number of concurrent calls you want to allow 
 execincludes = yes | no 			; Allow #exec entries in configuration files
 dontwarn = yes | no				; Don't over-inform the Asterisk sysadm, he's a guru
+uniquename = asterisk				; host name part to be included in the uniqueid
 
 [files]
 ; Changing the following lines may compromise your security
Index: asterisk-bristuff/HARDWARE
===================================================================
--- asterisk-bristuff.orig/HARDWARE	2005-11-29 19:24:39.000000000 +0100
+++ asterisk-bristuff/HARDWARE	2007-10-20 00:35:48.000000000 +0200
@@ -37,6 +37,19 @@
    * Wildcard TE410P - Quad T1/E1 switchable interface.  Supports PRI and 
      RBS signalling, as well as PPP, FR, and HDLC data modes.
 
+-- Junghanns.NET (Primary author of BRIstuff)
+	http://www.junghanns.net
+	
+    * quadBRI PCI ISDN - 4port BRI ISDN interface, supports NT and TE mode
+    
+    * octoBRI PCI ISDN - 8port BRI ISDN interface, supports NT and TE mode
+
+    * singleE1 PCI ISDN - Single E1 interface
+
+    * doubleE1 PCI ISDN - Double E1 interface
+    
+    * uno/duo/quad GSM PCI - 1/2/4 channel GSM interface cards
+
 Non-zaptel compatible hardware
 ==============================
 
Index: asterisk-bristuff/include/asterisk/agi.h
===================================================================
--- asterisk-bristuff.orig/include/asterisk/agi.h	2005-11-29 19:24:39.000000000 +0100
+++ asterisk-bristuff/include/asterisk/agi.h	2007-10-20 00:35:48.000000000 +0200
@@ -29,7 +29,8 @@
 
 typedef struct agi_state {
 	int fd;		/* FD for general output */
-	int audio;	/* FD for audio output */
+	int audio_out;	/* FD for audio output */
+	int audio_in;	/* FD for audio output */
 	int ctrl;	/* FD for input control */
 } AGI;
 
Index: asterisk-bristuff/include/asterisk/channel.h
===================================================================
--- asterisk-bristuff.orig/include/asterisk/channel.h	2006-11-07 19:22:01.000000000 +0100
+++ asterisk-bristuff/include/asterisk/channel.h	2007-10-20 00:35:48.000000000 +0200
@@ -86,6 +86,9 @@
 #ifndef _ASTERISK_CHANNEL_H
 #define _ASTERISK_CHANNEL_H
 
+/* Max length of the uniqueid */
+#define AST_MAX_UNIQUEID 64
+
 #include <unistd.h>
 #include <setjmp.h>
 #ifdef POLLCOMPAT 
@@ -207,7 +210,7 @@
 	int (* const write)(struct ast_channel *chan, struct ast_frame *frame);
 
 	/*! Display or transmit text */
-	int (* const send_text)(struct ast_channel *chan, const char *text);
+	int (* const send_text)(struct ast_channel *chan, const char *dest, const char *text, int ispdu);
 
 	/*! Display or send an image */
 	int (* const send_image)(struct ast_channel *chan, struct ast_frame *frame);
@@ -381,7 +384,7 @@
 	unsigned int fout;
 
 	/* Unique Channel Identifier */
-	char uniqueid[32];
+	char uniqueid[AST_MAX_UNIQUEID];
 
 	/* Why is the channel hanged up */
 	int hangupcause;
@@ -398,6 +401,12 @@
 	/*! ISDN Transfer Capbility - AST_FLAG_DIGITAL is not enough */
 	unsigned short transfercapability;
 
+	/*! ISDN Low Layer Compatibility */
+	char lowlayercompat[16];
+
+	/*! ISDN High Layer Compatibility */
+	char highlayercompat[4];
+
 	struct ast_frame *readq;
 	int alertpipe[2];
 	/*! Write translation path */
@@ -535,6 +544,11 @@
 #define AST_STATE_MUTE		(1 << 16)	
 /*! @} */
 
+extern ast_mutex_t uniquelock;			
+
+/*! \brief Change the state of a channel and the callerid of the calling channel*/
+int ast_setstate_and_cid(struct ast_channel *chan, int state, char *cid_num, char *cid_name);
+
 /*! \brief Change the state of a channel */
 int ast_setstate(struct ast_channel *chan, int state);
 
@@ -571,7 +585,7 @@
  * by the low level module
  * \return Returns an ast_channel on success, NULL on failure.
  */
-struct ast_channel *ast_request(const char *type, int format, void *data, int *status);
+struct ast_channel *ast_request(const char *type, int format, void *data, int *status, char *uniqueid);
 
 /*!
  * \brief Request a channel of a given type, with data as optional information used 
@@ -586,9 +600,19 @@
  * \return Returns an ast_channel on success or no answer, NULL on failure.  Check the value of chan->_state
  * to know if the call was answered or not.
  */
-struct ast_channel *ast_request_and_dial(const char *type, int format, void *data, int timeout, int *reason, const char *cidnum, const char *cidname);
+struct ast_channel *ast_request_and_dial(const char *type, int format, void *data, int timeout, int *reason, int callingpres, const char *cidnum, const char *cidname, char *uniqueid);
+
+struct ast_channel *__ast_request_and_dial(const char *type, int format, void *data, int timeout, int *reason, int callingpres, const char *cidnum, const char *cidname, struct outgoing_helper *oh, char *uniqueid);
 
-struct ast_channel *__ast_request_and_dial(const char *type, int format, void *data, int timeout, int *reason, const char *cidnum, const char *cidname, struct outgoing_helper *oh);
+/*! \brief "Requests" a channel for sending a message
+ * \param type type of channel to request
+ * \param data data to pass to the channel requester
+ * \param status status
+ * Request a channel of a given type, with data as optional information used 
+ * by the low level module
+ * \return Returns 0 on success, -1 on failure.
+ */
+int ast_send_message(const char *type, void *data, char *to, char *from, char *message, int ispdu);
 
 /*!\brief Register a channel technology (a new channel driver)
  * Called by a channel module to register the kind of channels it supports.
@@ -787,11 +811,13 @@
 /*! Sends text to a channel */
 /*! 
  * \param chan channel to act upon
+ * \param dest destination number/user
  * \param text string of text to send on the channel
+ * \param ispdu message is in PDU format
  * Write text to a display on a channel
  * Returns 0 on success, -1 on failure
  */
-int ast_sendtext(struct ast_channel *chan, const char *text);
+int ast_sendtext(struct ast_channel *chan, const char *dest, const char *text, int ispdu);
 
 /*! Receives a text character from a channel */
 /*! 
@@ -841,6 +867,10 @@
 /*--- ast_get_channel_by_exten_locked: Get channel by exten (and optionally context) and lock it */
 struct ast_channel *ast_get_channel_by_exten_locked(const char *exten, const char *context);
 
+/*! Get channel by uniqueid (locks channel) */
+struct ast_channel *ast_get_channel_by_uniqueid_locked(const char *uniqueid);
+ 
+
 /*! Waits for a digit */
 /*! 
  * \param c channel to wait for a digit on
@@ -911,6 +941,9 @@
    p->owner pointer) that is affected by the change.  The physical layer of the original
    channel is hung up.  */
 int ast_channel_masquerade(struct ast_channel *original, struct ast_channel *clone);
+int ast_channel_masquerade_locked(struct ast_channel *original, struct ast_channel *clone);
+ 
+char *ast_alloc_uniqueid(void);
 
 /*! Gives the string form of a given cause code */
 /*! 
Index: asterisk-bristuff/include/asterisk/devicestate.h
===================================================================
--- asterisk-bristuff.orig/include/asterisk/devicestate.h	2005-11-29 19:24:39.000000000 +0100
+++ asterisk-bristuff/include/asterisk/devicestate.h	2007-10-20 00:35:48.000000000 +0200
@@ -42,7 +42,7 @@
 /*! Device is ringing */
 #define AST_DEVICE_RINGING	6
 
-typedef int (*ast_devstate_cb_type)(const char *dev, int state, void *data);
+typedef int (*ast_devstate_cb_type)(const char *dev, int state, void *data, char *cid_num, char *cid_name);
 
 /*! \brief Convert device state to text string for output 
  * \param devstate Current device state 
@@ -84,7 +84,7 @@
  * callbacks for the changed extensions
  * Returns 0 on success, -1 on failure
  */
-int ast_device_state_changed_literal(const char *device);
+int ast_device_state_changed_literal(const char *device, const char *cid_num, const char *cid_name);
 
 /*! \brief Registers a device state change callback 
  * \param callback Callback
Index: asterisk-bristuff/include/asterisk/features.h
===================================================================
--- asterisk-bristuff.orig/include/asterisk/features.h	2005-11-29 19:24:39.000000000 +0100
+++ asterisk-bristuff/include/asterisk/features.h	2007-10-20 00:35:48.000000000 +0200
@@ -45,6 +45,8 @@
 };
 
 
+extern int ast_autoanswer_login(struct ast_channel *chan, void *data);
+extern int ast_masq_autoanswer_login(struct ast_channel *rchan, void *data);
 
 /*! \brief Park a call and read back parked location 
  *  \param chan the channel to actually be parked
@@ -68,11 +70,19 @@
 */
 extern int ast_masq_park_call(struct ast_channel *rchan, struct ast_channel *host, int timeout, int *extout);
 
+extern int ast_hold_call(struct ast_channel *chan, struct ast_channel *host);
+extern int ast_masq_hold_call(struct ast_channel *rchan, struct ast_channel *host);
+extern int ast_retrieve_call(struct ast_channel *chan, char *uniqueid);
+extern int ast_retrieve_call_to_death(char *uniqueid);
+extern struct ast_channel *ast_get_holded_call(char *uniqueid);
+
 /*! \brief Determine system parking extension
  *  Returns the call parking extension for drivers that provide special
     call parking help */
 extern char *ast_parking_ext(void);
 
+extern char *ast_parking_con(void);
+
 /*! \brief Determine system call pickup extension */
 extern char *ast_pickup_ext(void);
 
@@ -92,4 +102,12 @@
     \param feature the ast_call_feature object which was registered before*/
 extern void ast_unregister_feature(struct ast_call_feature *feature);
 
+/*! \brief find a  feature by name
+    \param name of the feature to be returned */
+extern struct ast_call_feature *ast_find_feature(char *name);
+
+/*! \brief find a builtin feature by name
+    \param name of the feature to be returned */
+extern struct ast_call_feature *ast_find_builtin_feature(char *name);
+
 #endif /* _AST_FEATURES_H */
Index: asterisk-bristuff/include/asterisk/manager.h
===================================================================
--- asterisk-bristuff.orig/include/asterisk/manager.h	2006-02-11 19:15:00.000000000 +0100
+++ asterisk-bristuff/include/asterisk/manager.h	2007-10-20 00:35:48.000000000 +0200
@@ -54,6 +54,7 @@
 #define EVENT_FLAG_COMMAND		(1 << 4) /* Ability to read/set commands */
 #define EVENT_FLAG_AGENT		(1 << 5) /* Ability to read/set agent info */
 #define EVENT_FLAG_USER                 (1 << 6) /* Ability to read/set user info */
+#define EVENT_FLAG_EXTENSIONSTATUS	(1 << 7) /* ExtensionStatus events */
 
 /* Export manager structures */
 #define AST_MAX_MANHEADERS 80
Index: asterisk-bristuff/include/asterisk/monitor.h
===================================================================
--- asterisk-bristuff.orig/include/asterisk/monitor.h	2005-11-29 19:24:39.000000000 +0100
+++ asterisk-bristuff/include/asterisk/monitor.h	2007-10-20 00:35:48.000000000 +0200
@@ -35,6 +35,8 @@
 	char write_filename[FILENAME_MAX];
 	char filename_base[FILENAME_MAX];
 	int filename_changed;
+	char target_url[FILENAME_MAX];
+	char target_script[FILENAME_MAX];
 	char *format;
 	int joinfiles;
 	int (*stop)(struct ast_channel *chan, int need_lock);
@@ -42,7 +44,7 @@
 
 /* Start monitoring a channel */
 int ast_monitor_start(struct ast_channel *chan, const char *format_spec,
-		      const char *fname_base, int need_lock );
+		      const char *fname_base, const char *target_url, const char *target_script, int need_lock );
 
 /* Stop monitoring a channel */
 int ast_monitor_stop(struct ast_channel *chan, int need_lock);
Index: asterisk-bristuff/include/asterisk/pbx.h
===================================================================
--- asterisk-bristuff.orig/include/asterisk/pbx.h	2006-03-29 21:11:18.000000000 +0200
+++ asterisk-bristuff/include/asterisk/pbx.h	2007-10-20 00:35:48.000000000 +0200
@@ -57,7 +57,7 @@
 	AST_EXTENSION_BUSY = 1 << 1,
 	/*! All devices UNAVAILABLE/UNREGISTERED */
 	AST_EXTENSION_UNAVAILABLE = 1 << 2,
-	/*! All devices RINGING */
+	/*! One or more devices RINGING */
 	AST_EXTENSION_RINGING = 1 << 3,
 };
 
@@ -80,7 +80,7 @@
 struct ast_ignorepat;
 struct ast_sw;
 
-typedef int (*ast_state_cb_type)(char *context, char* id, enum ast_extension_states state, void *data);
+typedef int (*ast_state_cb_type)(char *context, char* id, enum ast_extension_states state, void *data, char *cid_num, char *cid_name);
 
 /*! Data structure associated with a custom function */
 struct ast_custom_function {
@@ -156,6 +156,8 @@
  */
 extern struct ast_app *pbx_findapp(const char *app);
 
+void *ast_pbx_run_app(void *data);
+
 /*! executes an application */
 /*!
  * \param c channel to execute on
@@ -563,11 +565,11 @@
 
 /* Synchronously or asynchronously make an outbound call and send it to a
    particular extension */
-int ast_pbx_outgoing_exten(const char *type, int format, void *data, int timeout, const char *context, const char *exten, int priority, int *reason, int sync, const char *cid_num, const char *cid_name, struct ast_variable *vars, const char *account, struct ast_channel **locked_channel);
+int ast_pbx_outgoing_exten(const char *type, int format, void *data, int timeout, const char *context, const char *exten, int priority, int *reason, int sync, int callingpres, const char *cid_num, const char *cid_name, struct ast_variable *vars, const char *account, struct ast_channel **locked_channel, char *uniqueid);
 
 /* Synchronously or asynchronously make an outbound call and send it to a
    particular application with given extension */
-int ast_pbx_outgoing_app(const char *type, int format, void *data, int timeout, const char *app, const char *appdata, int *reason, int sync, const char *cid_num, const char *cid_name, struct ast_variable *vars, const char *account, struct ast_channel **locked_channel);
+int ast_pbx_outgoing_app(const char *type, int format, void *data, int timeout, const char *app, const char *appdata, int *reason, int sync, int callingpres, const char *cid_num, const char *cid_name, struct ast_variable *vars, const char *account, struct ast_channel **locked_channel, char *uniqueid);
 
 /* Evaluate a condition for non-falseness and return a boolean */
 int pbx_checkcondition(char *condition);
@@ -659,7 +661,7 @@
  */
 void ast_func_write(struct ast_channel *chan, const char *in, const char *value);
 
-void ast_hint_state_changed(const char *device);
+void ast_hint_state_changed(const char *device, char *cid_num, char *cid_name);
 
 #if defined(__cplusplus) || defined(c_plusplus)
 }
Index: asterisk-bristuff/include/asterisk.h
===================================================================
--- asterisk-bristuff.orig/include/asterisk.h	2007-10-20 00:35:42.000000000 +0200
+++ asterisk-bristuff/include/asterisk.h	2007-10-20 00:35:48.000000000 +0200
@@ -39,6 +39,7 @@
 extern char ast_config_AST_PID[AST_CONFIG_MAX_PATH];
 extern char ast_config_AST_SOCKET[AST_CONFIG_MAX_PATH];
 extern char ast_config_AST_RUN_DIR[AST_CONFIG_MAX_PATH];
+extern char ast_config_AST_SYMBOLIC_NAME[20];
 extern char ast_config_AST_CTL_PERMISSIONS[AST_CONFIG_MAX_PATH];
 extern char ast_config_AST_CTL_OWNER[AST_CONFIG_MAX_PATH];
 extern char ast_config_AST_CTL_GROUP[AST_CONFIG_MAX_PATH];
Index: asterisk-bristuff/LICENSE
===================================================================
--- asterisk-bristuff.orig/LICENSE	2006-10-17 19:22:01.000000000 +0200
+++ asterisk-bristuff/LICENSE	2007-10-20 00:35:48.000000000 +0200
@@ -1,7 +1,7 @@
-Asterisk is distributed under the GNU General Public License version 2
-and is also available under alternative licenses negotiated directly
-with Digium, Inc. If you obtained Asterisk under the GPL, then the GPL
-applies to all loadable Asterisk modules used on your system as well,
+BRIstuffed Asterisk is distributed under the GNU General Public License version 2
+and is not available under any alternative licenses.
+If you obtained BRIstuffed Asterisk under the GPL, then the GPL
+applies to all loadable BRIstuffed Asterisk modules used on your system as well,
 except as defined below. The GPL (version 2) is included in this
 source tree in the file COPYING.
 
Index: asterisk-bristuff/Makefile
===================================================================
--- asterisk-bristuff.orig/Makefile	2007-10-20 00:35:42.000000000 +0200
+++ asterisk-bristuff/Makefile	2007-10-20 00:35:48.000000000 +0200
@@ -780,6 +780,9 @@
 		echo ";astctlowner = root" ; \
 		echo ";astctlgroup = apache" ; \
 		echo ";astctl = asterisk.ctl" ; \
+		echo "[options]" ; \
+		echo "uniquename = `hostname`" ;\
+		echo "silence_suppression = yes" ;\
 		) > $(DESTDIR)$(ASTCONFPATH) ; \
 	else \
 		echo "Skipping asterisk.conf creation"; \
Index: asterisk-bristuff/manager.c
===================================================================
--- asterisk-bristuff.orig/manager.c	2007-06-24 19:32:21.000000000 +0200
+++ asterisk-bristuff/manager.c	2007-10-20 00:35:48.000000000 +0200
@@ -11,6 +11,9 @@
  * the project provides a web site, mailing lists and IRC
  * channels for your use.
  *
+ * Copyright (C) 2003-2004, Junghanns.NET Gmbh
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
  * This program is free software, distributed under the terms of
  * the GNU General Public License Version 2. See the LICENSE file
  * at the top of the source tree.
@@ -62,6 +65,7 @@
 #include "asterisk/md5.h"
 #include "asterisk/acl.h"
 #include "asterisk/utils.h"
+#include "asterisk/astdb.h"
 
 struct fast_originate_helper {
 	char tech[AST_MAX_MANHEADER_LEN];
@@ -76,6 +80,8 @@
 	char idtext[AST_MAX_MANHEADER_LEN];
 	char account[AST_MAX_ACCOUNT_CODE];
 	int priority;
+	int callingpres;
+	char uniqueid[64];
 	struct ast_variable *vars;
 };
 
@@ -99,6 +105,7 @@
 	{ EVENT_FLAG_COMMAND, "command" },
 	{ EVENT_FLAG_AGENT, "agent" },
 	{ EVENT_FLAG_USER, "user" },
+	{ EVENT_FLAG_EXTENSIONSTATUS, "extensionstatus" },
 	{ -1, "all" },
 	{ 0, "none" },
 };
@@ -658,11 +665,17 @@
 {
 	struct ast_channel *c = NULL;
 	char *name = astman_get_header(m, "Channel");
-	if (ast_strlen_zero(name)) {
-		astman_send_error(s, m, "No channel specified");
+	char *uniqueid = astman_get_header(m, "Uniqueid");
+	if (ast_strlen_zero(name) && ast_strlen_zero(uniqueid)) {
+		astman_send_error(s, m, "No channel or uniqueid specified");
 		return 0;
 	}
-	c = ast_get_channel_by_name_locked(name);
+	if (!ast_strlen_zero(uniqueid)) {
+		c = ast_get_channel_by_uniqueid_locked(uniqueid);
+	} else {
+	    if (!ast_strlen_zero(name))
+		c = ast_get_channel_by_name_locked(name);
+	}	
 	if (!c) {
 		astman_send_error(s, m, "No such channel");
 		return 0;
@@ -673,6 +686,49 @@
 	return 0;
 }
 
+static char mandescr_message[] = 
+"Description: Send a message\n"
+"Variables: \n"
+"	Channel: The destination channel(e.g. SIP/phone1)\n"
+"	From:	 \n"
+"	Message: The message to send\n";
+
+static int action_message(struct mansession *s, struct message *m)
+{
+	char *name = astman_get_header(m, "Channel");
+	char *from = astman_get_header(m, "From");
+	char *message = astman_get_header(m, "Message");
+	char *pdu = astman_get_header(m, "PDU");
+	char tmp[256];
+	char *tech, *data;
+	int res;
+	if (ast_strlen_zero(name) || (ast_strlen_zero(message) && ast_strlen_zero(pdu))) {
+		astman_send_error(s, m, "No channel or message/PDU specified");
+		return 0;
+	}
+	ast_copy_string(tmp, name, sizeof(tmp));
+	tech = tmp;
+	data = strchr(tmp, '/');
+	if (!data) {
+		astman_send_error(s, m, "Invalid channel\n");
+		return 0;
+	}
+	*data = '\0';
+	data++;
+	if (ast_strlen_zero(pdu)) {
+	    res = ast_send_message(tech, data, name, from, message, 0);
+	} else {
+	    res = ast_send_message(tech, data, name, from, pdu, 1);
+	}
+	
+	if (res) {
+		astman_send_error(s, m, "Error sending message");
+		return 0;
+	}
+	astman_send_ack(s, m, "Message sent");
+	return 0;
+}
+
 static char mandescr_setvar[] = 
 "Description: Set a global or local channel variable.\n"
 "Variables: (Names marked with * are required)\n"
@@ -756,6 +812,7 @@
 }
 
 
+
 /*! \brief  action_status: Manager "status" command to show channels */
 /* Needs documentation... */
 static int action_status(struct mansession *s, struct message *m)
@@ -862,19 +919,29 @@
 	char *exten = astman_get_header(m, "Exten");
 	char *context = astman_get_header(m, "Context");
 	char *priority = astman_get_header(m, "Priority");
+ 	char *uniqueid = astman_get_header(m, "Uniqueid");
+ 	char *uniqueid2 = astman_get_header(m, "ExtraUniqueid");
+	char *exten2 = astman_get_header(m, "ExtraExten");
+	char *context2 = astman_get_header(m, "ExtraContext");
+	char *priority2 = astman_get_header(m, "ExtraPriority");
 	struct ast_channel *chan, *chan2 = NULL;
 	int pi = 0;
+	int pi2 = 0;
 	int res;
 
-	if (ast_strlen_zero(name)) {
-		astman_send_error(s, m, "Channel not specified");
+ 	if ((!name || ast_strlen_zero(name)) && (!uniqueid || ast_strlen_zero(uniqueid))) {
+ 		astman_send_error(s, m, "Channel or Uniqueid not specified");
 		return 0;
 	}
 	if (!ast_strlen_zero(priority) && (sscanf(priority, "%d", &pi) != 1)) {
 		astman_send_error(s, m, "Invalid priority\n");
 		return 0;
 	}
-	chan = ast_get_channel_by_name_locked(name);
+ 	if (uniqueid && (!ast_strlen_zero(uniqueid))) {
+ 	    chan = ast_get_channel_by_uniqueid_locked(uniqueid);
+ 	} else {
+ 	    chan = ast_get_channel_by_name_locked(name);
+ 	}
 	if (!chan) {
 		char buf[BUFSIZ];
 		snprintf(buf, sizeof(buf), "Channel does not exist: %s", name);
@@ -896,19 +963,27 @@
 	}
 	res = ast_async_goto(chan, context, exten, pi);
 	if (!res) {
-		if (!ast_strlen_zero(name2)) {
-			if (chan2)
-				res = ast_async_goto(chan2, context, exten, pi);
-			else
-				res = -1;
-			if (!res)
-				astman_send_ack(s, m, "Dual Redirect successful");
-			else
-				astman_send_error(s, m, "Secondary redirect failed");
-		} else
+		if (!ast_strlen_zero(uniqueid2)) {
+		    chan2 = ast_get_channel_by_uniqueid_locked(uniqueid2);
+ 		    if (!ast_strlen_zero(priority2) && (sscanf(priority2, "%d", &pi2) != 1)) {
+ 			astman_send_error(s, m, "Invalid priority2\n");
+ 		        return 0;
+ 		    }
+ 		} else if (!ast_strlen_zero(name2)) {
+  			chan2 = ast_get_channel_by_name_locked(name2);
+		} else {
 			astman_send_ack(s, m, "Redirect successful");
-	} else
-		astman_send_error(s, m, "Redirect failed");
+		}
+		if (chan2) {
+		    res = ast_async_goto(chan2, context2, exten2, pi2);
+		    if (!res)
+			astman_send_ack(s, m, "Dual Redirect successful");
+		    else
+			astman_send_error(s, m, "Secondary redirect failed");
+		}
+	} else {
+	    astman_send_error(s, m, "Redirect failed");
+	}
 	if (chan)
 		ast_mutex_unlock(&chan->lock);
 	if (chan2)
@@ -944,15 +1019,15 @@
 	struct ast_channel *chan = NULL;
 
 	if (!ast_strlen_zero(in->app)) {
-		res = ast_pbx_outgoing_app(in->tech, AST_FORMAT_SLINEAR, in->data, in->timeout, in->app, in->appdata, &reason, 1, 
+		res = ast_pbx_outgoing_app(in->tech, AST_FORMAT_SLINEAR, in->data, in->timeout, in->app, in->appdata, &reason, 1, in->callingpres, 
 			!ast_strlen_zero(in->cid_num) ? in->cid_num : NULL, 
 			!ast_strlen_zero(in->cid_name) ? in->cid_name : NULL,
-			in->vars, in->account, &chan);
+			in->vars, in->account, &chan, in->uniqueid);
 	} else {
-		res = ast_pbx_outgoing_exten(in->tech, AST_FORMAT_SLINEAR, in->data, in->timeout, in->context, in->exten, in->priority, &reason, 1, 
+		res = ast_pbx_outgoing_exten(in->tech, AST_FORMAT_SLINEAR, in->data, in->timeout, in->context, in->exten, in->priority, &reason, 1, in->callingpres, 
 			!ast_strlen_zero(in->cid_num) ? in->cid_num : NULL, 
 			!ast_strlen_zero(in->cid_name) ? in->cid_name : NULL,
-			in->vars, in->account, &chan);
+			in->vars, in->account, &chan, in->uniqueid);
 	}   
 	if (!res)
 		manager_event(EVENT_FLAG_CALL,
@@ -963,7 +1038,7 @@
 			"Exten: %s\r\n"
 			"Reason: %d\r\n"
 			"Uniqueid: %s\r\n",
-			in->idtext, in->tech, in->data, in->context, in->exten, reason, chan ? chan->uniqueid : "<null>");
+			in->idtext, in->tech, in->data, in->context, in->exten, reason, in->uniqueid ? in->uniqueid : (chan ? chan->uniqueid : "<null>"));
 	else
 		manager_event(EVENT_FLAG_CALL,
 			"OriginateFailure",
@@ -973,7 +1048,7 @@
 			"Exten: %s\r\n"
 			"Reason: %d\r\n"
 			"Uniqueid: %s\r\n",
-			in->idtext, in->tech, in->data, in->context, in->exten, reason, chan ? chan->uniqueid : "<null>");
+			in->idtext, in->tech, in->data, in->context, in->exten, reason, in->uniqueid ? in->uniqueid : (chan ? chan->uniqueid : "<null>"));
 
 	/* Locked by ast_pbx_outgoing_exten or ast_pbx_outgoing_app */
 	if (chan)
@@ -1006,6 +1081,7 @@
 	char *priority = astman_get_header(m, "Priority");
 	char *timeout = astman_get_header(m, "Timeout");
 	char *callerid = astman_get_header(m, "CallerID");
+ 	char *callingpres = astman_get_header(m, "CallingPres");
 	char *account = astman_get_header(m, "Account");
 	char *app = astman_get_header(m, "Application");
 	char *appdata = astman_get_header(m, "Data");
@@ -1014,12 +1090,15 @@
 	struct ast_variable *vars = astman_get_variables(m);
 	char *tech, *data;
 	char *l=NULL, *n=NULL;
+ 	char *uniqueid;
 	int pi = 0;
+ 	int cpresi = 0;
 	int res;
 	int to = 30000;
 	int reason = 0;
 	char tmp[256];
 	char tmp2[256];
+ 	char idText[256] = "";
 	
 	pthread_t th;
 	pthread_attr_t attr;
@@ -1035,6 +1114,10 @@
 		astman_send_error(s, m, "Invalid timeout\n");
 		return 0;
 	}
+	if (!ast_strlen_zero(callingpres) && (sscanf(callingpres, "%d", &cpresi) != 1)) {
+		astman_send_error(s, m, "Invalid CallingPres\n");
+		return 0;
+	}
 	ast_copy_string(tmp, name, sizeof(tmp));
 	tech = tmp;
 	data = strchr(tmp, '/');
@@ -1055,6 +1138,7 @@
 		if (ast_strlen_zero(l))
 			l = NULL;
 	}
+ 	uniqueid = ast_alloc_uniqueid();
 	if (ast_true(async)) {
 		struct fast_originate_helper *fast = malloc(sizeof(struct fast_originate_helper));
 		if (!fast) {
@@ -1075,8 +1159,10 @@
 			ast_copy_string(fast->context, context, sizeof(fast->context));
 			ast_copy_string(fast->exten, exten, sizeof(fast->exten));
 			ast_copy_string(fast->account, account, sizeof(fast->account));
+			ast_copy_string(fast->uniqueid, uniqueid, sizeof(fast->uniqueid));
 			fast->timeout = to;
 			fast->priority = pi;
+			fast->callingpres = cpresi;
 			pthread_attr_init(&attr);
 			pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
 			if (ast_pthread_create(&th, &attr, fast_originate, fast)) {
@@ -1087,19 +1173,28 @@
 			pthread_attr_destroy(&attr);
 		}
 	} else if (!ast_strlen_zero(app)) {
-        	res = ast_pbx_outgoing_app(tech, AST_FORMAT_SLINEAR, data, to, app, appdata, &reason, 1, l, n, vars, account, NULL);
+     		res = ast_pbx_outgoing_app(tech, AST_FORMAT_SLINEAR, data, to, app, appdata, &reason, 1, cpresi, l, n, vars, account, NULL, uniqueid);
     	} else {
 		if (exten && context && pi)
-	        	res = ast_pbx_outgoing_exten(tech, AST_FORMAT_SLINEAR, data, to, context, exten, pi, &reason, 1, l, n, vars, account, NULL);
+	        	res = ast_pbx_outgoing_exten(tech, AST_FORMAT_SLINEAR, data, to, context, exten, pi, &reason, 1, cpresi, l, n, vars, account, NULL, uniqueid);
 		else {
 			astman_send_error(s, m, "Originate with 'Exten' requires 'Context' and 'Priority'");
 			return 0;
 		}
 	}   
-	if (!res)
-		astman_send_ack(s, m, "Originate successfully queued");
-	else
+ 	if (!res) {
+ 	        if (id && !ast_strlen_zero(id)) {
+       		    snprintf(idText,256,"ActionID: %s\r\n",id);
+  		}
+ 		ast_cli(s->fd, "Response: Success\r\n"
+ 				    "%s"
+ 				   "Message: Originate successfully queued\r\n"
+ 				   "Uniqueid: %s\r\n"
+ 				   "\r\n",
+ 				    idText, uniqueid);
+ 	} else {
 		astman_send_error(s, m, "Originate failed");
+	}
 	return 0;
 }
 
@@ -1573,10 +1668,12 @@
 	return 0;
 }
 
-static int manager_state_cb(char *context, char *exten, int state, void *data)
+static int manager_state_cb(char *context, char *exten, int state, void *data, char *cid_num, char *cid_name)
 {
+	char hint[256] = "";
+	ast_get_hint(hint, sizeof(hint) - 1, NULL, 0, NULL, context, exten);
 	/* Notify managers of change */
-	manager_event(EVENT_FLAG_CALL, "ExtensionStatus", "Exten: %s\r\nContext: %s\r\nStatus: %d\r\n", exten, context, state);
+	manager_event(EVENT_FLAG_EXTENSIONSTATUS, "ExtensionStatus", "Exten: %s\r\nContext: %s\r\nStatus: %d\r\nCallerID: \"%s\" <%s>\r\nHint: %s\r\n", exten, context, state, cid_num, cid_name, hint);
 	return 0;
 }
 
@@ -1661,6 +1758,7 @@
 		ast_manager_register2("Events", 0, action_events, "Control Event Flow", mandescr_events);
 		ast_manager_register2("Logoff", 0, action_logoff, "Logoff Manager", mandescr_logoff);
 		ast_manager_register2("Hangup", EVENT_FLAG_CALL, action_hangup, "Hangup Channel", mandescr_hangup);
+		ast_manager_register2("Message", EVENT_FLAG_CALL, action_message, "Send Message", mandescr_message);
 		ast_manager_register("Status", EVENT_FLAG_CALL, action_status, "Lists channel status" );
 		ast_manager_register2("Setvar", EVENT_FLAG_CALL, action_setvar, "Set Channel Variable", mandescr_setvar );
 		ast_manager_register2("Getvar", EVENT_FLAG_CALL, action_getvar, "Gets a Channel Variable", mandescr_getvar );
Index: asterisk-bristuff/pbx/pbx_spool.c
===================================================================
--- asterisk-bristuff.orig/pbx/pbx_spool.c	2007-07-02 01:51:34.000000000 +0200
+++ asterisk-bristuff/pbx/pbx_spool.c	2007-10-20 00:35:48.000000000 +0200
@@ -77,6 +77,10 @@
 	char app[256];
 	char data[256];
 
+	/* If SMS */
+	char message[256];
+	char pdu[256];
+
 	/* If extension/context/priority */
 	char exten[256];
 	char context[256];
@@ -167,6 +171,10 @@
 					strncpy(o->app, c, sizeof(o->app) - 1);
 				} else if (!strcasecmp(buf, "data")) {
 					strncpy(o->data, c, sizeof(o->data) - 1);
+				} else if (!strcasecmp(buf, "message")) {
+					strncpy(o->message, c, sizeof(o->message) - 1);
+				} else if (!strcasecmp(buf, "pdu")) {
+					strncpy(o->pdu, c, sizeof(o->pdu) - 1);
 				} else if (!strcasecmp(buf, "maxretries")) {
 					if (sscanf(c, "%d", &o->maxretries) != 1) {
 						ast_log(LOG_WARNING, "Invalid max retries at line %d of %s\n", lineno, fn);
@@ -224,8 +232,8 @@
 		}
 	}
 	strncpy(o->fn, fn, sizeof(o->fn) - 1);
-	if (ast_strlen_zero(o->tech) || ast_strlen_zero(o->dest) || (ast_strlen_zero(o->app) && ast_strlen_zero(o->exten))) {
-		ast_log(LOG_WARNING, "At least one of app or extension must be specified, along with tech and dest in file %s\n", fn);
+	if (ast_strlen_zero(o->tech) || ast_strlen_zero(o->dest) || ((ast_strlen_zero(o->app) && ast_strlen_zero(o->exten) && ast_strlen_zero(o->message) && ast_strlen_zero(o->pdu)))) {
+		ast_log(LOG_WARNING, "At least one of app or extension (or keyword message/pdu)must be specified, along with tech and dest in file %s\n", fn);
 		return -1;
 	}
 	return 0;
@@ -259,11 +267,19 @@
 	if (!ast_strlen_zero(o->app)) {
 		if (option_verbose > 2)
 			ast_verbose(VERBOSE_PREFIX_3 "Attempting call on %s/%s for application %s(%s) (Retry %d)\n", o->tech, o->dest, o->app, o->data, o->retries);
-		res = ast_pbx_outgoing_app(o->tech, AST_FORMAT_SLINEAR, o->dest, o->waittime * 1000, o->app, o->data, &reason, 2 /* wait to finish */, o->cid_num, o->cid_name, o->vars, o->account, NULL);
+		res = ast_pbx_outgoing_app(o->tech, AST_FORMAT_SLINEAR, o->dest, o->waittime * 1000, o->app, o->data, &reason, 2 /* wait to finish */, 0, o->cid_num, o->cid_name, o->vars, o->account, NULL, NULL);
+	} else if (!ast_strlen_zero(o->message)) {
+		if (option_verbose > 2)
+			ast_verbose(VERBOSE_PREFIX_3 "Attempting to send message on %s/%s (Retry %d)\n", o->tech, o->dest, o->retries);
+		res = ast_send_message(o->tech, o->dest, o->dest, (ast_strlen_zero(o->cid_name) ? o->cid_num : o->cid_name), o->message, 0);
+	} else if (!ast_strlen_zero(o->pdu)) {
+		if (option_verbose > 2)
+			ast_verbose(VERBOSE_PREFIX_3 "Attempting to send message in PDU format on %s/%s (Retry %d)\n", o->tech, o->dest, o->retries);
+		res = ast_send_message(o->tech, o->dest, o->dest, (ast_strlen_zero(o->cid_name) ? o->cid_num : o->cid_name), o->pdu, 1);
 	} else {
 		if (option_verbose > 2)
 			ast_verbose(VERBOSE_PREFIX_3 "Attempting call on %s/%s for %s@%s:%d (Retry %d)\n", o->tech, o->dest, o->exten, o->context,o->priority, o->retries);
-		res = ast_pbx_outgoing_exten(o->tech, AST_FORMAT_SLINEAR, o->dest, o->waittime * 1000, o->context, o->exten, o->priority, &reason, 2 /* wait to finish */, o->cid_num, o->cid_name, o->vars, o->account, NULL);
+		res = ast_pbx_outgoing_exten(o->tech, AST_FORMAT_SLINEAR, o->dest, o->waittime * 1000, o->context, o->exten, o->priority, &reason, 2 /* wait to finish */, 0, o->cid_num, o->cid_name, o->vars, o->account, NULL, NULL);
 	}
 	if (res) {
 		ast_log(LOG_NOTICE, "Call failed to go through, reason %d\n", reason);
@@ -276,9 +292,14 @@
 			safe_append(o, time(NULL), "EndRetry");
 		}
 	} else {
+	    if (!ast_strlen_zero(o->message)) {
+		if (option_verbose > 2)
+		    ast_verbose(VERBOSE_PREFIX_2 "Message sent to %s/%s\n", o->tech, o->dest);
+	    } else {
 		ast_log(LOG_NOTICE, "Call completed to %s/%s\n", o->tech, o->dest);
 		ast_log(LOG_EVENT, "Queued call to %s/%s completed\n", o->tech, o->dest);
-		unlink(o->fn);
+	    }
+	    unlink(o->fn);
 	}
 	free_outgoing(o);
 	return NULL;
Index: asterisk-bristuff/pbx.c
===================================================================
--- asterisk-bristuff.orig/pbx.c	2007-05-02 22:10:32.000000000 +0200
+++ asterisk-bristuff/pbx.c	2007-10-20 00:35:48.000000000 +0200
@@ -374,7 +374,8 @@
 	
 	{ "Hangup", pbx_builtin_hangup,
 	"Hang up the calling channel",
-	"  Hangup(): This application will hang up the calling channel.\n"
+	"  Hangup(Cause): Unconditionally hangs up a given channel by returning -1 always.\n" 
+	"                 If cause is given, it will set the hangup cause accordingly.\n" 
 	},
 
 	{ "NoOp", pbx_builtin_noop,
@@ -1903,7 +1904,7 @@
 	return ast_extension_state2(e);    		/* Check all devices in the hint */
 }
 
-void ast_hint_state_changed(const char *device)
+void ast_hint_state_changed(const char *device, char *cid_num, char *cid_name)
 {
 	struct ast_hint *hint;
 	struct ast_state_cb *cblist;
@@ -1931,11 +1932,11 @@
 			
 			/* For general callbacks */
 			for (cblist = statecbs; cblist; cblist = cblist->next)
-				cblist->callback(hint->exten->parent->name, hint->exten->exten, state, cblist->data);
+				cblist->callback(hint->exten->parent->name, hint->exten->exten, state, cblist->data, cid_num, cid_name);
 			
 			/* For extension callbacks */
 			for (cblist = hint->callbacks; cblist; cblist = cblist->next)
-				cblist->callback(hint->exten->parent->name, hint->exten->exten, state, cblist->data);
+				cblist->callback(hint->exten->parent->name, hint->exten->exten, state, cblist->data, cid_num, cid_name);
 			
 			hint->laststate = state;
 			break;
@@ -2176,7 +2177,7 @@
 				/* Notify with -1 and remove all callbacks */
 				cbprev = cblist;	    
 				cblist = cblist->next;
-				cbprev->callback(list->exten->parent->name, list->exten->exten, AST_EXTENSION_DEACTIVATED, cbprev->data);
+				cbprev->callback(list->exten->parent->name, list->exten->exten, AST_EXTENSION_DEACTIVATED, cbprev->data, NULL, NULL);
 				free(cbprev);
 	    		}
 	    		list->callbacks = NULL;
@@ -3799,7 +3800,7 @@
 			while (thiscb) {
 				prevcb = thiscb;	    
 				thiscb = thiscb->next;
-				prevcb->callback(this->context, this->exten, AST_EXTENSION_REMOVED, prevcb->data);
+				prevcb->callback(this->context, this->exten, AST_EXTENSION_REMOVED, prevcb->data, NULL, NULL);
 				free(prevcb);
 	    		}
 		} else {
@@ -5004,7 +5005,7 @@
 	return 0;  /* success */
 }
 
-int ast_pbx_outgoing_exten(const char *type, int format, void *data, int timeout, const char *context, const char *exten, int priority, int *reason, int sync, const char *cid_num, const char *cid_name, struct ast_variable *vars, const char *account, struct ast_channel **channel)
+int ast_pbx_outgoing_exten(const char *type, int format, void *data, int timeout, const char *context, const char *exten, int priority, int *reason, int sync, int callingpres, const char *cid_num, const char *cid_name, struct ast_variable *vars, const char *account, struct ast_channel **channel, char *uniqueid)
 {
 	struct ast_channel *chan;
 	struct async_stat *as;
@@ -5014,7 +5015,7 @@
 
 	if (sync) {
 		LOAD_OH(oh);
-		chan = __ast_request_and_dial(type, format, data, timeout, reason, cid_num, cid_name, &oh);
+		chan = __ast_request_and_dial(type, format, data, timeout, reason, callingpres, cid_num, cid_name, &oh, uniqueid);
 		if (channel) {
 			*channel = chan;
 			if (chan)
@@ -5116,7 +5117,7 @@
 			goto outgoing_exten_cleanup;
 		}	
 		memset(as, 0, sizeof(struct async_stat));
-		chan = ast_request_and_dial(type, format, data, timeout, reason, cid_num, cid_name);
+		chan = ast_request_and_dial(type, format, data, timeout, reason, callingpres, cid_num, cid_name, uniqueid);
 		if (channel) {
 			*channel = chan;
 			if (chan)
@@ -5164,7 +5165,7 @@
 	pthread_t t;
 };
 
-static void *ast_pbx_run_app(void *data)
+void *ast_pbx_run_app(void *data)
 {
 	struct app_tmp *tmp = data;
 	struct ast_app *app;
@@ -5180,7 +5181,7 @@
 	return NULL;
 }
 
-int ast_pbx_outgoing_app(const char *type, int format, void *data, int timeout, const char *app, const char *appdata, int *reason, int sync, const char *cid_num, const char *cid_name, struct ast_variable *vars, const char *account, struct ast_channel **locked_channel)
+int ast_pbx_outgoing_app(const char *type, int format, void *data, int timeout, const char *app, const char *appdata, int *reason, int sync, int callingpres, const char *cid_num, const char *cid_name, struct ast_variable *vars, const char *account, struct ast_channel **locked_channel, char *uniqueid)
 {
 	struct ast_channel *chan;
 	struct async_stat *as;
@@ -5200,7 +5201,7 @@
 		goto outgoing_app_cleanup;	
 	}
 	if (sync) {
-		chan = __ast_request_and_dial(type, format, data, timeout, reason, cid_num, cid_name, &oh);
+		chan = __ast_request_and_dial(type, format, data, timeout, reason, callingpres, cid_num, cid_name, &oh, uniqueid);
 		if (chan) {
 			if (chan->cdr) { /* check if the channel already has a cdr record, if not give it one */
 				ast_log(LOG_WARNING, "%s already has a call record??\n", chan->name);
@@ -5288,7 +5289,8 @@
 			goto outgoing_app_cleanup;
 		}
 		memset(as, 0, sizeof(struct async_stat));
-		chan = __ast_request_and_dial(type, format, data, timeout, reason, cid_num, cid_name, &oh);
+		chan = __ast_request_and_dial(type, format, data, timeout, reason, callingpres, cid_num, cid_name, &oh, uniqueid);
+//		chan = ast_request_and_dial(type, format, data, timeout, reason, callingpres, cid_num, cid_name, uniqueid);
 		if (!chan) {
 			free(as);
 			res = -1;
@@ -5579,6 +5581,9 @@
  */
 static int pbx_builtin_hangup(struct ast_channel *chan, void *data)
 {
+        /* Copy the hangup cause as specified */
+        if (data)
+	       chan->hangupcause = atoi(data);
 	/* Just return non-zero and it will hang up */
 	if (!chan->hangupcause)
 		chan->hangupcause = AST_CAUSE_NORMAL_CLEARING;
@@ -6233,6 +6238,9 @@
 			return -1;
 		}
 	}
+	if (chan->_state != AST_STATE_UP) {
+	    ast_answer(chan);
+	}
 	return res = ast_say_number(chan, atoi((char *) tmp), "", chan->language, options);
 }
 
@@ -6240,8 +6248,12 @@
 {
 	int res = 0;
 
-	if (data)
+	if (data) {
+		if (chan->_state != AST_STATE_UP) {
+		    ast_answer(chan);
+		}
 		res = ast_say_digit_str(chan, (char *)data, "", chan->language);
+	}
 	return res;
 }
 	
@@ -6249,8 +6261,12 @@
 {
 	int res = 0;
 
-	if (data)
+	if (data) {
+		if (chan->_state != AST_STATE_UP) {
+		    ast_answer(chan);
+		}
 		res = ast_say_character_str(chan, (char *)data, "", chan->language);
+	}
 	return res;
 }
 	
@@ -6258,8 +6274,12 @@
 {
 	int res = 0;
 
-	if (data)
+	if (data) {
+		if (chan->_state != AST_STATE_UP) {
+		    ast_answer(chan);
+		}
 		res = ast_say_phonetic_str(chan, (char *)data, "", chan->language);
+	}
 	return res;
 }
 	
Index: asterisk-bristuff/README
===================================================================
--- asterisk-bristuff.orig/README	2006-03-03 09:12:33.000000000 +0100
+++ asterisk-bristuff/README	2007-10-20 00:35:48.000000000 +0200
@@ -4,6 +4,8 @@
 
 Copyright (C) 2001-2005 Digium, Inc.
 and other copyright holders.
+Copyright (C) 2002-2005 Junghanns.NET GmbH 
+and other copyright holders.
 ================================================================
 
 * SECURITY
Index: asterisk-bristuff/res/Makefile
===================================================================
--- asterisk-bristuff.orig/res/Makefile	2005-11-29 19:24:39.000000000 +0100
+++ asterisk-bristuff/res/Makefile	2007-10-20 00:35:48.000000000 +0200
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
-MODS=res_indications.so res_monitor.so res_adsi.so res_agi.so res_features.so
+MODS=res_indications.so res_monitor.so res_adsi.so res_agi.so res_features.so res_esel.so
 
 ifneq ($(wildcard $(CROSS_COMPILE_TARGET)/usr/include/odbcinst.h)$(wildcard $(CROSS_COMPILE_TARGET)/usr/local/include/odbcinst.h),)
   ifneq (${OSARCH},FreeBSD)
Index: asterisk-bristuff/res/res_agi.c
===================================================================
--- asterisk-bristuff.orig/res/res_agi.c	2007-07-30 20:40:54.000000000 +0200
+++ asterisk-bristuff/res/res_agi.c	2007-10-20 00:35:48.000000000 +0200
@@ -11,6 +11,9 @@
  * the project provides a web site, mailing lists and IRC
  * channels for your use.
  *
+ * Copyright (C) 2005 Junghanns.NET GmbH
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
  * This program is free software, distributed under the terms of
  * the GNU General Public License Version 2. See the LICENSE file
  * at the top of the source tree.
@@ -74,16 +77,19 @@
 
 static char *app = "AGI";
 
+static char *xapp = "XAGI";
+
 static char *eapp = "EAGI";
 
 static char *deadapp = "DeadAGI";
 
 static char *synopsis = "Executes an AGI compliant application";
+static char *xsynopsis = "Executes an XAGI compliant application";
 static char *esynopsis = "Executes an EAGI compliant application";
 static char *deadsynopsis = "Executes AGI on a hungup channel";
 
 static char *descrip =
-"  [E|Dead]AGI(command|args): Executes an Asterisk Gateway Interface compliant\n"
+"  [E|Dead|X]AGI(command|args): Executes an Asterisk Gateway Interface compliant\n"
 "program on a channel. AGI allows Asterisk to launch external programs\n"
 "written in any language to control a telephony channel, play audio,\n"
 "read DTMF digits, etc. by communicating with the AGI protocol on stdin\n"
@@ -92,6 +98,8 @@
 " hangup, or 0 on non-hangup exit. \n"
 "Using 'EAGI' provides enhanced AGI, with incoming audio available out of band\n"
 "on file descriptor 3\n\n"
+"Using 'XAGI' provides enhanced AGI, with incoming audio available out of band"
+" on file descriptor 3 and outgoing audio available out of band on file descriptor 4\n\n"
 "Use the CLI command 'show agi' to list available agi commands\n";
 
 static int agidebug = 0;
@@ -225,13 +233,14 @@
 	return 0;
 }
 
-static int launch_script(char *script, char *argv[], int *fds, int *efd, int *opid)
+static int launch_script(char *script, char *argv[], int *fds, int *efd, int *efd2, int *opid)
 {
 	char tmp[256];
 	int pid;
 	int toast[2];
 	int fromast[2];
 	int audio[2];
+	int audio2[2];
 	int x;
 	int res;
 	sigset_t signal_set, old_set;
@@ -280,6 +289,33 @@
 	/* Block SIGHUP during the fork - prevents a race */
 	sigfillset(&signal_set);
 	pthread_sigmask(SIG_BLOCK, &signal_set, &old_set);
+	if (efd2) {
+		if (pipe(audio2)) {
+			ast_log(LOG_WARNING, "unable to create audio pipe: %s\n", strerror(errno));
+			close(fromast[0]);
+			close(fromast[1]);
+			close(toast[0]);
+			close(toast[1]);
+			close(audio[0]);
+			close(audio[1]);
+			return -1;
+		}
+		res = fcntl(audio2[0], F_GETFL);
+		if (res > -1) 
+			res = fcntl(audio2[0], F_SETFL, res | O_NONBLOCK);
+		if (res < 0) {
+			ast_log(LOG_WARNING, "unable to set audio pipe parameters: %s\n", strerror(errno));
+			close(fromast[0]);
+			close(fromast[1]);
+			close(toast[0]);
+			close(toast[1]);
+			close(audio[0]);
+			close(audio[1]);
+			close(audio2[0]);
+			close(audio2[1]);
+			return -1;
+		}
+	}
 	pid = fork();
 	if (pid < 0) {
 		ast_log(LOG_WARNING, "Failed to fork(): %s\n", strerror(errno));
@@ -307,6 +343,12 @@
 		signal(SIGPIPE, SIG_DFL);
 		signal(SIGXFSZ, SIG_DFL);
 
+		if (efd2) {
+			dup2(audio2[1], STDERR_FILENO + 2);
+ 		} else {
+			close(STDERR_FILENO + 2);
+		}
+
 		/* unblock important signal handlers */
 		if (pthread_sigmask(SIG_UNBLOCK, &signal_set, NULL)) {
 			ast_log(LOG_WARNING, "unable to unblock signals for AGI script: %s\n", strerror(errno));
@@ -314,7 +356,7 @@
 		}
 
 		/* Close everything but stdin/out/error */
-		for (x=STDERR_FILENO + 2;x<1024;x++) 
+		for (x=STDERR_FILENO + 3;x<1024;x++) 
 			close(x);
 
 		/* Execute script */
@@ -331,6 +373,9 @@
 	if (efd) {
 		*efd = audio[1];
 	}
+	if (efd2) {
+		*efd2 = audio2[0];
+	}
 	/* close what we're not using in the parent */
 	close(toast[1]);
 	close(fromast[0]);
@@ -339,6 +384,9 @@
 		/* [PHM 12/18/03] */
 		close(audio[0]);
 	}
+	if (efd2) {
+		close(audio2[1]);
+	}
 
 	*opid = pid;
 	return 0;
@@ -369,7 +417,7 @@
 	fdprintf(fd, "agi_context: %s\n", chan->context);
 	fdprintf(fd, "agi_extension: %s\n", chan->exten);
 	fdprintf(fd, "agi_priority: %d\n", chan->priority);
-	fdprintf(fd, "agi_enhanced: %s\n", enhanced ? "1.0" : "0.0");
+	fdprintf(fd, "agi_enhanced: %d%s\n", enhanced, ".0");
 
 	/* User information */
 	fdprintf(fd, "agi_accountcode: %s\n", chan->accountcode ? chan->accountcode : "");
@@ -401,7 +449,7 @@
 		return RESULT_SHOWUSAGE;
 	if (sscanf(argv[3], "%d", &to) != 1)
 		return RESULT_SHOWUSAGE;
-	res = ast_waitfordigit_full(chan, to, agi->audio, agi->ctrl);
+	res = ast_waitfordigit_full(chan, to, agi->audio_out, agi->ctrl);
 	fdprintf(agi->fd, "200 result=%d\n", res);
 	if (res >= 0)
 		return RESULT_SUCCESS;
@@ -421,7 +469,7 @@
 	   would probably be to strip off the trailing newline before
 	   parsing, then here, add a newline at the end of the string
 	   before sending it to ast_sendtext --DUDE */
-	res = ast_sendtext(chan, argv[2]);
+	res = ast_sendtext(chan, NULL, argv[2], 0);
 	fdprintf(agi->fd, "200 result=%d\n", res);
 	if (res >= 0)
 		return RESULT_SUCCESS;
@@ -570,7 +618,7 @@
 	ast_seekstream(fs, sample_offset, SEEK_SET);
 	res = ast_applystream(chan, fs);
 	ast_playstream(fs);
-	res = ast_waitstream_full(chan, argv[3], agi->audio, agi->ctrl);
+	res = ast_waitstream_full(chan, argv[3], agi->audio_out, agi->ctrl);
 	/* this is to check for if ast_waitstream closed the stream, we probably are at
 	 * the end of the stream, return that amount, else check for the amount */
 	sample_offset = (chan->stream) ? ast_tellstream(fs) : max_length;
@@ -623,7 +671,7 @@
         ast_seekstream(fs, sample_offset, SEEK_SET);
         res = ast_applystream(chan, fs);
         ast_playstream(fs);
-        res = ast_waitstream_full(chan, argv[3], agi->audio, agi->ctrl);
+        res = ast_waitstream_full(chan, argv[3], agi->audio_out, agi->ctrl);
         /* this is to check for if ast_waitstream closed the stream, we probably are at
          * the end of the stream, return that amount, else check for the amount */
         sample_offset = (chan->stream)?ast_tellstream(fs):max_length;
@@ -635,7 +683,7 @@
 
 	/* If the user didnt press a key, wait for digitTimeout*/
 	if (res == 0 ) {
-		res = ast_waitfordigit_full(chan, timeout, agi->audio, agi->ctrl);
+		res = ast_waitfordigit_full(chan, timeout, agi->audio_out, agi->ctrl);
 		/* Make sure the new result is in the escape digits of the GET OPTION */
 		if ( !strchr(edigits,res) )
                 	res=0;
@@ -662,7 +710,7 @@
 		return RESULT_SHOWUSAGE;
 	if (sscanf(argv[2], "%d", &num) != 1)
 		return RESULT_SHOWUSAGE;
-	res = ast_say_number_full(chan, num, argv[3], chan->language, (char *) NULL, agi->audio, agi->ctrl);
+	res = ast_say_number_full(chan, num, argv[3], chan->language, (char *) NULL, agi->audio_out, agi->ctrl);
 	if (res == 1)
 		return RESULT_SUCCESS;
 	fdprintf(agi->fd, "200 result=%d\n", res);
@@ -682,7 +730,7 @@
 	if (sscanf(argv[2], "%d", &num) != 1)
 		return RESULT_SHOWUSAGE;
 
-	res = ast_say_digit_str_full(chan, argv[2], argv[3], chan->language, agi->audio, agi->ctrl);
+	res = ast_say_digit_str_full(chan, argv[2], argv[3], chan->language, agi->audio_out, agi->ctrl);
 	if (res == 1) /* New command */
 		return RESULT_SUCCESS;
 	fdprintf(agi->fd, "200 result=%d\n", res);
@@ -699,7 +747,7 @@
 	if (argc != 4)
 		return RESULT_SHOWUSAGE;
 
-	res = ast_say_character_str_full(chan, argv[2], argv[3], chan->language, agi->audio, agi->ctrl);
+	res = ast_say_character_str_full(chan, argv[2], argv[3], chan->language, agi->audio_out, agi->ctrl);
 	if (res == 1) /* New command */
 		return RESULT_SUCCESS;
 	fdprintf(agi->fd, "200 result=%d\n", res);
@@ -789,7 +837,7 @@
 	if (argc != 4)
 		return RESULT_SHOWUSAGE;
 
-	res = ast_say_phonetic_str_full(chan, argv[2], argv[3], chan->language, agi->audio, agi->ctrl);
+	res = ast_say_phonetic_str_full(chan, argv[2], argv[3], chan->language, agi->audio_out, agi->ctrl);
 	if (res == 1) /* New command */
 		return RESULT_SUCCESS;
 	fdprintf(agi->fd, "200 result=%d\n", res);
@@ -816,7 +864,7 @@
 		max = atoi(argv[4]); 
 	else
 		max = 1024;
-	res = ast_app_getdata_full(chan, argv[2], data, max, timeout, agi->audio, agi->ctrl);
+	res = ast_app_getdata_full(chan, argv[2], data, max, timeout, agi->audio_out, agi->ctrl);
 	if (res == 2)			/* New command */
 		return RESULT_SUCCESS;
 	else if (res == 1)
@@ -1855,7 +1903,12 @@
 	int ms;
 	int returnstatus = 0;
 	struct ast_frame *f;
+	struct ast_frame fr;
 	char buf[2048];
+	char audiobuf[2048];
+	int audiobytes;
+	int fds[2];
+	int enhanced = 0;
 	FILE *readf;
 	/* how many times we'll retry if ast_waitfor_nandfs will return without either 
 	  channel or file descriptor in case select is interrupted by a system call (EINTR) */
@@ -1869,10 +1922,22 @@
 		return -1;
 	}
 	setlinebuf(readf);
-	setup_env(chan, request, agi->fd, (agi->audio > -1));
+	if (agi->audio_out > -1) {
+	    enhanced = 1;
+	}
+	if (agi->audio_in > -1) {
+	    enhanced++;
+	}
+	setup_env(chan, request, agi->fd, enhanced);
+	fds[0] = agi->ctrl;
+	fds[1] = agi->audio_in;
 	for (;;) {
 		ms = -1;
-		c = ast_waitfor_nandfds(&chan, dead ? 0 : 1, &agi->ctrl, 1, NULL, &outfd, &ms);
+		if (agi->audio_in > -1) {
+		    c = ast_waitfor_nandfds(&chan, dead ? 0 : 1, fds, 2, NULL, &outfd, &ms);
+		} else {
+		    c = ast_waitfor_nandfds(&chan, dead ? 0 : 1, &agi->ctrl, 1, NULL, &outfd, &ms);
+		}
 		if (c) {
 			retry = RETRY;
 			/* Idle the channel until we get a command */
@@ -1883,13 +1948,24 @@
 				break;
 			} else {
 				/* If it's voice, write it to the audio pipe */
-				if ((agi->audio > -1) && (f->frametype == AST_FRAME_VOICE)) {
+				if ((agi->audio_out > -1) && (f->frametype == AST_FRAME_VOICE)) {
 					/* Write, ignoring errors */
-					write(agi->audio, f->data, f->datalen);
+					write(agi->audio_out, f->data, f->datalen);
 				}
 				ast_frfree(f);
 			}
 		} else if (outfd > -1) {
+		    if ((agi->audio_in > -1) && (outfd == agi->audio_in)) {
+			audiobytes = read(agi->audio_in, audiobuf, sizeof(audiobuf));
+			if (audiobytes > 0) {
+			//    ast_log(LOG_NOTICE, "read %d bytes of audio\n", audiobytes);
+			    fr.frametype = AST_FRAME_VOICE;
+			    fr.subclass = AST_FORMAT_SLINEAR;
+			    fr.datalen = audiobytes;
+			    fr.data = audiobuf;
+			    ast_write(chan, &fr);
+			}
+		    } else {
 			retry = RETRY;
 			if (!fgets(buf, sizeof(buf), readf)) {
 				/* Program terminated */
@@ -1911,6 +1987,7 @@
 			if ((returnstatus < 0) || (returnstatus == AST_PBX_KEEPALIVE)) {
 				break;
 			}
+		    }
 		} else {
 			if (--retry <= 0) {
 				ast_log(LOG_WARNING, "No channel, no fd?\n");
@@ -2017,6 +2094,7 @@
 	int argc = 0;
 	int fds[2];
 	int efd = -1;
+	int efd2 = -1;
 	int pid;
         char *stringp;
 	AGI agi;
@@ -2042,16 +2120,19 @@
 		}
 	}
 #endif
-	res = launch_script(argv[0], argv, fds, enhanced ? &efd : NULL, &pid);
+	res = launch_script(argv[0], argv, fds, enhanced ? &efd : NULL, (enhanced == 2) ? &efd2 : NULL, &pid);
 	if (!res) {
 		agi.fd = fds[1];
 		agi.ctrl = fds[0];
-		agi.audio = efd;
+		agi.audio_out = efd;
+		agi.audio_in = efd2;
 		res = run_agi(chan, argv[0], &agi, pid, dead);
 		if (fds[1] != fds[0])
 			close(fds[1]);
 		if (efd > -1)
 			close(efd);
+		if (efd2 > -1)
+			close(efd2);
 	}
 	LOCAL_USER_REMOVE(u);
 	return res;
@@ -2085,6 +2166,35 @@
 	return res;
 }
 
+static int xagi_exec(struct ast_channel *chan, void *data)
+{
+	int readformat, writeformat;
+	int res;
+
+	if (chan->_softhangup)
+		ast_log(LOG_WARNING, "If you want to run AGI on hungup channels you should use DeadAGI!\n");
+	readformat = chan->readformat;
+	if (ast_set_read_format(chan, AST_FORMAT_SLINEAR)) {
+		ast_log(LOG_WARNING, "Unable to set channel '%s' to linear mode\n", chan->name);
+		return -1;
+	}
+	writeformat = chan->writeformat;
+	if (ast_set_write_format(chan, AST_FORMAT_SLINEAR)) {
+		ast_log(LOG_WARNING, "Unable to set channel '%s' to linear mode\n", chan->name);
+		return -1;
+	}
+	res = agi_exec_full(chan, data, 2, 0);
+	if (!res) {
+		if (ast_set_read_format(chan, readformat)) {
+			ast_log(LOG_WARNING, "Unable to restore channel '%s' to format %s\n", chan->name, ast_getformatname(readformat));
+		}
+		if (ast_set_write_format(chan, writeformat)) {
+			ast_log(LOG_WARNING, "Unable to restore channel '%s' to format %s\n", chan->name, ast_getformatname(writeformat));
+		}
+	}
+	return res;
+}
+
 static int deadagi_exec(struct ast_channel *chan, void *data)
 {
 	return agi_exec_full(chan, data, 0, 1);
@@ -2114,6 +2224,7 @@
 	ast_cli_unregister(&dumpagihtml);
 	ast_cli_unregister(&cli_debug);
 	ast_cli_unregister(&cli_no_debug);
+	ast_unregister_application(xapp);
 	ast_unregister_application(eapp);
 	ast_unregister_application(deadapp);
 	return ast_unregister_application(app);
@@ -2127,6 +2238,7 @@
 	ast_cli_register(&cli_no_debug);
 	ast_register_application(deadapp, deadagi_exec, deadsynopsis, descrip);
 	ast_register_application(eapp, eagi_exec, esynopsis, descrip);
+	ast_register_application(xapp, xagi_exec, xsynopsis, descrip);
 	return ast_register_application(app, agi_exec, synopsis, descrip);
 }
 
Index: asterisk-bristuff/res/res_esel.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ asterisk-bristuff/res/res_esel.c	2007-10-20 00:35:48.000000000 +0200
@@ -0,0 +1,399 @@
+/*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Extension State Export Logic (E.S.E.L) (Sorry, i couldnt resist...)
+ *
+ * Resource to export extension states to other Asterisk servers
+ *
+ * Copyright (C) 2006, Junghanns.NET GmbH
+ *
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#include <stdlib.h>
+#include <errno.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <sys/time.h>
+#include <sys/signal.h>
+#include <netinet/in.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <pthread.h>
+
+#include <asterisk/lock.h>
+#include <asterisk/file.h>
+#include <asterisk/logger.h>
+#include <asterisk/channel.h>
+#include <asterisk/pbx.h>
+#include <asterisk/options.h>
+#include <asterisk/module.h>
+#include <asterisk/translate.h>
+#include <asterisk/say.h>
+#include <asterisk/features.h>
+#include <asterisk/musiconhold.h>
+#include <asterisk/config.h>
+#include <asterisk/cli.h>
+#include <asterisk/manager.h>
+#include <asterisk/utils.h>
+#include <asterisk/adsi.h>
+
+static struct esel_pvt *donkeys = NULL;
+AST_MUTEX_DEFINE_STATIC(listlock);
+
+STANDARD_LOCAL_USER;
+
+LOCAL_USER_DECL;
+
+typedef struct esel_extension_state {
+    char context[AST_MAX_EXTENSION];
+    char exten[AST_MAX_EXTENSION];
+    int state;
+    char cid_num[AST_MAX_EXTENSION];
+    char cid_name[AST_MAX_EXTENSION];
+    char devstate[AST_MAX_EXTENSION];
+    struct esel_extension_state *next;
+    struct esel_extension_state *prev;
+} esel_extension_state;
+
+typedef struct esel_export {
+    char context[AST_MAX_EXTENSION];
+    char exten[AST_MAX_EXTENSION];
+    char devstate[AST_MAX_EXTENSION];
+    struct esel_export *next;
+} esel_export;
+
+typedef struct esel_queue {
+	struct esel_extension_state *head;
+	struct esel_extension_state *tail;
+	int count;
+	ast_cond_t cond;
+	ast_mutex_t lock;
+}  esel_queue;
+
+typedef struct esel_pvt {
+    char name[80];
+    char username[80];
+    char secret[80];
+    char host[80];
+    int port;
+    struct sockaddr_in raddr;
+    int sockfd;
+    int connected;
+    pthread_t esel_thread;
+
+    /* list of extensions to export */
+    struct esel_export *extensions;
+
+    /* queue */
+    struct esel_queue queue;
+    
+    struct esel_pvt *next;
+} esel_pvt;
+
+static int esel_queue_extension_state(struct esel_queue *queue, char *context, char *exten, int state, void *data, char *cid_num, char *cid_name) {
+	struct esel_extension_state *exstate = NULL;
+
+	exstate = malloc(sizeof(struct esel_extension_state));
+	if (!exstate) {
+	    ast_log(LOG_ERROR, "Unable to malloc!\n");
+	    return 1;
+	}
+	memset(exstate,0,sizeof(struct esel_extension_state));
+	exstate->next = NULL;
+	exstate->prev = NULL;
+
+	ast_mutex_lock(&queue->lock);
+	if (queue->count > 100) {
+	    ast_mutex_unlock(&queue->lock);
+	    free(exstate);
+	    if (option_verbose > 5)
+		ast_log(LOG_WARNING, "E.S.E.L Queue too long.\n");
+	    return -1;
+	}
+	ast_copy_string(exstate->exten, exten, sizeof(exstate->exten));
+	ast_copy_string(exstate->context, context, sizeof(exstate->context));
+	ast_copy_string(exstate->cid_num, cid_num, sizeof(exstate->cid_num));
+	ast_copy_string(exstate->cid_name, cid_name, sizeof(exstate->cid_name));
+	exstate->state = state;
+	if (!queue->head) {
+		/* Empty queue */
+		queue->head = exstate;
+		queue->tail = exstate;
+	} else {
+		/* Double link */
+		queue->tail->next = exstate;
+		exstate->prev = queue->tail;
+		queue->tail = exstate;
+	}
+	queue->count++;
+	ast_cond_signal(&queue->cond);
+	ast_mutex_unlock(&queue->lock);
+	return 0;
+}
+
+static int esel_is_exported(struct esel_export *extensions, struct esel_extension_state *exstate) {
+    struct esel_export *export = NULL;
+    export = extensions;
+    while (export) {
+	if ((!strcasecmp(export->exten, exstate->exten)) && (!strcasecmp(export->context, exstate->context))) {
+	    /* copy mapping */
+	    ast_copy_string(exstate->devstate, export->devstate, sizeof(exstate->devstate));
+	    return 1;
+	}
+	export = export->next;
+    }
+    return 0;
+}
+
+static int esel_state2devstate(int state) {
+    switch(state) {
+	case 1:
+	    return 2;
+	case 8:
+	    return 6;
+	default:
+	    return state;
+    }
+}
+
+static void esel_export_to_remote(struct esel_extension_state *exstate, struct esel_pvt *esel) {
+    char msg[1024];
+    int sent = 0;
+    memset(msg, 0x0, sizeof(msg));
+    snprintf(msg, sizeof(msg) - 1, "Action: Devstate\r\nDevstate: %s\r\nValue: %d\r\nCallerID: %s\r\nCallerIDName: %s\r\n\r\n", exstate->devstate, esel_state2devstate(exstate->state), exstate->cid_num, exstate->cid_name);
+    sent = send(esel->sockfd, msg, strlen(msg), 0);
+    if (sent == -1) {
+	esel->connected = 0;
+    }
+//    ast_log(LOG_NOTICE, "%s", msg);
+}
+
+static void *do_esel_thread(void *data) {
+    struct esel_pvt *esel = (struct esel_pvt *)data;
+    struct esel_queue *queue = &esel->queue;
+    struct esel_extension_state *exstate = NULL;
+    char msg[1024];
+    char buf[1024];
+    int numbytes = 0;
+    int sent = 0;
+    int res = 0;
+    for (;;) {
+	if (esel->connected) {
+	    ast_mutex_lock(&queue->lock);
+	    if (queue->count == 0) 
+		ast_cond_wait(&queue->cond, &queue->lock);
+	    exstate = queue->head;
+	    if (exstate) {
+		if (exstate->next) {
+		    queue->head = exstate->next;
+		} else {
+		    queue->head = NULL;
+		    queue->tail = NULL;
+		}
+		queue->count--;
+	    } else {
+		ast_log(LOG_ERROR, "I SHOULD NEVER HAPPEN! EXPECT SOME MAJOR KABOOM! DUCK AND COVER!\n");
+	    }
+	    ast_mutex_unlock(&queue->lock);
+	    
+	    if (exstate) {
+	        if (esel_is_exported(esel->extensions, exstate)) {
+		    esel_export_to_remote(exstate, esel);
+		}
+		free(exstate);
+		exstate = NULL;
+	    }	    
+	} else {
+	    if (esel->sockfd > 0)
+		close(esel->sockfd);
+	    if ((esel->sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
+		ast_log(LOG_ERROR, "unable to request socket!\n");
+		return NULL;
+	    }
+	    /* try to connect */
+	    res = connect(esel->sockfd, (struct sockaddr *)&esel->raddr, sizeof(struct sockaddr));
+	    if (res) {
+		ast_log(LOG_NOTICE, "error connecting to %s:%d\n", esel->host, esel->port);
+	    } else {
+		while (strncasecmp(buf, "Asterisk Call Manager:", 21)) {
+		    if ((numbytes=recv(esel->sockfd, buf, sizeof(buf), 0)) == -1) {
+			esel->connected = 0;
+			continue;
+		    }
+		    buf[numbytes] = '\0';
+		//    ast_log(LOG_NOTICE, "read: %s", buf);
+		}
+		/* log into remote manager */
+		memset(msg, 0x0, sizeof(msg));
+		snprintf(msg, sizeof(msg) - 1, "Action: Login\r\nUsername: %s\r\nSecret: %s\r\n\r\n", esel->username, esel->secret);
+		sent = send(esel->sockfd, msg, strlen(msg), 0);
+	
+		while (strncasecmp(buf, "Response:", 9)) {
+		    if ((numbytes=recv(esel->sockfd, buf, sizeof(buf), 0)) == -1) {
+			continue;
+		    }
+		    buf[numbytes] = '\0';
+		//    ast_log(LOG_NOTICE, "read: %s", buf);
+		}
+	
+		if (!strncasecmp(buf, "Response: Success", 17)) {
+		    esel->connected = 1;
+		} else {
+		    ast_log(LOG_ERROR, "error login into remote asterisk %s\n", esel->name);
+		}
+	    }
+	    /* time heals everything... */
+	    sleep(10);
+  	}
+    }
+    return NULL;
+}
+
+static int esel_state_cb(char *context, char *exten, int state, void *data, char *cid_num, char *cid_name) {
+	struct esel_pvt *esel;
+
+	esel = donkeys;
+        ast_mutex_lock(&listlock);
+	while (esel) {
+	    esel_queue_extension_state(&esel->queue, context, exten, state, data, cid_num, cid_name);
+	    esel = esel->next;
+	}
+        ast_mutex_unlock(&listlock);
+	return 0;
+}
+
+
+int load_module(void)
+{
+	int res = 0;
+	char *cat, *host, *port, *username, *secret, *name;
+	struct ast_config *cfg;
+	struct ast_variable *var;
+	struct esel_pvt *esel = NULL;
+	struct esel_export *export = NULL;
+	struct hostent *he;
+	struct ast_hostent h;
+
+	cfg = ast_config_load("esel.conf");
+	if (cfg) {
+	    cat = ast_category_browse(cfg, NULL);
+	    while(cat) {
+		name = cat;
+		host = ast_variable_retrieve(cfg, cat, "host");
+		username = ast_variable_retrieve(cfg, cat, "username");
+		secret = ast_variable_retrieve(cfg, cat, "secret");
+		port = ast_variable_retrieve(cfg, cat, "port");
+
+		if (name && host && username && secret && port) {
+		    esel = malloc(sizeof(struct esel_pvt));
+		    if (!esel) {
+			ast_log(LOG_ERROR, "unable to malloc!\n");
+			return -1;
+		    }
+		    memset(esel, 0x0, sizeof(struct esel_pvt));
+		    ast_copy_string(esel->name, name, sizeof(esel->name));
+		    ast_copy_string(esel->host, host, sizeof(esel->host));
+		    ast_copy_string(esel->username, username, sizeof(esel->username));
+		    ast_copy_string(esel->secret, secret, sizeof(esel->secret));
+		    
+		    esel->port = atoi(port);
+		    if ((he=ast_gethostbyname(host, &h)) == NULL) {
+			ast_log(LOG_ERROR, "unknown host!\n");
+			return -1;
+		    }
+
+		    esel->raddr.sin_family = AF_INET;
+		    esel->raddr.sin_port = htons(esel->port);
+		    esel->raddr.sin_addr = *((struct in_addr *)he->h_addr);
+		    bzero(&(esel->raddr.sin_zero), 8);  
+		    
+		    esel->connected = 0;
+
+		    ast_mutex_init(&esel->queue.lock);
+		    ast_cond_init(&esel->queue.cond, NULL);
+
+
+		    /* read exports */
+		    var = ast_variable_browse(cfg, cat);
+		    while (var) {
+			if (!strcasecmp(var->name, "export")) {
+			    char *extenp = NULL, *contextp = NULL, *devstatep = NULL;
+			    extenp = var->value;
+			    devstatep = strchr(var->value, ',') + 1;
+			    contextp = strchr(var->value, '@') + 1;
+			    if (devstatep && contextp) {
+				export = malloc(sizeof(struct esel_export));
+				if (!export) {
+				    ast_log(LOG_ERROR, "unable to malloc!\n");
+				    return -1;
+				}
+				memset(export, 0x0, sizeof(struct esel_export));
+		    		ast_copy_string(export->exten, extenp, contextp - extenp);
+		    		ast_copy_string(export->context, contextp, devstatep - contextp);
+		    		ast_copy_string(export->devstate, devstatep, sizeof(export->devstate));
+				if (option_verbose > 2)
+				    ast_verbose(VERBOSE_PREFIX_3 "exporting %s @ %s as %s to %s\n", export->exten, export->context , export->devstate , esel->name);		    
+				export->next = esel->extensions;
+				esel->extensions = export;
+				export = NULL;
+			    }
+			}
+			var = var->next;
+		    }
+
+
+
+		    esel->next = donkeys;
+		    donkeys = esel;
+
+		    ast_pthread_create(&esel->esel_thread, NULL, do_esel_thread, esel);
+
+		}
+		cat = ast_category_browse(cfg, cat);
+	    }
+    	    ast_config_destroy(cfg);
+	}
+	ast_extension_state_add(NULL, NULL, esel_state_cb, NULL);
+	return res;
+}
+
+
+int unload_module(void)
+{
+	struct esel_pvt *esel, *eseln;
+	STANDARD_HANGUP_LOCALUSERS;
+	esel = donkeys;
+        ast_mutex_lock(&listlock);
+	while (esel) {
+	    pthread_cancel(esel->esel_thread);
+	    pthread_join(esel->esel_thread, NULL);
+	    ast_mutex_destroy(&esel->queue.lock);
+	    close(esel->sockfd);
+	    eseln = esel->next;
+	    free(esel);
+	    esel = eseln;
+	}
+        ast_mutex_unlock(&listlock);
+	return 0;
+}
+
+char *description(void)
+{
+	return "Extension State Export Logic (E.S.E.L.) Resource";
+}
+
+int usecount(void)
+{
+	return 1;
+}
+
+char *key()
+{
+	return ASTERISK_GPL_KEY;
+}
Index: asterisk-bristuff/res/res_features.c
===================================================================
--- asterisk-bristuff.orig/res/res_features.c	2007-10-20 00:35:42.000000000 +0200
+++ asterisk-bristuff/res/res_features.c	2007-10-20 00:35:48.000000000 +0200
@@ -11,6 +11,10 @@
  * the project provides a web site, mailing lists and IRC
  * channels for your use.
  *
+ * Copyright (C) 2004, Junghanns.NET GmbH
+ *
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
  * This program is free software, distributed under the terms of
  * the GNU General Public License Version 2. See the LICENSE file
  * at the top of the source tree.
@@ -56,6 +60,7 @@
 #include "asterisk/utils.h"
 #include "asterisk/adsi.h"
 #include "asterisk/monitor.h"
+#include "asterisk/indications.h"
 
 #ifdef __AST_DEBUG_MALLOC
 static void FREE(void *ptr)
@@ -73,6 +78,7 @@
 #define AST_MAX_WATCHERS 256
 
 static char *parkedcall = "ParkedCall";
+static char *holdedcall = "HoldedCall";
 
 /* No more than 45 seconds parked before you do something with them */
 static int parkingtime = DEFAULT_PARK_TIME;
@@ -132,6 +138,20 @@
 "into the dialplan, although you should include the 'parkedcalls'\n"
 "context.\n";
 
+static char *autoanswerlogin = "AutoanswerLogin";
+
+static char *synopsis3 = "Log in for autoanswer";
+
+static char *descrip3 = "AutoanswerLogin(exten):"
+"Used to login to the autoanswer application for an extension.\n";
+
+static char *autoanswer = "Autoanswer";
+
+static char *synopsis4 = "Autoanswer a call";
+
+static char *descrip4 = "Autoanswer(exten):"
+"Used to autoanswer a call for an extension.\n";
+
 static struct ast_app *monitor_app=NULL;
 static int monitor_ok=1;
 
@@ -150,12 +170,51 @@
 	struct parkeduser *next;
 };
 
+struct holdeduser {
+	struct ast_channel *chan;
+	struct timeval start;
+	int parkingnum;
+	int cref;
+	int tei;
+	/* Where to go if our parking time expires */
+	char context[AST_MAX_EXTENSION];
+	char exten[AST_MAX_EXTENSION];
+	int priority;
+	int parkingtime;
+	char uniqueid[AST_MAX_UNIQUEID];
+	char uniqueidpeer[AST_MAX_UNIQUEID];
+	struct holdeduser *next;
+};
+
+/* auto answer user */
+struct aauser {
+	struct ast_channel *chan;
+	struct timeval start;
+	/* waiting on this extension/context */
+	char exten[AST_MAX_EXTENSION];
+	char context[AST_MAX_EXTENSION];
+	int priority;
+	int notquiteyet;
+	struct aauser *next;
+};
+
+ 
+static struct aauser *aalot;
+AST_MUTEX_DEFINE_STATIC(autoanswer_lock);
+static pthread_t autoanswer_thread;
+
 static struct parkeduser *parkinglot;
 
+static struct holdeduser *holdlist;
+
 AST_MUTEX_DEFINE_STATIC(parking_lock);
 
+AST_MUTEX_DEFINE_STATIC(holding_lock);
+
 static pthread_t parking_thread;
 
+static pthread_t holding_thread;
+
 STANDARD_LOCAL_USER;
 
 LOCAL_USER_DECL;
@@ -165,6 +224,12 @@
 	return parking_ext;
 }
 
+char *ast_parking_con(void)
+{
+	return parking_con;
+}
+
+
 char *ast_pickup_ext(void)
 {
 	return pickup_ext;
@@ -371,10 +436,11 @@
 		"Timeout: %ld\r\n"
 		"CallerID: %s\r\n"
 		"CallerIDName: %s\r\n"
+		"Uniqueid: %s\r\n\r\n"
 		,pu->parkingnum, pu->chan->name, peer ? peername : ""
 		,(long)pu->start.tv_sec + (long)(pu->parkingtime/1000) - (long)time(NULL)
 		,(pu->chan->cid.cid_num ? pu->chan->cid.cid_num : "<unknown>")
-		,(pu->chan->cid.cid_name ? pu->chan->cid.cid_name : "<unknown>")
+		,(pu->chan->cid.cid_name ? pu->chan->cid.cid_name : "<unknown>"), pu->chan->uniqueid
 		);
 
 	if (peer) {
@@ -427,7 +493,8 @@
 		ast_copy_string(chan->context, rchan->context, sizeof(chan->context));
 		ast_copy_string(chan->exten, rchan->exten, sizeof(chan->exten));
 		chan->priority = rchan->priority;
-
+		/* might be dirty but we want trackable channels */
+		strncpy(chan->uniqueid, rchan->uniqueid, sizeof(chan->uniqueid) - 1);
 		/* Make the masq execute */
 		f = ast_read(chan);
 		if (f)
@@ -919,7 +986,7 @@
 }
 
 /* find a feature by name */
-static struct ast_call_feature *find_feature(char *name)
+struct ast_call_feature *ast_find_feature(char *name)
 {
 	struct ast_call_feature *tmp;
 
@@ -929,10 +996,21 @@
 			break;
 	}
 	AST_LIST_UNLOCK(&feature_list);
-
 	return tmp;
 }
 
+struct ast_call_feature *ast_find_builtin_feature(char *name)
+{
+	int x = 0;
+
+	for (x = 0; x < FEATURES_COUNT; x++) {
+		if (!strcasecmp(name, builtin_features[x].sname)) {
+		    return &builtin_features[x];
+		} 
+	}
+	return NULL;
+}
+
 /* exec an app by feature */
 static int feature_exec_app(struct ast_channel *chan, struct ast_channel *peer, struct ast_bridge_config *config, char *code, int sense)
 {
@@ -1031,7 +1109,7 @@
 			return res;
 		
 		while ((tok = strsep(&tmp, "#")) != NULL) {
-			feature = find_feature(tok);
+			feature = ast_find_feature(tok);
 			
 			if (feature) {
 				/* Feature is up for consideration */
@@ -1084,7 +1162,7 @@
 
 			/* while we have a feature */
 			while (NULL != (tok = strsep(&tmp, "#"))) {
-				if ((feature = find_feature(tok))) {
+				if ((feature = ast_find_feature(tok))) {
 					if (ast_test_flag(feature, AST_FEATURE_FLAG_NEEDSDTMF)) {
 						if (ast_test_flag(feature, AST_FEATURE_FLAG_CALLER))
 							ast_set_flag(config, AST_BRIDGE_DTMF_CHANNEL_0);
@@ -1109,7 +1187,7 @@
 	struct ast_frame *f = NULL;
 	int res = 0, ready = 0;
 	
-	if ((chan = ast_request(type, format, data, &cause))) {
+	if ((chan = ast_request(type, format, data, &cause, NULL))) {
 		ast_set_callerid(chan, cid_num, cid_name, cid_num);
 		ast_channel_inherit_variables(caller, chan);	
 		if (!ast_call(chan, data, timeout)) {
@@ -1564,9 +1642,10 @@
 					"Channel: %s\r\n"
 					"CallerID: %s\r\n"
 					"CallerIDName: %s\r\n"
+					"Uniqueid: %s\r\n\r\n"
 					,pu->parkingnum, pu->chan->name
 					,(pu->chan->cid.cid_num ? pu->chan->cid.cid_num : "<unknown>")
-					,(pu->chan->cid.cid_name ? pu->chan->cid.cid_name : "<unknown>")
+					,(pu->chan->cid.cid_name ? pu->chan->cid.cid_name : "<unknown>"), pu->chan->uniqueid
 					);
 
 				if (option_verbose > 1) 
@@ -1609,9 +1688,10 @@
 								"Channel: %s\r\n"
 								"CallerID: %s\r\n"
 								"CallerIDName: %s\r\n"
+								"Uniqueid: %s\r\n\r\n"
 								,pu->parkingnum, pu->chan->name
 								,(pu->chan->cid.cid_num ? pu->chan->cid.cid_num : "<unknown>")
-								,(pu->chan->cid.cid_name ? pu->chan->cid.cid_name : "<unknown>")
+								,(pu->chan->cid.cid_name ? pu->chan->cid.cid_name : "<unknown>"), pu->chan->uniqueid
 								);
 
 							/* There's a problem, hang them up*/
@@ -1698,6 +1778,282 @@
 	return res;
 }
 
+int ast_hold_call(struct ast_channel *chan, struct ast_channel *peer)
+{
+	/* We put the user in the parking list, then wake up the parking thread to be sure it looks
+	   after these channels too */
+	struct holdeduser *pu;
+	pu = malloc(sizeof(struct holdeduser));
+	if (pu) {
+		memset(pu, 0, sizeof(pu));
+		ast_mutex_lock(&holding_lock);
+		chan->appl = "Holded Call";
+		chan->data = NULL; 
+
+		pu->chan = chan;
+		strncpy(pu->uniqueid, chan->uniqueid, sizeof(pu->uniqueid));
+		strncpy(pu->uniqueidpeer, peer->uniqueid, sizeof(pu->uniqueidpeer));
+		/* Start music on hold */
+		ast_moh_start(pu->chan, NULL);
+		gettimeofday(&pu->start, NULL);
+		pu->next = holdlist;
+		holdlist = pu;
+		ast_mutex_unlock(&holding_lock);
+		/* Wake up the (presumably select()ing) thread */
+		pthread_kill(holding_thread, SIGURG);
+
+		manager_event(EVENT_FLAG_CALL, "HoldedCall",
+                            "Channel1: %s\r\n"
+                            "Channel2: %s\r\n"
+                    	    "Uniqueid1: %s\r\n"
+                    	    "Uniqueid2: %s\r\n"
+                            ,pu->chan->name, peer->name, pu->chan->uniqueid, peer->uniqueid);
+
+	} else {
+		ast_log(LOG_WARNING, "Out of memory\n");
+		return -1;
+	}
+	return 0;
+}
+
+int ast_masq_hold_call(struct ast_channel *rchan, struct ast_channel *peer)
+{
+	struct ast_channel *chan;
+	struct ast_frame *f;
+	/* Make a new, fake channel that we'll use to masquerade in the real one */
+	chan = ast_channel_alloc(0);
+	if (chan) {
+		/* Let us keep track of the channel name */
+		snprintf(chan->name, sizeof (chan->name), "Onhold/%s",rchan->name);
+		/* Make formats okay */
+		chan->readformat = rchan->readformat;
+		chan->writeformat = rchan->writeformat;
+		ast_channel_masquerade(chan, rchan);
+		/* Setup the extensions and such */
+		strncpy(chan->context, rchan->context, sizeof(chan->context) - 1);
+		strncpy(chan->exten, rchan->exten, sizeof(chan->exten) - 1);
+		chan->priority = rchan->priority;
+		/* this might be dirty, but we need to preserve the uniqueid */
+		strncpy(chan->uniqueid, rchan->uniqueid, sizeof(chan->uniqueid) - 1);
+		/* Make the masq execute */
+		f = ast_read(chan);
+		if (f)
+			ast_frfree(f);
+		ast_hold_call(chan, peer);
+		return -1;
+    	} else {
+		ast_log(LOG_WARNING, "Unable to create holded channel\n");
+		return -1;
+	}
+	return 0;
+}
+
+int ast_retrieve_call(struct ast_channel *chan, char *uniqueid)
+{
+	int res=-1, dres=-1;
+	struct ast_channel *peer=NULL;
+	struct ast_bridge_config config;
+
+	peer = ast_get_holded_call(uniqueid);
+
+	/* JK02: it helps to answer the channel if not already up */
+	if (chan->_state != AST_STATE_UP) {
+		ast_answer(chan);
+	}
+
+	if (peer) {
+		ast_mutex_unlock(&peer->lock);
+		ast_moh_stop(peer);
+		res = ast_channel_make_compatible(chan, peer);
+		if (res < 0) {
+			ast_log(LOG_WARNING, "Could not make channels %s and %s compatible for bridge\n", chan->name, peer->name);
+			ast_hangup(peer);
+			return -1;
+		}
+		/* This runs sorta backwards, since we give the incoming channel control, as if it
+		   were the person called. */
+		if (option_verbose > 2) 
+			ast_verbose(VERBOSE_PREFIX_3 "Channel %s connected to holded call %s\n", chan->name, peer->name);
+
+		memset(&config,0,sizeof(struct ast_bridge_config));
+		ast_set_flag(&(config.features_callee), AST_FEATURE_REDIRECT);
+		ast_set_flag(&(config.features_caller), AST_FEATURE_REDIRECT);
+		config.timelimit = 0;
+		config.play_warning = 0;
+		config.warning_freq = 0;
+		config.warning_sound=NULL;
+		res = ast_bridge_call(chan,peer,&config);
+
+		/* Simulate the PBX hanging up */
+		if (res != AST_PBX_NO_HANGUP_PEER)
+			ast_hangup(peer);
+		return res;
+	} else {
+		/* XXX Play a message XXX */
+	  dres = ast_streamfile(chan, "pbx-invalidpark", chan->language);
+	  if (!dres)
+	    dres = ast_waitstream(chan, "");
+	  else {
+	    ast_log(LOG_WARNING, "ast_streamfile of %s failed on %s\n", "pbx-invalidpark", chan->name);
+	    dres = 0;
+	  }
+	}
+	return res;
+}
+
+int ast_retrieve_call_to_death(char *uniqueid)
+{
+	int res=-1;
+	struct ast_channel *peer=NULL;
+
+	peer = ast_get_holded_call(uniqueid);
+
+	if (peer) {
+		res=0;
+		if (option_verbose > 2) 
+			ast_verbose(VERBOSE_PREFIX_3 "Channel %s removed from hold.\n", peer->name);
+		ast_mutex_unlock(&peer->lock);
+		ast_hangup(peer);
+	} else {
+		ast_log(LOG_WARNING, "Could not find channel with uniqueid %s to retrieve.\n", uniqueid);
+	}
+	return res;
+}
+
+struct ast_channel *ast_get_holded_call(char *uniqueid)
+{
+	int res=-1;
+	struct ast_channel *peer=NULL;
+	struct holdeduser *pu, *pl=NULL;
+
+	ast_mutex_lock(&holding_lock);
+	pu = holdlist;
+	while(pu) {
+		if (!strncmp(uniqueid,pu->uniqueid,sizeof(pu->uniqueid))) {
+			if (pl)
+				pl->next = pu->next;
+			else
+				holdlist = pu->next; 
+			break;
+		}
+		pl = pu;
+		pu = pu->next;
+	}
+	ast_mutex_unlock(&holding_lock);
+	if (pu) {
+		peer = ast_get_channel_by_uniqueid_locked(pu->uniqueid);
+		free(pu);
+		if (peer) {
+		    res=0;
+		    if (option_verbose > 2) 
+			ast_verbose(VERBOSE_PREFIX_3 "Channel %s removed from hold.\n", peer->name);
+		    ast_moh_stop(peer);
+		    return peer;
+		} else {
+		    if (option_verbose > 2) 
+			ast_verbose(VERBOSE_PREFIX_3 "Could not find channel with uniqueid %s.\n", uniqueid);
+		    return NULL;
+		}
+	} else {
+		ast_log(LOG_WARNING, "Could not find held channel with uniqueid %s to retrieve.\n", uniqueid);
+	}
+	return NULL;
+}
+
+/* this is our autmagically service thread that keeps channels onhold happy */
+static void *do_holding_thread(void *ignore)
+{
+	int ms, tms, max;
+	struct holdeduser *pu, *pl, *pt = NULL;
+	struct timeval tv;
+	struct ast_frame *f;
+	int x;
+	fd_set rfds, efds;
+	fd_set nrfds, nefds;
+	FD_ZERO(&rfds);
+	FD_ZERO(&efds);
+	for (;;) {
+		ms = -1;
+		max = -1;
+		ast_mutex_lock(&holding_lock);
+		pl = NULL;
+		pu = holdlist;
+		gettimeofday(&tv, NULL);
+		FD_ZERO(&nrfds);
+		FD_ZERO(&nefds);
+		while(pu) {
+			tms = (tv.tv_sec - pu->start.tv_sec) * 1000 + (tv.tv_usec - pu->start.tv_usec) / 1000;
+				for (x=0;x<AST_MAX_FDS;x++) {
+					if ((pu->chan->fds[x] > -1) && (FD_ISSET(pu->chan->fds[x], &rfds) || FD_ISSET(pu->chan->fds[x], &efds))) {
+						if (FD_ISSET(pu->chan->fds[x], &efds))
+							ast_set_flag(pu->chan, AST_FLAG_EXCEPTION);
+						else
+							ast_clear_flag(pu->chan, AST_FLAG_EXCEPTION);
+						pu->chan->fdno = x;
+						/* See if they need servicing */
+						f = ast_read(pu->chan);
+						if (!f || ((f->frametype == AST_FRAME_CONTROL) && (f->subclass ==  AST_CONTROL_HANGUP))) {
+							/* There's a problem, hang them up*/
+							if (option_verbose > 1) 
+								ast_verbose(VERBOSE_PREFIX_2 "%s got tired of being onhold\n", pu->chan->name);
+							ast_hangup(pu->chan);
+							/* find the corresponding channel and hang them up too! */
+							/* but only if it is not bridged yet! */
+							/* And take them out of the parking lot */
+							if (pl) 
+								pl->next = pu->next;
+							else
+								holdlist = pu->next;
+							pt = pu;
+							pu = pu->next;
+							free(pt);
+							break;
+						} else {
+							/* XXX Maybe we could do something with packets, like dial "0" for operator or something XXX */
+							ast_frfree(f);
+							goto std;	/* XXX Ick: jumping into an else statement??? XXX */
+						}
+					}
+				}
+				if (x >= AST_MAX_FDS) {
+std:					for (x=0;x<AST_MAX_FDS;x++) {
+						/* Keep this one for next one */
+						if (pu->chan->fds[x] > -1) {
+							FD_SET(pu->chan->fds[x], &nrfds);
+							FD_SET(pu->chan->fds[x], &nefds);
+							if (pu->chan->fds[x] > max)
+								max = pu->chan->fds[x];
+						}
+					}
+					/* Keep track of our longest wait */
+					if ((tms < ms) || (ms < 0))
+						ms = tms;
+					pl = pu;
+					pu = pu->next;
+				}
+		}
+		ast_mutex_unlock(&holding_lock);
+		rfds = nrfds;
+		efds = nefds;
+		tv.tv_sec = ms / 1000;
+		tv.tv_usec = (ms % 1000) * 1000;
+		/* Wait for something to happen */
+		ast_select(max + 1, &rfds, NULL, &efds, (ms > -1) ? &tv : NULL);
+		pthread_testcancel();
+	}
+	return NULL;	/* Never reached */
+}
+
+static int retrieve_call_exec(struct ast_channel *chan, void *data) {
+	int res=0;
+	struct localuser *u;
+	char *uniqueid = (char *)data;
+	LOCAL_USER_ADD(u);
+	    res = ast_retrieve_call(chan, uniqueid);
+	LOCAL_USER_REMOVE(u);
+	return res;
+}
+
 static int park_exec(struct ast_channel *chan, void *data)
 {
 	int res=0;
@@ -1746,9 +2102,10 @@
 			"From: %s\r\n"
 			"CallerID: %s\r\n"
 			"CallerIDName: %s\r\n"
+			"Uniqueid: %s\r\n\r\n"
 			,pu->parkingnum, pu->chan->name, chan->name
 			,(pu->chan->cid.cid_num ? pu->chan->cid.cid_num : "<unknown>")
-			,(pu->chan->cid.cid_name ? pu->chan->cid.cid_name : "<unknown>")
+			,(pu->chan->cid.cid_name ? pu->chan->cid.cid_name : "<unknown>"), pu->chan->uniqueid
 			);
 
 		free(pu);
@@ -1912,12 +2269,13 @@
 			"Timeout: %ld\r\n"
 			"CallerID: %s\r\n"
 			"CallerIDName: %s\r\n"
+			"Uniqueid: %s\r\n"
 			"%s"
 			"\r\n"
                         ,cur->parkingnum, cur->chan->name
                         ,(long)cur->start.tv_sec + (long)(cur->parkingtime/1000) - (long)time(NULL)
 			,(cur->chan->cid.cid_num ? cur->chan->cid.cid_num : "")
-			,(cur->chan->cid.cid_name ? cur->chan->cid.cid_name : "")
+			,(cur->chan->cid.cid_name ? cur->chan->cid.cid_name : ""), cur->chan->uniqueid
 			,idText);
 
             cur = cur->next;
@@ -1933,6 +2291,416 @@
         return RESULT_SUCCESS;
 }
 
+static int handle_autoanswer(int fd, int argc, char *argv[])
+{
+	struct aauser *cur;
+
+	ast_cli(fd, "%25s %10s %15s \n", "Channel"
+		, "Extension", "Context");
+
+	ast_mutex_lock(&autoanswer_lock);
+
+	cur=aalot;
+	while(cur) {
+		ast_cli(fd, "%25s %10s %15s\n",cur->chan->name, cur->exten, cur->context);
+
+		cur = cur->next;
+	}
+
+	ast_mutex_unlock(&autoanswer_lock);
+
+	return RESULT_SUCCESS;
+}
+static char showautoanswer_help[] =
+"Usage: show autoanswer\n"
+"       Lists currently logged in autoanswr channels.\n";
+
+static struct ast_cli_entry showautoanswer =
+{ { "show", "autoanswer", NULL }, handle_autoanswer, "Lists autoanswer channels", showautoanswer_help };
+
+int ast_masq_autoanswer_login(struct ast_channel *rchan, void *data)
+{
+	struct ast_channel *chan;
+	struct ast_frame *f;
+	/* Make a new, fake channel that we'll use to masquerade in the real one */
+	chan = ast_channel_alloc(0);
+	if (chan) {
+		/* Let us keep track of the channel name */
+		snprintf(chan->name, sizeof (chan->name), "Autoanswer/%s",rchan->name);
+		/* Make formats okay */
+		chan->readformat = rchan->readformat;
+		chan->writeformat = rchan->writeformat;
+		ast_channel_masquerade(chan, rchan);
+		/* Setup the extensions and such */
+		strncpy(chan->context, rchan->context, sizeof(chan->context) - 1);
+		strncpy(chan->exten, rchan->exten, sizeof(chan->exten) - 1);
+		chan->priority = rchan->priority;
+		/* Make the masq execute */
+		f = ast_read(chan);
+		if (f)
+			ast_frfree(f);
+		ast_autoanswer_login(chan, data);
+	} else {
+		ast_log(LOG_WARNING, "Unable to create aa channel\n");
+		return -1;
+	}
+	return 0;
+}
+
+static int autoanswer_login_exec(struct ast_channel *chan, void *data)
+{
+	int res=0;
+	struct localuser *u;
+	LOCAL_USER_ADD(u);
+	if (!data) {
+		ast_log(LOG_WARNING, "AutoanswerLogin requires an argument (extension number)\n");
+		return -1;
+	}
+	res = ast_masq_autoanswer_login(chan, data);
+	LOCAL_USER_REMOVE(u);
+	return res; 
+}
+
+int ast_autoanswer_login(struct ast_channel *chan, void *data)
+{
+	/* We put the user in the parking list, then wake up the parking thread to be sure it looks
+	   after these channels too */
+	struct ast_context *con;
+	char exten[AST_MAX_EXTENSION];
+	struct aauser *pu,*pl = NULL;
+	char *s, *stringp, *aacontext, *aaexten = NULL;
+
+	s = ast_strdupa((void *) data);
+	stringp=s;
+	aacontext = strsep(&stringp, "|");
+	aaexten = strsep(&stringp, "|");
+	if (!aaexten) {
+	    aaexten = aacontext;
+	    aacontext = NULL;
+	}
+	if (!aaexten) {
+		ast_log(LOG_WARNING, "AutoanswerLogin requires at least an extension!\n");
+		return -1;
+	} else {
+		if (!aacontext) {
+			aacontext = "default";
+		}
+	}
+
+	ast_mutex_lock(&autoanswer_lock);
+	pu = aalot;
+	while(pu) {
+		if ((!strncasecmp(pu->exten, aaexten, sizeof(pu->exten)-1)) && (!strncasecmp(pu->context, aacontext, sizeof(pu->context)-1))){
+			if (pl)
+				pl->next = pu->next;
+			else
+				aalot = pu->next;
+			break;
+		}
+		pl = pu;
+		pu = pu->next;
+	}
+	ast_mutex_unlock(&autoanswer_lock);
+	if (pu) {
+	    ast_log(LOG_NOTICE, "Logout old Channel %s for %s@%s.\n",pu->chan->name, pu->exten, pu->context);
+	    manager_event(EVENT_FLAG_CALL, "AutoanswerLogout",
+                    			    "Channel: %s\r\n"
+                    			    "Uniqueid: %s\r\n"
+                    			    "Context: %s\r\n"
+                    			    "Exten: %s\r\n"
+                    			,pu->chan->name, pu->chan->uniqueid, pu->context, pu->exten);
+	    ast_hangup(pu->chan);
+	    free(pu);
+	}
+	pu = malloc(sizeof(struct aauser));
+	if (pu) {
+		memset(pu, 0, sizeof(pu));
+		ast_mutex_lock(&autoanswer_lock);
+		chan->appl = "Autoanswer";
+		chan->data = NULL; 
+
+		pu->chan = chan;
+		if (chan->_state != AST_STATE_UP) {
+		    ast_answer(chan);
+		}
+
+		/* Start music on hold */
+		ast_moh_start(pu->chan, NULL);
+		gettimeofday(&pu->start, NULL);
+		strncpy(pu->exten, aaexten, sizeof(pu->exten)-1);
+		strncpy(pu->context, aacontext, sizeof(pu->exten)-1);
+		pu->next = aalot;
+		aalot = pu;
+		con = ast_context_find(aacontext);
+		if (!con) {
+			con = ast_context_create(NULL,aacontext, registrar);
+			if (!con) {
+				ast_log(LOG_ERROR, "Context '%s' does not exist and unable to create\n", aacontext);
+			}
+		}
+		if (con) {
+			snprintf(exten, sizeof(exten), "%s", aaexten);
+			ast_add_extension2(con, 1, exten, 1, NULL, NULL, autoanswer, strdup((char *)data), free, registrar);
+		}
+
+		ast_mutex_unlock(&autoanswer_lock);
+		/* Wake up the (presumably select()ing) thread */
+		pthread_kill(autoanswer_thread, SIGURG);
+		if (option_verbose > 1) 
+			ast_verbose(VERBOSE_PREFIX_2 "Autoanswer login from %s for %s@%s.\n", pu->chan->name, pu->exten, pu->context);
+			manager_event(EVENT_FLAG_CALL, "AutoanswerLogin",
+                                "Channel: %s\r\n"
+                                "Uniqueid: %s\r\n"
+        			"Context: %s\r\n"
+                    		"Exten: %s\r\n"
+                    		,pu->chan->name, pu->chan->uniqueid, pu->context, pu->exten);
+
+			return 0;
+	} else {
+		ast_log(LOG_WARNING, "Out of memory\n");
+		return -1;
+	}
+	return 0;
+}
+
+static void autoanswer_reregister_extensions(void)
+{
+	struct aauser *cur;
+	struct ast_context *con;
+	char exten[AST_MAX_EXTENSION];
+	char args[AST_MAX_EXTENSION];
+
+	ast_mutex_lock(&autoanswer_lock);
+
+	cur=aalot;
+	while(cur) {
+		con = ast_context_find(cur->context);
+		if (!con) {
+			con = ast_context_create(NULL,cur->context, registrar);
+			if (!con) {
+				ast_log(LOG_ERROR, "Context '%s' does not exist and unable to create\n", cur->context);
+			}
+		}
+		if (con) {
+			snprintf(exten, sizeof(exten), "%s", cur->exten);
+			snprintf(args, sizeof(args), "%s|%s", cur->context, cur->exten);
+			ast_add_extension2(con, 1, exten, 1, NULL, NULL, autoanswer, strdup((char *)args), free, registrar);
+		}
+		cur = cur->next;
+	}
+
+	ast_mutex_unlock(&autoanswer_lock);
+}
+static void *do_autoanswer_thread(void *ignore)
+{
+	int ms, tms, max;
+	struct ast_context *con;
+	char exten[AST_MAX_EXTENSION];
+	struct aauser *pu, *pl, *pt = NULL;
+	struct timeval tv;
+	struct ast_frame *f;
+	int x;
+	fd_set rfds, efds;
+	fd_set nrfds, nefds;
+	FD_ZERO(&rfds);
+	FD_ZERO(&efds);
+	for (;;) {
+		ms = -1;
+		max = -1;
+		ast_mutex_lock(&autoanswer_lock);
+		pl = NULL;
+		pu = aalot;
+		gettimeofday(&tv, NULL);
+		FD_ZERO(&nrfds);
+		FD_ZERO(&nefds);
+		while(pu) {
+			tms = (tv.tv_sec - pu->start.tv_sec) * 1000 + (tv.tv_usec - pu->start.tv_usec) / 1000;
+			for (x=0;x<AST_MAX_FDS;x++) {
+				if ((pu->chan->fds[x] > -1) && (FD_ISSET(pu->chan->fds[x], &rfds) || FD_ISSET(pu->chan->fds[x], &efds))) {
+					if (FD_ISSET(pu->chan->fds[x], &efds))
+						ast_set_flag(pu->chan, AST_FLAG_EXCEPTION);
+					else
+						ast_clear_flag(pu->chan, AST_FLAG_EXCEPTION);
+					pu->chan->fdno = x;
+					/* See if they need servicing */
+					f = ast_read(pu->chan);
+					if (!f || ((f->frametype == AST_FRAME_CONTROL) && (f->subclass ==  AST_CONTROL_HANGUP))) {
+						/* There's a problem, hang them up*/
+						if (option_verbose > 1) 
+							ast_verbose(VERBOSE_PREFIX_2 "%s logged out of autoanswer app\n", pu->chan->name);
+						manager_event(EVENT_FLAG_CALL, "AutoanswerLogout",
+                            			    "Channel: %s\r\n"
+                            			    "Uniqueid: %s\r\n"
+                    				    "Context: %s\r\n"
+                    				    "Exten: %s\r\n"
+                    				,pu->chan->name, pu->chan->uniqueid, pu->context, pu->exten);
+						ast_hangup(pu->chan);
+						con = ast_context_find(pu->context);
+						if (con) {
+						    snprintf(exten, sizeof(exten), "%s", pu->exten);
+						    if (ast_context_remove_extension2(con, exten, 1, registrar))
+							ast_log(LOG_WARNING, "Whoa, failed to remove the extension!\n");
+						} else {
+							ast_log(LOG_WARNING, "Whoa, no %s context?\n", pu->exten);
+						}
+						/* And take them out of the parking lot */
+						if (pl) 
+							pl->next = pu->next;
+						else
+							aalot = pu->next;
+						pt = pu;
+						pu = pu->next;
+						free(pt);
+						break;
+					} else {
+						/* XXX Maybe we could do something with packets, like dial "0" for operator or something XXX */
+						ast_frfree(f);
+						goto std;	/* XXX Ick: jumping into an else statement??? XXX */
+					}
+				}
+			}
+			if (x >= AST_MAX_FDS) {
+std:				for (x=0;x<AST_MAX_FDS;x++) {
+					/* Keep this one for next one */
+					if (pu->chan->fds[x] > -1) {
+						FD_SET(pu->chan->fds[x], &nrfds);
+						FD_SET(pu->chan->fds[x], &nefds);
+						if (pu->chan->fds[x] > max)
+							max = pu->chan->fds[x];
+					}
+				}
+				/* Keep track of our longest wait */
+				if ((tms < ms) || (ms < 0))
+					ms = tms;
+				pl = pu;
+				pu = pu->next;
+			}
+		}
+		ast_mutex_unlock(&autoanswer_lock);
+		rfds = nrfds;
+		efds = nefds;
+		tv.tv_sec = ms / 1000;
+		tv.tv_usec = (ms % 1000) * 1000;
+		/* Wait for something to happen */
+		ast_select(max + 1, &rfds, NULL, &efds, (ms > -1) ? &tv : NULL);
+		pthread_testcancel();
+	}
+	return NULL;	/* Never reached */
+}
+
+static int autoanswer_exec(struct ast_channel *chan, void *data)
+{
+	int res=0;
+	struct localuser *u;
+	struct ast_channel *peer=NULL;
+	struct aauser *pu, *pl=NULL;
+	struct ast_bridge_config config;
+	char *s, *stringp, *aacontext, *aaexten = NULL;
+	char datastring[80];
+
+	if (!data) {
+		ast_log(LOG_WARNING, "Autoanswer requires an argument (extension number)\n");
+		return -1;
+	}
+	s = ast_strdupa((void *) data);
+	stringp=s;
+	aacontext = strsep(&stringp, "|");
+	aaexten = strsep(&stringp, "|");
+	if (!aaexten) {
+	    aaexten = aacontext;
+	    aacontext = NULL;
+	}
+	if (!aaexten) {
+		ast_log(LOG_WARNING, "AutoanswerLogin requires at least an extension!\n");
+		return -1;
+	} else {
+		if (!aacontext) {
+			aacontext = "default";
+		}
+	}
+
+	LOCAL_USER_ADD(u);
+	ast_mutex_lock(&autoanswer_lock);
+	pu = aalot;
+	while(pu) {
+		if ((!strncasecmp(pu->exten, aaexten, sizeof(pu->exten)-1)) && (!strncasecmp(pu->context, aacontext, sizeof(pu->context)-1))){
+			if (pl)
+				pl->next = pu->next;
+			else
+				aalot = pu->next;
+			break;
+		}
+		pl = pu;
+		pu = pu->next;
+	}
+	ast_mutex_unlock(&autoanswer_lock);
+	if (pu) {
+		peer = pu->chan;
+		free(pu);
+		pu = NULL;
+	}
+	/* JK02: it helps to answer the channel if not already up */
+	if (chan->_state != AST_STATE_UP) {
+		ast_answer(chan);
+	}
+
+	if (peer) {
+		ast_moh_stop(peer);
+		/* Play a courtesy beep in the callED channel to prefix the bridge connecting */	
+		if (!ast_strlen_zero(courtesytone)) {
+			if (!ast_streamfile(peer, courtesytone, peer->language)) {
+				if (ast_waitstream(peer, "") < 0) {
+					ast_log(LOG_WARNING, "Failed to play courtesy tone!\n");
+					ast_hangup(peer);
+					return -1;
+				}
+			}
+		}
+ 
+		res = ast_channel_make_compatible(chan, peer);
+		if (res < 0) {
+			ast_log(LOG_WARNING, "Could not make channels %s and %s compatible for bridge\n", chan->name, peer->name);
+			ast_hangup(peer);
+			return -1;
+		}
+		/* This runs sorta backwards, since we give the incoming channel control, as if it
+		   were the person called. */
+		if (option_verbose > 2) 
+			ast_verbose(VERBOSE_PREFIX_3 "Channel %s autoanswered  %s\n", peer->name, chan->name);
+		manager_event(EVENT_FLAG_CALL, "Autoanswer",
+                    "Channel: %s\r\n"
+                    "Uniqueid: %s\r\n"
+                    "Channel2: %s\r\n"
+                    "Uniqueid2: %s\r\n"
+                    "Context: %s\r\n"
+                    "Exten: %s\r\n"
+                ,chan->name, chan->uniqueid, peer->name, peer->uniqueid, aacontext, aaexten);
+
+
+		memset(&config,0,sizeof(struct ast_bridge_config));
+		ast_set_flag(&(config.features_callee), AST_FEATURE_REDIRECT);
+		ast_set_flag(&(config.features_caller), AST_FEATURE_REDIRECT);
+		config.timelimit = 0;
+		config.play_warning = 0;
+		config.warning_freq = 0;
+		config.warning_sound=NULL;
+		res = ast_bridge_call(chan,peer,&config);
+
+		if (option_verbose > 2) 
+			ast_verbose(VERBOSE_PREFIX_3 "returning from bridge %s\n", peer->name);
+			/* relogin */
+		snprintf(datastring, sizeof(datastring) - 1, "%s|%s", aacontext, aaexten);
+		ast_autoanswer_login(peer, datastring);
+		return res;
+	} else {
+		if (option_verbose > 2) 
+			ast_verbose(VERBOSE_PREFIX_3 "Nobody logged in for autoanswer %s@%s\n", aaexten, aacontext);
+		res = -1;
+	}
+	LOCAL_USER_REMOVE(u);
+	return res;
+}
+
 
 int ast_pickup_call(struct ast_channel *chan)
 {
@@ -2088,7 +2856,7 @@
 			}
 
 			{
-				struct ast_call_feature *feature=find_feature(var->name);
+				struct ast_call_feature *feature = ast_find_feature(var->name);
 				int mallocd=0;
 				
 				if (!feature) {
@@ -2151,6 +2919,7 @@
 }
 
 int reload(void) {
+	autoanswer_reregister_extensions();
 	return load_config();
 }
 
@@ -2164,14 +2933,22 @@
 	if ((res = load_config()))
 		return res;
 	ast_cli_register(&showparked);
+	ast_cli_register(&showautoanswer);
 	ast_cli_register(&showfeatures);
 	ast_pthread_create(&parking_thread, NULL, do_parking_thread, NULL);
+	ast_pthread_create(&holding_thread, NULL, do_holding_thread, NULL);
 	res = ast_register_application(parkedcall, park_exec, synopsis, descrip);
 	if (!res)
 		res = ast_register_application(parkcall, park_call_exec, synopsis2, descrip2);
 	if (!res) {
 		ast_manager_register("ParkedCalls", 0, manager_parking_status, "List parked calls" );
 	}
+	res = ast_register_application(holdedcall, retrieve_call_exec, synopsis, descrip);
+	ast_pthread_create(&autoanswer_thread, NULL, do_autoanswer_thread, NULL);
+	if (!res)
+		res = ast_register_application(autoanswerlogin, autoanswer_login_exec, synopsis3, descrip3);
+	if (!res)
+		res = ast_register_application(autoanswer, autoanswer_exec, synopsis4, descrip4);
 	return res;
 }
 
@@ -2182,7 +2959,11 @@
 
 	ast_manager_unregister("ParkedCalls");
 	ast_cli_unregister(&showfeatures);
+ 	ast_cli_unregister(&showautoanswer);
 	ast_cli_unregister(&showparked);
+ 	ast_unregister_application(autoanswer);
+ 	ast_unregister_application(autoanswerlogin);
+ 	ast_unregister_application(holdedcall);
 	ast_unregister_application(parkcall);
 	return ast_unregister_application(parkedcall);
 }
Index: asterisk-bristuff/res/res_monitor.c
===================================================================
--- asterisk-bristuff.orig/res/res_monitor.c	2007-03-21 19:03:20.000000000 +0100
+++ asterisk-bristuff/res/res_monitor.c	2007-10-20 00:35:48.000000000 +0200
@@ -90,7 +90,7 @@
 
 /* Start monitoring a channel */
 int ast_monitor_start(	struct ast_channel *chan, const char *format_spec,
-		const char *fname_base, int need_lock)
+		const char *fname_base, const char *target_url, const char *target_script, int need_lock)
 {
 	int res = 0;
 	char tmp[256];
@@ -122,6 +122,11 @@
 		}
 		memset(monitor, 0, sizeof(struct ast_channel_monitor));
 
+		if (target_url)
+		    ast_copy_string(monitor->target_url, target_url, sizeof(monitor->target_url));
+		if (target_script)
+		    ast_copy_string(monitor->target_script, target_script, sizeof(monitor->target_script));
+
 		/* Determine file names */
 		if (!ast_strlen_zero(fname_base)) {
 			int directory = strchr(fname_base, '/') ? 1 : 0;
@@ -274,6 +279,8 @@
 		if (chan->monitor->joinfiles && !ast_strlen_zero(chan->monitor->filename_base)) {
 			char tmp[1024];
 			char tmp2[1024];
+			char tmp3[1024];
+			int result;
 			const char *format = !strcasecmp(chan->monitor->format,"wav49") ? "WAV" : chan->monitor->format;
 			char *name = chan->monitor->filename_base;
 			int directory = strchr(name, '/') ? 1 : 0;
@@ -296,9 +303,19 @@
 				snprintf(tmp2,sizeof(tmp2), "( %s& rm -f \"%s/%s-\"* ) &",tmp, dir ,name); /* remove legs when done mixing */
 				ast_copy_string(tmp, tmp2, sizeof(tmp));
 			}
-			ast_log(LOG_DEBUG,"monitor executing %s\n",tmp);
-			if (ast_safe_system(tmp) == -1)
+			if (!ast_strlen_zero(chan->monitor->target_script) && !ast_strlen_zero(chan->monitor->target_url)) {
+				snprintf(tmp3,sizeof(tmp3), "( %s& nice -n 19 %s \"%s/%s.%s\" \"%s\" ) &",tmp, chan->monitor->target_script , dir, name, format, chan->monitor->target_url); 
+				ast_copy_string(tmp, tmp3, sizeof(tmp));
+			}
+			ast_log(LOG_NOTICE,"monitor executing %s\n",tmp);
+			result = ast_safe_system(tmp);
+			if (result == -1)
 				ast_log(LOG_WARNING, "Execute of %s failed.\n",tmp);
+			manager_event(EVENT_FLAG_CALL, "MonitorStopped",
+                    			    "Channel: %s\r\n"
+                    			    "Uniqueid: %s\r\n"
+					    "Result: %d\r\n"
+                    			,chan->name, chan->uniqueid, result);
 		}
 		
 		free(chan->monitor->format);
@@ -411,7 +428,7 @@
 		return 0;
 	}
 
-	res = ast_monitor_start(chan, format, fname_base, 1);
+	res = ast_monitor_start(chan, format, fname_base, NULL, NULL, 1);
 	if (res < 0)
 		res = ast_monitor_change_fname(chan, fname_base, 1);
 	ast_monitor_setjoinfiles(chan, joinfiles);
@@ -447,19 +464,30 @@
 {
 	struct ast_channel *c = NULL;
 	char *name = astman_get_header(m, "Channel");
+	char *uniqueid = astman_get_header(m, "Uniqueid");
 	char *fname = astman_get_header(m, "File");
 	char *format = astman_get_header(m, "Format");
 	char *mix = astman_get_header(m, "Mix");
+	char *target_url = astman_get_header(m, "TargetURL");
+	char *target_script = astman_get_header(m, "TargetScript");
 	char *d;
 	
-	if (ast_strlen_zero(name)) {
-		astman_send_error(s, m, "No channel specified");
+	if (ast_strlen_zero(name) && ast_strlen_zero(uniqueid)) {
+		astman_send_error(s, m, "No channel/uniqueid specified");
 		return 0;
 	}
-	c = ast_get_channel_by_name_locked(name);
-	if (!c) {
+	if (!ast_strlen_zero(uniqueid)) {
+	    c = ast_get_channel_by_uniqueid_locked(uniqueid);
+	    if (!c) {
+		astman_send_error(s, m, "No such uniqueid");
+		return 0;
+	    }
+	} else {
+	    c = ast_get_channel_by_name_locked(name);
+	    if (!c) {
 		astman_send_error(s, m, "No such channel");
 		return 0;
+	    }
 	}
 
 	if (ast_strlen_zero(fname)) {
@@ -476,7 +504,7 @@
 		if ((d=strchr(fname, '/'))) *d='-';
 	}
 	
-	if (ast_monitor_start(c, format, fname, 1)) {
+	if (ast_monitor_start(c, format, fname, target_url, target_script, 1)) {
 		if (ast_monitor_change_fname(c, fname, 1)) {
 			astman_send_error(s, m, "Could not start monitoring channel");
 			ast_mutex_unlock(&c->lock);
@@ -502,16 +530,26 @@
 {
 	struct ast_channel *c = NULL;
 	char *name = astman_get_header(m, "Channel");
+	char *uniqueid = astman_get_header(m, "Uniqueid");
 	int res;
-	if (ast_strlen_zero(name)) {
-		astman_send_error(s, m, "No channel specified");
+	if (ast_strlen_zero(name) && ast_strlen_zero(uniqueid)) {
+		astman_send_error(s, m, "No channel/uniqueid specified");
 		return 0;
 	}
-	c = ast_get_channel_by_name_locked(name);
-	if (!c) {
+	if (!ast_strlen_zero(uniqueid)) {
+	    c = ast_get_channel_by_uniqueid_locked(uniqueid);
+	    if (!c) {
+		astman_send_error(s, m, "No such uniqueid");
+		return 0;
+	    }
+	} else {
+	    c = ast_get_channel_by_name_locked(name);
+	    if (!c) {
 		astman_send_error(s, m, "No such channel");
 		return 0;
+	    }
 	}
+
 	res = ast_monitor_stop(c, 1);
 	ast_mutex_unlock(&c->lock);
 	if (res) {
Index: asterisk-bristuff/rtp.c
===================================================================
--- asterisk-bristuff.orig/rtp.c	2007-06-19 19:00:58.000000000 +0200
+++ asterisk-bristuff/rtp.c	2007-10-20 00:35:48.000000000 +0200
@@ -448,6 +448,11 @@
 	struct rtpPayloadType rtpPT;
 	
 	len = sizeof(sin);
+
+	/* XXX SYMPTON CURE, DIRTY FIX, CHECK, BEGIN */
+	if (!rtp)
+	    return &null_frame;
+	/* XXX SYMPTON CURE, DIRTY FIX, CHECK, END */
 	
 	/* Cache where the header will go */
 	res = recvfrom(rtp->s, rtp->rawdata + AST_FRIENDLY_OFFSET, sizeof(rtp->rawdata) - AST_FRIENDLY_OFFSET,
