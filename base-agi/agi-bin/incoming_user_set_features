#!/usr/bin/python
#
# Authors : Sylvain Boily, Guillaume Knispel, Richard Braun
#	   Proformatique
#	   67, rue Voltaire
#	   92800 PUTEAUX
#	   (+33/0)1.41.38.99.60
#	   mailto:technique@proformatique.com
#	   (C) 2007 Proformatique

__version__ = "$Revision$ $Date$"
__license__ = """
    Copyright (C) 2007, Proformatique

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
"""

CONFIG_FILE = '/etc/asterisk/xivo_agi.conf'

import xivo.to_path

import sys
import time
import anysql
import except_tb
import agi_helpers
from BackSQL import backsqlite
from BackSQL import backmysql
import ConfigDict
from agi import *
import agitb

agi = AGI()
agitb.enable(agi)
db_uri = ConfigDict.ReadSingleKey(CONFIG_FILE, 'db', 'db_uri')

def ds_set_fwd_vars(id, lookuptype, status, type_varname, typeval1_varname, typeval2_varname):
	"""Front-end to agi_helpers.set_fwd_vars() that fetches some data from
	the dialstatus table.

	This function is called when fetching the redirection settings from the
	dialstatus table instead of the userfeatures table, which means that
	the user didn't set its own redirection, and a default (set by the
	administrator) is used instead. In this case, an extra variable named
	type_varname + "_FROMDS" is exported to the dial plan.

	"""

	cursor.query("SELECT ${columns} FROM dialstatus WHERE status = %s AND category = %s AND categoryval = %s AND linked = 1",
                     ('type', 'typeval', 'applicationval'),
                     (status, lookuptype, id))
	res = cursor.fetchone()

	if not res:
		type = "endcall"
		typeval = "none"
		applicationval = None
	else:
		type = res['type']
		typeval = res['typeval']
		applicationval = res['applicationval']

	agi.set_variable(type_varname + "_FROMDS", 1)
	agi_helpers.set_fwd_vars(agi, cursor, type, typeval, applicationval, type_varname, typeval1_varname, typeval2_varname)

# Cursors have a weak reference on their connection, so make a strong one.
conn = agi_helpers.db_connect(agi, db_uri)
cursor = conn.cursor()
srcnum = agi.get_variable('REAL_SRCNUM')
dstnum = agi.get_variable('REAL_DSTNUM')
context = agi.get_variable('REAL_CONTEXT')
zone = agi.get_variable('REAL_CALLTYPE')

cursor.query("SELECT ${columns} FROM userfeatures "
             "WHERE number = %s "
             "AND context = %s "
             "AND internal = 0 "
             "AND commented = 0",
             ('id', 'protocol' , 'protocolid', 'name', 'ringseconds', 'simultcalls', 'enablevoicemail', 'enablexfer', 'enableautomon', 'callrecord', 'callfilter', 'enablednd', 'enableunc', 'destunc', 'enablerna', 'destrna', 'enablebusy', 'destbusy', 'musiconhold', 'bsfilter'),
             (dstnum, context))
res = cursor.fetchone()

if not res:
	agi_helpers.dp_break(agi, "Unknown number '%s'" % dstnum)

id = res['id']
protocol = res['protocol']
protocolid = res['protocolid']
name = res['name']
simultcalls = res['simultcalls']
ringseconds = res['ringseconds']
enablednd = res['enablednd']
enablevoicemail = res['enablevoicemail']
enablexfer = res['enablexfer']
enableautomon = res['enableautomon']
callfilter = res['callfilter']
enableunc = res['enableunc']
destunc = res['destunc']
enablebusy = res['enablebusy']
destbusy = res['destbusy']
enablerna = res['enablerna']
destrna = res['destrna']
callrecord = res['callrecord']
musiconhold = res['musiconhold']
bsfilter = res['bsfilter']

# Special case. If a boss-secretary filter is set, the code will prematurely
# exit because the other normally set variables become useless.
if bsfilter == 'boss':
	apply_filter = False

	try:
		filter = agi_helpers.bsfilter(agi, cursor, dstnum, context)
		zone_applies = filter.check_zone(zone)
		secretary_calling = filter.is_secretary(srcnum)

		if zone_applies and not secretary_calling:
			apply_filter = True
	except LookupError:
		pass

	if apply_filter:
		agi.verbose("Filter applies")

		if filter.mode in ("bossfirst-simult", "secretary-simult", "all"):
			if filter.mode in ("bossfirst-simult", "all"):
				agi.set_variable('XIVO_BSFILTER_BOSS_INTERFACE', filter.boss.interface)
				agi.set_variable('XIVO_BSFILTER_BOSS_TIMEOUT', filter.boss.ringseconds)

			interface = '&'.join(secretary.interface for secretary in filter.secretaries)
			agi.set_variable('XIVO_BSFILTER_INTERFACE', interface)
			agi.set_variable('XIVO_BSFILTER_TIMEOUT', filter.ringseconds)

		ds_set_fwd_vars(filter.id, 'callfilter', 'noanswer', 'XIVO_BSFILTER_FWD_TYPERNA', 'XIVO_BSFILTER_FWD_TYPEVAL1RNA', 'XIVO_BSFILTER_FWD_TYPEVAL2RNA')
		agi.set_variable('XIVO_BSFILTER_MODE', filter.mode)
		agi.set_variable('XIVO_BSFILTER', '1')
		agi.verbose('AGI script "%s" successfully executed' % sys.argv[0])
		sys.exit(0)

if protocol in ("sip", "iax"):
	interface = protocol.upper() + "/" + name
elif protocol == "custom":
	cursor.query("SELECT ${columns} FROM usercustom "
                     "WHERE id = %s "
                     "AND commented = 0 "
                     "AND category = 'user'",
                     ('interface',),
                     (protocolid,))
	res = cursor.fetchone()

	if not res:
		agi_helpers.dp_break(agi, "Database inconsistency: unable to find custom user (name = '%s', context = '%s')" % (name, context))

	interface = res['interface']
else:
	agi_helpers.dp_break(agi, "Unknown protocol '%s'" % protocol)

# The extension table contains some rows which are used to activate some
# services like redirections or voicemail.
cursor.query("SELECT ${columns} FROM extensions "
             "WHERE name IN ('fwdunc', 'fwdrna', 'fwdbusy', 'enablevm', 'incallfilter', 'incallrec', 'enablednd') "
             "AND commented = 0",
             ('name',))
res = cursor.fetchall()

features_list = [row['name'] for row in res]

calloptions = ''

if enablexfer == 1:
	calloptions += "t"

if enableautomon == 1:
	calloptions += "w"

if 'incallfilter' in features_list and callfilter == 1:
	calloptions += "p"

agi.set_variable('XIVO_INTERFACE', interface)
agi.set_variable('XIVO_SIMULTCALLS', simultcalls)

if ringseconds > 0:
	agi.set_variable('XIVO_RINGSECONDS', ringseconds)

if 'enablednd' in features_list:
	agi.set_variable('XIVO_ENABLEDND', enablednd)
else:
	agi.set_variable('XIVO_ENABLEDND', 0)

if 'enablevm' in features_list:
	agi.set_variable('XIVO_ENABLEVOICEMAIL', enablevoicemail)
else:
	agi.set_variable('XIVO_ENABLEVOICEMAIL', 0)

agi.set_variable('XIVO_CALLOPTIONS', calloptions)

if 'fwdunc' in features_list:
	agi.set_variable('XIVO_ENABLEUNC', enableunc)

	if enableunc == 1:
		# The redirection isn't actually meant to target a user, but
		# the current implementation allows the use of this type for
		# any kind of number.
		agi.set_variable('XIVO_FWD_TYPEUNC', 'user')
		agi.set_variable('XIVO_FWD_TYPEVAL1UNC', destunc)
		agi.set_variable('XIVO_FWD_TYPEVAL2UNC', context)
else:
	agi.set_variable('XIVO_ENABLEUNC', 0)

if 'fwdbusy' in features_list:
	agi.set_variable('XIVO_ENABLEBUSY', enablebusy)

	if enablebusy == 1:
		# See the comment concerning the fwdunc feature.
		agi.set_variable('XIVO_FWD_TYPEBUSY', 'user')
		agi.set_variable('XIVO_FWD_TYPEVAL1BUSY', destbusy)
		agi.set_variable('XIVO_FWD_TYPEVAL2BUSY', context)
	else:
		ds_set_fwd_vars(id, 'user', 'busy', 'XIVO_FWD_TYPEBUSY', 'XIVO_FWD_TYPEVAL1BUSY', 'XIVO_FWD_TYPEVAL2BUSY')
else:
	agi.set_variable('XIVO_FWD_TYPEBUSY', 'endcall')
	agi.set_variable('XIVO_FWD_TYPEVAL1BUSY', 'none')

if 'fwdrna' in features_list:
	if enablerna:
		# See the comment concerning the fwdunc feature.
		agi.set_variable('XIVO_FWD_TYPERNA', 'user')
		agi.set_variable('XIVO_FWD_TYPEVAL1RNA', destrna)
		agi.set_variable('XIVO_FWD_TYPEVAL2RNA', context)
	else:
		ds_set_fwd_vars(id, 'user', 'noanswer', 'XIVO_FWD_TYPERNA', 'XIVO_FWD_TYPEVAL1RNA', 'XIVO_FWD_TYPEVAL2RNA')
else:
	agi.set_variable('XIVO_FWD_TYPERNA', 'endcall')
	agi.set_variable('XIVO_FWD_TYPEVAL1RNA', 'none')

ds_set_fwd_vars(id, 'user', 'congestion', 'XIVO_FWD_TYPECONGESTION', 'XIVO_FWD_TYPEVAL1CONGESTION', 'XIVO_FWD_TYPEVAL2CONGESTION')
ds_set_fwd_vars(id, 'user', 'chanunavail', 'XIVO_FWD_TYPEUNAVAIL', 'XIVO_FWD_TYPEVAL1UNAVAIL', 'XIVO_FWD_TYPEVAL2UNAVAIL')

if 'incallrec' in features_list and callrecord:
	agi.set_variable('XIVO_CALLRECORDFILE', "/usr/share/asterisk/sounds/web-interface/monitor/user-%s-%s-%s.wav" % (srcnum, dstnum, int(time.time())))

if musiconhold:
	agi.set_variable('MUSICCLASS()', musiconhold)

agi.verbose('AGI script "%s" successfully executed' % sys.argv[0])
