# Xivo 0.3 - Common variables and functions.
# Copyright (C) 2006 Richard Braun <rbraun@proformatique.com>
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# When extracting a source tarball, any of these extensions are supported.
# If you add an extension here, see extract function too.
EXTENSIONS="tar.gz tar.bz2 tgz"

# usage: exit_with_error "error message" ...
exit_with_error()
{
  echo -e "error: $1."

  while shift; do
    [ "$1" ] && echo -e "$1."
  done

  exit 1
}

# Fail if running as root.
# 
# usage: check_root
check_root()
{
  [ $UID -ne 0 ] || exit_with_error "running as root is dangerous and useless"
}

# Download a source file and check size and sha1sum.
# 
# usage: download_source <srcfile> <url> <size> <sha1sum>
download_source()
{
  pushd $DISTFILES &> /dev/null

  if [ ! -f "$1" ]; then
    wget "$2"
  fi

  size=$(stat -c %s "$1")
  sha1sum=$(sha1sum "$1" | cut -d ' ' -f 1)
  echo "checking $1"

  if [ "$size" != "$3" ] || [ "$sha1sum" != "$4" ]; then
    exit_with_error "bad size/sha1sum for $1"
  fi

  popd &> /dev/null
  echo "ok"
}

# Return the base name of the source file, e.g. get_basename tool-1.2.3.tar.gz
# returns tool-1.2.3. Supported extensions are listed in the $EXTENSIONS
# global variable. Set global variable $BASENAME on success.
# 
# usage: get_basename <source_file>
get_basename()
{
  for extension in $EXTENSIONS; do
    if echo "$1" | grep "\.$extension\$" &> /dev/null; then
      BASENAME=$(basename "$1" .$extension)
      return
    fi
  done

  exit_with_error "unable to get base name"
}

# Call tar with the right arguments based on the extension of source file.
# 
# usage: extract <source_file>
extract()
{
  echo "extracting $1"

  for extension in $EXTENSIONS; do
    if echo "$1" | grep "\.$extension\$" &> /dev/null; then
      if [ $extension = "tar.gz" ] || [ $extension = "tgz" ]; then
        arg="z"
      elif [ $extension = "tar.bz2" ]; then
        arg="j"
      else
        exit_with_error "unsupported source file type"
      fi

      tar xf$arg "$DISTFILES/$1"
      echo "ok"
      return
    fi
  done

  exit_with_error "unable to get base name"
}

# Apply a patch from the patches/ directory.
# 
# usage: apply_patch <patchfile> [patchlevel=1]
apply_patch()
{
  patchfile=$1

  if [ -z "$2" ]; then
    patchlevel="1"
  else
    patchlevel=$2
  fi

  patch -p$patchlevel < $ROOTDIR/patches/$patchfile
}

# Call make with $MAKEFLAGS.
# 
# usage: do_make [target...]
do_make()
{
  make $MAKEFLAGS "$@"
}

# Download, check, extract, build and install a package.
# 
# The $build_dir variable is set from the $srcdir variable. Sometimes, it can
# be useful to have several build directories. When extracting the glibc, there
# is a build directory for the headers installation, and a build directory for
# the glibc itself. If $build_dir is set when calling this function, its value
# will be used instead of the value of $srcdir. $build_dir is unset when the
# function returns.
# 
# To build from a separate directory, set build_outside to 1. The build_function
# callback function will be given the path of a new source directory as its
# first argument. This directory can then be patched safely.
# 
# Some toolchain package are handled in two steps. The same directories are
# used in each step, but the stamp files must be different. When this is the
# case, set dont_extract to 1 so that only stamp files are created.
# 
# It is suggested to omit build_outside and dont_extract if they're not needed.
# 
# usage: make_package <srcfile> <srcfile_url> <srcfile_size> <srcfile_sha1sum>
# <srcdir> <build_function> <install_function> <build_outside> <dont_extract>
make_package()
{
  srcfile=$1
  srcfile_url=$2
  srcfile_size=$3
  srcfile_sha1sum=$4
  srcdir=$5
  build_function=$6
  install_function=$7
  build_outside=$8
  dont_extract=$9

  if [ -z "$build_dir" ]; then
    build_dir="$SRC/$srcdir-build"
  else
    build_dir="$SRC/$build_dir"
  fi

  build_stamp="$build_dir.build_stamp"
  install_stamp="$build_dir.install_stamp"

  pushd $SRC &> /dev/null

  if [ ! -f $build_stamp ]; then
    download_source $srcfile $srcfile_url $srcfile_size $srcfile_sha1sum
    rm -rf $srcdir $build_dir

    if [ "$dont_extract" ]; then
      mkdir $srcdir
    else
      extract $srcfile
    fi

    if [ "$build_outside" = "1" ]; then
      new_srcdir="$build_dir-src"
      build_function_arg=$new_srcdir
      rm -rf $new_srcdir
      mv $srcdir $new_srcdir
      mkdir $build_dir
    else
      build_function_arg=
      mv $srcdir $build_dir
    fi

    pushd $build_dir &> /dev/null
    $build_function $build_function_arg
    popd &> /dev/null
    touch $build_stamp
  fi

  if [ ! -f $install_stamp ]; then
    pushd $build_dir &> /dev/null
    $install_function
    popd &> /dev/null
    touch $install_stamp
  fi

  popd &> /dev/null

  build_dir=
}

# Set $PATH so that target cross compiling tools (gcc, ld, as, etc...) don't
# conflict with native compiling tools. See init_buildenv().
use_simple_path()
{
  export PATH=$SIMPLE_PATH
}

# See use_simple_path() and init_buildenv().
use_extended_path()
{
  export PATH=$EXTENDED_PATH
}

# Install a script in /etc/init.d and handle symlinks in /etc/rc.startup and
# /etc/rc.shutdown. startup and shutdown are numeric values telling the order
# of execution of the script. The special value 00 means that the script must
# not be called at startup or shutdown. Values must have 2 digits. If
# omitted, the default value is 20.
# 
# usage: install_rc_script <script> <startup> <shutdown>
install_rc_script()
{
  script=$1
  startup=$2
  shutdown=$3
  scriptname=$(basename $script)

  mkdir -p -m 755 $SYSROOT/etc/{init.d,rc.startup,rc.shutdown}
  install -m 755 $script $SYSROOT/etc/init.d

  [ -z "$startup" ] && startup="20"
  [ -z "$shutdown" ] && shutdown="20"

  if [ "$startup" != "00" ]; then
    ln -s /etc/init.d/$scriptname $SYSROOT/etc/rc.startup/$startup-$scriptname
  fi

  if [ "$shutdown" != "00" ]; then
    ln -s /etc/init.d/$scriptname $SYSROOT/etc/rc.shutdown/$shutdown-$scriptname
  fi
}

# Install a script in /etc/hotplug.d, creating the directory if it doesn't
# exist.
# 
# usage: install_hotplug_rule <script>
install_hotplug_rule()
{
  mkdir -p -m 755 $SYSROOT/etc/hotplug.d
  install -m 644 "$1" $SYSROOT/etc/hotplug.d
}

# Install a site-local configuration file. The file will be written
# into $SYSCONF (/mnt at runtime), and a symlink of this file will be
# created in $SYSROOT/destdir (if conffile has a directory part, this
# directory will be created in $SYSCONF). For example :
# 
# make_conf_file zaptel/zaptel.conf /etc 644
# 
# usage: make_conf_file <conffile> <destdir> <mode>
make_conf_file()
{
  conffile=$1
  destdir=$2
  mode=$3
  dir=$(dirname $conffile)
  file=$(basename $conffile)

  mkdir -p -m 755 $SYSCONF/$dir
  mkdir -p -m 755 ${SYSROOT}$destdir
  install -m $mode $SYSCONFDIR/$conffile $SYSCONF/$dir
  ln -s /mnt/$conffile ${SYSROOT}$destdir/$file
}

# Compare the build and host GNU system types. If they're the same,
# some configure scripts may think we're not cross compiling. This must
# be prevented. $ROOTDIR, $BUILD and $TARGET must be set before calling
# this function.
# 
# usage: check_build_and_target
check_build_and_target()
{
  target_alias=$($ROOTDIR/utils/config.sub $TARGET)

  if [ "$BUILD" = "$target_alias" ]; then
    exit_with_error "$BUILD and $TARGET are the same GNU system type" \
                    "This prevents cross compilation from working correctly"
  fi
}

# Set variables, paths, and various elements related to the build environment.
# Sizes are in MB.
# 
# usage: init_buildenv
init_buildenv()
{
  check_root
  ROOTDIR=$PWD
  BUILD=$($ROOTDIR/utils/config.guess)

  check_build_and_target

  DIST_HOSTNAME=$(echo $DIST_NAME | tr '[:upper:]' '[:lower:]')
  DISTFILES="$BASE/distfiles"
  PREFIX="$BASE/dists/$DIST"
  SRC="$PREFIX/src"
  TOOLCHAIN="$PREFIX/toolchain"
  SYSROOT="$PREFIX/sysroot"
  SYSBOOT="$PREFIX/sysboot"
  SYSCONF="$PREFIX/sysconf"
  SYSBOOTIMG="$PREFIX/sysboot.img"
  SYSROOTTMP="$PREFIX/sysroot.tmp"
  SYSROOTIMG="$PREFIX/sysroot.img"
  SYSCONFIMG="$PREFIX/sysconf.img"

  mkdir -p $DISTFILES \
           $SRC \
           $TOOLCHAIN \
           $SYSROOT \
           $SYSBOOT \
           $SYSCONF

  rm -rf $SRC/*.install_stamp \
         $TOOLCHAIN/* \
         $SYSROOT/* \
         $SYSBOOT/* \
         $SYSCONF/*

  # Directory where system configuration files are located.
  # Dont mistake $SYSCONF and $SYSCONFDIR. $SYSCONF is the directory
  # used to generate the ext2fs/jffs2 file system where modifyable
  # configuration files will be located.
  SYSCONFDIR="$ROOTDIR/sysconf"

  export BUILD_CC=$(which gcc)
  SIMPLE_PATH=$TOOLCHAIN/bin:$PATH:/sbin:/usr/sbin:/usr/local/sbin
  EXTENDED_PATH=$TOOLCHAIN/bin:$TOOLCHAIN/$TARGET/bin:$PATH:/sbin:/usr/sbin:/usr/local/sbin
  use_simple_path
}

# Copy and optimize content of $SYSROOT into $SYSROOTTMP.
# 
# usage: copy_sysroot
copy_sysroot()
{
  echo -n "creating temporary sysroot tree... "
  rm -rf $SYSROOTTMP
  cp -a $SYSROOT $SYSROOTTMP
  echo "done"

  echo -n "create dummy link $SYSROOT -> /... "
  mkdir -p -m 755 $(dirname $SYSROOTTMP/$SYSROOT)
  ln -s / $SYSROOTTMP/$SYSROOT
  echo "done"

  echo -n "removing static libraries and object files... "
  find $SYSROOTTMP \( -name '*.a' -o -name '*.la' -o -name '*.o' \) -exec rm {} \;
  echo "done"

  echo -n "removing useless files... "
  rm -rf $SYSROOTTMP/usr/{include,src,man,info,share/{aclocal,i18n,locale,man,info}}
  rm -rf $SYSROOTTMP/usr/lib/pkgconfig
  rm -rf $SYSROOTTMP/usr/lib/php/build
  rm -rf $SYSROOTTMP/man $SYSROOTTMP/etc/ssl/{man,misc}
  echo "done"

  echo "stripping binaries (ignore errors about unrecognized formats)..."
  for dir in $SYSROOTTMP/{,usr/}{{,s}bin}; do
    find $dir -type f -exec $TOOLCHAIN/bin/$TARGET-strip -s {} \;
  done
  echo "done"

  echo -n "creating directories below / ... "
  mkdir -p -m 755 $SYSROOTTMP/boot
  mkdir -p -m 755 $SYSROOTTMP/dev
  mkdir -p -m 755 $SYSROOTTMP/etc
  mkdir -p -m 755 $SYSROOTTMP/etc/init.d
  mkdir -p -m 755 $SYSROOTTMP/mnt
  mkdir -p -m 755 $SYSROOTTMP/proc
  mkdir -p -m 755 $SYSROOTTMP/root
  mkdir -p -m 755 $SYSROOTTMP/sys
  mkdir -p -m 755 $SYSROOTTMP/tmp
  sudo mknod -m 600 $SYSROOTTMP/dev/console c 5 1
  echo "done"

  echo -n "saving sysconf image inside sysroot image... "
  gzip -c $SYSCONFIMG > $SYSROOTTMP/sysconf.img.gz
  echo "done"

  echo -n "saving kernel and system map inside sysroot image... "
  cp $SYSBOOT/vmlinux-$KERNEL_VERSION $SYSROOTTMP/vmlinux
  cp $SYSBOOT/System.map-$KERNEL_VERSION $SYSROOTTMP/System.map
  echo "done"
}

# Create the system images from $SYSROOT, $SYSBOOT and $SYSCONF.
# 
# usage: make_sysimgs
make_sysimgs()
{
  rm -f $SYSROOTIMG $SYSBOOTIMG $SYSCONFIMG

  if [ "$DIST_FS" = "ext2fs" ]; then
    # Here, we assume the size will always be small enough so that the block
    # size is 1024...
    genext2fs -U -b $(($SYSBOOTIMGSIZE * 1024)) -d $SYSBOOT > $SYSBOOTIMG
    e2fsck -y $SYSBOOTIMG
    genext2fs -U -b $(($SYSCONFIMGSIZE * 1024)) -d $SYSCONF > $SYSCONFIMG
    e2fsck -y $SYSCONFIMG
  elif [ "$DIST_FS" = "jffs2" ]; then
    if [ "$BIG_ENDIAN" = "true" ]; then
      mkfsjffs2_opt="-b"
    else
      mkfsjffs2_opt="-l"
    fi

    mkfs.jffs2 -v -d $SYSBOOT -q $mkfsjffs2_opt > $SYSBOOTIMG
    mkfs.jffs2 -v -d $SYSCONF -q $mkfsjffs2_opt > $SYSCONFIMG
  else
    echo "error: invalid \$DIST_FS."
    exit 1
  fi

  copy_sysroot

  if [ "$BIG_ENDIAN" = "true" ]; then
    mksquashfs_opt="-be"
  else
    mksquashfs_opt="-le"
  fi

  mksquashfs $SYSROOTTMP $SYSROOTIMG -all-root $mksquashfs_opt
  chmod 644 $SYSROOTIMG
  sudo rm -rf $SYSROOTTMP
}
