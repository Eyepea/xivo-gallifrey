diff -Nurp gcc-3.4.6.orig/boehm-gc/configure gcc-3.4.6/boehm-gc/configure
--- gcc-3.4.6.orig/boehm-gc/configure	2006-03-06 04:55:49.000000000 +0100
+++ gcc-3.4.6/boehm-gc/configure	2006-11-08 18:56:53.000000000 +0100
@@ -1947,6 +1947,11 @@ linux-gnu*)
   lt_cv_file_magic_test_file=`echo /lib/libc.so* /lib/libc-*.so`
   ;;
 
+linux-uclibc*)
+  lt_cv_deplibs_check_method=pass_all
+  lt_cv_file_magic_test_file=`echo /lib/libuClibc-*.so`
+  ;;
+
 netbsd*)
   if echo __ELF__ | $CC -E - | grep __ELF__ > /dev/null; then
     lt_cv_deplibs_check_method='match_pattern /lib[^/\.]+\.so\.[0-9]+\.[0-9]+$'
diff -Nurp gcc-3.4.6.orig/boehm-gc/ltconfig gcc-3.4.6/boehm-gc/ltconfig
--- gcc-3.4.6.orig/boehm-gc/ltconfig	2002-11-20 16:59:07.000000000 +0100
+++ gcc-3.4.6/boehm-gc/ltconfig	2006-11-08 18:56:53.000000000 +0100
@@ -1981,6 +1981,23 @@ linux-gnu*)
   fi
   ;;
 
+linux-uclibc*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so$major $libname.so'
+  soname_spec='${libname}${release}.so$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )'
+  file_magic_cmd=/usr/bin/file
+  file_magic_test_file=`echo /lib/libuClibc-*.so`
+
+  # Assume using the uClibc dynamic linker.
+  dynamic_linker="uClibc ld.so"
+  ;;
+
 netbsd*)
   version_type=sunos
   if echo __ELF__ | $CC -E - | grep __ELF__ >/dev/null; then
diff -Nurp gcc-3.4.6.orig/gcc/config/alpha/linux-elf.h gcc-3.4.6/gcc/config/alpha/linux-elf.h
--- gcc-3.4.6.orig/gcc/config/alpha/linux-elf.h	2003-09-27 06:48:30.000000000 +0200
+++ gcc-3.4.6/gcc/config/alpha/linux-elf.h	2006-11-08 18:56:53.000000000 +0100
@@ -27,7 +27,11 @@ Boston, MA 02111-1307, USA.  */
 #define SUBTARGET_EXTRA_SPECS \
 { "elf_dynamic_linker", ELF_DYNAMIC_LINKER },
 
+#ifdef USE_UCLIBC
+#define ELF_DYNAMIC_LINKER	"/lib/ld-uClibc.so.0"
+#else
 #define ELF_DYNAMIC_LINKER	"/lib/ld-linux.so.2"
+#endif
 
 #define LINK_SPEC "-m elf64alpha %{G*} %{relax:-relax}		\
   %{O*:-O3} %{!O*:-O1}						\
diff -Nurp gcc-3.4.6.orig/gcc/config/arm/linux-elf.h gcc-3.4.6/gcc/config/arm/linux-elf.h
--- gcc-3.4.6.orig/gcc/config/arm/linux-elf.h	2004-01-31 07:18:40.000000000 +0100
+++ gcc-3.4.6/gcc/config/arm/linux-elf.h	2006-11-08 18:56:53.000000000 +0100
@@ -80,6 +80,11 @@
 #define ENDFILE_SPEC \
   "%{!shared:crtend.o%s} %{shared:crtendS.o%s} crtn.o%s"
 
+#ifdef USE_UCLIBC
+#define ELF_DYNAMIC_LINKER "/lib/ld-uClibc.so.0"
+#else
+#define ELF_DYNAMIC_LINKER "/lib/ld-linux.so.2"
+#endif
 #undef  LINK_SPEC
 #define LINK_SPEC "%{h*} %{version:-v} \
    %{b} %{Wl,*:%*} \
@@ -87,7 +92,7 @@
    %{shared:-shared} \
    %{symbolic:-Bsymbolic} \
    %{rdynamic:-export-dynamic} \
-   %{!dynamic-linker:-dynamic-linker /lib/ld-linux.so.2} \
+   %{!dynamic-linker:-dynamic-linker " ELF_DYNAMIC_LINKER "} \
    -X \
    %{mbig-endian:-EB}" \
    SUBTARGET_EXTRA_LINK_SPEC
diff -Nurp gcc-3.4.6.orig/gcc/config/cris/linux.h gcc-3.4.6/gcc/config/cris/linux.h
--- gcc-3.4.6.orig/gcc/config/cris/linux.h	2003-11-29 04:08:13.000000000 +0100
+++ gcc-3.4.6/gcc/config/cris/linux.h	2006-11-08 18:56:53.000000000 +0100
@@ -79,6 +79,25 @@ Boston, MA 02111-1307, USA.  */
 #undef CRIS_DEFAULT_CPU_VERSION
 #define CRIS_DEFAULT_CPU_VERSION CRIS_CPU_NG
 
+#ifdef USE_UCLIBC
+
+#undef CRIS_SUBTARGET_VERSION
+#define CRIS_SUBTARGET_VERSION " - cris-axis-linux-uclibc"
+
+#undef CRIS_LINK_SUBTARGET_SPEC
+#define CRIS_LINK_SUBTARGET_SPEC \
+ "-mcrislinux\
+  -rpath-link include/asm/../..%s\
+  %{shared} %{static}\
+  %{symbolic:-Bdynamic} %{shlib:-Bdynamic} %{static:-Bstatic}\
+  %{!shared: \
+    %{!static: \
+      %{rdynamic:-export-dynamic} \
+      %{!dynamic-linker:-dynamic-linker /lib/ld-uClibc.so.0}}} \
+  %{!r:%{O2|O3: --gc-sections}}"
+
+#else  /* USE_UCLIBC */
+
 #undef CRIS_SUBTARGET_VERSION
 #define CRIS_SUBTARGET_VERSION " - cris-axis-linux-gnu"
 
@@ -93,6 +112,8 @@ Boston, MA 02111-1307, USA.  */
   %{!shared:%{!static:%{rdynamic:-export-dynamic}}}\
   %{!r:%{O2|O3: --gc-sections}}"
 
+#endif  /* USE_UCLIBC */
+
 
 /* Node: Run-time Target */
 
diff -Nurp gcc-3.4.6.orig/gcc/config/i386/linux64.h gcc-3.4.6/gcc/config/i386/linux64.h
--- gcc-3.4.6.orig/gcc/config/i386/linux64.h	2003-11-29 04:08:13.000000000 +0100
+++ gcc-3.4.6/gcc/config/i386/linux64.h	2006-11-08 18:56:53.000000000 +0100
@@ -54,14 +54,21 @@ Boston, MA 02111-1307, USA.  */
    When the -shared link option is used a final link is not being
    done.  */
 
+#ifdef USE_UCLIBC
+#define ELF32_DYNAMIC_LINKER "/lib/ld-uClibc.so.0"
+#define ELF64_DYNAMIC_LINKER "/lib/ld64-uClibc.so.0"
+#else
+#define ELF32_DYNAMIC_LINKER "/lib/ld-linux.so.2"
+#define ELF64_DYNAMIC_LINKER "/lib64/ld-linux-x86-64.so.2"
+#endif
 #undef	LINK_SPEC
 #define LINK_SPEC "%{!m32:-m elf_x86_64} %{m32:-m elf_i386} \
   %{shared:-shared} \
   %{!shared: \
     %{!static: \
       %{rdynamic:-export-dynamic} \
-      %{m32:%{!dynamic-linker:-dynamic-linker /lib/ld-linux.so.2}} \
-      %{!m32:%{!dynamic-linker:-dynamic-linker /lib64/ld-linux-x86-64.so.2}}} \
+      %{m32:%{!dynamic-linker:-dynamic-linker " ELF32_DYNAMIC_LINKER "}} \
+      %{!m32:%{!dynamic-linker:-dynamic-linker " ELF64_DYNAMIC_LINKER "}}} \
     %{static:-static}}"
 
 #define MULTILIB_DEFAULTS { "m64" }
diff -Nurp gcc-3.4.6.orig/gcc/config/i386/linux.h gcc-3.4.6/gcc/config/i386/linux.h
--- gcc-3.4.6.orig/gcc/config/i386/linux.h	2003-11-29 04:08:13.000000000 +0100
+++ gcc-3.4.6/gcc/config/i386/linux.h	2006-11-08 18:56:53.000000000 +0100
@@ -110,22 +110,21 @@ Boston, MA 02111-1307, USA.  */
 
 #undef	LINK_SPEC
 #ifdef USE_GNULIBC_1
-#define LINK_SPEC "-m elf_i386 %{shared:-shared} \
-  %{!shared: \
-    %{!ibcs: \
-      %{!static: \
-	%{rdynamic:-export-dynamic} \
-	%{!dynamic-linker:-dynamic-linker /lib/ld-linux.so.1}} \
-	%{static:-static}}}"
+#define ELF_DYNAMIC_LINKER "/lib/ld-linux.so.1"
+#else
+#ifdef USE_UCLIBC
+#define ELF_DYNAMIC_LINKER "/lib/ld-uClibc.so.0"
 #else
+#define ELF_DYNAMIC_LINKER "/lib/ld-linux.so.2"
+#endif
+#endif
 #define LINK_SPEC "-m elf_i386 %{shared:-shared} \
   %{!shared: \
     %{!ibcs: \
       %{!static: \
 	%{rdynamic:-export-dynamic} \
-	%{!dynamic-linker:-dynamic-linker /lib/ld-linux.so.2}} \
+	%{!dynamic-linker:-dynamic-linker " ELF_DYNAMIC_LINKER "}} \
 	%{static:-static}}}"
-#endif
 
 /* A C statement (sans semicolon) to output to the stdio stream
    FILE the assembler definition of uninitialized global DECL named
diff -Nurp gcc-3.4.6.orig/gcc/config/ia64/linux.h gcc-3.4.6/gcc/config/ia64/linux.h
--- gcc-3.4.6.orig/gcc/config/ia64/linux.h	2004-02-07 08:56:17.000000000 +0100
+++ gcc-3.4.6/gcc/config/ia64/linux.h	2006-11-08 18:56:53.000000000 +0100
@@ -37,13 +37,18 @@ do {						\
 /* Define this for shared library support because it isn't in the main
    linux.h file.  */
 
+#ifdef USE_UCLIBC
+#define ELF_DYNAMIC_LINKER	"/lib/ld-uClibc.so.0"
+#else
+#define ELF_DYNAMIC_LINKER "/lib/ld-linux-ia64.so.2"
+#endif
 #undef LINK_SPEC
 #define LINK_SPEC "\
   %{shared:-shared} \
   %{!shared: \
     %{!static: \
       %{rdynamic:-export-dynamic} \
-      %{!dynamic-linker:-dynamic-linker /lib/ld-linux-ia64.so.2}} \
+      %{!dynamic-linker:-dynamic-linker " ELF_DYNAMIC_LINKER "}} \
       %{static:-static}}"
 
 
diff -Nurp gcc-3.4.6.orig/gcc/config/m68k/linux.h gcc-3.4.6/gcc/config/m68k/linux.h
--- gcc-3.4.6.orig/gcc/config/m68k/linux.h	2003-11-29 04:08:13.000000000 +0100
+++ gcc-3.4.6/gcc/config/m68k/linux.h	2006-11-08 18:56:53.000000000 +0100
@@ -131,12 +131,17 @@ Boston, MA 02111-1307, USA.  */
 
 /* If ELF is the default format, we should not use /lib/elf.  */
 
+#ifdef USE_UCLIBC
+#define ELF_DYNAMIC_LINKER "/lib/ld-uClibc.so.0"
+#else
+#define ELF_DYNAMIC_LINKER "/lib/ld.so.1"
+#endif
 #undef	LINK_SPEC
 #define LINK_SPEC "-m m68kelf %{shared} \
   %{!shared: \
     %{!static: \
       %{rdynamic:-export-dynamic} \
-      %{!dynamic-linker*:-dynamic-linker /lib/ld.so.1}} \
+      %{!dynamic-linker*:-dynamic-linker " ELF_DYNAMIC_LINKER "}} \
     %{static}}"
 
 /* For compatibility with linux/a.out */
diff -Nurp gcc-3.4.6.orig/gcc/config/mips/linux.h gcc-3.4.6/gcc/config/mips/linux.h
--- gcc-3.4.6.orig/gcc/config/mips/linux.h	2004-06-16 03:42:25.000000000 +0200
+++ gcc-3.4.6/gcc/config/mips/linux.h	2006-11-08 18:56:53.000000000 +0100
@@ -109,6 +109,11 @@ Boston, MA 02111-1307, USA.  */
 
 /* Borrowed from sparc/linux.h */
 #undef LINK_SPEC
+#ifdef USE_UCLIBC
+#define ELF_DYNAMIC_LINKER "/lib/ld-uClibc.so.0"
+#else
+#define ELF_DYNAMIC_LINKER "/lib/ld.so.1"
+#endif
 #define LINK_SPEC \
  "%(endian_spec) \
   %{shared:-shared} \
@@ -116,7 +121,7 @@ Boston, MA 02111-1307, USA.  */
     %{!ibcs: \
       %{!static: \
         %{rdynamic:-export-dynamic} \
-        %{!dynamic-linker:-dynamic-linker /lib/ld.so.1}} \
+        %{!dynamic-linker:-dynamic-linker " ELF_DYNAMIC_LINKER "}} \
         %{static:-static}}}"
 
 #undef SUBTARGET_ASM_SPEC
diff -Nurp gcc-3.4.6.orig/gcc/config/pa/pa-linux.h gcc-3.4.6/gcc/config/pa/pa-linux.h
--- gcc-3.4.6.orig/gcc/config/pa/pa-linux.h	2003-11-29 04:08:13.000000000 +0100
+++ gcc-3.4.6/gcc/config/pa/pa-linux.h	2006-11-08 18:56:53.000000000 +0100
@@ -77,13 +77,18 @@ Boston, MA 02111-1307, USA.  */
 /* Define this for shared library support because it isn't in the main
    linux.h file.  */
 
+#ifdef USE_UCLIBC
+#define ELF_DYNAMIC_LINKER "/lib/ld-uClibc.so.0"
+#else
+#define ELF_DYNAMIC_LINKER "/lib/ld.so.1"
+#endif
 #undef LINK_SPEC
 #define LINK_SPEC "\
   %{shared:-shared} \
   %{!shared: \
     %{!static: \
       %{rdynamic:-export-dynamic} \
-      %{!dynamic-linker:-dynamic-linker /lib/ld.so.1}} \
+      %{!dynamic-linker:-dynamic-linker " ELF_DYNAMIC_LINKER "}} \
       %{static:-static}}"
 
 /* glibc's profiling functions don't need gcc to allocate counters.  */
diff -Nurp gcc-3.4.6.orig/gcc/config/rs6000/linux.h gcc-3.4.6/gcc/config/rs6000/linux.h
--- gcc-3.4.6.orig/gcc/config/rs6000/linux.h	2005-03-17 11:41:18.000000000 +0100
+++ gcc-3.4.6/gcc/config/rs6000/linux.h	2006-11-08 18:56:53.000000000 +0100
@@ -69,7 +69,11 @@
 #define LINK_START_DEFAULT_SPEC "%(link_start_linux)"
 
 #undef	LINK_OS_DEFAULT_SPEC
+#ifdef USE_UCLIBC
+#define LINK_OS_DEFAULT_SPEC "%(link_os_linux_uclibc)"
+#else
 #define LINK_OS_DEFAULT_SPEC "%(link_os_linux)"
+#endif
 
 #define LINK_GCC_C_SEQUENCE_SPEC \
   "%{static:--start-group} %G %L %{static:--end-group}%{!static:%G}"
diff -Nurp gcc-3.4.6.orig/gcc/config/rs6000/sysv4.h gcc-3.4.6/gcc/config/rs6000/sysv4.h
--- gcc-3.4.6.orig/gcc/config/rs6000/sysv4.h	2005-10-30 00:35:37.000000000 +0200
+++ gcc-3.4.6/gcc/config/rs6000/sysv4.h	2006-11-08 18:56:53.000000000 +0100
@@ -949,6 +949,7 @@ extern int fixuplabelno;
   mcall-linux  : %(link_os_linux)       ; \
   mcall-gnu    : %(link_os_gnu)         ; \
   mcall-netbsd : %(link_os_netbsd)      ; \
+  mcall-linux-uclibc : %(link_os_linux_uclibc); \
   mcall-openbsd: %(link_os_openbsd)     ; \
                : %(link_os_default)     }"
 
@@ -1127,6 +1128,10 @@ extern int fixuplabelno;
   %{rdynamic:-export-dynamic} \
   %{!dynamic-linker:-dynamic-linker /lib/ld.so.1}}}"
 
+#define LINK_OS_LINUX_UCLIBC_SPEC "-m elf32ppclinux %{!shared: %{!static: \
+  %{rdynamic:-export-dynamic} \
+  %{!dynamic-linker:-dynamic-linker /lib/ld-uClibc.so.0}}}"
+
 #if defined(HAVE_LD_EH_FRAME_HDR)
 # define LINK_EH_SPEC "%{!static:--eh-frame-hdr} "
 #endif
@@ -1293,6 +1298,7 @@ ncrtn.o%s"
   { "link_os_sim",		LINK_OS_SIM_SPEC },			\
   { "link_os_freebsd",		LINK_OS_FREEBSD_SPEC },			\
   { "link_os_linux",		LINK_OS_LINUX_SPEC },			\
+  { "link_os_linux_uclibc",	LINK_OS_LINUX_UCLIBC_SPEC },		\
   { "link_os_gnu",		LINK_OS_GNU_SPEC },			\
   { "link_os_netbsd",		LINK_OS_NETBSD_SPEC },			\
   { "link_os_openbsd",		LINK_OS_OPENBSD_SPEC },			\
diff -Nurp gcc-3.4.6.orig/gcc/config/rs6000/sysv4.h.orig gcc-3.4.6/gcc/config/rs6000/sysv4.h.orig
--- gcc-3.4.6.orig/gcc/config/rs6000/sysv4.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/config/rs6000/sysv4.h.orig	2005-10-30 00:35:37.000000000 +0200
@@ -0,0 +1,1362 @@
+/* Target definitions for GNU compiler for PowerPC running System V.4
+   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
+   2004, 2005 Free Software Foundation, Inc.
+   Contributed by Cygnus Support.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 2, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING.  If not, write to the
+   Free Software Foundation, 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA.  */
+
+/* Header files should be C++ aware in general.  */
+#define NO_IMPLICIT_EXTERN_C
+
+/* Yes!  We are ELF.  */
+#define	TARGET_OBJECT_FORMAT OBJECT_ELF
+
+/* Default ABI to compile code for.  */
+#define DEFAULT_ABI rs6000_current_abi
+
+/* Default ABI to use.  */
+#define RS6000_ABI_NAME "sysv"
+
+/* Override rs6000.h definition.  */
+#undef	ASM_DEFAULT_SPEC
+#define	ASM_DEFAULT_SPEC "-mppc"
+
+/* Small data support types.  */
+enum rs6000_sdata_type {
+  SDATA_NONE,			/* No small data support.  */
+  SDATA_DATA,			/* Just put data in .sbss/.sdata, don't use relocs.  */
+  SDATA_SYSV,			/* Use r13 to point to .sdata/.sbss.  */
+  SDATA_EABI			/* Use r13 like above, r2 points to .sdata2/.sbss2.  */
+};
+
+extern enum rs6000_sdata_type rs6000_sdata;
+
+/* V.4/eabi switches.  */
+#define	MASK_NO_BITFIELD_TYPE	0x40000000	/* Set PCC_BITFIELD_TYPE_MATTERS to 0.  */
+#define	MASK_STRICT_ALIGN	0x20000000	/* Set STRICT_ALIGNMENT to 1.  */
+#define	MASK_RELOCATABLE	0x10000000	/* GOT pointers are PC relative.  */
+#define	MASK_EABI		0x08000000	/* Adhere to eabi, not System V spec.  */
+#define	MASK_LITTLE_ENDIAN	0x04000000	/* Target is little endian.  */
+#define	MASK_REGNAMES		0x02000000	/* Use alternate register names.  */
+#define	MASK_PROTOTYPE		0x01000000	/* Only prototyped fcns pass variable args.  */
+#define MASK_NO_BITFIELD_WORD	0x00800000	/* Bitfields cannot cross word boundaries */
+
+#define	TARGET_NO_BITFIELD_TYPE	(target_flags & MASK_NO_BITFIELD_TYPE)
+#define	TARGET_STRICT_ALIGN	(target_flags & MASK_STRICT_ALIGN)
+#define	TARGET_RELOCATABLE	(target_flags & MASK_RELOCATABLE)
+#define	TARGET_EABI		(target_flags & MASK_EABI)
+#define	TARGET_LITTLE_ENDIAN	(target_flags & MASK_LITTLE_ENDIAN)
+#define	TARGET_REGNAMES		(target_flags & MASK_REGNAMES)
+#define	TARGET_PROTOTYPE	(target_flags & MASK_PROTOTYPE)
+#define TARGET_NO_BITFIELD_WORD	(target_flags & MASK_NO_BITFIELD_WORD)
+#define	TARGET_TOC		((target_flags & MASK_64BIT)		\
+				 || ((target_flags & (MASK_RELOCATABLE	\
+						      | MASK_MINIMAL_TOC)) \
+				     && flag_pic > 1)			\
+				 || DEFAULT_ABI == ABI_AIX)
+
+#define	TARGET_BITFIELD_TYPE	(! TARGET_NO_BITFIELD_TYPE)
+#define	TARGET_BIG_ENDIAN	(! TARGET_LITTLE_ENDIAN)
+#define	TARGET_NO_PROTOTYPE	(! TARGET_PROTOTYPE)
+#define	TARGET_NO_TOC		(! TARGET_TOC)
+#define	TARGET_NO_EABI		(! TARGET_EABI)
+
+/* Strings provided by SUBTARGET_OPTIONS */
+extern const char *rs6000_abi_name;
+extern const char *rs6000_sdata_name;
+extern const char *rs6000_tls_size_string; /* For -mtls-size= */
+
+/* Override rs6000.h definition.  */
+#undef	SUBTARGET_OPTIONS
+#define	SUBTARGET_OPTIONS							\
+  { "call-",  &rs6000_abi_name, N_("Select ABI calling convention"), 0},	\
+  { "sdata=", &rs6000_sdata_name, N_("Select method for sdata handling"), 0},	\
+  { "tls-size=", &rs6000_tls_size_string,					\
+   N_("Specify bit size of immediate TLS offsets"), 0 }
+
+#define SDATA_DEFAULT_SIZE 8
+
+/* Note, V.4 no longer uses a normal TOC, so make -mfull-toc, be just
+   the same as -mminimal-toc.  */
+/* Override rs6000.h definition.  */
+#undef	SUBTARGET_SWITCHES
+#define SUBTARGET_SWITCHES						\
+  { "bit-align",	-MASK_NO_BITFIELD_TYPE,				\
+    N_("Align to the base type of the bit-field") },			\
+  { "no-bit-align",	 MASK_NO_BITFIELD_TYPE,				\
+    N_("Don't align to the base type of the bit-field") },		\
+  { "strict-align",	 MASK_STRICT_ALIGN,				\
+    N_("Don't assume that unaligned accesses are handled by the system") }, \
+  { "no-strict-align",	-MASK_STRICT_ALIGN,				\
+    N_("Assume that unaligned accesses are handled by the system") },	\
+  { "relocatable",	 MASK_RELOCATABLE | MASK_MINIMAL_TOC | MASK_NO_FP_IN_TOC, \
+    N_("Produce code relocatable at runtime") },			\
+  { "no-relocatable",	-MASK_RELOCATABLE,				\
+    N_("Don't produce code relocatable at runtime") },			\
+  { "relocatable-lib",	 MASK_RELOCATABLE | MASK_MINIMAL_TOC | MASK_NO_FP_IN_TOC, \
+    N_("Produce code relocatable at runtime") },			\
+  { "no-relocatable-lib", -MASK_RELOCATABLE,				\
+    N_("Don't produce code relocatable at runtime") },			\
+  { "little-endian",	 MASK_LITTLE_ENDIAN,				\
+    N_("Produce little endian code") },					\
+  { "little",		 MASK_LITTLE_ENDIAN,				\
+    N_("Produce little endian code") },					\
+  { "big-endian",	-MASK_LITTLE_ENDIAN,				\
+    N_("Produce big endian code") },					\
+  { "big",		-MASK_LITTLE_ENDIAN,				\
+    N_("Produce big endian code") },					\
+  { "no-toc",		 0, N_("no description yet") },			\
+  { "toc",		 MASK_MINIMAL_TOC, N_("no description yet") },	\
+  { "full-toc",		 MASK_MINIMAL_TOC, N_("no description yet") },	\
+  { "prototype",	 MASK_PROTOTYPE,				\
+    N_("Assume all variable arg functions are prototyped") },		\
+  { "no-prototype",	-MASK_PROTOTYPE,				\
+    N_("Non-prototyped functions might take a variable number of args") }, \
+  { "no-traceback",	 0, N_("no description yet") },			\
+  { "eabi",		 MASK_EABI, N_("Use EABI") },			\
+  { "no-eabi",		-MASK_EABI, N_("Don't use EABI") },		\
+  { "bit-word",		-MASK_NO_BITFIELD_WORD, "" },			\
+  { "no-bit-word",	 MASK_NO_BITFIELD_WORD,				\
+    N_("Do not allow bit-fields to cross word boundaries") },		\
+  { "regnames",		  MASK_REGNAMES,				\
+    N_("Use alternate register names") },				\
+  { "no-regnames",	 -MASK_REGNAMES,				\
+    N_("Don't use alternate register names") },				\
+  { "sdata",		 0, N_("no description yet") },			\
+  { "no-sdata",		 0, N_("no description yet") },			\
+  { "sim",		 0,						\
+    N_("Link with libsim.a, libc.a and sim-crt0.o") },			\
+  { "ads",		 0,						\
+    N_("Link with libads.a, libc.a and crt0.o") },			\
+  { "yellowknife",	 0,						\
+    N_("Link with libyk.a, libc.a and crt0.o") },			\
+  { "mvme",		 0,						\
+    N_("Link with libmvme.a, libc.a and crt0.o") },			\
+  { "emb",		 0,						\
+    N_("Set the PPC_EMB bit in the ELF flags header") },		\
+  { "windiss",           0, N_("Use the WindISS simulator") },          \
+  { "shlib",		 0, N_("no description yet") },			\
+  { "64",		 MASK_64BIT | MASK_POWERPC64 | MASK_POWERPC,	\
+			 N_("Generate 64-bit code") },			\
+  { "32",		 - (MASK_64BIT | MASK_POWERPC64),		\
+			 N_("Generate 32-bit code") },			\
+  EXTRA_SUBTARGET_SWITCHES						\
+  { "newlib",		 0, N_("no description yet") },
+
+/* This is meant to be redefined in the host dependent files.  */
+#define EXTRA_SUBTARGET_SWITCHES
+
+/* Sometimes certain combinations of command options do not make sense
+   on a particular target machine.  You can define a macro
+   `OVERRIDE_OPTIONS' to take account of this.  This macro, if
+   defined, is executed once just after all the command options have
+   been parsed.
+
+   The macro SUBTARGET_OVERRIDE_OPTIONS is provided for subtargets, to
+   get control.  */
+
+#define SUBTARGET_OVERRIDE_OPTIONS					\
+do {									\
+  if (!g_switch_set)							\
+    g_switch_value = SDATA_DEFAULT_SIZE;				\
+									\
+  if (rs6000_abi_name == NULL)						\
+    rs6000_abi_name = RS6000_ABI_NAME;					\
+									\
+  if (!strcmp (rs6000_abi_name, "sysv"))				\
+    rs6000_current_abi = ABI_V4;					\
+  else if (!strcmp (rs6000_abi_name, "sysv-noeabi"))			\
+    {									\
+      rs6000_current_abi = ABI_V4;					\
+      target_flags &= ~ MASK_EABI;					\
+    }									\
+  else if (!strcmp (rs6000_abi_name, "sysv-eabi")			\
+	   || !strcmp (rs6000_abi_name, "eabi"))			\
+    {									\
+      rs6000_current_abi = ABI_V4;					\
+      target_flags |= MASK_EABI;					\
+    }									\
+  else if (!strcmp (rs6000_abi_name, "aixdesc"))			\
+    rs6000_current_abi = ABI_AIX;					\
+  else if (!strcmp (rs6000_abi_name, "freebsd"))			\
+    rs6000_current_abi = ABI_V4;					\
+  else if (!strcmp (rs6000_abi_name, "linux"))				\
+    rs6000_current_abi = ABI_V4;					\
+  else if (!strcmp (rs6000_abi_name, "gnu"))				\
+    rs6000_current_abi = ABI_V4;					\
+  else if (!strcmp (rs6000_abi_name, "netbsd"))				\
+    rs6000_current_abi = ABI_V4;					\
+  else if (!strcmp (rs6000_abi_name, "openbsd"))			\
+    rs6000_current_abi = ABI_V4;					\
+  else if (!strcmp (rs6000_abi_name, "i960-old"))			\
+    {									\
+      rs6000_current_abi = ABI_V4;					\
+      target_flags |= (MASK_LITTLE_ENDIAN | MASK_EABI			\
+		       | MASK_NO_BITFIELD_WORD);			\
+      target_flags &= ~MASK_STRICT_ALIGN;				\
+    }									\
+  else									\
+    {									\
+      rs6000_current_abi = ABI_V4;					\
+      error ("bad value for -mcall-%s", rs6000_abi_name);		\
+    }									\
+									\
+  if (rs6000_sdata_name)						\
+    {									\
+      if (!strcmp (rs6000_sdata_name, "none"))				\
+	rs6000_sdata = SDATA_NONE;					\
+      else if (!strcmp (rs6000_sdata_name, "data"))			\
+	rs6000_sdata = SDATA_DATA;					\
+      else if (!strcmp (rs6000_sdata_name, "default"))			\
+	rs6000_sdata = (TARGET_EABI) ? SDATA_EABI : SDATA_SYSV;		\
+      else if (!strcmp (rs6000_sdata_name, "sysv"))			\
+	rs6000_sdata = SDATA_SYSV;					\
+      else if (!strcmp (rs6000_sdata_name, "eabi"))			\
+	rs6000_sdata = SDATA_EABI;					\
+      else								\
+	error ("bad value for -msdata=%s", rs6000_sdata_name);		\
+    }									\
+  else if (DEFAULT_ABI == ABI_V4)					\
+    {									\
+      rs6000_sdata = SDATA_DATA;					\
+      rs6000_sdata_name = "data";					\
+    }									\
+  else									\
+    {									\
+      rs6000_sdata = SDATA_NONE;					\
+      rs6000_sdata_name = "none";					\
+    }									\
+									\
+  if (TARGET_RELOCATABLE &&						\
+      (rs6000_sdata == SDATA_EABI || rs6000_sdata == SDATA_SYSV))	\
+    {									\
+      rs6000_sdata = SDATA_DATA;					\
+      error ("-mrelocatable and -msdata=%s are incompatible",		\
+	     rs6000_sdata_name);					\
+    }									\
+									\
+  else if (flag_pic && DEFAULT_ABI != ABI_AIX				\
+	   && (rs6000_sdata == SDATA_EABI				\
+	       || rs6000_sdata == SDATA_SYSV))				\
+    {									\
+      rs6000_sdata = SDATA_DATA;					\
+      error ("-f%s and -msdata=%s are incompatible",			\
+	     (flag_pic > 1) ? "PIC" : "pic",				\
+	     rs6000_sdata_name);					\
+    }									\
+									\
+  if ((rs6000_sdata != SDATA_NONE && DEFAULT_ABI != ABI_V4)		\
+      || (rs6000_sdata == SDATA_EABI && !TARGET_EABI))			\
+    {									\
+      rs6000_sdata = SDATA_NONE;					\
+      error ("-msdata=%s and -mcall-%s are incompatible",		\
+	     rs6000_sdata_name, rs6000_abi_name);			\
+    }									\
+									\
+  targetm.have_srodata_section = rs6000_sdata == SDATA_EABI;		\
+									\
+  if (TARGET_RELOCATABLE && !TARGET_MINIMAL_TOC)			\
+    {									\
+      target_flags |= MASK_MINIMAL_TOC;					\
+      error ("-mrelocatable and -mno-minimal-toc are incompatible");	\
+    }									\
+									\
+  if (TARGET_RELOCATABLE && rs6000_current_abi == ABI_AIX)		\
+    {									\
+      target_flags &= ~MASK_RELOCATABLE;				\
+      error ("-mrelocatable and -mcall-%s are incompatible",		\
+	     rs6000_abi_name);						\
+    }									\
+									\
+  if (!TARGET_64BIT && flag_pic > 1 && rs6000_current_abi == ABI_AIX)	\
+    {									\
+      flag_pic = 0;							\
+      error ("-fPIC and -mcall-%s are incompatible",			\
+	     rs6000_abi_name);						\
+    }									\
+									\
+  if (rs6000_current_abi == ABI_AIX && TARGET_LITTLE_ENDIAN)		\
+    {									\
+      target_flags &= ~MASK_LITTLE_ENDIAN;				\
+      error ("-mcall-aixdesc must be big endian");			\
+    }									\
+									\
+  /* Treat -fPIC the same as -mrelocatable.  */				\
+  if (flag_pic > 1 && DEFAULT_ABI != ABI_AIX)				\
+    target_flags |= MASK_RELOCATABLE | MASK_MINIMAL_TOC | MASK_NO_FP_IN_TOC; \
+									\
+  else if (TARGET_RELOCATABLE)						\
+    flag_pic = 2;							\
+} while (0)
+
+#ifndef RS6000_BI_ARCH
+# define SUBSUBTARGET_OVERRIDE_OPTIONS					\
+do {									\
+  if ((TARGET_DEFAULT ^ target_flags) & MASK_64BIT)			\
+    error ("-m%s not supported in this configuration",			\
+	   (target_flags & MASK_64BIT) ? "64" : "32");			\
+} while (0)
+#endif
+
+/* Override rs6000.h definition.  */
+#undef	TARGET_DEFAULT
+#define	TARGET_DEFAULT (MASK_POWERPC | MASK_NEW_MNEMONICS)
+
+/* Override rs6000.h definition.  */
+#undef	PROCESSOR_DEFAULT
+#define	PROCESSOR_DEFAULT PROCESSOR_PPC750
+
+#define FIXED_R2 1
+/* System V.4 uses register 13 as a pointer to the small data area,
+   so it is not available to the normal user.  */
+#define FIXED_R13 1
+
+/* Size of the V.4 varargs area if needed.  */
+/* Override rs6000.h definition.  */
+#undef	RS6000_VARARGS_AREA
+#define RS6000_VARARGS_AREA ((cfun->machine->sysv_varargs_p) ? RS6000_VARARGS_SIZE : 0)
+
+/* Override default big endianism definitions in rs6000.h.  */
+#undef	BYTES_BIG_ENDIAN
+#undef	WORDS_BIG_ENDIAN
+#define	BYTES_BIG_ENDIAN (TARGET_BIG_ENDIAN)
+#define	WORDS_BIG_ENDIAN (TARGET_BIG_ENDIAN)
+
+/* Define this to set the endianness to use in libgcc2.c, which can
+   not depend on target_flags.  */
+#if !defined(__LITTLE_ENDIAN__) && !defined(__sun__)
+#define LIBGCC2_WORDS_BIG_ENDIAN 1
+#else
+#define LIBGCC2_WORDS_BIG_ENDIAN 0
+#endif
+
+/* Define cutoff for using external functions to save floating point.
+   Currently on V.4, always use inline stores.  */
+#define FP_SAVE_INLINE(FIRST_REG) ((FIRST_REG) < 64)
+
+/* Put jump tables in read-only memory, rather than in .text.  */
+#define JUMP_TABLES_IN_TEXT_SECTION 0
+
+/* Prefix and suffix to use to saving floating point.  */
+#define	SAVE_FP_PREFIX "_savefpr_"
+#define SAVE_FP_SUFFIX "_l"
+
+/* Prefix and suffix to use to restoring floating point.  */
+#define	RESTORE_FP_PREFIX "_restfpr_"
+#define RESTORE_FP_SUFFIX "_l"
+
+/* Type used for ptrdiff_t, as a string used in a declaration.  */
+#define PTRDIFF_TYPE "int"
+
+/* Type used for wchar_t, as a string used in a declaration.  */
+/* Override svr4.h definition.  */
+#undef	WCHAR_TYPE
+#define WCHAR_TYPE "long int"
+
+/* Width of wchar_t in bits.  */
+/* Override svr4.h definition.  */
+#undef	WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE 32
+
+/* Make int foo : 8 not cause structures to be aligned to an int boundary.  */
+/* Override elfos.h definition.  */
+#undef	PCC_BITFIELD_TYPE_MATTERS
+#define	PCC_BITFIELD_TYPE_MATTERS (TARGET_BITFIELD_TYPE)
+
+#undef	BITFIELD_NBYTES_LIMITED
+#define	BITFIELD_NBYTES_LIMITED (TARGET_NO_BITFIELD_WORD)
+
+/* Define this macro to be the value 1 if instructions will fail to
+   work if given data not on the nominal alignment.  If instructions
+   will merely go slower in that case, define this macro as 0.  */
+#undef	STRICT_ALIGNMENT
+#define	STRICT_ALIGNMENT (TARGET_STRICT_ALIGN)
+
+/* Define this macro if you wish to preserve a certain alignment for
+   the stack pointer, greater than what the hardware enforces.  The
+   definition is a C expression for the desired alignment (measured
+   in bits).  This macro must evaluate to a value equal to or larger
+   than STACK_BOUNDARY.
+   For the SYSV ABI and variants the alignment of the stack pointer
+   is usually controlled manually in rs6000.c. However, to maintain
+   alignment across alloca () in all circumstances,
+   PREFERRED_STACK_BOUNDARY needs to be set as well.
+   This has the additional advantage of allowing a bigger maximum
+   alignment of user objects on the stack.  */
+
+#undef PREFERRED_STACK_BOUNDARY
+#define PREFERRED_STACK_BOUNDARY 128
+
+/* Real stack boundary as mandated by the appropriate ABI.  */
+#define ABI_STACK_BOUNDARY \
+  ((TARGET_EABI && !TARGET_ALTIVEC && !TARGET_ALTIVEC_ABI) ? 64 : 128)
+
+/* An expression for the alignment of a structure field FIELD if the
+   alignment computed in the usual way is COMPUTED.  */
+#define ADJUST_FIELD_ALIGN(FIELD, COMPUTED)				      \
+	((TARGET_ALTIVEC && TREE_CODE (TREE_TYPE (FIELD)) == VECTOR_TYPE)     \
+	 ? 128 : COMPUTED)
+
+/* Define this macro as an expression for the alignment of a type
+   (given by TYPE as a tree node) if the alignment computed in the
+   usual way is COMPUTED and the alignment explicitly specified was
+   SPECIFIED.  */
+#define ROUND_TYPE_ALIGN(TYPE, COMPUTED, SPECIFIED)			\
+	((TARGET_ALTIVEC  && TREE_CODE (TYPE) == VECTOR_TYPE)	        \
+	 ? MAX (MAX ((COMPUTED), (SPECIFIED)), 128)                     \
+         : MAX (COMPUTED, SPECIFIED))
+
+#undef  BIGGEST_FIELD_ALIGNMENT
+
+/* Use ELF style section commands.  */
+
+#define	TEXT_SECTION_ASM_OP	"\t.section\t\".text\""
+
+#define	DATA_SECTION_ASM_OP	"\t.section\t\".data\""
+
+#define	BSS_SECTION_ASM_OP	"\t.section\t\".bss\""
+
+/* Override elfos.h definition.  */
+#undef	INIT_SECTION_ASM_OP
+#define	INIT_SECTION_ASM_OP "\t.section\t\".init\",\"ax\""
+
+/* Override elfos.h definition.  */
+#undef	FINI_SECTION_ASM_OP
+#define	FINI_SECTION_ASM_OP "\t.section\t\".fini\",\"ax\""
+
+#define	TOC_SECTION_ASM_OP "\t.section\t\".got\",\"aw\""
+
+/* Put PC relative got entries in .got2.  */
+#define	MINIMAL_TOC_SECTION_ASM_OP \
+  (TARGET_RELOCATABLE || (flag_pic && DEFAULT_ABI != ABI_AIX)		\
+   ? "\t.section\t\".got2\",\"aw\"" : "\t.section\t\".got1\",\"aw\"")
+
+#define	SDATA_SECTION_ASM_OP "\t.section\t\".sdata\",\"aw\""
+#define	SDATA2_SECTION_ASM_OP "\t.section\t\".sdata2\",\"a\""
+#define	SBSS_SECTION_ASM_OP "\t.section\t\".sbss\",\"aw\",@nobits"
+
+/* Besides the usual ELF sections, we need a toc section.  */
+/* Override elfos.h definition.  */
+#undef	EXTRA_SECTIONS
+#define	EXTRA_SECTIONS in_toc, in_sdata, in_sdata2, in_sbss, in_init, in_fini
+
+/* Override elfos.h definition.  */
+#undef	EXTRA_SECTION_FUNCTIONS
+#define	EXTRA_SECTION_FUNCTIONS						\
+  TOC_SECTION_FUNCTION							\
+  SDATA_SECTION_FUNCTION						\
+  SDATA2_SECTION_FUNCTION						\
+  SBSS_SECTION_FUNCTION							\
+  INIT_SECTION_FUNCTION							\
+  FINI_SECTION_FUNCTION
+
+#define	TOC_SECTION_FUNCTION						\
+void									\
+toc_section (void)							\
+{									\
+  if (in_section != in_toc)						\
+    {									\
+      in_section = in_toc;						\
+      if (DEFAULT_ABI == ABI_AIX					\
+	  && TARGET_MINIMAL_TOC						\
+	  && !TARGET_RELOCATABLE)					\
+	{								\
+	  if (! toc_initialized)					\
+	    {								\
+	      toc_initialized = 1;					\
+	      fprintf (asm_out_file, "%s\n", TOC_SECTION_ASM_OP);	\
+	      (*targetm.asm_out.internal_label) (asm_out_file, "LCTOC", 0); \
+	      fprintf (asm_out_file, "\t.tc ");				\
+	      ASM_OUTPUT_INTERNAL_LABEL_PREFIX (asm_out_file, "LCTOC1[TC],"); \
+	      ASM_OUTPUT_INTERNAL_LABEL_PREFIX (asm_out_file, "LCTOC1"); \
+	      fprintf (asm_out_file, "\n");				\
+									\
+	      fprintf (asm_out_file, "%s\n", MINIMAL_TOC_SECTION_ASM_OP); \
+	      ASM_OUTPUT_INTERNAL_LABEL_PREFIX (asm_out_file, "LCTOC1"); \
+	      fprintf (asm_out_file, " = .+32768\n");			\
+	    }								\
+	  else								\
+	    fprintf (asm_out_file, "%s\n", MINIMAL_TOC_SECTION_ASM_OP);	\
+	}								\
+      else if (DEFAULT_ABI == ABI_AIX && !TARGET_RELOCATABLE)		\
+	fprintf (asm_out_file, "%s\n", TOC_SECTION_ASM_OP);		\
+      else								\
+	{								\
+	  fprintf (asm_out_file, "%s\n", MINIMAL_TOC_SECTION_ASM_OP);	\
+	  if (! toc_initialized)					\
+	    {								\
+	      ASM_OUTPUT_INTERNAL_LABEL_PREFIX (asm_out_file, "LCTOC1"); \
+	      fprintf (asm_out_file, " = .+32768\n");			\
+	      toc_initialized = 1;					\
+	    }								\
+	}								\
+    }									\
+}									\
+									\
+extern int in_toc_section (void);					\
+int in_toc_section (void)						\
+{									\
+  return in_section == in_toc;						\
+}
+
+#define	SDATA_SECTION_FUNCTION						\
+void									\
+sdata_section (void)							\
+{									\
+  if (in_section != in_sdata)						\
+    {									\
+      in_section = in_sdata;						\
+      fprintf (asm_out_file, "%s\n", SDATA_SECTION_ASM_OP);		\
+    }									\
+}
+
+#define	SDATA2_SECTION_FUNCTION						\
+void									\
+sdata2_section (void)							\
+{									\
+  if (in_section != in_sdata2)						\
+    {									\
+      in_section = in_sdata2;						\
+      fprintf (asm_out_file, "%s\n", SDATA2_SECTION_ASM_OP);		\
+    }									\
+}
+
+#define	SBSS_SECTION_FUNCTION						\
+void									\
+sbss_section (void)							\
+{									\
+  if (in_section != in_sbss)						\
+    {									\
+      in_section = in_sbss;						\
+      fprintf (asm_out_file, "%s\n", SBSS_SECTION_ASM_OP);		\
+    }									\
+}
+
+#define	INIT_SECTION_FUNCTION						\
+void									\
+init_section (void)							\
+{									\
+  if (in_section != in_init)						\
+    {									\
+      in_section = in_init;						\
+      fprintf (asm_out_file, "%s\n", INIT_SECTION_ASM_OP);		\
+    }									\
+}
+
+#define	FINI_SECTION_FUNCTION						\
+void									\
+fini_section (void)							\
+{									\
+  if (in_section != in_fini)						\
+    {									\
+      in_section = in_fini;						\
+      fprintf (asm_out_file, "%s\n", FINI_SECTION_ASM_OP);		\
+    }									\
+}
+
+/* Override default elf definitions.  */
+#undef	TARGET_ASM_SELECT_RTX_SECTION
+#define	TARGET_ASM_SELECT_RTX_SECTION rs6000_elf_select_rtx_section
+#undef	TARGET_ASM_SELECT_SECTION
+#define	TARGET_ASM_SELECT_SECTION  rs6000_elf_select_section
+#define TARGET_ASM_UNIQUE_SECTION  rs6000_elf_unique_section
+
+/* Return nonzero if this entry is to be written into the constant pool
+   in a special way.  We do so if this is a SYMBOL_REF, LABEL_REF or a CONST
+   containing one of them.  If -mfp-in-toc (the default), we also do
+   this for floating-point constants.  We actually can only do this
+   if the FP formats of the target and host machines are the same, but
+   we can't check that since not every file that uses
+   GO_IF_LEGITIMATE_ADDRESS_P includes real.h.
+
+   Unlike AIX, we don't key off of -mminimal-toc, but instead do not
+   allow floating point constants in the TOC if -mrelocatable.  */
+
+#undef	ASM_OUTPUT_SPECIAL_POOL_ENTRY_P
+#define	ASM_OUTPUT_SPECIAL_POOL_ENTRY_P(X, MODE)			\
+  (TARGET_TOC								\
+   && (GET_CODE (X) == SYMBOL_REF					\
+       || (GET_CODE (X) == CONST && GET_CODE (XEXP (X, 0)) == PLUS	\
+	   && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF)		\
+       || GET_CODE (X) == LABEL_REF					\
+       || (GET_CODE (X) == CONST_INT 					\
+	   && GET_MODE_BITSIZE (MODE) <= GET_MODE_BITSIZE (Pmode))	\
+       || (!TARGET_NO_FP_IN_TOC						\
+	   && !TARGET_RELOCATABLE					\
+	   && GET_CODE (X) == CONST_DOUBLE				\
+	   && GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT		\
+	   && BITS_PER_WORD == HOST_BITS_PER_INT)))
+
+/* These macros generate the special .type and .size directives which
+   are used to set the corresponding fields of the linker symbol table
+   entries in an ELF object file under SVR4.  These macros also output
+   the starting labels for the relevant functions/objects.  */
+
+/* Write the extra assembler code needed to declare a function properly.
+   Some svr4 assemblers need to also have something extra said about the
+   function's return value.  We allow for that here.  */
+
+extern int rs6000_pic_labelno;
+
+/* Override elfos.h definition.  */
+#undef	ASM_DECLARE_FUNCTION_NAME
+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)			\
+  rs6000_elf_declare_function_name ((FILE), (NAME), (DECL))
+
+/* The USER_LABEL_PREFIX stuff is affected by the -fleading-underscore
+   flag.  The LOCAL_LABEL_PREFIX variable is used by dbxelf.h.  */
+
+#define	LOCAL_LABEL_PREFIX "."
+#define	USER_LABEL_PREFIX ""
+
+/* svr4.h overrides (*targetm.asm_out.internal_label).  */
+
+#define	ASM_OUTPUT_INTERNAL_LABEL_PREFIX(FILE,PREFIX)	\
+  asm_fprintf (FILE, "%L%s", PREFIX)
+
+/* Globalizing directive for a label.  */
+#define GLOBAL_ASM_OP "\t.globl "
+
+/* This says how to output assembler code to declare an
+   uninitialized internal linkage data object.  Under SVR4,
+   the linker seems to want the alignment of data objects
+   to depend on their types.  We do exactly that here.  */
+
+#define	LOCAL_ASM_OP	"\t.local\t"
+
+#define	LCOMM_ASM_OP	"\t.lcomm\t"
+
+/* Override elfos.h definition.  */
+#undef	ASM_OUTPUT_ALIGNED_LOCAL
+#define	ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)		\
+do {									\
+  if (rs6000_sdata != SDATA_NONE && (SIZE) > 0				\
+      && (SIZE) <= g_switch_value)					\
+    {									\
+      sbss_section ();							\
+      ASM_OUTPUT_ALIGN (FILE, exact_log2 (ALIGN / BITS_PER_UNIT));	\
+      ASM_OUTPUT_LABEL (FILE, NAME);					\
+      ASM_OUTPUT_SKIP (FILE, SIZE);					\
+      if (!flag_inhibit_size_directive && (SIZE) > 0)			\
+	ASM_OUTPUT_SIZE_DIRECTIVE (FILE, NAME, SIZE);			\
+    }									\
+  else									\
+    {									\
+      fprintf (FILE, "%s", LCOMM_ASM_OP);				\
+      assemble_name ((FILE), (NAME));					\
+      fprintf ((FILE), ","HOST_WIDE_INT_PRINT_UNSIGNED",%u\n",		\
+	       (SIZE), (ALIGN) / BITS_PER_UNIT);			\
+    }									\
+  ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, "object");			\
+} while (0)
+
+/* Describe how to emit uninitialized external linkage items.  */
+#define	ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN)		\
+do {									\
+  ASM_OUTPUT_ALIGNED_LOCAL (FILE, NAME, SIZE, ALIGN);			\
+} while (0)
+
+#ifdef HAVE_GAS_MAX_SKIP_P2ALIGN
+/* To support -falign-* switches we need to use .p2align so
+   that alignment directives in code sections will be padded
+   with no-op instructions, rather than zeroes.  */
+#define ASM_OUTPUT_MAX_SKIP_ALIGN(FILE,LOG,MAX_SKIP)			\
+  if ((LOG) != 0)							\
+    {									\
+      if ((MAX_SKIP) == 0)						\
+	fprintf ((FILE), "\t.p2align %d\n", (LOG));			\
+      else								\
+	fprintf ((FILE), "\t.p2align %d,,%d\n",	(LOG), (MAX_SKIP));	\
+    }
+#endif
+
+/* This is how to output code to push a register on the stack.
+   It need not be very fast code.
+
+   On the rs6000, we must keep the backchain up to date.  In order
+   to simplify things, always allocate 16 bytes for a push (System V
+   wants to keep stack aligned to a 16 byte boundary).  */
+
+#define	ASM_OUTPUT_REG_PUSH(FILE, REGNO)				\
+do {									\
+  if (DEFAULT_ABI == ABI_V4)						\
+    asm_fprintf (FILE,							\
+		 "\t{stu|stwu} %s,-16(%s)\n\t{st|stw} %s,12(%s)\n",	\
+		 reg_names[1], reg_names[1], reg_names[REGNO],		\
+		 reg_names[1]);						\
+} while (0)
+
+/* This is how to output an insn to pop a register from the stack.
+   It need not be very fast code.  */
+
+#define	ASM_OUTPUT_REG_POP(FILE, REGNO)					\
+do {									\
+  if (DEFAULT_ABI == ABI_V4)						\
+    asm_fprintf (FILE,							\
+		 "\t{l|lwz} %s,12(%s)\n\t{ai|addic} %s,%s,16\n",	\
+		 reg_names[REGNO], reg_names[1], reg_names[1],		\
+		 reg_names[1]);						\
+} while (0)
+
+/* Switch  Recognition by gcc.c.  Add -G xx support.  */
+
+/* Override svr4.h definition.  */
+#undef	SWITCH_TAKES_ARG
+#define	SWITCH_TAKES_ARG(CHAR)						\
+  ((CHAR) == 'D' || (CHAR) == 'U' || (CHAR) == 'o'			\
+   || (CHAR) == 'e' || (CHAR) == 'T' || (CHAR) == 'u'			\
+   || (CHAR) == 'I' || (CHAR) == 'm' || (CHAR) == 'x'			\
+   || (CHAR) == 'L' || (CHAR) == 'A' || (CHAR) == 'V'			\
+   || (CHAR) == 'B' || (CHAR) == 'b' || (CHAR) == 'G')
+
+extern int fixuplabelno;
+
+/* Handle constructors specially for -mrelocatable.  */
+#define TARGET_ASM_CONSTRUCTOR  rs6000_elf_asm_out_constructor
+#define TARGET_ASM_DESTRUCTOR   rs6000_elf_asm_out_destructor
+
+/* This is the end of what might become sysv4.h.  */
+
+/* Use DWARF 2 debugging information by default.  */
+#undef  PREFERRED_DEBUGGING_TYPE
+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG
+
+/* Historically we have also supported stabs debugging.  */
+#define DBX_DEBUGGING_INFO 1
+
+#define DBX_REGISTER_NUMBER(REGNO) rs6000_dbx_register_number (REGNO)
+
+/* Map register numbers held in the call frame info that gcc has
+   collected using DWARF_FRAME_REGNUM to those that should be output in
+   .debug_frame and .eh_frame.  We continue to use gcc hard reg numbers
+   for .eh_frame, but use the numbers mandated by the various ABIs for
+   .debug_frame.  rs6000_emit_prologue has translated any combination of
+   CR2, CR3, CR4 saves to a save of CR2.  The actual code emitted saves
+   the whole of CR, so we map CR2_REGNO to the DWARF reg for CR.  */
+#define DWARF2_FRAME_REG_OUT(REGNO, FOR_EH)	\
+  ((FOR_EH) ? (REGNO)				\
+   : (REGNO) == CR2_REGNO ? 64			\
+   : DBX_REGISTER_NUMBER (REGNO))
+
+#define TARGET_ENCODE_SECTION_INFO  rs6000_elf_encode_section_info
+#define TARGET_IN_SMALL_DATA_P  rs6000_elf_in_small_data_p
+#define TARGET_SECTION_TYPE_FLAGS  rs6000_elf_section_type_flags
+
+/* The ELF version doesn't encode [DS] or whatever at the end of symbols.  */
+
+#define	RS6000_OUTPUT_BASENAME(FILE, NAME)	\
+    assemble_name (FILE, NAME)
+
+/* We have to output the stabs for the function name *first*, before
+   outputting its label.  */
+
+#define	DBX_FUNCTION_FIRST
+
+/* This is the end of what might become sysv4dbx.h.  */
+
+#ifndef	TARGET_VERSION
+#define	TARGET_VERSION fprintf (stderr, " (PowerPC System V.4)");
+#endif
+
+#define TARGET_OS_SYSV_CPP_BUILTINS()	  \
+  do                                      \
+    {                                     \
+      if (flag_pic == 1)		  \
+        {				  \
+	  builtin_define ("__pic__=1");	  \
+	  builtin_define ("__PIC__=1");	  \
+        }				  \
+      else if (flag_pic == 2)		  \
+        {				  \
+	  builtin_define ("__pic__=2");	  \
+	  builtin_define ("__PIC__=2");	  \
+        }				  \
+      if (target_flags_explicit		  \
+	  & MASK_RELOCATABLE)		  \
+	builtin_define ("_RELOCATABLE");  \
+    }                                     \
+  while (0)
+
+#ifndef	TARGET_OS_CPP_BUILTINS
+#define TARGET_OS_CPP_BUILTINS()          \
+  do                                      \
+    {                                     \
+      builtin_define_std ("PPC");         \
+      builtin_define_std ("unix");        \
+      builtin_define ("__svr4__");        \
+      builtin_assert ("system=unix");     \
+      builtin_assert ("system=svr4");     \
+      builtin_assert ("cpu=powerpc");     \
+      builtin_assert ("machine=powerpc"); \
+      TARGET_OS_SYSV_CPP_BUILTINS ();	  \
+    }                                     \
+  while (0)
+#endif
+
+/* Pass various options to the assembler.  */
+/* Override svr4.h definition.  */
+#undef	ASM_SPEC
+#define	ASM_SPEC "%(asm_cpu) \
+%{.s: %{mregnames} %{mno-regnames}} %{.S: %{mregnames} %{mno-regnames}} \
+%{v:-V} %{Qy:} %{!Qn:-Qy} %{n} %{T} %{Ym,*} %{Yd,*} %{Wa,*:%*} \
+%{mrelocatable} %{mrelocatable-lib} %{fpic|fpie|fPIC|fPIE:-K PIC} \
+%{memb|msdata|msdata=eabi: -memb} \
+%{mlittle|mlittle-endian:-mlittle; \
+  mbig|mbig-endian      :-mbig;    \
+  mcall-aixdesc |		   \
+  mcall-freebsd |		   \
+  mcall-netbsd  |		   \
+  mcall-openbsd |		   \
+  mcall-linux   |		   \
+  mcall-gnu             :-mbig;    \
+  mcall-i960-old        :-mlittle}"
+
+#define	CC1_ENDIAN_BIG_SPEC ""
+
+#define	CC1_ENDIAN_LITTLE_SPEC "\
+%{!mstrict-align: %{!mno-strict-align: \
+    %{!mcall-i960-old: \
+	-mstrict-align \
+    } \
+}}"
+
+#define	CC1_ENDIAN_DEFAULT_SPEC "%(cc1_endian_big)"
+
+/* Pass -G xxx to the compiler and set correct endian mode.  */
+#define	CC1_SPEC "%{G*} \
+%{mlittle|mlittle-endian: %(cc1_endian_little);           \
+  mbig   |mbig-endian   : %(cc1_endian_big);              \
+  mcall-aixdesc |					  \
+  mcall-freebsd |					  \
+  mcall-netbsd  |					  \
+  mcall-openbsd |					  \
+  mcall-linux   |					  \
+  mcall-gnu             : -mbig %(cc1_endian_big);        \
+  mcall-i960-old        : -mlittle %(cc1_endian_little);  \
+                        : %(cc1_endian_default)}          \
+%{mno-sdata: -msdata=none } \
+%{meabi: %{!mcall-*: -mcall-sysv }} \
+%{!meabi: %{!mno-eabi: \
+    %{mrelocatable: -meabi } \
+    %{mcall-freebsd: -mno-eabi } \
+    %{mcall-i960-old: -meabi } \
+    %{mcall-linux: -mno-eabi } \
+    %{mcall-gnu: -mno-eabi } \
+    %{mcall-netbsd: -mno-eabi } \
+    %{mcall-openbsd: -mno-eabi }}} \
+%{msdata: -msdata=default} \
+%{mno-sdata: -msdata=none} \
+%{profile: -p}"
+
+/* Don't put -Y P,<path> for cross compilers.  */
+#ifndef CROSS_COMPILE
+#define LINK_PATH_SPEC "\
+%{!R*:%{L*:-R %*}} \
+%{!nostdlib: %{!YP,*: \
+    %{compat-bsd: \
+	%{p:-Y P,/usr/ucblib:/usr/ccs/lib/libp:/usr/lib/libp:/usr/ccs/lib:/usr/lib} \
+	%{!p:-Y P,/usr/ucblib:/usr/ccs/lib:/usr/lib}} \
+	%{!R*: %{!L*: -R /usr/ucblib}} \
+    %{!compat-bsd: \
+	%{p:-Y P,/usr/ccs/lib/libp:/usr/lib/libp:/usr/ccs/lib:/usr/lib} \
+	%{!p:-Y P,/usr/ccs/lib:/usr/lib}}}}"
+
+#else
+#define LINK_PATH_SPEC ""
+#endif
+
+/* Default starting address if specified.  */
+#define LINK_START_SPEC "\
+%{mads         : %(link_start_ads)         ; \
+  myellowknife : %(link_start_yellowknife) ; \
+  mmvme        : %(link_start_mvme)        ; \
+  msim         : %(link_start_sim)         ; \
+  mwindiss     : %(link_start_windiss)     ; \
+  mcall-freebsd: %(link_start_freebsd)     ; \
+  mcall-linux  : %(link_start_linux)       ; \
+  mcall-gnu    : %(link_start_gnu)         ; \
+  mcall-netbsd : %(link_start_netbsd)      ; \
+  mcall-openbsd: %(link_start_openbsd)     ; \
+               : %(link_start_default)     }"
+
+#define LINK_START_DEFAULT_SPEC ""
+
+/* Override svr4.h definition.  */
+#undef	LINK_SPEC
+#define	LINK_SPEC "\
+%{h*} %{v:-V} %{!msdata=none:%{G*}} %{msdata=none:-G0} \
+%{YP,*} %{R*} \
+%{Qy:} %{!Qn:-Qy} \
+%(link_shlib) \
+%{!Wl,-T*: %{!T*: %(link_start) }} \
+%(link_target) \
+%(link_os)"
+
+/* For now, turn off shared libraries by default.  */
+#ifndef SHARED_LIB_SUPPORT
+#define NO_SHARED_LIB_SUPPORT
+#endif
+
+#ifndef NO_SHARED_LIB_SUPPORT
+/* Shared libraries are default.  */
+#define LINK_SHLIB_SPEC "\
+%{!static: %(link_path) %{!R*:%{L*:-R %*}}} \
+%{mshlib: } \
+%{static:-dn -Bstatic} \
+%{shared:-G -dy -z text} \
+%{symbolic:-Bsymbolic -G -dy -z text}"
+
+#else
+/* Shared libraries are not default.  */
+#define LINK_SHLIB_SPEC "\
+%{mshlib: %(link_path) } \
+%{!mshlib: %{!shared: %{!symbolic: -dn -Bstatic}}} \
+%{static: } \
+%{shared:-G -dy -z text %(link_path) } \
+%{symbolic:-Bsymbolic -G -dy -z text %(link_path) }"
+#endif
+
+/* Override the default target of the linker.  */
+#define	LINK_TARGET_SPEC "\
+%{mlittle: --oformat elf32-powerpcle } %{mlittle-endian: --oformat elf32-powerpcle } \
+%{!mlittle: %{!mlittle-endian: %{!mbig: %{!mbig-endian: \
+    %{mcall-i960-old: --oformat elf32-powerpcle} \
+  }}}}"
+
+/* Any specific OS flags.  */
+#define LINK_OS_SPEC "\
+%{mads         : %(link_os_ads)         ; \
+  myellowknife : %(link_os_yellowknife) ; \
+  mmvme        : %(link_os_mvme)        ; \
+  msim         : %(link_os_sim)         ; \
+  mwindiss     : %(link_os_windiss)     ; \
+  mcall-freebsd: %(link_os_freebsd)     ; \
+  mcall-linux  : %(link_os_linux)       ; \
+  mcall-gnu    : %(link_os_gnu)         ; \
+  mcall-netbsd : %(link_os_netbsd)      ; \
+  mcall-openbsd: %(link_os_openbsd)     ; \
+               : %(link_os_default)     }"
+
+#define LINK_OS_DEFAULT_SPEC ""
+
+/* Override rs6000.h definition.  */
+#undef	CPP_SPEC
+#define	CPP_SPEC "%{posix: -D_POSIX_SOURCE} \
+%{mads         : %(cpp_os_ads)         ; \
+  myellowknife : %(cpp_os_yellowknife) ; \
+  mmvme        : %(cpp_os_mvme)        ; \
+  msim         : %(cpp_os_sim)         ; \
+  mwindiss     : %(cpp_os_windiss)     ; \
+  mcall-freebsd: %(cpp_os_freebsd)     ; \
+  mcall-linux  : %(cpp_os_linux)       ; \
+  mcall-gnu    : %(cpp_os_gnu)         ; \
+  mcall-netbsd : %(cpp_os_netbsd)      ; \
+  mcall-openbsd: %(cpp_os_openbsd)     ; \
+               : %(cpp_os_default)     }"
+
+#define	CPP_OS_DEFAULT_SPEC ""
+
+/* Override svr4.h definition.  */
+#undef	STARTFILE_SPEC
+#define	STARTFILE_SPEC "\
+%{mads         : %(startfile_ads)         ; \
+  myellowknife : %(startfile_yellowknife) ; \
+  mmvme        : %(startfile_mvme)        ; \
+  msim         : %(startfile_sim)         ; \
+  mwindiss     : %(startfile_windiss)     ; \
+  mcall-freebsd: %(startfile_freebsd)     ; \
+  mcall-linux  : %(startfile_linux)       ; \
+  mcall-gnu    : %(startfile_gnu)         ; \
+  mcall-netbsd : %(startfile_netbsd)      ; \
+  mcall-openbsd: %(startfile_openbsd)     ; \
+               : %(startfile_default)     }"
+
+#define	STARTFILE_DEFAULT_SPEC ""
+
+/* Override svr4.h definition.  */
+#undef	LIB_SPEC
+#define	LIB_SPEC "\
+%{mads         : %(lib_ads)         ; \
+  myellowknife : %(lib_yellowknife) ; \
+  mmvme        : %(lib_mvme)        ; \
+  msim         : %(lib_sim)         ; \
+  mwindiss     : %(lib_windiss)     ; \
+  mcall-freebsd: %(lib_freebsd)     ; \
+  mcall-linux  : %(lib_linux)       ; \
+  mcall-gnu    : %(lib_gnu)         ; \
+  mcall-netbsd : %(lib_netbsd)      ; \
+  mcall-openbsd: %(lib_openbsd)     ; \
+               : %(lib_default)     }"
+
+#define LIB_DEFAULT_SPEC ""
+
+/* Override svr4.h definition.  */
+#undef	ENDFILE_SPEC
+#define	ENDFILE_SPEC "\
+%{mads         : crtsavres.o%s        %(endfile_ads)         ; \
+  myellowknife : crtsavres.o%s        %(endfile_yellowknife) ; \
+  mmvme        : crtsavres.o%s        %(endfile_mvme)        ; \
+  msim         : crtsavres.o%s        %(endfile_sim)         ; \
+  mwindiss     :                      %(endfile_windiss)     ; \
+  mcall-freebsd: crtsavres.o%s        %(endfile_freebsd)     ; \
+  mcall-linux  : crtsavres.o%s        %(endfile_linux)       ; \
+  mcall-gnu    : crtsavres.o%s        %(endfile_gnu)         ; \
+  mcall-netbsd : crtsavres.o%s        %(endfile_netbsd)      ; \
+  mcall-openbsd: crtsavres.o%s        %(endfile_openbsd)     ; \
+               : %(crtsavres_default) %(endfile_default)     }"
+
+#define CRTSAVRES_DEFAULT_SPEC "crtsavres.o%s"
+
+#define	ENDFILE_DEFAULT_SPEC ""
+
+/* Motorola ADS support.  */
+#define LIB_ADS_SPEC "--start-group -lads -lc --end-group"
+
+#define	STARTFILE_ADS_SPEC "ecrti.o%s crt0.o%s crtbegin.o%s"
+
+#define	ENDFILE_ADS_SPEC "crtend.o%s ecrtn.o%s"
+
+#define LINK_START_ADS_SPEC "-T ads.ld%s"
+
+#define LINK_OS_ADS_SPEC ""
+
+#define CPP_OS_ADS_SPEC ""
+
+/* Motorola Yellowknife support.  */
+#define LIB_YELLOWKNIFE_SPEC "--start-group -lyk -lc --end-group"
+
+#define	STARTFILE_YELLOWKNIFE_SPEC "ecrti.o%s crt0.o%s crtbegin.o%s"
+
+#define	ENDFILE_YELLOWKNIFE_SPEC "crtend.o%s ecrtn.o%s"
+
+#define LINK_START_YELLOWKNIFE_SPEC "-T yellowknife.ld%s"
+
+#define LINK_OS_YELLOWKNIFE_SPEC ""
+
+#define CPP_OS_YELLOWKNIFE_SPEC ""
+
+/* Motorola MVME support.  */
+#define LIB_MVME_SPEC "--start-group -lmvme -lc --end-group"
+
+#define	STARTFILE_MVME_SPEC "ecrti.o%s crt0.o%s crtbegin.o%s"
+
+#define	ENDFILE_MVME_SPEC "crtend.o%s ecrtn.o%s"
+
+#define LINK_START_MVME_SPEC "-Ttext 0x40000"
+
+#define LINK_OS_MVME_SPEC ""
+
+#define CPP_OS_MVME_SPEC ""
+
+/* PowerPC simulator based on netbsd system calls support.  */
+#define LIB_SIM_SPEC "--start-group -lsim -lc --end-group"
+
+#define	STARTFILE_SIM_SPEC "ecrti.o%s sim-crt0.o%s crtbegin.o%s"
+
+#define	ENDFILE_SIM_SPEC "crtend.o%s ecrtn.o%s"
+
+#define LINK_START_SIM_SPEC ""
+
+#define LINK_OS_SIM_SPEC "-m elf32ppcsim"
+
+#define CPP_OS_SIM_SPEC ""
+
+/* FreeBSD support.  */
+
+#define CPP_OS_FREEBSD_SPEC	"\
+  -D__PPC__ -D__ppc__ -D__PowerPC__ -D__powerpc__ \
+  -Acpu=powerpc -Amachine=powerpc"
+
+#define	STARTFILE_FREEBSD_SPEC	FBSD_STARTFILE_SPEC
+#define ENDFILE_FREEBSD_SPEC	FBSD_ENDFILE_SPEC
+#define LIB_FREEBSD_SPEC	FBSD_LIB_SPEC
+#define LINK_START_FREEBSD_SPEC	""
+
+#define LINK_OS_FREEBSD_SPEC "\
+  %{p:%nconsider using `-pg' instead of `-p' with gprof(1)} \
+  %{Wl,*:%*} \
+  %{v:-V} \
+  %{assert*} %{R*} %{rpath*} %{defsym*} \
+  %{shared:-Bshareable %{h*} %{soname*}} \
+  %{!shared: \
+    %{!static: \
+      %{rdynamic: -export-dynamic} \
+      %{!dynamic-linker:-dynamic-linker %(fbsd_dynamic_linker) }} \
+    %{static:-Bstatic}} \
+  %{symbolic:-Bsymbolic}"
+
+/* GNU/Linux support.  */
+#define LIB_LINUX_SPEC "%{mnewlib: --start-group -llinux -lc --end-group } \
+%{!mnewlib: %{pthread:-lpthread} %{shared:-lc} \
+%{!shared: %{profile:-lc_p} %{!profile:-lc}}}"
+
+#ifdef HAVE_LD_PIE
+#define	STARTFILE_LINUX_SPEC "\
+%{!shared: %{pg|p:gcrt1.o%s;pie:Scrt1.o%s;:crt1.o%s}} \
+%{mnewlib:ecrti.o%s;:crti.o%s} \
+%{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s}"
+#else
+#define	STARTFILE_LINUX_SPEC "\
+%{!shared: %{pg|p:gcrt1.o%s;:crt1.o%s}} \
+%{mnewlib:ecrti.o%s;:crti.o%s} \
+%{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s}"
+#endif
+
+#define	ENDFILE_LINUX_SPEC "\
+%{shared|pie:crtendS.o%s;:crtend.o%s} \
+%{mnewlib:ecrtn.o%s;:crtn.o%s}"
+
+#define LINK_START_LINUX_SPEC ""
+
+#define LINK_OS_LINUX_SPEC "-m elf32ppclinux %{!shared: %{!static: \
+  %{rdynamic:-export-dynamic} \
+  %{!dynamic-linker:-dynamic-linker /lib/ld.so.1}}}"
+
+#if defined(HAVE_LD_EH_FRAME_HDR)
+# define LINK_EH_SPEC "%{!static:--eh-frame-hdr} "
+#endif
+
+#define CPP_OS_LINUX_SPEC "-D__unix__ -D__gnu_linux__ -D__linux__ \
+%{!undef:							  \
+  %{!ansi:							  \
+    %{!std=*:-Dunix -D__unix -Dlinux -D__linux}			  \
+    %{std=gnu*:-Dunix -D__unix -Dlinux -D__linux}}}		  \
+-Asystem=linux -Asystem=unix -Asystem=posix %{pthread:-D_REENTRANT}"
+
+/* GNU/Hurd support.  */
+#define LIB_GNU_SPEC "%{mnewlib: --start-group -lgnu -lc --end-group } \
+%{!mnewlib: %{shared:-lc} %{!shared: %{pthread:-lpthread } \
+%{profile:-lc_p} %{!profile:-lc}}}"
+
+#define	STARTFILE_GNU_SPEC "\
+%{!shared: %{!static: %{pg:gcrt1.o%s} %{!pg:%{p:gcrt1.o%s} %{!p:crt1.o%s}}}} \
+%{static: %{pg:gcrt0.o%s} %{!pg:%{p:gcrt0.o%s} %{!p:crt0.o%s}}} \
+%{mnewlib: ecrti.o%s} %{!mnewlib: crti.o%s} \
+%{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}"
+
+#define	ENDFILE_GNU_SPEC "%{!shared:crtend.o%s} %{shared:crtendS.o%s} \
+%{mnewlib: ecrtn.o%s} %{!mnewlib: crtn.o%s}"
+
+#define LINK_START_GNU_SPEC ""
+
+#define LINK_OS_GNU_SPEC "-m elf32ppclinux %{!shared: %{!static: \
+  %{rdynamic:-export-dynamic} \
+  %{!dynamic-linker:-dynamic-linker /lib/ld.so.1}}}"
+
+#define CPP_OS_GNU_SPEC "-D__unix__ -D__gnu_hurd__ -D__GNU__	\
+%{!undef:					                \
+  %{!ansi: -Dunix -D__unix}}			                \
+-Asystem=gnu -Asystem=unix -Asystem=posix %{pthread:-D_REENTRANT}"
+
+/* NetBSD support.  */
+#define LIB_NETBSD_SPEC "\
+%{profile:-lgmon -lc_p} %{!profile:-lc}"
+
+#define	STARTFILE_NETBSD_SPEC "\
+ncrti.o%s crt0.o%s \
+%{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}"
+
+#define ENDFILE_NETBSD_SPEC "\
+%{!shared:crtend.o%s} %{shared:crtendS.o%s} \
+ncrtn.o%s"
+
+#define LINK_START_NETBSD_SPEC "\
+"
+
+#define LINK_OS_NETBSD_SPEC "\
+%{!shared: %{!static: \
+  %{rdynamic:-export-dynamic} \
+  %{!dynamic-linker:-dynamic-linker /usr/libexec/ld.elf_so}}}"
+
+#define CPP_OS_NETBSD_SPEC "\
+-D__powerpc__ -D__NetBSD__ -D__KPRINTF_ATTRIBUTE__"
+
+/* OpenBSD support.  */
+#ifndef	LIB_OPENBSD_SPEC
+#define LIB_OPENBSD_SPEC "%{!shared:%{pthread:-lpthread%{p:_p}%{!p:%{pg:_p}}}} %{!shared:-lc%{p:_p}%{!p:%{pg:_p}}}"
+#endif
+
+#ifndef	STARTFILE_OPENBSD_SPEC
+#define	STARTFILE_OPENBSD_SPEC "\
+%{!shared: %{pg:gcrt0.o%s} %{!pg:%{p:gcrt0.o%s} %{!p:crt0.o%s}}} \
+%{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}"
+#endif
+
+#ifndef	ENDFILE_OPENBSD_SPEC
+#define	ENDFILE_OPENBSD_SPEC "\
+%{!shared:crtend.o%s} %{shared:crtendS.o%s}"
+#endif
+
+#ifndef LINK_START_OPENBSD_SPEC
+#define LINK_START_OPENBSD_SPEC "-Ttext 0x400074"
+#endif
+
+#ifndef LINK_OS_OPENBSD_SPEC
+#define LINK_OS_OPENBSD_SPEC ""
+#endif
+
+#ifndef CPP_OS_OPENBSD_SPEC
+#define CPP_OS_OPENBSD_SPEC "%{posix:-D_POSIX_SOURCE} %{pthread:-D_POSIX_THREADS}"
+#endif
+
+/* WindISS support.  */
+
+#define LIB_WINDISS_SPEC "--start-group -li -lcfp -lwindiss -lram -limpl -limpfp --end-group"
+
+#define CPP_OS_WINDISS_SPEC "\
+-D__rtasim \
+-D__EABI__ \
+-D__ppc \
+%{!msoft-float: -D__hardfp} \
+"
+
+#define STARTFILE_WINDISS_SPEC "crt0.o%s crtbegin.o%s"
+
+#define ENDFILE_WINDISS_SPEC "crtend.o%s"
+
+#define LINK_START_WINDISS_SPEC ""
+
+#define LINK_OS_WINDISS_SPEC ""
+
+/* Define any extra SPECS that the compiler needs to generate.  */
+/* Override rs6000.h definition.  */
+#undef	SUBTARGET_EXTRA_SPECS
+#define	SUBTARGET_EXTRA_SPECS						\
+  { "crtsavres_default",        CRTSAVRES_DEFAULT_SPEC },              \
+  { "lib_ads",			LIB_ADS_SPEC },				\
+  { "lib_yellowknife",		LIB_YELLOWKNIFE_SPEC },			\
+  { "lib_mvme",			LIB_MVME_SPEC },			\
+  { "lib_sim",			LIB_SIM_SPEC },				\
+  { "lib_freebsd",		LIB_FREEBSD_SPEC },			\
+  { "lib_gnu",			LIB_GNU_SPEC },				\
+  { "lib_linux",		LIB_LINUX_SPEC },			\
+  { "lib_netbsd",		LIB_NETBSD_SPEC },			\
+  { "lib_openbsd",		LIB_OPENBSD_SPEC },			\
+  { "lib_windiss",              LIB_WINDISS_SPEC },                     \
+  { "lib_default",		LIB_DEFAULT_SPEC },			\
+  { "startfile_ads",		STARTFILE_ADS_SPEC },			\
+  { "startfile_yellowknife",	STARTFILE_YELLOWKNIFE_SPEC },		\
+  { "startfile_mvme",		STARTFILE_MVME_SPEC },			\
+  { "startfile_sim",		STARTFILE_SIM_SPEC },			\
+  { "startfile_freebsd",	STARTFILE_FREEBSD_SPEC },		\
+  { "startfile_gnu",		STARTFILE_GNU_SPEC },			\
+  { "startfile_linux",		STARTFILE_LINUX_SPEC },			\
+  { "startfile_netbsd",		STARTFILE_NETBSD_SPEC },		\
+  { "startfile_openbsd",	STARTFILE_OPENBSD_SPEC },		\
+  { "startfile_windiss",        STARTFILE_WINDISS_SPEC },               \
+  { "startfile_default",	STARTFILE_DEFAULT_SPEC },		\
+  { "endfile_ads",		ENDFILE_ADS_SPEC },			\
+  { "endfile_yellowknife",	ENDFILE_YELLOWKNIFE_SPEC },		\
+  { "endfile_mvme",		ENDFILE_MVME_SPEC },			\
+  { "endfile_sim",		ENDFILE_SIM_SPEC },			\
+  { "endfile_freebsd",		ENDFILE_FREEBSD_SPEC },			\
+  { "endfile_gnu",		ENDFILE_GNU_SPEC },			\
+  { "endfile_linux",		ENDFILE_LINUX_SPEC },			\
+  { "endfile_netbsd",		ENDFILE_NETBSD_SPEC },			\
+  { "endfile_openbsd",		ENDFILE_OPENBSD_SPEC },			\
+  { "endfile_windiss",          ENDFILE_WINDISS_SPEC },                 \
+  { "endfile_default",		ENDFILE_DEFAULT_SPEC },			\
+  { "link_path",		LINK_PATH_SPEC },			\
+  { "link_shlib",		LINK_SHLIB_SPEC },			\
+  { "link_target",		LINK_TARGET_SPEC },			\
+  { "link_start",		LINK_START_SPEC },			\
+  { "link_start_ads",		LINK_START_ADS_SPEC },			\
+  { "link_start_yellowknife",	LINK_START_YELLOWKNIFE_SPEC },		\
+  { "link_start_mvme",		LINK_START_MVME_SPEC },			\
+  { "link_start_sim",		LINK_START_SIM_SPEC },			\
+  { "link_start_freebsd",	LINK_START_FREEBSD_SPEC },		\
+  { "link_start_gnu",		LINK_START_GNU_SPEC },			\
+  { "link_start_linux",		LINK_START_LINUX_SPEC },		\
+  { "link_start_netbsd",	LINK_START_NETBSD_SPEC },		\
+  { "link_start_openbsd",	LINK_START_OPENBSD_SPEC },		\
+  { "link_start_windiss",	LINK_START_WINDISS_SPEC },		\
+  { "link_start_default",	LINK_START_DEFAULT_SPEC },		\
+  { "link_os",			LINK_OS_SPEC },				\
+  { "link_os_ads",		LINK_OS_ADS_SPEC },			\
+  { "link_os_yellowknife",	LINK_OS_YELLOWKNIFE_SPEC },		\
+  { "link_os_mvme",		LINK_OS_MVME_SPEC },			\
+  { "link_os_sim",		LINK_OS_SIM_SPEC },			\
+  { "link_os_freebsd",		LINK_OS_FREEBSD_SPEC },			\
+  { "link_os_linux",		LINK_OS_LINUX_SPEC },			\
+  { "link_os_gnu",		LINK_OS_GNU_SPEC },			\
+  { "link_os_netbsd",		LINK_OS_NETBSD_SPEC },			\
+  { "link_os_openbsd",		LINK_OS_OPENBSD_SPEC },			\
+  { "link_os_windiss",		LINK_OS_WINDISS_SPEC },			\
+  { "link_os_default",		LINK_OS_DEFAULT_SPEC },			\
+  { "cc1_endian_big",		CC1_ENDIAN_BIG_SPEC },			\
+  { "cc1_endian_little",	CC1_ENDIAN_LITTLE_SPEC },		\
+  { "cc1_endian_default",	CC1_ENDIAN_DEFAULT_SPEC },		\
+  { "cpp_os_ads",		CPP_OS_ADS_SPEC },			\
+  { "cpp_os_yellowknife",	CPP_OS_YELLOWKNIFE_SPEC },		\
+  { "cpp_os_mvme",		CPP_OS_MVME_SPEC },			\
+  { "cpp_os_sim",		CPP_OS_SIM_SPEC },			\
+  { "cpp_os_freebsd",		CPP_OS_FREEBSD_SPEC },			\
+  { "cpp_os_gnu",		CPP_OS_GNU_SPEC },			\
+  { "cpp_os_linux",		CPP_OS_LINUX_SPEC },			\
+  { "cpp_os_netbsd",		CPP_OS_NETBSD_SPEC },			\
+  { "cpp_os_openbsd",		CPP_OS_OPENBSD_SPEC },			\
+  { "cpp_os_windiss",           CPP_OS_WINDISS_SPEC },                  \
+  { "cpp_os_default",		CPP_OS_DEFAULT_SPEC },			\
+  { "fbsd_dynamic_linker",	FBSD_DYNAMIC_LINKER },			\
+  SUBSUBTARGET_EXTRA_SPECS
+
+#define	SUBSUBTARGET_EXTRA_SPECS
+
+/* Define this macro as a C expression for the initializer of an
+   array of string to tell the driver program which options are
+   defaults for this target and thus do not need to be handled
+   specially when using `MULTILIB_OPTIONS'.
+
+   Do not define this macro if `MULTILIB_OPTIONS' is not defined in
+   the target makefile fragment or if none of the options listed in
+   `MULTILIB_OPTIONS' are set by default.  *Note Target Fragment::.  */
+
+#define	MULTILIB_DEFAULTS { "mbig", "mcall-sysv" }
+
+/* Define this macro if the code for function profiling should come
+   before the function prologue.  Normally, the profiling code comes
+   after.  */
+#define PROFILE_BEFORE_PROLOGUE 1
+
+/* Function name to call to do profiling.  */
+#define RS6000_MCOUNT "_mcount"
+
+/* Define this macro (to a value of 1) if you want to support the
+   Win32 style pragmas #pragma pack(push,<n>)' and #pragma
+   pack(pop)'.  The pack(push,<n>) pragma specifies the maximum
+   alignment (in bytes) of fields within a structure, in much the
+   same way as the __aligned__' and __packed__' __attribute__'s
+   do.  A pack value of zero resets the behavior to the default.
+   Successive invocations of this pragma cause the previous values to
+   be stacked, so that invocations of #pragma pack(pop)' will return
+   to the previous value.  */
+
+#define HANDLE_PRAGMA_PACK_PUSH_POP 1
+
+/* Select a format to encode pointers in exception handling data.  CODE
+   is 0 for data, 1 for code labels, 2 for function pointers.  GLOBAL is
+   true if the symbol may be affected by dynamic relocations.  */
+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL)			     \
+  ((flag_pic || TARGET_RELOCATABLE)					     \
+   ? (((GLOBAL) ? DW_EH_PE_indirect : 0) | DW_EH_PE_pcrel | DW_EH_PE_sdata4) \
+   : DW_EH_PE_absptr)
+
+#define DOUBLE_INT_ASM_OP "\t.quad\t"
+
+/* Generate entries in .fixup for relocatable addresses.  */
+#define RELOCATABLE_NEEDS_FIXUP 1
diff -Nurp gcc-3.4.6.orig/gcc/config/s390/linux.h gcc-3.4.6/gcc/config/s390/linux.h
--- gcc-3.4.6.orig/gcc/config/s390/linux.h	2003-11-29 04:08:13.000000000 +0100
+++ gcc-3.4.6/gcc/config/s390/linux.h	2006-11-08 18:56:53.000000000 +0100
@@ -77,6 +77,13 @@ Software Foundation, 59 Temple Place - S
 #define MULTILIB_DEFAULTS { "m31" }
 #endif
 
+#ifdef USE_UCLIBC
+#define ELF31_DYNAMIC_LINKER "/lib/ld-uClibc.so.0"
+#define ELF64_DYNAMIC_LINKER "/lib/ld64-uClibc.so.0"
+#else
+#define ELF31_DYNAMIC_LINKER "/lib/ld.so.1"
+#define ELF64_DYNAMIC_LINKER "/lib/ld64.so.1"
+#endif
 #undef  LINK_SPEC
 #define LINK_SPEC \
   "%{m31:-m elf_s390}%{m64:-m elf64_s390} \
@@ -86,8 +93,8 @@ Software Foundation, 59 Temple Place - S
       %{!static: \
 	%{rdynamic:-export-dynamic} \
 	%{!dynamic-linker: \
-          %{m31:-dynamic-linker /lib/ld.so.1} \
-          %{m64:-dynamic-linker /lib/ld64.so.1}}}}"
+          %{m31:-dynamic-linker " ELF31_DYNAMIC_LINKER "} \
+          %{m64:-dynamic-linker " ELF64_DYNAMIC_LINKER "}}}}"
 
 
 #define TARGET_ASM_FILE_END file_end_indicate_exec_stack
diff -Nurp gcc-3.4.6.orig/gcc/config/sh/linux.h gcc-3.4.6/gcc/config/sh/linux.h
--- gcc-3.4.6.orig/gcc/config/sh/linux.h	2004-01-12 03:29:13.000000000 +0100
+++ gcc-3.4.6/gcc/config/sh/linux.h	2006-11-08 18:56:53.000000000 +0100
@@ -73,11 +73,16 @@ do { \
 #undef SUBTARGET_LINK_EMUL_SUFFIX
 #define SUBTARGET_LINK_EMUL_SUFFIX "_linux"
 #undef SUBTARGET_LINK_SPEC
+#ifdef USE_UCLIBC
+#define ELF_DYNAMIC_LINKER "/lib/ld-uClibc.so.0"
+#else
+#define ELF_DYNAMIC_LINKER "/lib/ld-linux.so.2"
+#endif
 #define SUBTARGET_LINK_SPEC \
   "%{shared:-shared} \
    %{!static: \
      %{rdynamic:-export-dynamic} \
-     %{!dynamic-linker:-dynamic-linker /lib/ld-linux.so.2}} \
+     %{!dynamic-linker:-dynamic-linker " ELF_DYNAMIC_LINKER "}} \
    %{static:-static}"
 
 #undef LIB_SPEC
diff -Nurp gcc-3.4.6.orig/gcc/config/sparc/linux64.h gcc-3.4.6/gcc/config/sparc/linux64.h
--- gcc-3.4.6.orig/gcc/config/sparc/linux64.h	2004-06-06 05:55:17.000000000 +0200
+++ gcc-3.4.6/gcc/config/sparc/linux64.h	2006-11-08 18:56:53.000000000 +0100
@@ -167,12 +167,17 @@ Boston, MA 02111-1307, USA.  */
   { "link_arch_default", LINK_ARCH_DEFAULT_SPEC },	  \
   { "link_arch",	 LINK_ARCH_SPEC },
     
+#ifdef USE_UCLIBC
+#define ELF_DYNAMIC_LINKER	"/lib/ld-uClibc.so.0"
+#else
+#define ELF_DYNAMIC_LINKER  "/lib/ld-linux.so.2"
+#endif
 #define LINK_ARCH32_SPEC "-m elf32_sparc -Y P,/usr/lib %{shared:-shared} \
   %{!shared: \
     %{!ibcs: \
       %{!static: \
         %{rdynamic:-export-dynamic} \
-        %{!dynamic-linker:-dynamic-linker /lib/ld-linux.so.2}} \
+        %{!dynamic-linker:-dynamic-linker " ELF_DYNAMIC_LINKER "}} \
         %{static:-static}}} \
 "
 
diff -Nurp gcc-3.4.6.orig/gcc/config/sparc/linux.h gcc-3.4.6/gcc/config/sparc/linux.h
--- gcc-3.4.6.orig/gcc/config/sparc/linux.h	2004-06-06 05:55:17.000000000 +0200
+++ gcc-3.4.6/gcc/config/sparc/linux.h	2006-11-08 18:56:53.000000000 +0100
@@ -162,13 +162,18 @@ Boston, MA 02111-1307, USA.  */
         %{!dynamic-linker:-dynamic-linker /lib/ld-linux.so.1}} \
         %{static:-static}}}"
 #else
+#ifdef USE_UCLIBC
+#define ELF_DYNAMIC_LINKER "/lib/ld-uClibc.so.0"
+#else
+#define ELF_DYNAMIC_LINKER "/lib/ld-linux.so.2"
+#endif
 #define LINK_SPEC "-m elf32_sparc -Y P,/usr/lib %{shared:-shared} \
   %{!mno-relax:%{!r:-relax}} \
   %{!shared: \
     %{!ibcs: \
       %{!static: \
         %{rdynamic:-export-dynamic} \
-        %{!dynamic-linker:-dynamic-linker /lib/ld-linux.so.2}} \
+        %{!dynamic-linker:-dynamic-linker " ELF_DYNAMIC_LINKER "}} \
         %{static:-static}}}"
 #endif
 
diff -Nurp gcc-3.4.6.orig/gcc/config/t-linux-uclibc gcc-3.4.6/gcc/config/t-linux-uclibc
--- gcc-3.4.6.orig/gcc/config/t-linux-uclibc	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/config/t-linux-uclibc	2006-11-08 18:56:53.000000000 +0100
@@ -0,0 +1,5 @@
+# Remove glibc specific files added in t-linux
+SHLIB_MAPFILES := $(filter-out $(srcdir)/config/libgcc-glibc.ver, $(SHLIB_MAPFILES))
+
+# Use unwind-dw2-fde instead of unwind-dw2-fde-glibc
+LIB2ADDEH := $(subst unwind-dw2-fde-glibc.c,unwind-dw2-fde.c,$(LIB2ADDEH))
diff -Nurp gcc-3.4.6.orig/gcc/config.gcc gcc-3.4.6/gcc/config.gcc
--- gcc-3.4.6.orig/gcc/config.gcc	2005-07-19 23:08:48.000000000 +0200
+++ gcc-3.4.6/gcc/config.gcc	2006-11-08 18:56:53.000000000 +0100
@@ -2322,6 +2322,12 @@ am33_2.0-*-linux*)
 	;;
 esac
 
+# Rather than hook into each target, just do it after all the linux
+# targets have been processed
+case ${target} in
+*-linux-uclibc*) tm_defines="${tm_defines} USE_UCLIBC" ; tmake_file="${tmake_file} t-linux-uclibc"
+esac
+
 # Support for --with-cpu and related options (and a few unrelated options,
 # too).
 case ${with_cpu} in
diff -Nurp gcc-3.4.6.orig/gcc/config.gcc.orig gcc-3.4.6/gcc/config.gcc.orig
--- gcc-3.4.6.orig/gcc/config.gcc.orig	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/config.gcc.orig	2005-07-19 23:08:48.000000000 +0200
@@ -0,0 +1,2838 @@
+# GCC target-specific configuration file.
+# Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
+# Free Software Foundation, Inc.
+
+#This file is part of GCC.
+
+#GCC is free software; you can redistribute it and/or modify it under
+#the terms of the GNU General Public License as published by the Free
+#Software Foundation; either version 2, or (at your option) any later
+#version.
+
+#GCC is distributed in the hope that it will be useful, but WITHOUT
+#ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+#FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+#for more details.
+
+#You should have received a copy of the GNU General Public License
+#along with GCC; see the file COPYING.  If not, write to the Free
+#Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+#02111-1307, USA.
+
+# This is the GCC target-specific configuration file
+# where a configuration type is mapped to different system-specific
+# definitions and files.  This is invoked by the autoconf-generated
+# configure script.  Putting it in a separate shell file lets us skip
+# running autoconf when modifying target-specific information.
+
+# This file switches on the shell variable ${target}, and also uses the
+# following shell variables:
+#
+#  with_*		Various variables as set by configure.
+#
+#  enable_threads_flag	Either the name, yes or no depending on whether
+#			threads support was requested.
+#
+#  default_use_cxa_atexit
+#			"no" by default, can be set to "yes" if a target
+#			wishes to use __cxa_atexit() by default if the
+#			$enable___cxa_atexit variable is not set.
+#
+#  gas_flag		Either yes or no depending on whether GNU as was
+#			requested.
+#
+#  gnu_ld_flag		Either yes or no depending on whether GNU ld was
+#			requested.
+
+# This file sets the following shell variables for use by the
+# autoconf-generated configure script:
+#
+#  cpu_type		The name of the cpu, if different from the first
+#			chunk of the canonical target name.
+#
+#  tm_defines		List of target macros to define for all compilations.
+#
+#  tm_file		A list of target macro files, if different from
+#			"$cpu_type/$cpu_type.h". Usually it's constructed
+#			per target in a way like this:
+#			tm_file="${tm_file} dbxelf.h elfos.h svr4.h ${cpu_type.h}/elf.h"
+#			Note that the preferred order is:
+#			- specific target header "${cpu_type}/${cpu_type.h}"
+#			- generic headers like dbxelf.h elfos.h, netware.h, etc.
+#			- specializing target headers like ${cpu_type.h}/elf.h
+#			This helps to keep OS specific stuff out of the CPU
+#			defining header ${cpu_type}/${cpu_type.h}.
+#
+#  tm_p_file		Location of file with declarations for functions
+#			in $out_file.
+#
+#  out_file		The name of the machine description C support
+#			file, if different from "$cpu_type/$cpu_type.c".
+#
+#  md_file		The name of the machine-description file, if
+#			different from "$cpu_type/$cpu_type.md".
+#
+#  tmake_file		A list of machine-description-specific
+#			makefile-fragments, if different from
+#			"$cpu_type/t-$cpu_type".
+#
+#  extra_modes          The name of the file containing a list of extra
+#                       machine modes, if necessary and different from
+#                       "$cpu_type/$cpu_type-modes.def".
+#
+#  extra_objs		List of extra objects that should be linked into
+#			the compiler proper (cc1, cc1obj, cc1plus)
+#			depending on target.
+#
+#  extra_gcc_objs	List of extra objects that should be linked into
+#			the compiler driver (gcc) depending on target.
+#
+#  extra_headers	List of used header files from the directory
+#			config/${cpu_type}.
+#
+#  extra_passes		List of extra executables compiled for this target
+#			machine, used for compiling from source to object.
+#
+#  extra_parts		List of extra object files that should be compiled
+#			for this target machine.
+#
+#  extra_programs	Like extra_passes, but these are used when linking.
+#
+#  c_target_objs	List of extra target-dependent objects that be
+#			linked into the C compiler only.
+#
+#  cxx_target_objs	List of extra target-dependent objects that be
+#			linked into the C++ compiler only.
+#
+#  target_gtfiles       List of extra source files with type information.
+#
+#  xm_defines		List of macros to define when compiling for the
+#			target machine.
+#
+#  xm_file		List of files to include when compiling for the
+#			target machine.
+#
+#  use_collect2		Set to yes or no, depending on whether collect2
+#			will be used.
+#
+#  target_cpu_default	Set to override the default target model.
+#
+#  gdb_needs_out_file_path
+#			Set to yes if gdb needs a dir command with
+#			`dirname $out_file`.
+#
+#  thread_file		Set to control which thread package to use.
+#
+#  gas			Set to yes or no depending on whether the target
+#			system normally uses GNU as.
+#
+#  need_64bit_hwint	Set to yes if HOST_WIDE_INT must be 64 bits wide
+#			for this target.  This is true iff
+#			MAX_LONG_TYPE_SIZE is 64.  (The code which
+#			determines the underlying integral type for
+#			HOST_WIDE_INT cannot see the definition of
+#			MAX_LONG_TYPE_SIZE.)
+#
+#  configure_default_options
+#			Set to an initializer for configure_default_options
+#			in configargs.h, based on --with-cpu et cetera.
+#
+#  use_fixproto		Set to "yes" if fixproto should be run normally,
+#			"no" if fixproto should never be run.
+
+# The following variables are used in each case-construct to build up the
+# outgoing variables:
+#
+#  gnu_ld		Set to yes or no depending on whether the target
+#			system normally uses GNU ld.
+
+out_file=
+tmake_file=
+extra_headers=
+extra_passes=
+extra_parts=
+extra_programs=
+extra_objs=
+extra_gcc_objs=
+c_target_objs=
+cxx_target_objs=
+tm_defines=
+xm_defines=
+# Set this to force installation and use of collect2.
+use_collect2=
+# Set this to override the default target model.
+target_cpu_default=
+# Set this if gdb needs a dir command with `dirname $out_file`
+gdb_needs_out_file_path=
+# Set this to control which thread package will be used.
+thread_file=
+# Reinitialize these from the flag values every loop pass, since some
+# configure entries modify them.
+gas="$gas_flag"
+gnu_ld="$gnu_ld_flag"
+enable_threads=$enable_threads_flag
+default_use_cxa_atexit=no
+target_gtfiles=
+need_64bit_hwint=
+
+# Default to not using fixproto.  Targets which need fixproto should
+# specifically set this to 'yes'.
+use_fixproto=no
+
+# Don't carry these over build->host->target.  Please.
+xm_file=
+md_file=
+
+# Obsolete configurations.
+case ${target} in
+ d30v-* | \
+ dsp16xx-* | \
+ i370-* | \
+ i960-* | \
+ i?86-moss-msdos | i?86-*-moss* | \
+ i?86-ncr-sysv4* | \
+ i?86-*-netware | \
+ i?86-*-freebsd2* | i?86-*-freebsd*aout* | \
+ i?86-*-linux*aout* | \
+ i?86-*-linux*libc1* | \
+ i?86-*-interix | \
+ i?86-*-mach* | \
+ i?86-*-udk* | \
+ i?86-*-sysv[123]* | \
+ i386-*-vsta | \
+ m68k-hp-hpux* | m68000-hp-hpux* | \
+ m68k-*-sysv4*)
+    if test "x$enable_obsolete" != xyes; then
+      echo "*** Configuration ${target} is obsolete." >&2
+      echo "*** Specify --enable-obsolete to build it anyway." >&2
+      echo "*** Support will be REMOVED in the next major release of GCC," >&2
+      echo "*** unless a maintainer comes forward." >&2
+      exit 1
+    fi;;
+esac
+
+# Unsupported targets list.  Do not put an entry in this list unless
+# it would otherwise be caught by a more permissive pattern.  The list
+# should be in alphabetical order.
+case ${target} in
+   alpha*-*-linux*libc1*		\
+ | i[34567]86-sequent-sysv		\
+ | i[34567]86-sequent-sysv[123]*	\
+ | i[34567]86-go32-*			\
+ | i[34567]86-*-go32*			\
+ | m68k-*-linux*aout*			\
+ | m68k-*-linux*libc1*			\
+ | mips64orion*-*-rtems*		\
+ | powerpc-*-linux*libc1*		\
+ | sparc-*-linux*aout*			\
+ | sparc-*-linux*libc1*			\
+ | sparc-hal-solaris2*			\
+ | thumb-*-*				\
+ | *-*-linux*coff*			\
+ | *-*-linux*oldld*			\
+ | *-*-rtemsaout*			\
+ | *-*-rtemscoff*			\
+ | vax-*-vms*				\
+ )
+	echo "*** Configuration ${target} not supported" 1>&2
+	exit 1
+	;;
+esac
+
+# Set default cpu_type, tm_file, tm_p_file and xm_file so it can be
+# updated in each machine entry.  Also set default extra_headers for some
+# machines.
+tm_p_file=
+cpu_type=`echo ${target} | sed 's/-.*$//'`
+cpu_is_64bit=
+case ${target} in
+alpha*-*-*)
+	cpu_type=alpha
+	need_64bit_hwint=yes
+	;;
+am33_2.0-*-linux*)
+	cpu_type=mn10300
+	;;
+strongarm*-*-*)
+	cpu_type=arm
+	;;
+arm*-*-*)
+	cpu_type=arm
+	extra_headers="mmintrin.h"
+	;;
+ep9312*-*-*)
+	cpu_type=arm
+	;;
+xscale-*-*)
+	cpu_type=arm
+	extra_headers="mmintrin.h"
+	;;
+i[34567]86-*-*)
+	cpu_type=i386
+	extra_headers="mmintrin.h xmmintrin.h emmintrin.h pmmintrin.h"
+	;;
+x86_64-*-*)
+	cpu_type=i386
+	extra_headers="mmintrin.h xmmintrin.h emmintrin.h pmmintrin.h"
+	need_64bit_hwint=yes
+	;;
+ia64-*-*)
+	extra_headers=ia64intrin.h
+	need_64bit_hwint=yes
+	;;
+hppa*-*-* | parisc*-*-*)
+	cpu_type=pa
+	;;
+m32r*-*-*)
+        cpu_type=m32r
+        ;;
+m680[012]0-*-*)
+	cpu_type=m68k
+	extra_headers=math-68881.h
+	;;
+m68k-*-*)
+	extra_headers=math-68881.h
+	;;
+mips*-*-*)
+	cpu_type=mips
+	need_64bit_hwint=yes
+	;;
+powerpc*-*-*)
+	cpu_type=rs6000
+	extra_headers="ppc-asm.h altivec.h spe.h"
+	need_64bit_hwint=yes
+	case x$with_cpu in
+	    xpowerpc64|xdefault64|x6[23]0|x970|xG5|xpower[345]|xrs64a)
+		cpu_is_64bit=yes
+		;;
+	esac
+	;;
+rs6000*-*-*)
+	need_64bit_hwint=yes
+	;;
+sparc64*-*-*)
+	cpu_type=sparc
+	need_64bit_hwint=yes
+	;;
+sparc*-*-*)
+	cpu_type=sparc
+	;;
+s390*-*-*)
+	need_64bit_hwint=yes
+	;;
+# Note the 'l'; we need to be able to match e.g. "shle" or "shl".
+sh[123456789l]*-*-*)
+	cpu_type=sh
+	need_64bit_hwint=yes
+	;;
+tic4x-*-*)
+        cpu_type=c4x
+        ;;
+esac
+
+tm_file=${cpu_type}/${cpu_type}.h
+if test -f ${srcdir}/config/${cpu_type}/${cpu_type}-protos.h
+then
+	tm_p_file=${cpu_type}/${cpu_type}-protos.h
+fi
+extra_modes=
+if test -f ${srcdir}/config/${cpu_type}/${cpu_type}-modes.def
+then
+	extra_modes=${cpu_type}/${cpu_type}-modes.def
+fi
+
+case ${target} in
+x86_64-*-*)
+	tm_file="i386/biarch64.h ${tm_file}"
+	;;
+esac
+
+# On a.out targets, we need to use collect2.
+case ${target} in
+*-*-*aout*)
+	use_collect2=yes
+	;;
+esac
+
+# Common parts for widely ported systems.
+case ${target} in
+*-*-darwin*)
+  tm_file="${tm_file} darwin.h"
+  tm_p_file="${tm_p_file} darwin-protos.h"
+  tmake_file="t-darwin"
+  target_gtfiles="\$(srcdir)/config/darwin.c"
+  c_target_objs="darwin-c.o"
+  cxx_target_objs="darwin-c.o"
+  extra_parts="crt2.o"
+  extra_objs="darwin.o"
+  case ${enable_threads} in
+    "" | yes | posix) thread_file='posix' ;;
+  esac
+  ;;
+*-*-freebsd[12] | *-*-freebsd[12].* | *-*-freebsd*aout*)
+  # This is the place-holder for the generic a.out configuration
+  # of FreeBSD.  No actual configuration resides here since
+  # there was only ever a bare-bones ix86 configuration for
+  # a.out and it exists solely in the machine-specific section.
+  # This place-holder must exist to avoid dropping into
+  # the generic ELF configuration of FreeBSD (i.e. it must be
+  # ordered before that section).
+  ;;
+*-*-freebsd*)
+  # This is the generic ELF configuration of FreeBSD.  Later
+  # machine-specific sections may refine and add to this
+  # configuration.
+  #
+  # Due to tm_file entry ordering issues that vary between cpu
+  # architectures, we only define fbsd_tm_file to allow the
+  # machine-specific section to dictate the final order of all
+  # entries of tm_file with the minor exception that components
+  # of the tm_file set here will always be of the form:
+  #
+  # freebsd<version_number>.h [freebsd-<conf_option>.h ...] freebsd-spec.h freebsd.h
+  #
+  # The machine-specific section should not tamper with this
+  # ordering but may order all other entries of tm_file as it
+  # pleases around the provided core setting.
+  gas=yes
+  gnu_ld=yes
+  extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o"
+  case ${target} in
+    *-*-freebsd3 | *-*-freebsd[3].*)
+      tm_defines="${tm_defines} FBSD_MAJOR=3" ;;
+    *-*-freebsd4 | *-*-freebsd[4].*)
+      tm_defines="${tm_defines} FBSD_MAJOR=4" ;;
+    *-*-freebsd5 | *-*-freebsd[5].*)
+      tm_defines="${tm_defines} FBSD_MAJOR=5" ;;
+    *-*-freebsd6 | *-*-freebsd[6].*)
+      tm_defines="${tm_defines} FBSD_MAJOR=6" ;;
+    *-*-freebsd7 | *-*-freebsd[7].*)
+      tm_defines="${tm_defines} FBSD_MAJOR=7" ;;
+    *-*-freebsd8 | *-*-freebsd[8].*)
+      tm_defines="${tm_defines} FBSD_MAJOR=8" ;;
+    *-*-freebsd9 | *-*-freebsd[9].*)
+      tm_defines="${tm_defines} FBSD_MAJOR=9" ;;
+    *)
+      echo 'Please update *-*-freebsd* in gcc/config.gcc'
+      exit 1
+      ;;
+  esac
+  tmake_file="t-slibgcc-elf-ver t-freebsd"
+  case ${enable_threads} in
+    no)
+      fbsd_tm_file="${fbsd_tm_file} freebsd-nthr.h"
+      ;;
+    "" | yes | posix)
+      thread_file='posix'
+      tmake_file="${tmake_file} t-freebsd-thread"
+      # Before 5.0, FreeBSD can't bind shared libraries to -lc
+      # when "optionally" threaded via weak pthread_* checks.
+      case ${target} in
+        *-*-freebsd[34] | *-*-freebsd[34].*)
+          tmake_file="${tmake_file} t-slibgcc-nolc-override"
+          ;;
+      esac
+      ;;
+    *) 
+      echo 'Unknown thread configuration for FreeBSD'
+      exit 1
+      ;;
+  esac
+  fbsd_tm_file="${fbsd_tm_file} freebsd-spec.h freebsd.h"
+  ;;
+*-*-kfreebsd*-gnu)
+  # Must come before *-*-gnu*
+  xm_defines=POSIX # needed for cross-compiling from FreeBSD?
+  extra_parts="crtbegin.o crtbeginS.o crtbeginT.o crtend.o crtendS.o"
+  # GNU tools are the only tools.
+  gas=yes
+  gnu_ld=yes
+  case ${enable_threads} in
+    "" | yes | posix) thread_file='posix' ;;
+  esac
+  ;;
+*-*-linux*libc1* | *-*-linux*aout*)
+  # Avoid the generic linux case.
+  ;;
+*-*-linux*)
+  # Must come before *-*-gnu* (because of *-*-linux-gnu* systems).
+  extra_parts="crtbegin.o crtbeginS.o crtbeginT.o crtend.o crtendS.o"
+  gas=yes
+  gnu_ld=yes
+  case ${enable_threads} in
+    "" | yes | posix) thread_file='posix' ;;
+  esac
+  ;;
+*-*-gnu*)
+  # On the Hurd, the setup is just about the same on
+  # each different CPU.  The specific machines that we
+  # support are matched above and just set $cpu_type.
+  tm_file="${cpu_type}/gnu.h"
+  extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o"
+  # GNU tools are the only tools.
+  gas=yes
+  gnu_ld=yes
+  # These details are the same as for Linux.
+  # But here we need a little extra magic.
+  tmake_file="t-slibgcc-elf-ver t-linux t-gnu"
+  case ${target} in
+    alpha*)
+      tm_file="${cpu_type}/${cpu_type}.h alpha/elf.h alpha/linux.h alpha/linux-elf.h gnu.h ${tm_file}"
+      ;;
+    i[34567]86-*-*)
+      tm_file="${cpu_type}/${cpu_type}.h i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h linux.h i386/linux.h gnu.h ${tm_file}"
+      ;;
+  esac
+  ;;
+*-*-netbsd*)
+  tmake_file="t-slibgcc-elf-ver t-libc-ok t-netbsd t-libgcc-pic"
+  gas=yes
+  gnu_ld=yes
+
+  # NetBSD 2.0 and later get POSIX threads enabled by default.
+  # Allow them to be explicitly enabled on any other version.
+  case ${enable_threads} in
+    "")
+      case ${target} in
+        *-*-netbsd[2-9]* | *-*-netbsdelf[2-9]*)
+          thread_file='posix'
+          tm_defines="${tm_defines} NETBSD_ENABLE_PTHREADS"
+          ;;
+      esac
+      ;;
+    yes | posix)
+      thread_file='posix'
+      tm_defines="${tm_defines} NETBSD_ENABLE_PTHREADS"
+      ;;
+  esac
+
+  # NetBSD 1.7 and later are set up to use GCC's crtstuff for
+  # ELF configurations.  We will clear extra_parts in the
+  # a.out configurations.
+  case ${target} in
+    *-*-netbsd*1.[7-9]* | *-*-netbsd[2-9]* | *-*-netbsdelf[2-9]*)
+      extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o"
+      ;;
+  esac
+
+  # NetBSD 2.0 and later provide __cxa_atexit(), which we use by
+  # default (unless overridden by --disable-__cxa_atexit).
+  case ${target} in
+    *-*-netbsd[2-9]* | *-*-netbsdelf[2-9]*)
+      default_use_cxa_atexit=yes
+      ;;
+  esac
+  ;;
+*-*-openbsd*)
+  tmake_file="t-libc-ok t-openbsd t-libgcc-pic"
+  case ${enable_threads} in
+    yes)
+      thread_file='posix'
+      tmake_file="${tmake_file} t-openbsd-thread"
+      ;;
+  esac
+  ;;
+*-*-rtems*)
+  case ${enable_threads} in
+    yes) thread_file='rtems' ;;
+  esac
+  ;;
+*-*-vxworks*)
+  tmake_file=t-vxworks
+  tm_file="${tm_file} elfos.h svr4.h vxworks.h"
+  case ${enable_threads} in
+    no) ;;
+    "" | yes | vxworks) thread_file='vxworks' ;;
+    *) echo 'Unknown thread configuration for VxWorks'; exit 1 ;;
+  esac
+  use_collect2=yes
+  xm_defines=POSIX
+  ;;
+esac
+
+case ${target} in
+# Support site-specific machine types.
+*local*)
+	rest=`echo ${target} | sed -e "s/$cpu_type-//"`
+	tm_file=${cpu_type}/$rest.h
+	if test -f $srcdir/config/${cpu_type}/xm-$rest.h
+	then xm_file=${cpu_type}/xm-$rest.h
+	fi
+	if test -f $srcdir/config/${cpu_type}/t-$rest
+	then tmake_file=${cpu_type}/t-$rest
+	fi
+	;;
+alpha*-*-unicosmk*)
+	use_collect2=yes
+	tm_file="${tm_file} alpha/unicosmk.h"
+
+	# Don't include t-ieee for now because we don't support that yet
+	# tmake_file="alpha/t-ieee"
+	tmake_file="alpha/t-unicosmk"
+	use_fixproto=yes
+	;;
+alpha*-*-linux*)
+	tm_file="${tm_file} alpha/elf.h alpha/linux.h alpha/linux-elf.h"
+	target_cpu_default="MASK_GAS"
+	tmake_file="t-slibgcc-elf-ver t-linux alpha/t-crtfm alpha/t-alpha alpha/t-ieee"
+	;;
+alpha*-*-gnu*)
+	target_cpu_default="MASK_GAS"
+	tmake_file="${tmake_file} alpha/t-crtfm alpha/t-alpha alpha/t-ieee"
+	;;
+alpha*-*-freebsd*)
+	tm_file="${tm_file} ${fbsd_tm_file} alpha/elf.h alpha/freebsd.h"
+	target_cpu_default="MASK_GAS"
+	tmake_file="${tmake_file} alpha/t-crtfm alpha/t-alpha alpha/t-ieee"
+	extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o"
+	;;
+alpha*-*-netbsd*)
+	tm_file="${tm_file} netbsd.h alpha/elf.h netbsd-elf.h alpha/netbsd.h"
+	target_cpu_default="MASK_GAS"
+	tmake_file="${tmake_file} alpha/t-alpha alpha/t-ieee"
+	;;
+alpha*-*-openbsd*)
+	tm_defines="OBSD_NO_DYNAMIC_LIBRARIES OBSD_HAS_DECLARE_FUNCTION_NAME OBSD_HAS_DECLARE_FUNCTION_SIZE OBSD_HAS_DECLARE_OBJECT"
+	tm_file="alpha/alpha.h openbsd.h alpha/openbsd.h"
+	# default x-alpha is only appropriate for dec-osf.
+	target_cpu_default="MASK_GAS"
+	tmake_file="alpha/t-alpha alpha/t-ieee"
+	;;
+alpha*-dec-osf[45]*)
+	if test x$stabs = xyes
+	then
+		tm_file="${tm_file} dbx.h"
+	fi
+	if test x$gas != xyes
+	then
+		extra_passes="mips-tfile mips-tdump"
+	fi
+	use_collect2=yes
+	tmake_file="alpha/t-alpha alpha/t-ieee alpha/t-crtfm alpha/t-osf4"
+	tm_file="${tm_file} alpha/osf.h"
+	extra_headers=va_list.h
+	case ${target} in
+	  *-*-osf4*)
+	    # Set target_cpu_default except on 4.0a.
+	    case ${target} in
+		*-*-osf4.0a) ;;
+		*) target_cpu_default=MASK_SUPPORT_ARCH
+	    esac
+	    ;;
+	  *-*-osf5*)
+	    tm_file="${tm_file} alpha/osf5.h"
+	    target_cpu_default=MASK_SUPPORT_ARCH
+	    ;;
+	esac
+	case ${enable_threads} in
+	  "" | yes | posix)
+	    thread_file='posix'
+	    tmake_file="${tmake_file} alpha/t-osf-pthread"
+	    ;;
+	esac
+	;;
+alpha64-dec-*vms*)
+	tm_file="${tm_file} alpha/vms.h alpha/vms64.h"
+	xm_file="alpha/xm-vms.h"
+	tmake_file="alpha/t-alpha alpha/t-vms alpha/t-vms64 alpha/t-ieee"
+	prefix=/gnu
+	local_prefix=/gnu
+	;;
+alpha*-dec-*vms*)
+	tm_file="${tm_file} alpha/vms.h"
+	xm_file=alpha/xm-vms.h
+	tmake_file="alpha/t-alpha alpha/t-vms alpha/t-ieee"
+	prefix=/gnu
+	local_prefix=/gnu
+	;;
+arc-*-elf*)
+	tm_file="dbxelf.h elfos.h svr4.h ${tm_file}"
+	extra_parts="crtinit.o crtfini.o"
+	use_fixproto=yes
+	;;
+arm-*-coff* | armel-*-coff*)
+	tm_file="arm/semi.h arm/aout.h arm/arm.h arm/coff.h dbxcoff.h"
+	tmake_file=arm/t-arm-coff
+	;;
+arm-semi-aof | armel-semi-aof)
+	tm_file="arm/semiaof.h arm/aof.h arm/arm.h"
+	tmake_file=arm/t-semi
+	;;
+arm-wrs-vxworks)
+	tm_file="dbxelf.h elfos.h svr4.h vxworks.h arm/elf.h arm/aout.h arm/arm.h arm/vxworks.h"
+	tmake_file="${tmake_file} arm/t-vxworks"
+	;;
+arm*-*-freebsd*|strongarm*-*-freebsd*)
+	tm_file="dbxelf.h elfos.h ${fbsd_tm_file} arm/elf.h arm/aout.h arm/freebsd.h arm/arm.h"
+	tmake_file="${tmake_file} arm/t-strongarm-elf"
+	;;
+arm*-*-netbsdelf*)
+	tm_file="dbxelf.h elfos.h netbsd.h netbsd-elf.h arm/elf.h arm/aout.h arm/arm.h arm/netbsd-elf.h"
+	tmake_file="${tmake_file} arm/t-netbsd"
+	;;
+arm*-*-netbsd*)
+	tm_file="arm/aout.h arm/arm.h netbsd.h netbsd-aout.h arm/netbsd.h"
+	tmake_file="t-netbsd arm/t-netbsd"
+	extra_parts=""
+	use_collect2=yes
+	;;
+arm*-*-linux*)			# ARM GNU/Linux with ELF
+	tm_file="dbxelf.h elfos.h linux.h arm/elf.h  arm/linux-gas.h arm/linux-elf.h arm/aout.h arm/arm.h"
+	tmake_file="t-slibgcc-elf-ver t-linux arm/t-linux"
+	extra_parts="crtbegin.o crtbeginS.o crtend.o crtendS.o"
+	gnu_ld=yes
+	;;
+arm*-*-uclinux*)		# ARM ucLinux
+	tm_file="dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h arm/linux-gas.h arm/linux-elf.h arm/uclinux-elf.h"
+	tmake_file=arm/t-arm-elf
+	;;
+arm*-*-ecos-elf)
+	tm_file="dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h arm/ecos-elf.h"
+	tmake_file=arm/t-arm-elf
+	;;
+arm*-*-rtems*)
+	tm_file="dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h arm/rtems-elf.h rtems.h"
+	tmake_file="arm/t-arm-elf t-rtems arm/t-rtems"
+	;;
+arm*-*-elf | ep9312-*-elf)
+	tm_file="dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h"
+	tmake_file=arm/t-arm-elf
+	;;
+arm*-wince-pe*)
+	tm_file="arm/semi.h arm/aout.h arm/arm.h arm/coff.h dbxcoff.h arm/pe.h arm/wince-pe.h"
+	tmake_file=arm/t-wince-pe
+	extra_objs="pe.o"
+	;;
+arm-*-pe*)
+	tm_file="arm/semi.h arm/aout.h arm/arm.h arm/coff.h dbxcoff.h arm/pe.h"
+	tmake_file=arm/t-pe
+	extra_objs="pe.o"
+	;;
+arm*-*-kaos*)
+	tm_file="dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h kaos.h arm/kaos-arm.h"
+	tmake_file=arm/t-arm-elf
+	;;
+avr-*-rtems*)
+	tm_file="avr/avr.h dbxelf.h avr/rtems.h rtems.h"
+	tmake_file="avr/t-avr t-rtems avr/t-rtems"
+	;;
+avr-*-*)
+	tm_file="avr/avr.h dbxelf.h"
+	use_fixproto=yes
+	;;
+c4x-*-rtems* | tic4x-*-rtems*)
+	tmake_file="c4x/t-c4x t-rtems c4x/t-rtems"
+	tm_file="c4x/c4x.h c4x/rtems.h rtems.h"
+	c_target_objs="c4x-c.o"
+	cxx_target_objs="c4x-c.o"
+	;;
+c4x-* | tic4x-*)
+	tmake_file=c4x/t-c4x
+	c_target_objs="c4x-c.o"
+	cxx_target_objs="c4x-c.o"
+	;;
+cris-*-aout)
+	tm_file="dbxelf.h ${tm_file} cris/aout.h"
+	gas=yes
+	tmake_file="cris/t-cris cris/t-aout"
+	;;
+cris-*-elf | cris-*-none)
+	tm_file="dbxelf.h elfos.h ${tm_file}"
+	tmake_file="cris/t-cris cris/t-elfmulti"
+	gas=yes
+	;;
+cris-*-linux*)
+	tm_file="dbxelf.h elfos.h svr4.h ${tm_file} linux.h cris/linux.h"
+	tmake_file="cris/t-cris t-slibgcc-elf-ver cris/t-linux"
+	;;
+d30v-*)
+	tm_file="dbxelf.h elfos.h svr4.h ${tm_file}"
+	;;
+dsp16xx-*)
+	use_fixproto=yes
+	;;
+fr30-*-elf)
+	tm_file="dbxelf.h elfos.h svr4.h ${tm_file}"
+	tmake_file=fr30/t-fr30
+	extra_parts="crti.o crtn.o crtbegin.o crtend.o"
+	use_fixproto=yes
+	;;
+frv-*-elf)
+	tm_file="dbxelf.h elfos.h svr4.h ${tm_file} frv/frv-abi.h"
+	tmake_file=frv/t-frv
+	use_fixproto=yes
+	;;
+h8300-*-rtems*)
+	tmake_file="h8300/t-h8300 t-rtems h8300/t-rtems"
+	tm_file="h8300/h8300.h dbxcoff.h h8300/coff.h h8300/rtems.h rtems.h"
+	;;
+h8300-*-elf*)
+	tmake_file="h8300/t-h8300 h8300/t-elf"
+	tm_file="h8300/h8300.h dbxelf.h elfos.h h8300/elf.h"
+	use_fixproto=yes
+	;;
+h8300-*-*)
+	tm_file="h8300/h8300.h dbxcoff.h h8300/coff.h"
+	use_fixproto=yes
+	;;
+hppa*64*-*-linux* | parisc*64*-*-linux*)
+	target_cpu_default="(MASK_PA_11 | MASK_PA_20)"
+	tm_file="pa/pa64-start.h ${tm_file} dbxelf.h elfos.h svr4.h linux.h \
+		 pa/pa-linux.h pa/pa64-regs.h pa/pa-64.h pa/pa64-linux.h"
+	tmake_file="t-slibgcc-elf-ver t-linux pa/t-linux64"
+	gas=yes gnu_ld=yes
+	need_64bit_hwint=yes
+	;;
+hppa*-*-linux* | parisc*-*-linux*)
+	target_cpu_default="MASK_PA_11 | MASK_NO_SPACE_REGS"
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h linux.h pa/pa-linux.h \
+		 pa/pa32-regs.h pa/pa32-linux.h"
+	tmake_file="t-slibgcc-elf-ver t-linux pa/t-linux"
+	# if not configured with --enable-sjlj-exceptions, bump the
+	# libgcc version number
+	if test x$sjlj != x1; then
+	    tmake_file="$tmake_file pa/t-slibgcc-elf-ver"
+	fi
+	;;
+# port not yet contributed.
+#hppa*-*-openbsd*)
+#	target_cpu_default="MASK_PA_11"
+#	;;
+hppa1.1-*-pro*)
+	target_cpu_default="(MASK_JUMP_IN_DELAY | MASK_PORTABLE_RUNTIME | MASK_GAS | MASK_NO_SPACE_REGS | MASK_SOFT_FLOAT)"
+	tm_file="${tm_file} pa/pa32-regs.h dbxelf.h elfos.h pa/elf.h pa/pa-pro-end.h libgloss.h"
+	tmake_file="pa/t-pro"
+	;;
+hppa1.1-*-osf*)
+	target_cpu_default="MASK_PA_11"
+	tm_file="${tm_file} pa/pa32-regs.h dbxelf.h pa/som.h pa/pa-osf.h"
+	tmake_file="pa/t-pa"
+	use_collect2=yes
+	;;
+hppa1.1-*-rtems*)
+	target_cpu_default="(MASK_JUMP_IN_DELAY | MASK_PORTABLE_RUNTIME | MASK_GAS | MASK_NO_SPACE_REGS | MASK_SOFT_FLOAT)"
+	tm_file="${tm_file} pa/pa32-regs.h dbxelf.h elfos.h pa/elf.h pa/pa-pro-end.h libgloss.h pa/rtems.h rtems.h"
+	tmake_file="pa/t-pro t-rtems"
+	;;
+hppa1.1-*-bsd*)
+	tm_file="${tm_file} pa/pa32-regs.h dbxelf.h pa/som.h"
+	target_cpu_default="MASK_PA_11"
+	tmake_file="pa/t-pa"
+	use_collect2=yes
+	;;
+hppa1.1-*-hpux10* | hppa2*-*-hpux10*)
+	target_cpu_default="MASK_PA_11"
+	tm_file="${tm_file} pa/pa32-regs.h dbxelf.h pa/som.h pa/pa-hpux.h pa/pa-hpux10.h"
+	tmake_file="pa/t-pa pa/t-pa-hpux pa/t-hpux-shlib"
+	if test x$enable_threads = x; then
+	    enable_threads=$have_pthread_h
+	fi
+	case x${enable_threads} in
+	xyes | xdce)
+		tmake_file="${tmake_file} pa/t-dce-thr"
+		;;
+	esac
+	use_collect2=yes
+	use_fixproto=yes
+	;;
+hppa1.0-*-hpux10*)
+	tm_file="${tm_file} pa/pa32-regs.h dbxelf.h pa/som.h pa/pa-hpux.h pa/pa-hpux10.h"
+	tmake_file="pa/t-pa pa/t-pa-hpux pa/t-hpux-shlib"
+	if test x$enable_threads = x; then
+	    enable_threads=$have_pthread_h
+	fi
+	case x${enable_threads} in
+	xyes | xdce)
+		tmake_file="${tmake_file} pa/t-dce-thr"
+		;;
+	esac
+	use_collect2=yes
+	use_fixproto=yes
+	;;
+hppa*64*-*-hpux11*)
+	if test x$gas = xyes
+	then
+		tm_file="pa/pa64-start.h ${tm_file} dbxelf.h elfos.h  \
+			 pa/pa64-regs.h pa/pa-hpux.h \
+			 pa/pa-hpux11.h pa/pa-64.h pa/pa64-hpux.h"
+	else
+		tm_file="pa/pa64-start.h ${tm_file} dbxelf.h pa/elf.h \
+			 pa/pa64-regs.h pa/pa-hpux.h \
+			 pa/pa-hpux11.h pa/pa-64.h pa/pa64-hpux.h"
+	fi
+	need_64bit_hwint=yes
+	tmake_file="pa/t-pa64 pa/t-pa-hpux"
+	target_cpu_default="(MASK_PA_11|MASK_PA_20|MASK_GAS)"
+	extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o"
+	if test x$gnu_ld = xyes
+	then
+		target_cpu_default="${target_cpu_default}|MASK_GNU_LD"
+	fi
+	case x${enable_threads} in
+	xyes | xposix )
+		thread_file=posix 
+		;;
+	esac
+	;;
+hppa1.1-*-hpux11* | hppa2*-*-hpux11*)
+	target_cpu_default="MASK_PA_11"
+	tm_file="${tm_file} pa/pa32-regs.h dbxelf.h pa/som.h pa/pa-hpux.h pa/pa-hpux11.h"
+	tmake_file="pa/t-pa pa/t-pa-hpux pa/t-hpux-shlib"
+	case x${enable_threads} in
+	xyes | xposix )
+		thread_file=posix 
+		;;
+	esac
+	use_collect2=yes
+	;;
+hppa1.0-*-hpux11*)
+	tm_file="${tm_file} pa/pa32-regs.h dbxelf.h pa/som.h pa/pa-hpux.h pa/pa-hpux11.h"
+	tmake_file="pa/t-pa pa/t-pa-hpux pa/t-hpux-shlib"
+	case x${enable_threads} in
+	xyes | xposix )
+		thread_file=posix 
+		;;
+	esac
+	use_collect2=yes
+	;;
+i370-*-opened*)			 # IBM 360/370/390 Architecture
+	xm_defines='FATAL_EXIT_CODE=12'
+	tm_file="i370/oe.h i370/i370.h"
+	tmake_file="i370/t-i370"
+	c_target_objs="i370-c.o"
+	cxx_target_objs="i370-c.o"
+	# Don't bother fixing up header files; they're weird.
+	;;
+i370-*-mvs*)
+	xm_defines='FATAL_EXIT_CODE=12'
+	tm_file="i370/mvs.h i370/i370.h"
+	tmake_file="i370/t-i370"
+	c_target_objs="i370-c.o"
+	cxx_target_objs="i370-c.o"
+	use_fixproto=yes
+	;;
+i370-*-linux*)
+	tm_file="dbxelf.h elfos.h svr4.h linux.h i370/linux.h i370/i370.h"
+	tmake_file="t-slibgcc-elf-ver t-linux"
+	# broken_install=yes
+	;;
+i[34567]86-*-darwin*)
+	tm_file="${tm_file} i386/darwin.h"
+	;;
+i[34567]86-*-elf*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h i386/i386elf.h"
+	tmake_file="i386/t-i386elf t-svr4"
+	use_fixproto=yes
+	;;
+i[34567]86-ncr-sysv4*)		# NCR 3000 - ix86 running system V.4
+	xm_defines="SMALL_ARG_MAX"
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h i386/sysv4.h i386/sysv4-cpp.h"
+	extra_parts="crtbegin.o crtend.o"
+	tmake_file=i386/t-crtpic
+	use_fixproto=yes
+	;;
+i[34567]86-*-netware)		# Intel 80386's running netware
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h i386/sysv4.h netware.h i386/netware.h"
+	;;
+i[34567]86-sequent-ptx4* | i[34567]86-sequent-sysv4*)
+	if test x$gas = xyes
+	then
+		tm_file="${tm_file} usegas.h"
+	fi
+	xm_defines="SMALL_ARG_MAX"
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h ptx4.h i386/ptx4-i.h"
+	tmake_file=t-svr4
+	extra_parts="crtbegin.o crtend.o"
+	use_fixproto=yes
+	;;
+i[34567]86-*-aout*)
+	tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h i386/i386-aout.h"
+	use_fixproto=yes
+	;;
+i[34567]86-*-beoself* | i[34567]86-*-beos*)
+	tmake_file='i386/t-beos i386/t-crtpic'
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h i386/beos-elf.h"
+	extra_parts='crtbegin.o crtend.o'
+	;;
+i[34567]86-*-freebsd2 | i[34567]86-*-freebsd2.* | i[34567]86-*-freebsd*aout*)
+	tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h i386/freebsd-aout.h"
+	tmake_file=t-freebsd
+	;;
+i[34567]86-*-freebsd*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h ${fbsd_tm_file} i386/freebsd.h"
+	;;
+x86_64-*-freebsd*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h ${fbsd_tm_file} i386/x86-64.h i386/freebsd.h i386/freebsd64.h"
+	;;
+i[34567]86-*-netbsdelf*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h netbsd.h netbsd-elf.h i386/netbsd-elf.h"
+	;;
+i[34567]86-*-netbsd*)
+	tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h netbsd.h netbsd-aout.h i386/netbsd.h"
+	tmake_file=t-netbsd
+	extra_parts=""
+	use_collect2=yes
+	;;
+x86_64-*-netbsd*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h netbsd.h netbsd-elf.h i386/x86-64.h i386/netbsd64.h"
+	;;
+i[34567]86-*-openbsd*)
+	tm_file="i386/i386.h i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h openbsd-oldgas.h openbsd.h i386/openbsd.h"
+	# needed to unconfuse gdb
+	tmake_file="t-libc-ok t-openbsd i386/t-openbsd"
+	# we need collect2 until our bug is fixed...
+	use_collect2=yes
+	;;
+i[34567]86-*-coff*)
+	tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h dbxcoff.h i386/i386-coff.h"
+	use_fixproto=yes
+	;;
+i[34567]86-*-linux*aout*)	# Intel 80386's running GNU/Linux
+				# with a.out format
+	tmake_file="i386/t-crtstuff"
+	tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h linux-aout.h i386/linux-aout.h"
+	gnu_ld=yes
+	;;
+i[34567]86-*-linux*libc1)	# Intel 80386's running GNU/Linux
+				# with ELF format using the
+				# GNU/Linux C library 5
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h linux.h i386/linux.h"
+	tmake_file="t-slibgcc-elf-ver t-linux t-linux-gnulibc1 i386/t-crtstuff"
+	extra_parts="crtbegin.o crtbeginS.o crtend.o crtendS.o"
+	gnu_ld=yes
+	if test x$enable_threads = xyes; then
+		thread_file='single'
+	fi
+	;;
+i[34567]86-*-linux*)	# Intel 80386's running GNU/Linux
+			# with ELF format using glibc 2
+			# aka GNU/Linux C library 6
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h linux.h i386/linux.h"
+	tmake_file="t-slibgcc-elf-ver t-linux i386/t-crtstuff"
+	;;
+x86_64-*-linux*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h linux.h \
+		 i386/x86-64.h i386/linux64.h"
+	tmake_file="t-slibgcc-elf-ver t-linux i386/t-linux64"
+	;;
+i[34567]86-*-kfreebsd*-gnu) # must be before i[34567]86-*-gnu*
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h linux.h i386/linux.h kfreebsdgnu.h i386/kfreebsdgnu.h"
+	tmake_file="t-slibgcc-elf-ver t-kfreebsd-gnu i386/t-crtstuff"
+	float_format=i386
+	use_fixproto=no
+	;;
+i[34567]86-*-gnu*)
+	;;
+i[34567]86-pc-msdosdjgpp*)
+	xm_file=i386/xm-djgpp.h
+	tm_file="dbxcoff.h ${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/djgpp.h"
+	tmake_file=i386/t-djgpp
+	gnu_ld=yes
+	gas=yes
+	;;
+i[34567]86-moss-msdos* | i[34567]86-*-moss*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h linux.h i386/linux.h i386/moss.h"
+	tmake_file=t-libc-ok
+	gnu_ld=yes
+	gas=yes
+	use_fixproto=yes
+	;;
+i[34567]86-*-lynxos*)
+	if test x$gas = xyes
+	then
+		tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h svr3.h lynx.h i386/lynx.h"
+	else
+		tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h lynx-ng.h i386/lynx-ng.h"
+	fi
+	use_fixproto=yes
+	;;
+i[34567]86-*-mach*)
+	tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h i386/mach.h"
+#	tmake_file=t-libc-ok
+	use_collect2=yes
+	use_fixproto=yes
+	;;
+i[34567]86-*-nto-qnx*)
+	tm_file="${tm_file} i386/att.h dbxelf.h tm-dwarf2.h elfos.h svr4.h i386/unix.h i386/nto.h"
+	tmake_file=i386/t-nto
+	gnu_ld=yes
+	gas=yes
+	;;
+i[34567]86-*-rtems*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h i386/i386elf.h i386/rtemself.h rtems.h"
+	extra_parts="crtbegin.o crtend.o crti.o crtn.o"
+	tmake_file="i386/t-rtems-i386 i386/t-crtstuff t-rtems"
+	;;
+i[34567]86-*-sco3.2v5*)	# 80386 running SCO Open Server 5
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h i386/sco5.h"
+	if test x$gas = xyes
+	then
+		tm_file="usegas.h ${tm_file}"
+	fi
+	tmake_file=i386/t-sco5
+	extra_parts="crtbegin.o crtend.o"
+	use_fixproto=yes
+	;;
+i[34567]86-*-solaris2*)
+	xm_defines="SMALL_ARG_MAX"
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h i386/sysv4.h sol2.h i386/sol2.h"
+	tmake_file="i386/t-sol2 t-svr4"
+	if test x$gnu_ld = xyes; then
+		tmake_file="$tmake_file t-slibgcc-elf-ver"
+	else
+		tmake_file="$tmake_file t-slibgcc-sld"
+	fi
+	case ${target} in
+	*-*-solaris2.[789] | *-*-solaris2.1[0-9])
+		tm_file="$tm_file tm-dwarf2.h"
+		;;
+	esac
+	extra_parts="crt1.o crti.o crtn.o gcrt1.o gmon.o crtbegin.o crtend.o"
+	if test x${enable_threads} = x; then
+	    enable_threads=$have_pthread_h
+	    if test x${enable_threads} = x; then
+		enable_threads=$have_thread_h
+	    fi
+	fi
+	if test x${enable_threads} = xyes; then
+	    if test x${have_pthread_h} = xyes; then
+		thread_file='posix'
+	    else
+		thread_file='solaris'
+	    fi
+	fi
+	;;
+i[34567]86-*-sysv5*)           # Intel x86 on System V Release 5
+       tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h i386/sysv4.h i386/sysv5.h"
+       if test x$stabs = xyes
+       then
+               tm_file="${tm_file} dbx.h"
+       fi
+       tmake_file="i386/t-crtpic t-svr4"
+       extra_parts="crtbegin.o crtend.o"
+       if test x$enable_threads = xyes; then
+	       thread_file='posix'
+       fi
+	use_fixproto=yes
+       ;;
+i[34567]86-*-sysv4*)		# Intel 80386's running system V.4
+	xm_defines="SMALL_ARG_MAX"
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h i386/sysv4.h i386/sysv4-cpp.h"
+	if test x$stabs = xyes
+	then
+		tm_file="${tm_file} dbx.h"
+	fi
+	tmake_file="i386/t-crtpic t-svr4"
+	extra_parts="crtbegin.o crtend.o"
+	use_fixproto=yes
+	;;
+i[34567]86-*-udk*)      # Intel x86 on SCO UW/OSR5 Dev Kit
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h i386/sysv4.h i386/sysv5.h i386/udk.h"
+	tmake_file="i386/t-crtpic i386/t-udk t-svr4"
+	extra_parts="crtbegin.o crtend.o"
+	use_fixproto=yes
+	;;
+i[34567]86-*-sysv*)		# Intel 80386's running system V
+	if test x$gas = xyes
+	then
+		if test x$stabs = xyes
+		then
+			tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/svr3gas.h i386/svr3dbx.h"
+			tmake_file=i386/t-svr3dbx
+			extra_parts="svr3.ifile svr3z.ifile"
+		else
+			tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/svr3gas.h"
+			extra_parts="crtbegin.o crtend.o"
+			tmake_file=i386/t-crtstuff
+		fi
+	else
+		tm_file="${tm_file} svr3.h i386/unix.h i386/att.h i386/sysv3.h"
+		extra_parts="crtbegin.o crtend.o"
+		tmake_file=i386/t-crtstuff
+	fi
+	tmake_file="$tmake_file i386/t-crtpic"
+	use_fixproto=yes
+	;;
+i386-*-vsta)			# Intel 80386's running VSTa kernel
+	xm_file="i386/xm-vsta.h"
+	tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/vsta.h"
+	use_fixproto=yes
+	;;
+i[4567]86-wrs-vxworks)
+	tm_file="${tm_file} i386/sysv4.h i386/unix.h i386/vxworks.h"
+	tmake_file="${tmake_file} i386/t-vxworks"
+	;;
+i[34567]86-*-pe | i[34567]86-*-cygwin*)
+	tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h dbxcoff.h i386/cygming.h i386/cygwin.h"
+	xm_file=i386/xm-cygwin.h
+	tmake_file="i386/t-cygwin i386/t-cygming"
+	extra_objs=winnt.o
+	c_target_objs=cygwin2.o
+	cxx_target_objs=cygwin2.o
+	extra_gcc_objs=cygwin1.o
+	if test x$enable_threads = xyes; then
+		thread_file='posix'
+	fi
+	;;
+i[34567]86-*-mingw32*)
+	tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h dbxcoff.h i386/cygming.h i386/mingw32.h"
+	xm_file=i386/xm-mingw32.h
+	tmake_file="i386/t-cygming i386/t-mingw32"
+	extra_objs=winnt.o
+	if test x$enable_threads = xyes; then
+		thread_file='win32'
+	fi
+	case ${target} in
+		*mingw32crt*)
+			tm_file="${tm_file} i386/crtdll.h"
+			;;
+		*mingw32msv* | *mingw32*)
+			;;
+	esac
+	;;
+i[34567]86-*-uwin*)
+	tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h dbxcoff.h i386/cygwin.h i386/uwin.h"
+	tmake_file="i386/t-cygwin i386/t-uwin"
+	extra_objs=winnt.o
+	if test x$enable_threads = xyes; then
+		thread_file='win32'
+	fi
+	use_fixproto=yes
+	;;
+i[34567]86-*-interix3*)
+	tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/i386-interix.h i386/i386-interix3.h interix.h interix3.h"
+	tmake_file="i386/t-interix"
+	extra_objs=winnt.o
+	if test x$enable_threads = xyes ; then
+		thread_file='posix'
+	fi
+	if test x$stabs = xyes ; then
+		tm_file="${tm_file} dbxcoff.h"
+	fi
+	;;
+i[34567]86-*-interix*)
+	tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/i386-interix.h interix.h"
+	tmake_file="i386/t-interix"
+	extra_objs=winnt.o
+	if test x$enable_threads = xyes ; then
+		thread_file='posix'
+	fi
+	if test x$stabs = xyes ; then
+		tm_file="${tm_file} dbxcoff.h"
+	fi
+	;;
+i[34567]86-*-kaos*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h i386/i386elf.h kaos.h i386/kaos-i386.h"
+	tmake_file="i386/t-i386elf t-svr4"
+	;;
+i860-*-sysv4*)
+        tm_file="${tm_file} elfos.h svr4.h i860/sysv4.h"
+        tmake_file="i860/t-i860 i860/t-svr4"
+        extra_parts="crtbegin.o crtend.o"
+	use_fixproto=yes
+        ;;
+i960-*-coff*)
+	tm_file="${tm_file} dbxcoff.h i960/i960-coff.h libgloss.h"
+	tmake_file=i960/t-960bare
+	c_target_objs="i960-c.o"
+	cxx_target_objs="i960-c.o"
+	;;
+i960-*-rtems)
+	tmake_file="i960/t-960bare t-rtems"
+	tm_file="${tm_file} dbxcoff.h i960/i960-coff.h i960/rtems.h rtems.h"
+	c_target_objs="i960-c.o"
+	cxx_target_objs="i960-c.o"
+	;;
+i960-*-*)			# Default i960 environment.
+	use_collect2=yes
+	tmake_file=i960/t-960bare
+	c_target_objs="i960-c.o"
+	cxx_target_objs="i960-c.o"
+	use_fixproto=yes
+	;;
+ia64*-*-elf*)
+	tm_file="${tm_file} dbxelf.h elfos.h ia64/sysv4.h ia64/elf.h"
+	tmake_file="ia64/t-ia64"
+	target_cpu_default="0"
+	if test x$gas = xyes
+	then
+		target_cpu_default="${target_cpu_default}|MASK_GNU_AS"
+	fi
+	if test x$gnu_ld = xyes
+	then
+		target_cpu_default="${target_cpu_default}|MASK_GNU_LD"
+	fi
+	extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o crtfastmath.o"
+	use_fixproto=yes
+	;;
+ia64*-*-freebsd*)
+	tm_file="${tm_file} dbxelf.h elfos.h ${fbsd_tm_file} ia64/sysv4.h ia64/freebsd.h"
+	target_cpu_default="MASK_GNU_AS|MASK_GNU_LD"
+	tmake_file="${tmake_file} ia64/t-ia64"
+	extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o crtfastmath.o"
+	;;
+ia64*-*-linux*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h linux.h ia64/sysv4.h ia64/linux.h"
+	tmake_file="t-slibgcc-elf-ver t-linux ia64/t-ia64 t-libunwind ia64/t-glibc"
+	if test x$with_system_libunwind != xyes ; then
+		tmake_file="${tmake_file} t-libunwind-elf ia64/t-glibc-libunwind"
+	fi
+	target_cpu_default="MASK_GNU_AS|MASK_GNU_LD"
+	extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o crtfastmath.o"
+	;;
+ia64*-*-hpux*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h ia64/sysv4.h ia64/hpux.h"
+	tmake_file="ia64/t-ia64 ia64/t-hpux"
+	target_cpu_default="MASK_GNU_AS"
+	case x$enable_threads in
+	xyes | xposix )
+		thread_file=posix
+		;;
+	esac
+	use_collect2=no
+	c_target_objs="ia64-c.o"
+	cxx_target_objs="ia64-c.o"
+	# If we decide to run fixproto we should define FIXPROTO_DEFINES
+	# in ia64/t-hpux, and also fix the definition of putenv in
+	# sys-protos.h (const char not char).
+	;;
+ip2k-*-elf)
+	tm_file="elfos.h ${tm_file}"
+	use_fixproto=yes
+	;;
+iq2000*-*-elf*)
+        tm_file="svr4.h elfos.h iq2000/iq2000.h"
+        tmake_file=iq2000/t-iq2000
+        out_file=iq2000/iq2000.c
+        md_file=iq2000/iq2000.md
+	use_fixproto=yes
+        ;;
+m32r-*-elf*)
+	tm_file="dbxelf.h elfos.h svr4.h ${tm_file}"
+	extra_parts="crtinit.o crtfini.o"
+	use_fixproto=yes
+ 	;;
+m32rle-*-elf*)
+	tm_file="dbxelf.h elfos.h svr4.h m32r/little.h ${tm_file}"
+	extra_parts="crtinit.o crtfini.o m32rx/crtinit.o m32rx/crtfini.o"
+	use_fixproto=yes
+	;;
+m32r-*-linux*)
+	tm_file="dbxelf.h elfos.h svr4.h linux.h ${tm_file} m32r/linux.h"
+	extra_parts="crtbegin.o crtbeginS.o crtend.o crtendS.o"
+	tmake_file="m32r/t-linux"
+	gnu_ld=yes
+	use_fixproto=yes
+	if test x$enable_threads = xyes; then
+		thread_file='posix'
+	fi
+ 	;;
+m32rle-*-linux*)
+	tm_file="dbxelf.h elfos.h svr4.h linux.h m32r/little.h ${tm_file} m32r/linux.h"
+	extra_parts="crtbegin.o crtbeginS.o crtend.o crtendS.o"
+	tmake_file="m32r/t-linux"
+	gnu_ld=yes
+	use_fixproto=yes
+	if test x$enable_threads = xyes; then
+		thread_file='posix'
+	fi
+	;;
+# m68hc11 and m68hc12 share the same machine description.
+m68hc11-*-*|m6811-*-*)
+	tm_file="dbxelf.h elfos.h m68hc11/m68hc11.h"
+	tm_p_file="m68hc11/m68hc11-protos.h"
+	md_file="m68hc11/m68hc11.md"
+	out_file="m68hc11/m68hc11.c"
+	tmake_file="m68hc11/t-m68hc11-gas"
+	use_fixproto=yes
+        ;;
+m68hc12-*-*|m6812-*-*)
+	tm_file="m68hc11/m68hc12.h dbxelf.h elfos.h m68hc11/m68hc11.h"
+	tm_p_file="m68hc11/m68hc11-protos.h"
+	md_file="m68hc11/m68hc11.md"
+	out_file="m68hc11/m68hc11.c"
+	tmake_file="m68hc11/t-m68hc11-gas"
+	use_fixproto=yes
+        ;;
+m68000-hp-hpux*)		# HP 9000 series 300
+	tm_file="m68k/hp320base.h m68k/m68k.h m68k/hp320.h m68k/hp310.h"
+	tm_defines="TARGET_DEFAULT=0" # 68000, no 68881, no bitfield ops
+	if test x$gas = xyes
+	then
+		tm_defines="${tm_defines} DBX_DEBUGGING_INFO=1 USE_GAS"
+	fi
+	tmake_file=m68k/t-hp320
+	use_collect2=yes
+	use_fixproto=yes
+	;;
+m68k-hp-hpux7*)	# HP 9000 series 300 running HPUX version 7.
+	tm_file="m68k/hp320base.h m68k/m68k.h m68k/hp320.h"
+	if test x$gas = xyes
+	then
+		tm_defines="DBX_DEBUGGING_INFO=1 USE_GAS"
+	else
+		tm_defines="NO_DOT_IN_LABEL NO_BUGS"
+	fi
+	use_collect2=yes
+	use_fixproto=yes
+	;;
+m68k-hp-hpux*)	# HP 9000 series 300
+	tm_file="m68k/hp320base.h m68k/m68k.h m68k/hp320.h"
+	if test x$gas = xyes
+	then
+		tm_defines="DBX_DEBUGGING_INFO=1 USE_GAS"
+	fi
+	use_collect2=yes
+	use_fixproto=yes
+	;;
+m68k-*-aout*)
+	tmake_file=m68k/t-m68kbare
+	tm_file="m68k/m68k.h m68k/m68k-none.h m68k/m68kemb.h m68k/m68k-aout.h libgloss.h"
+	;;
+m68k-*-coff*)
+	tmake_file=m68k/t-m68kbare
+	tm_defines="MOTOROLA USE_GAS"
+	tm_file="m68k/m68k.h m68k/m68k-none.h m68k/m68kemb.h dbxcoff.h m68k/coff.h dbx.h"
+	use_fixproto=yes
+	;;
+m68020-*-elf* | m68k-*-elf*)
+	tm_file="m68k/m68k.h m68k/m68k-none.h m68k/m68kelf.h dbxelf.h elfos.h m68k/m68kemb.h m68k/m68020-elf.h"
+	tm_defines="MOTOROLA USE_GAS"
+	tmake_file=m68k/t-m68kelf
+	extra_parts="crtbegin.o crtend.o"
+	use_fixproto=yes
+	;;
+m68010-*-netbsdelf* | m68k*-*-netbsdelf*)
+	tm_file="${tm_file} dbxelf.h elfos.h netbsd.h netbsd-elf.h m68k/netbsd-elf.h"
+	tm_defines="MOTOROLA USE_GAS"
+	case ${target} in
+	m68010*)
+		target_cpu_default="0"
+		;;
+	*)
+		target_cpu_default="MASK_68020|MASK_68881|MASK_BITFIELD"
+		;;
+	esac
+	;;
+m68k*-*-netbsd*)
+    if test "x$enable_obsolete" != xyes; then
+      echo "*** Configuration ${target} is obsolete." >&2
+      echo "*** Specify --enable-obsolete to build it anyway." >&2
+      echo "*** Support will be REMOVED in the next major release of GCC," >&2
+      echo "*** unless a maintainer comes forward." >&2
+      exit 1
+    fi
+	tm_file="m68k/m68k.h netbsd.h netbsd-aout.h m68k/netbsd.h"
+	tmake_file=t-netbsd
+	extra_parts=""
+	use_collect2=yes
+	;;
+m68k*-*-openbsd*)
+	# needed to unconfuse gdb
+	tm_defines="OBSD_OLD_GAS TARGET_DEFAULT=(MASK_68020|MASK_68881|MASK_BITFIELD)"
+	tm_file="m68k/m68k.h openbsd.h m68k/openbsd.h"
+	tmake_file="t-libc-ok t-openbsd m68k/t-openbsd"
+	# we need collect2 until our bug is fixed...
+	use_collect2=yes
+	;;
+m68k-*-sysv4*)			# Motorola m68k's running system V.4
+	tm_file="m68k/m68k.h m68k/sgs.h dbxelf.h elfos.h svr4.h m68k/m68kv4.h"
+	tm_defines="MOTOROLA SGS SGS_CMP_ORDER SGS_SWITCH_TABLES"
+	tmake_file=t-svr4
+	extra_parts="crtbegin.o crtend.o"
+	use_fixproto=yes
+	;;
+m68k-*-uclinux*)		# Motorola m68k/ColdFire running uClinux with uClibc
+	tm_file="m68k/m68k.h m68k/m68k-none.h m68k/m68kelf.h dbxelf.h elfos.h m68k/uclinux.h"
+ 	tm_defines="MOTOROLA USE_GAS"
+	tmake_file=m68k/t-uclinux
+	use_fixproto=no
+	;;
+m68k-*-linux*)		# Motorola m68k's running GNU/Linux
+				# with ELF format using glibc 2
+				# aka the GNU/Linux C library 6.
+	tm_file="m68k/m68k.h dbxelf.h elfos.h svr4.h linux.h m68k/linux.h"
+	tm_defines="MOTOROLA USE_GAS"
+	tmake_file="t-slibgcc-elf-ver t-linux"
+	# if not configured with --enable-sjlj-exceptions, bump the
+	# libgcc version number
+	if test x$sjlj != x1; then
+	    tmake_file="$tmake_file m68k/t-slibgcc-elf-ver"
+	fi
+	;;
+m68k-*-rtems*)
+	tmake_file="m68k/t-m68kbare m68k/t-crtstuff t-rtems m68k/t-rtems"
+	tm_file="m68k/m68k.h m68k/m68k-none.h m68k/m68kelf.h dbxelf.h elfos.h m68k/m68kemb.h m68k/m68020-elf.h m68k/rtemself.h rtems.h"
+	tm_defines="MOTOROLA USE_GAS"
+	extra_parts="crtbegin.o crtend.o"
+	;;
+mcore-*-elf)
+	tm_file="dbxelf.h elfos.h svr4.h ${tm_file} mcore/mcore-elf.h"
+	tmake_file=mcore/t-mcore
+	use_fixproto=yes
+	;;
+mcore-*-pe*)
+	tm_file="svr3.h dbxcoff.h ${tm_file} mcore/mcore-pe.h"
+	tmake_file=mcore/t-mcore-pe
+	use_fixproto=yes
+	;;
+mips-sgi-irix6*)		# SGI System V.4., IRIX 6
+	tm_file="${tm_file} mips/iris5.h mips/iris6.h"
+	tmake_file="mips/t-iris mips/t-iris5-6 mips/t-iris6"
+	if test x$gas = xyes
+	then
+		tm_file="${tm_file} mips/iris6gas.h"
+	fi
+	if test "x$gnu_ld" = xyes
+	then
+		tm_file="${tm_file} mips/iris6gld.h"
+		tmake_file="$tmake_file mips/t-irix-gld"
+	fi
+	target_cpu_default="MASK_ABICALLS|MASK_FLOAT64|MASK_64BIT"
+	tm_defines="MIPS_ISA_DEFAULT=3 MIPS_ABI_DEFAULT=ABI_N32"
+	# See comment in mips/iris5.h file.  Only enabled for O32 ABI
+	# without GNU as.
+	if test x$gas = xno
+	then
+		use_collect2=yes
+	fi
+#	if test x$enable_threads = xyes; then
+#		thread_file='irix'
+#	fi
+	use_fixproto=yes
+	;;
+mips-sgi-irix5cross64)		# Irix5 host, Irix 6 target, cross64
+	tm_file="${tm_file} mips/iris5.h mips/iris6.h mips/cross64.h"
+	tmake_file="mips/t-iris mips/t-cross64"
+	target_cpu_default="MASK_ABICALLS|MASK_FLOAT64|MASK_64BIT"
+	tm_defines="MIPS_ISA_DEFAULT=3 MIPS_ABI_DEFAULT=ABI_N32"
+	# See comment in mips/iris[56].h files.
+	use_collect2=yes
+#	if test x$enable_threads = xyes; then
+#		thread_file='irix'
+#	fi
+	use_fixproto=yes
+	;;
+mips-sgi-irix5*)		# SGI System V.4., IRIX 5
+	tm_file="${tm_file} mips/iris5.h"
+	if test x$gas = xyes
+	then
+		tm_file="${tm_file} mips/sdb.h mips/iris5gas.h"
+		if test x$stabs = xyes
+		then
+			tm_file="${tm_file} dbx.h mips/dbxmdebug.h"
+		fi
+		tmake_file=mips/t-iris5-gas
+	else
+		tmake_file=mips/t-iris5-as
+	fi
+	if test "x$gnu_ld" = xyes
+	then
+		tm_file="${tm_file} mips/iris5gld.h"
+		tmake_file="$tmake_file mips/t-irix-gld"
+	fi
+	tmake_file="${tmake_file} mips/t-iris mips/t-iris5-6"
+	target_cpu_default="MASK_ABICALLS"
+	# mips-tfile doesn't work yet
+	# See comment in mips/iris5.h file.
+	if test x$gas = xno
+	then
+		use_collect2=yes
+	fi
+#	if test x$enable_threads = xyes; then
+#		thread_file='irix'
+#	fi
+	use_fixproto=yes
+	;;
+mips*-*-netbsd*)			# NetBSD/mips, either endian.
+	target_cpu_default="MASK_GAS|MASK_ABICALLS"
+	tm_file="elfos.h ${tm_file} mips/elf.h netbsd.h netbsd-elf.h mips/netbsd.h"
+	;;
+mips64*-*-linux*)
+	tm_file="dbxelf.h elfos.h svr4.h linux.h ${tm_file} mips/linux.h mips/linux64.h"
+	tmake_file="t-slibgcc-elf-ver t-linux mips/t-linux64"
+
+	# This default ABI is a partial lie: t-linux64 overrides the
+	# DRIVER_SELF_SPEC that sets the default abi, in the spec file
+	# that is installed.  What GCC thinks of as the default must
+	# remain as ABI_32 such that the SONAMEs of the libgcc shared
+	# libraries remain compatible with those of mips-linux-gnu.
+	tm_defines="MIPS_ISA_DEFAULT=1 MIPS_ABI_DEFAULT=ABI_32"
+	target_cpu_default="MASK_ABICALLS|MASK_FLOAT64|MASK_64BIT"
+	extra_parts="crtbegin.o crtbeginS.o crtbeginT.o crtend.o crtendS.o"
+	gnu_ld=yes
+	gas=yes
+	;;
+mips*-*-linux*)				# Linux MIPS, either endian.
+        tm_file="dbxelf.h elfos.h svr4.h linux.h ${tm_file} mips/linux.h"
+	case ${target} in
+        mipsisa32*-*)
+                target_cpu_default="MASK_SOFT_FLOAT"
+		tm_defines="MIPS_ISA_DEFAULT=32"
+                ;;
+        esac
+	tmake_file="t-slibgcc-elf-ver t-linux"
+	;;
+mips*-*-openbsd*)
+	tm_defines="OBSD_HAS_DECLARE_FUNCTION_NAME OBSD_HAS_DECLARE_OBJECT OBSD_HAS_CORRECT_SPECS"
+	target_cpu_default="MASK_GAS|MASK_ABICALLS"
+	tm_file="mips/mips.h openbsd.h mips/openbsd.h mips/sdb.h"
+	case ${target} in
+	mips*el-*-openbsd*) 
+	    tm_defines="${tm_defines} TARGET_ENDIAN_DEFAULT=0";;
+	*)  tm_defines="${tm_defines} TARGET_ENDIAN_DEFAULT=MASK_BIG_ENDIAN";;
+        esac
+	;;
+mipsisa32-*-elf* | mipsisa32el-*-elf*)
+	tm_file="${tm_file} mips/elf.h"
+	tmake_file=mips/t-isa3264
+	tm_defines="MIPS_ISA_DEFAULT=32 MIPS_ABI_DEFAULT=ABI_EABI"
+	use_fixproto=yes
+	;;
+mipsisa32r2-*-elf* | mipsisa32r2el-*-elf*)
+	tm_file="${tm_file} mips/elf.h"
+	tmake_file=mips/t-isa3264
+	tm_defines="MIPS_ISA_DEFAULT=33 MIPS_ABI_DEFAULT=ABI_EABI"
+	use_fixproto=yes
+	;;
+mipsisa64-*-elf* | mipsisa64el-*-elf*)
+	tm_file="${tm_file} mips/elf.h"
+	tmake_file=mips/t-isa3264
+	target_cpu_default="MASK_64BIT|MASK_FLOAT64|MASK_GAS"
+	tm_defines="MIPS_ISA_DEFAULT=64 MIPS_ABI_DEFAULT=ABI_EABI"
+	use_fixproto=yes
+	;;
+mipsisa64sr71k-*-elf*)
+        tm_file="${tm_file} mips/elf.h"
+        tmake_file=mips/t-sr71k
+	target_cpu_default="MASK_64BIT|MASK_FLOAT64|MASK_GAS"
+	tm_defines="MIPS_ISA_DEFAULT=64 MIPS_CPU_STRING_DEFAULT=\\\"sr71000\\\" MIPS_ABI_DEFAULT=ABI_EABI"
+	use_fixproto=yes
+        ;;
+mipsisa64sb1-*-elf* | mipsisa64sb1el-*-elf*)
+	tm_file="${tm_file} mips/elf.h"
+	tmake_file=mips/t-elf
+	target_cpu_default="MASK_64BIT|MASK_FLOAT64|MASK_GAS"
+	tm_defines="MIPS_ISA_DEFAULT=64 MIPS_CPU_STRING_DEFAULT=\\\"sb1\\\" MIPS_ABI_DEFAULT=ABI_O64"
+	use_fixproto=yes
+	;;
+mips-*-elf* | mipsel-*-elf*)
+	tm_file="${tm_file} mips/elf.h"
+	tmake_file=mips/t-elf
+	use_fixproto=yes
+	;;
+mips64-*-elf* | mips64el-*-elf*)
+	tm_file="${tm_file} mips/elf64.h"
+	tmake_file=mips/t-elf
+	target_cpu_default="MASK_64BIT|MASK_FLOAT64|MASK_GAS"
+	tm_defines="MIPS_ISA_DEFAULT=3 MIPS_ABI_DEFAULT=ABI_O64"
+	use_fixproto=yes
+	;;
+mips64vr-*-elf* | mips64vrel-*-elf*)
+        tm_file="mips/vr.h ${tm_file} mips/elf64.h"
+        tm_defines="MIPS_ABI_DEFAULT=ABI_O64 MIPS_MARCH_CONTROLS_SOFT_FLOAT=1"
+        tmake_file=mips/t-vr
+	use_fixproto=yes
+        ;;
+mips64orion-*-elf* | mips64orionel-*-elf*)
+	tm_file="${tm_file} mips/elforion.h mips/elf64.h"
+	tmake_file=mips/t-elf
+	tmake_file=mips/t-elf
+	target_cpu_default="MASK_64BIT|MASK_FLOAT64|MASK_GAS"
+	tm_defines="MIPS_ISA_DEFAULT=3 MIPS_ABI_DEFAULT=ABI_O64"
+	use_fixproto=yes
+	;;
+mips*-*-rtems*)
+	tm_file="${tm_file} mips/elf.h mips/rtems.h rtems.h"
+	tmake_file="mips/t-elf t-rtems mips/t-rtems"
+	;;
+mips-wrs-vxworks)
+	# We want vxworks.h after mips/elf.h, which unfortunately means we
+	# have to redo the tm_file list from scratch.
+	tm_file="elfos.h mips/mips.h svr4.h mips/elf.h vxworks.h mips/vxworks.h"
+	tmake_file="${tmake_file} mips/t-vxworks"
+	target_cpu_default="MASK_GAS"
+	;;
+mips-wrs-windiss)	# Instruction-level simulator for VxWorks.
+	xm_defines=POSIX
+	tm_file="elfos.h mips/mips.h svr4.h mips/elf.h windiss.h mips/windiss.h"
+	tmake_file="${tmake_file} mips/t-elf"
+	target_cpu_default="MASK_GAS"
+	thread_file=
+	;;
+mipstx39-*-elf* | mipstx39el-*-elf*)
+	tm_file="${tm_file} mips/r3900.h mips/elf.h"
+	tmake_file=mips/t-r3900
+	use_fixproto=yes
+	;;
+mmix-knuth-mmixware)
+	need_64bit_hwint=yes
+	;;
+mn10300-*-*)
+	tm_file="dbxelf.h elfos.h svr4.h ${tm_file}"
+	if test x$stabs = xyes
+	then
+		tm_file="${tm_file} dbx.h"
+	fi
+	use_collect2=no
+	use_fixproto=yes
+	;;
+ns32k-*-netbsdelf*)
+	echo "GCC does not yet support the ${target} target"; exit 1
+	;;
+ns32k-*-netbsd*)
+	tm_file="${tm_file} netbsd.h netbsd-aout.h ns32k/netbsd.h"
+	# On NetBSD, the headers are already okay, except for math.h.
+	tmake_file="t-netbsd ns32k/t-ns32k"
+	extra_parts=""
+	use_collect2=yes
+	;;
+pdp11-*-bsd)
+	tm_file="${tm_file} pdp11/2bsd.h"
+	use_fixproto=yes
+        ;;
+pdp11-*-*)
+	use_fixproto=yes
+	;;
+# port not yet contributed
+#powerpc-*-openbsd*)
+#	tmake_file="${tmake_file} rs6000/t-fprules "
+#	extra_headers=
+#	;;
+powerpc64-*-linux*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h"
+	test x$with_cpu != x || cpu_is_64bit=yes
+	test x$cpu_is_64bit != xyes || tm_file="${tm_file} rs6000/default64.h"
+	tm_file="rs6000/biarch64.h ${tm_file} rs6000/linux64.h"
+	tmake_file="rs6000/t-fprules t-slibgcc-elf-ver t-linux rs6000/t-ppccomm rs6000/t-linux64"
+	;;
+powerpc64-*-gnu*)
+	tm_file="${cpu_type}/${cpu_type}.h elfos.h svr4.h freebsd-spec.h gnu.h rs6000/sysv4.h rs6000/linux64.h rs6000/gnu.h"
+	tmake_file="rs6000/t-fprules t-slibgcc-elf-ver t-gnu rs6000/t-linux64"
+	;;
+powerpc-*-beos*)
+	tm_file="${tm_file} rs6000/aix.h rs6000/beos.h rs6000/xcoff.h"
+	tmake_file="rs6000/t-fprules rs6000/t-beos"
+	extra_headers=
+	use_fixproto=yes
+	;;
+powerpc-*-darwin*)
+	tm_file="${tm_file} rs6000/darwin.h"
+	tmake_file="t-darwin t-slibgcc-darwin rs6000/t-darwin"
+	extra_headers=altivec.h
+	;;
+powerpc*-*-freebsd*)
+	tm_file="${tm_file} dbxelf.h elfos.h ${fbsd_tm_file} rs6000/sysv4.h rs6000/freebsd.h"
+	tmake_file="rs6000/t-fprules rs6000/t-ppcos ${tmake_file} rs6000/t-ppccomm"
+	;;
+powerpc-*-netbsd*)
+	tm_file="${tm_file} dbxelf.h elfos.h netbsd.h netbsd-elf.h freebsd-spec.h rs6000/sysv4.h rs6000/netbsd.h"
+	tmake_file="${tmake_file} rs6000/t-netbsd"
+	;;
+powerpc-*-chorusos*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h chorus.h"
+	tmake_file="rs6000/t-fprules rs6000/t-ppcos rs6000/t-ppccomm"
+	case ${enable_threads} in
+	  yes | posix)
+	    thread_file='posix'
+	    ;;
+	esac
+	use_fixproto=yes
+	;;
+powerpc-*-eabispe*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/eabi.h rs6000/eabispe.h"
+	tmake_file="rs6000/t-spe rs6000/t-ppccomm"
+	;;
+powerpc-*-eabisimaltivec*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/eabi.h rs6000/eabisim.h rs6000/eabialtivec.h"
+	tmake_file="rs6000/t-fprules rs6000/t-ppcendian rs6000/t-ppccomm"
+	;;
+powerpc-*-eabisim*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/eabi.h rs6000/eabisim.h"
+	tmake_file="rs6000/t-fprules rs6000/t-ppcgas rs6000/t-ppccomm"
+	;;
+powerpc-*-elf*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h"
+	tmake_file="rs6000/t-fprules rs6000/t-ppcgas rs6000/t-ppccomm"
+	use_fixproto=yes
+	;;
+powerpc-*-eabialtivec*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/eabi.h rs6000/eabialtivec.h"
+	tmake_file="rs6000/t-fprules rs6000/t-ppcendian rs6000/t-ppccomm"
+	;;
+powerpc-*-eabi*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/eabi.h"
+	tmake_file="rs6000/t-fprules rs6000/t-ppcgas rs6000/t-ppccomm"
+	;;
+powerpc-*-rtems*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/eabi.h rs6000/rtems.h rtems.h"
+	tmake_file="rs6000/t-fprules rs6000/t-rtems t-rtems rs6000/t-ppccomm"
+	;;
+powerpc-*-linux*altivec*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/linux.h rs6000/linuxaltivec.h"
+	tmake_file="rs6000/t-fprules rs6000/t-ppcos t-slibgcc-elf-ver t-linux rs6000/t-ppccomm"
+	;;
+powerpc-*-linux*spe*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/linux.h rs6000/linuxspe.h"
+	tmake_file="rs6000/t-fprules rs6000/t-ppcos t-slibgcc-elf-ver t-linux rs6000/t-ppccomm"
+	;;
+powerpc-*-linux*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h"
+	tmake_file="rs6000/t-fprules rs6000/t-ppcos t-slibgcc-elf-ver t-linux rs6000/t-ppccomm"
+	case ${enable_targets}:${cpu_is_64bit} in
+	    *powerpc64* | all:* | *:yes)
+		if test x$cpu_is_64bit = xyes; then
+		    tm_file="${tm_file} rs6000/default64.h"
+		fi
+		tm_file="rs6000/biarch64.h ${tm_file} rs6000/linux64.h"
+		tmake_file="$tmake_file rs6000/t-linux64"
+		;;
+	    *)
+		tm_file="${tm_file} rs6000/linux.h"
+		;;
+	esac
+	;;
+powerpc-*-gnu-gnualtivec*)
+	tm_file="${cpu_type}/${cpu_type}.h elfos.h svr4.h freebsd-spec.h gnu.h rs6000/sysv4.h rs6000/linux.h rs6000/linuxaltivec.h rs6000/gnu.h"
+	tmake_file="rs6000/t-fprules rs6000/t-ppcos t-slibgcc-elf-ver t-gnu rs6000/t-ppccomm"
+	if test x$enable_threads = xyes; then
+		thread_file='posix'
+	fi
+	;;
+powerpc-*-gnu*)
+	tm_file="${cpu_type}/${cpu_type}.h elfos.h svr4.h freebsd-spec.h gnu.h rs6000/sysv4.h rs6000/linux.h rs6000/gnu.h"
+	tmake_file="rs6000/t-fprules rs6000/t-ppcos t-slibgcc-elf-ver t-gnu rs6000/t-ppccomm"
+	if test x$enable_threads = xyes; then
+		thread_file='posix'
+	fi
+	;;
+powerpc-wrs-vxworks*)
+	# We want vxworks.h after rs6000/sysv4.h, which unfortunately
+	# means we have to redo the tm_file list from scratch.
+	tm_file="rs6000/rs6000.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h"
+	tm_file="${tm_file} vxworks.h rs6000/vxworks.h"
+	tmake_file="${tmake_file} rs6000/t-fprules rs6000/t-ppccomm rs6000/t-vxworks"
+	extra_headers=ppc-asm.h
+	;;
+powerpc-wrs-windiss*)	# Instruction-level simulator for VxWorks.
+	tm_file="${tm_file} elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/windiss.h"
+        tmake_file="rs6000/t-fprules rs6000/t-ppcgas rs6000/t-ppccomm"
+        thread_file=""
+	use_fixproto=yes
+        ;;
+powerpcle-*-sysv*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/sysv4le.h"
+	tmake_file="rs6000/t-fprules rs6000/t-ppcos rs6000/t-ppccomm"
+	use_fixproto=yes
+	;;
+powerpcle-*-elf*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/sysv4le.h"
+	tmake_file="rs6000/t-fprules rs6000/t-ppcgas rs6000/t-ppccomm"
+	use_fixproto=yes
+	;;
+powerpcle-*-eabisim*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/sysv4le.h rs6000/eabi.h rs6000/eabisim.h"
+	tmake_file="rs6000/t-fprules rs6000/t-ppcgas rs6000/t-ppccomm"
+	;;
+powerpcle-*-eabi*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/sysv4le.h rs6000/eabi.h"
+	tmake_file="rs6000/t-fprules rs6000/t-ppcgas rs6000/t-ppccomm"
+	;;
+powerpc-*-kaos*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h kaos.h rs6000/kaos-ppc.h"
+	tmake_file="rs6000/t-fprules rs6000/t-ppcgas rs6000/t-ppccomm"
+	;;
+powerpcle-*-kaos*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/sysv4le.h kaos.h rs6000/kaos-ppc.h"
+	tmake_file="rs6000/t-fprules rs6000/t-ppcgas rs6000/t-ppccomm"
+	;;
+rs6000-ibm-aix4.[12]* | powerpc-ibm-aix4.[12]*)
+	tm_file="${tm_file} rs6000/aix.h rs6000/aix41.h rs6000/xcoff.h"
+	tmake_file="rs6000/t-fprules rs6000/t-newas"
+	use_collect2=yes
+	extra_headers=
+	use_fixproto=yes
+	;;
+rs6000-ibm-aix4.[3456789]* | powerpc-ibm-aix4.[3456789]*)
+	tm_file="rs6000/biarch64.h ${tm_file} rs6000/aix.h rs6000/aix43.h rs6000/xcoff.h"
+	tmake_file=rs6000/t-aix43
+	use_collect2=yes
+	thread_file='aix'
+	extra_headers=
+	;;
+rs6000-ibm-aix5.1.* | powerpc-ibm-aix5.1.*)
+	tm_file="rs6000/biarch64.h ${tm_file} rs6000/aix.h rs6000/aix51.h rs6000/xcoff.h"
+	tmake_file=rs6000/t-aix43
+	use_collect2=yes
+	thread_file='aix'
+	extra_headers=
+	;;
+rs6000-ibm-aix[56789].* | powerpc-ibm-aix[56789].*)
+	tm_file="${tm_file} rs6000/aix.h rs6000/aix52.h rs6000/xcoff.h"
+	tmake_file=rs6000/t-aix52
+	use_collect2=yes
+	thread_file='aix'
+	extra_headers=
+	;;
+rs6000-*-lynxos*)
+	tm_file="svr3.h lynx.h rs6000/lynxbase.h rs6000/rs6000.h rs6000/lynx.h"
+	tmake_file=rs6000/t-fprules
+	use_collect2=yes
+	use_fixproto=yes
+	;;
+s390-*-linux*)
+	tm_file="s390/s390.h dbxelf.h elfos.h svr4.h linux.h s390/linux.h"
+	tmake_file="t-slibgcc-elf-ver t-linux s390/t-crtstuff"
+	;;
+s390x-*-linux*)
+	tm_file="s390/s390x.h s390/s390.h dbxelf.h elfos.h svr4.h linux.h s390/linux.h"
+	tm_p_file=s390/s390-protos.h
+	md_file=s390/s390.md
+	extra_modes=s390/s390-modes.def
+	out_file=s390/s390.c
+	tmake_file="t-slibgcc-elf-ver t-linux s390/t-crtstuff s390/t-linux64"
+	;;
+s390x-ibm-tpf*)
+	tm_file="s390/s390x.h s390/s390.h dbxelf.h elfos.h svr4.h s390/tpf.h"
+	tm_p_file=s390/s390-protos.h
+	md_file=s390/s390.md
+	extra_modes=s390/s390-modes.def
+	extra_parts="crtbegin.o crtbeginS.o crtbeginT.o crtend.o crtendS.o"
+	out_file=s390/s390.c
+	tmake_file="t-slibgcc-elf-ver s390/t-crtstuff s390/t-tpf"
+	;;
+sh-*-elf* | sh[2346l]*-*-elf* | sh*-*-kaos*)
+	tmake_file="sh/t-sh sh/t-elf"
+	case ${target} in
+	shl* | sh64l*)
+		tm_file="sh/little.h ${tm_file}"
+		tmake_file="${tmake_file} sh/t-le"
+		;;
+	esac
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sh/elf.h sh/embed-elf.h"
+	case ${target} in
+	sh64*)
+		tmake_file="${tmake_file} sh/t-sh64"
+		tm_file="${tm_file} sh/sh64.h"
+		extra_headers="shmedia.h ushmedia.h sshmedia.h"
+		;;
+	sh4_single*)  target_cpu_default="SELECT_SH4_SINGLE" ;;
+	sh4*)  target_cpu_default="SELECT_SH4" ;;
+	sh3e*) target_cpu_default="SELECT_SH3E" ;;
+	sh3*)  target_cpu_default="SELECT_SH3" ;;
+	sh2e*) target_cpu_default="SELECT_SH2E" ;;
+	sh2*)  target_cpu_default="SELECT_SH2" ;;
+	esac
+	case ${target} in
+	sh[234]*) tmake_file="${tmake_file} sh/t-monolib" ;;
+	esac
+	case ${target} in
+	sh*-*-kaos*) tm_file="${tm_file} kaos.h sh/kaos-sh.h" ;;
+	esac
+	use_fixproto=yes
+	;;
+sh-*-rtemscoff*)
+	tmake_file="sh/t-sh t-rtems"
+	tm_file="${tm_file} dbxcoff.h sh/coff.h sh/rtems.h rtems.h"
+	;;
+sh-*-rtems*)
+	tmake_file="sh/t-sh sh/t-elf t-rtems"
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sh/elf.h sh/embed-elf.h sh/rtemself.h rtems.h"
+	;;
+sh-*-linux* | sh[2346lbe]*-*-linux*)
+	tmake_file="sh/t-sh sh/t-elf t-slibgcc-elf-ver t-linux"
+	case ${target} in
+	sh*be-*-* | sh*eb-*-*) ;;
+	*)
+		tm_file="sh/little.h ${tm_file}"
+		tmake_file="${tmake_file} sh/t-le"
+		;;
+	esac
+	tmake_file="${tmake_file} sh/t-linux"
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sh/elf.h sh/linux.h"
+	case ${target} in
+	sh64*)
+		tmake_file="${tmake_file} sh/t-sh64"
+		tm_file="${tm_file} sh/sh64.h"
+		extra_headers="shmedia.h ushmedia.h sshmedia.h"
+		;;
+	sh4_single*) target_cpu_default="SELECT_SH4_SINGLE" ;;
+	sh4*) target_cpu_default="SELECT_SH4" ;;
+	sh3e[lb]e*) target_cpu_default="SELECT_SH3E" ;;
+	sh3e[lb]*) target_cpu_default="SELECT_SH3" ;;
+	sh3e*) target_cpu_default="SELECT_SH3E" ;;
+	sh3*) target_cpu_default="SELECT_SH3" ;;
+	sh2e[lb]e*) target_cpu_default="SELECT_SH2E" ;;
+	sh2e[lb]*) target_cpu_default="SELECT_SH2" ;;
+	sh2e*) target_cpu_default="SELECT_SH2E" ;;
+	sh2*) target_cpu_default="SELECT_SH2" ;;
+	esac
+	case ${target} in
+	sh[234]*) tmake_file="${tmake_file} sh/t-monolib" ;;
+	esac
+	;;
+sh-*-netbsdelf* | shl*-*-netbsdelf* | sh5-*-netbsd* | sh5l*-*-netbsd* | \
+  sh64-*-netbsd* | sh64l*-*-netbsd*)
+	tm_file="${tm_file} dbxelf.h elfos.h sh/elf.h netbsd.h netbsd-elf.h sh/netbsd-elf.h"
+	tmake_file="${tmake_file} sh/t-sh sh/t-elf"
+	case ${target} in
+	sh*l*-*)
+		tm_file="sh/little.h ${tm_file}"
+		tmake_file="${tmake_file} sh/t-le"
+		;;
+	*)
+		tmake_file="${tmake_file} sh/t-be"
+		;;
+	esac
+	case ${target} in
+	sh5*-*)
+		# SHmedia, 32-bit ABI
+		target_cpu_default="SH5_BIT|SH4_BIT|SH3_BIT|SH_E_BIT"
+		tmake_file="${tmake_file} sh/t-sh64 sh/t-netbsd-sh5"
+		;;
+	sh64*-*)
+		# SHmedia, 64-bit ABI
+		target_cpu_default="SH5_BIT|SH4_BIT"
+		tmake_file="${tmake_file} sh/t-sh64 sh/t-netbsd-sh5 sh/t-netbsd-sh5-64"
+		;;
+	*)
+		# SH3, software floating point
+		target_cpu_default="SH1_BIT|SH2_BIT|SH3_BIT"
+		tmake_file="${tmake_file} sh/t-netbsd"
+		;;
+	esac
+	;;
+sh-wrs-vxworks)
+	tmake_file="$tmake_file sh/t-sh sh/t-elf sh/t-vxworks"
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sh/embed-elf.h sh/vxworks.h"
+	;;
+sh-*-*)
+	tm_file="${tm_file} dbxcoff.h sh/coff.h"
+	use_fixproto=yes
+	;;
+sparc-tti-*)
+	tm_file="${tm_file} sparc/pbd.h"
+	use_fixproto=yes
+	;;
+sparc-*-netbsdelf*)
+	tm_file="${tm_file} elfos.h svr4.h sparc/sysv4.h netbsd.h netbsd-elf.h sparc/netbsd-elf.h"
+	;;
+sparc-*-openbsd*)
+	tm_defines=OBSD_OLD_GAS
+	tm_file="sparc/sparc.h openbsd.h sparc/openbsd.h"
+	# needed to unconfuse gdb
+	tmake_file="t-libc-ok t-openbsd sparc/t-openbsd"
+	# we need collect2 until our bug is fixed...
+	use_collect2=yes
+	;;
+sparc64-*-openbsd*)
+	tm_file="sparc/openbsd1-64.h sparc/sparc.h elfos.h svr4.h sparc/sysv4.h sparc/sp64-elf.h openbsd.h sparc/openbsd64.h"
+	gas=yes gnu_ld=yes
+	with_cpu=ultrasparc
+	;;
+sparc-*-elf*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sol2.h sparc/sol2.h sparc/sol2-gld.h sparc/elf.h"
+	tmake_file="sparc/t-elf sparc/t-crtfm"
+	extra_parts="crti.o crtn.o crtbegin.o crtend.o"
+	use_fixproto=yes
+	;;
+sparc-*-linux*)		# SPARC's running GNU/Linux, libc6
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/linux.h"
+	tmake_file="t-slibgcc-elf-ver t-linux sparc/t-crtfm"
+	;;
+sparc-*-rtems*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sol2.h sparc/sol2.h sparc/sol2-gld.h sparc/elf.h sparc/rtemself.h rtems.h"
+	tmake_file="sparc/t-elf sparc/t-crtfm t-rtems"
+	extra_parts="crti.o crtn.o crtbegin.o crtend.o"
+	;;
+sparc64-*-solaris2* | sparcv9-*-solaris2*)
+	tm_file="sparc/biarch64.h ${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sol2.h sparc/sol2.h sparc/sol2-64.h sparc/sol2-bi.h"
+	if test x$gnu_ld = xyes; then
+		tm_file="${tm_file} sparc/sol2-gld.h sparc/sol2-gld-bi.h"
+	fi
+	if test x$gas = xyes; then
+		tm_file="${tm_file} sparc/sol2-gas-bi.h"
+	fi
+	tmake_file="sparc/t-sol2 sparc/t-sol2-64 sparc/t-crtfm"
+	if test x$gnu_ld = xyes; then
+		tmake_file="$tmake_file t-slibgcc-elf-ver"
+	else
+		tmake_file="$tmake_file t-slibgcc-sld"
+	fi
+	extra_parts="crt1.o crti.o crtn.o gcrt1.o crtbegin.o crtend.o"
+	if test x${enable_threads} = x ; then
+	    enable_threads=$have_pthread_h
+	    if test x${enable_threads} = x ; then
+		enable_threads=$have_thread_h
+	    fi
+	fi
+	if test x${enable_threads} = xyes ; then
+	    if test x${have_pthread_h} = xyes ; then
+		thread_file='posix'
+	    else
+		thread_file='solaris'
+	    fi
+	fi
+	need_64bit_hwint=yes
+	;;
+sparc-*-solaris2*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sol2.h sparc/sol2.h"
+	if test x$gnu_ld = xyes; then
+		tm_file="${tm_file} sparc/sol2-gld.h"
+	fi
+	tmake_file="sparc/t-sol2 sparc/t-crtfm"
+	if test x$gnu_ld = xyes; then
+		tmake_file="$tmake_file t-slibgcc-elf-ver"
+	else
+		tmake_file="$tmake_file t-slibgcc-sld"
+	fi
+	case ${target} in
+	*-*-solaris2.[0-6] | *-*-solaris2.[0-6].*)
+		if test x$gnu_ld = xno; then
+			tm_file="${tm_file} sparc/sol26-sld.h"
+		fi
+		;;
+	*-*-solaris2.[789] | *-*-solaris2.1[0-9])
+		tm_file="sparc/biarch64.h ${tm_file} sparc/sol2-bi.h"
+		if test x$gnu_ld = xyes; then
+			tm_file="${tm_file} sparc/sol2-gld-bi.h"
+		fi
+		if test x$gas = xyes; then
+			tm_file="${tm_file} sparc/sol2-gas-bi.h"
+		fi
+		tmake_file="$tmake_file sparc/t-sol2-64"
+		need_64bit_hwint=yes
+		;;
+	esac
+	extra_parts="crt1.o crti.o crtn.o gcrt1.o gmon.o crtbegin.o crtend.o"
+	if test x${enable_threads} = x; then
+	    enable_threads=$have_pthread_h
+	    if test x${enable_threads} = x; then
+		enable_threads=$have_thread_h
+	    fi
+	fi
+	if test x${enable_threads} = xyes; then
+	    if test x${have_pthread_h} = xyes; then
+		thread_file='posix'
+	    else
+		thread_file='solaris'
+	    fi
+	fi
+	;;
+sparc-*-sysv4*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/sysv4-only.h"
+	tmake_file=t-svr4
+	extra_parts="crtbegin.o crtend.o"
+	use_fixproto=yes
+	;;
+sparclite-*-coff*)
+	tm_file="${tm_file} sparc/lite.h svr3.h sparc/litecoff.h dbxcoff.h libgloss.h"
+	tmake_file=sparc/t-sparclite
+	;;
+sparclite-*-elf*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sol2.h sparc/sol2.h sparc/sol2-gld.h sparc/elf.h sparc/liteelf.h"
+	tmake_file="sparc/t-sparclite sparc/t-crtfm"
+        extra_parts="crtbegin.o crtend.o"
+	use_fixproto=yes
+	;;
+sparc86x-*-elf*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sol2.h sparc/sol2.h sparc/sol2-gld.h sparc/elf.h sparc/sp86x-elf.h"
+	tmake_file="sparc/t-sp86x sparc/t-crtfm"
+        extra_parts="crtbegin.o crtend.o"
+	use_fixproto=yes
+	;;
+sparc64-*-aout*)
+	tm_file="sparc/sparc.h sparc/aout.h sparc/sp64-aout.h"
+	use_fixproto=yes
+	;;
+sparc64-*-elf*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sol2.h sparc/sol2.h sparc/sol2-gld.h sparc/sp64-elf.h"
+	tmake_file="${tmake_file} sparc/t-crtfm"
+	extra_parts="crtbegin.o crtend.o"
+	use_fixproto=yes
+	;;
+sparc64-*-freebsd*|ultrasparc-*-freebsd*)
+	tm_file="${tm_file} ${fbsd_tm_file} dbxelf.h elfos.h sparc/sysv4.h sparc/freebsd.h"
+	tmake_file="${tmake_file} sparc/t-crtfm"
+	case "x$with_cpu" in
+		xultrasparc) ;;
+		x) with_cpu=ultrasparc ;;
+		*) echo "$with_cpu not supported for freebsd target"; exit 1 ;;
+	esac
+	need_64bit_hwint=yes
+	;;
+sparc64-*-linux*)		# 64-bit SPARC's running GNU/Linux
+	tmake_file="t-slibgcc-elf-ver t-linux sparc/t-linux64 sparc/t-crtfm"
+	tm_file="sparc/biarch64.h ${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/linux64.h"
+	;;
+sparc64-*-netbsd*)
+	tmake_file="${tmake_file} sparc/t-netbsd64"
+	tm_file="sparc/biarch64.h ${tm_file}"
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h netbsd.h netbsd-elf.h sparc/netbsd-elf.h"
+	;;
+strongarm-*-elf*)
+	tm_file="arm/strongarm-elf.h dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h"
+	tmake_file=arm/t-strongarm-elf
+	out_file=arm/arm.c
+	md_file=arm/arm.md
+	extra_modes=arm/arm-modes.def
+	use_fixproto=yes
+	;;
+strongarm-*-pe)
+	tm_file="arm/semi.h arm/aout.h arm/coff.h dbxcoff.h arm/strongarm-coff.h arm/arm.h arm/pe.h arm/strongarm-pe.h"
+	tmake_file=arm/t-strongarm-pe
+	out_file=arm/arm.c
+	md_file=arm/arm.md
+	extra_modes=arm/arm-modes.def
+	extra_objs=pe.o
+	use_fixproto=yes
+	;;
+strongarm-*-kaos*)
+	tm_file="arm/strongarm-elf.h dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h kaos.h arm/kaos-strongarm.h"
+	tmake_file=arm/t-strongarm-elf
+	out_file=arm/arm.c
+	md_file=arm/arm.md
+	extra_modes=arm/arm-modes.def
+	;;
+v850e1-*-*)
+	target_cpu_default="TARGET_CPU_v850e1"
+	tm_file="dbxelf.h elfos.h svr4.h v850/v850.h"
+	tm_p_file=v850/v850-protos.h
+	tmake_file=v850/t-v850e
+	md_file=v850/v850.md
+	out_file=v850/v850.c
+	if test x$stabs = xyes
+	then
+		tm_file="${tm_file} dbx.h"
+	fi
+	use_collect2=no
+	c_target_objs="v850-c.o"
+	cxx_target_objs="v850-c.o"
+	use_fixproto=yes
+	;;
+v850e-*-*)
+	target_cpu_default="TARGET_CPU_v850e"
+	tm_file="dbxelf.h elfos.h svr4.h v850/v850.h"
+	tm_p_file=v850/v850-protos.h
+	tmake_file=v850/t-v850e
+	md_file=v850/v850.md
+	out_file=v850/v850.c
+	if test x$stabs = xyes
+	then
+		tm_file="${tm_file} dbx.h"
+	fi
+	use_collect2=no
+	c_target_objs="v850-c.o"
+	cxx_target_objs="v850-c.o"
+	use_fixproto=yes
+	;;
+v850-*-*)
+	target_cpu_default="TARGET_CPU_generic"
+	tm_file="dbxelf.h elfos.h svr4.h ${tm_file}"
+	tmake_file=v850/t-v850
+	if test x$stabs = xyes
+	then
+		tm_file="${tm_file} dbx.h"
+	fi
+	use_collect2=no
+	c_target_objs="v850-c.o"
+	cxx_target_objs="v850-c.o"
+	use_fixproto=yes
+	;;
+vax-*-bsd*)			# VAXen running BSD
+	tm_file="${tm_file} vax/bsd.h"
+	use_collect2=yes
+	use_fixproto=yes
+	;;
+vax-*-sysv*)			# VAXen running system V
+	tm_file="${tm_file} vax/vaxv.h"
+	use_fixproto=yes
+	;;
+vax-*-netbsdelf*)
+	tm_file="${tm_file} elfos.h netbsd.h netbsd-elf.h vax/elf.h vax/netbsd-elf.h"
+	;;
+vax-*-netbsd*)
+	tm_file="${tm_file} netbsd.h netbsd-aout.h vax/netbsd.h"
+	tmake_file=t-netbsd
+	extra_parts=""
+	use_collect2=yes
+	;;
+vax-*-openbsd*)
+	tm_file="vax/vax.h vax/openbsd1.h openbsd.h vax/openbsd.h"
+	use_collect2=yes
+	;;
+vax-*-ultrix*)			# VAXen running ultrix
+	tm_file="${tm_file} vax/ultrix.h"
+	use_fixproto=yes
+	;;
+vax-*-*)			# VAX default entry
+    if test "x$enable_obsolete" != xyes; then
+      echo "*** Configuration ${target} is obsolete." >&2
+      echo "*** Specify --enable-obsolete to build it anyway." >&2
+      echo "*** Support will be REMOVED in the next major release of GCC," >&2
+      echo "*** unless a maintainer comes forward." >&2
+      exit 1
+    fi
+	use_fixproto=yes
+	;;
+xscale-*-elf)
+	tm_file="arm/xscale-elf.h dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h"
+	tmake_file=arm/t-xscale-elf
+	out_file=arm/arm.c
+	md_file=arm/arm.md
+	extra_modes=arm/arm-modes.def
+	use_fixproto=yes
+	;;
+xscale-*-coff)
+	tm_file="arm/semi.h arm/aout.h arm/coff.h dbxcoff.h arm/xscale-coff.h arm/arm.h"
+	tmake_file=arm/t-xscale-coff
+	out_file=arm/arm.c
+	md_file=arm/arm.md
+	extra_modes=arm/arm-modes.def
+	use_fixproto=yes
+	;;
+xstormy16-*-elf)
+	# For historical reasons, the target files omit the 'x'.
+	tm_file="dbxelf.h elfos.h svr4.h stormy16/stormy16.h"
+	tm_p_file=stormy16/stormy16-protos.h
+	md_file=stormy16/stormy16.md
+	out_file=stormy16/stormy16.c
+	tmake_file="stormy16/t-stormy16"
+	extra_parts="crtbegin.o crtend.o"
+	use_fixproto=yes
+	;;
+xtensa-*-elf*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h xtensa/elf.h"
+	tmake_file="xtensa/t-xtensa xtensa/t-elf"
+	;;
+xtensa-*-linux*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h linux.h xtensa/linux.h"
+	tmake_file="t-slibgcc-elf-ver t-linux xtensa/t-xtensa xtensa/t-linux"
+	;;
+am33_2.0-*-linux*)
+	tm_file="mn10300/mn10300.h dbxelf.h elfos.h linux.h mn10300/linux.h"
+	tmake_file="t-slibgcc-elf-ver t-linux mn10300/t-linux"
+	gas=yes gnu_ld=yes
+	extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o"
+	use_collect2=no
+	;;
+*)
+	echo "*** Configuration ${target} not supported" 1>&2
+	exit 1
+	;;
+esac
+
+# Support for --with-cpu and related options (and a few unrelated options,
+# too).
+case ${with_cpu} in
+  yes | no)
+    echo "--with-cpu must be passed a value" 1>&2
+    exit 1
+    ;;
+esac
+
+# If there is no $with_cpu option, try to infer one from ${target}.
+# This block sets nothing except for with_cpu.
+if test x$with_cpu = x ; then
+  case ${target} in
+    ep9312-*-*)
+      # A Cirrus ARM variant.
+      with_cpu="ep9312"
+      ;;
+    i486-*-*)
+      with_cpu=i486
+      ;;
+    i586-*-*)
+      case ${target_noncanonical} in
+        k6_2-*)
+          with_cpu=k6-2
+          ;;
+        k6_3-*)
+          with_cpu=k6-3
+          ;;
+        k6-*)
+          with_cpu=k6
+          ;;
+        pentium_mmx-*|winchip_c6-*|winchip2-*|c3-*)
+          with_cpu=pentium-mmx
+          ;;
+        *)
+          with_cpu=pentium
+          ;;
+      esac
+      ;;
+    i686-*-* | i786-*-*)
+      case ${target_noncanonical} in
+        k8-*|opteron-*|athlon_64-*)
+          with_cpu=k8
+          ;;
+        athlon_xp-*|athlon_mp-*|athlon_4-*)
+          with_cpu=athlon-4
+          ;;
+        athlon_tbird-*|athlon-*)
+          with_cpu=athlon
+          ;;
+        pentium2-*)
+          with_cpu=pentium2
+          ;;
+        pentium3-*|pentium3m-*)
+          with_cpu=pentium3
+          ;;
+        pentium4-*|pentium4m-*)
+          with_cpu=pentium4
+          ;;
+        prescott-*)
+          with_cpu=prescott
+          ;;
+        nocona-*)
+          with_cpu=nocona
+          ;;
+        pentium_m-*)
+          with_cpu=pentium-m
+          ;;
+        *)
+          with_cpu=pentiumpro
+          ;;
+      esac
+      ;;
+    x86_64-*-*)
+      with_cpu=k8
+      ;;
+    alphaev6[78]*-*-*)
+      with_cpu=ev67
+      ;;
+    alphaev6*-*-*)
+      with_cpu=ev6
+      ;;
+    alphapca56*-*-*)
+      with_cpu=pca56
+      ;;
+    alphaev56*-*-*)
+      with_cpu=ev56
+      ;;
+    alphaev5*-*-*)
+      with_cpu=ev5
+      ;;
+    sparc*-*-*)
+      with_cpu="`echo ${target} | sed 's/-.*$//'`"
+      if [ x$with_cpu = xsparc64 ]; then
+        with_cpu=v9
+      fi
+      ;;
+  esac
+fi
+
+# Similarly for --with-schedule.
+if test x$with_schedule = x; then
+	case ${target} in
+	hppa1* | parisc1*)
+		# Override default PA8000 scheduling model.
+		with_schedule=7100LC
+		;;
+	esac
+fi
+
+# Validate and mark as valid any --with options supported
+# by this target.  In order to use a particular --with option
+# you must list it in supported_defaults; validating the value
+# is optional.  This case statement should set nothing besides
+# supported_defaults.
+
+supported_defaults=
+case "${target}" in
+	alpha*-*-*)
+		supported_defaults="cpu tune"
+		for which in cpu tune; do
+			eval "val=\$with_$which"
+			case "$val" in
+			"" \
+			| ev4 | ev45 | 21064 | ev5 | 21164 | ev56 | 21164a \
+			| pca56 | 21164PC | 21164pc | ev6 | 21264 | ev67 \
+			| 21264a)
+				;;
+			*)
+				echo "Unknown CPU used in --with-$which=$val" 1>&2
+				exit 1
+				;;
+			esac
+		done
+		;;
+
+	arm*-*-*)
+		supported_defaults="arch cpu float tune"
+		for which in cpu tune; do
+			eval "val=\$with_$which"
+			case "$val" in
+			"" \
+			| arm[236789] | arm250 | arm[67][01]0 \
+			| arm60 | arm620 | arm7d | arm7di \
+			| arm7m | arm7dm | arm7dmi | arm[79]tdmi \
+			| arm70 | arm700i | arm710t | arm720 \
+			| arm720t | arm740t | arm710c | arm920 \
+			| arm920t | arm926ejs | arm940t | arm9e | arm10tdmi \
+			| arm7100 | arm7500 | arm7500fe | arm810 \
+			| arm1026ejs | arm1020t | arm1136js | arm1136jfs \
+			| xscale | iwmmxt \
+			| ep9312 \
+			| strongarm | strongarm110 | strongarm11[01]0)
+				# OK
+				;;
+			*)
+				echo "Unknown CPU used in --with-$which=$val" 1>&2
+				exit 1
+				;;
+			esac
+		done
+
+		case "$with_arch" in
+		"" \
+		| armv[2345] | armv2a | armv3m | armv4t | armv5t \
+		| armv5te | armv6j | ep9312)
+			# OK
+			;;
+		*)
+			echo "Unknown arch used in --with-arch=$with_arch" 1>&2
+			exit 1
+			;;
+		esac
+
+		case "$with_float" in
+		"" \
+		| soft | hard)
+			# OK
+			;;
+		*)
+			echo "Unknown floating point type used in --with-float=$with_float" 1>&2
+			exit 1
+			;;
+		esac
+
+		if test "x$with_arch" != x && test "x$with_cpu" != x; then
+			echo "Warning: --with-arch overrides --with-cpu" 1>&2
+		fi
+		;;
+
+	hppa*-*-* | parisc*-*-*)
+		supported_defaults="arch schedule"
+
+		case "$with_arch" in
+		"" | 1.0 | 1.1 | 2.0)
+			# OK
+			;;
+		*)
+			echo "Unknown architecture used in --with-arch=$with_arch" 1>&2
+			exit 1
+			;;
+		esac
+
+		case "$with_schedule" in
+		"" | 700 | 7100 | 7100LC | 7200 | 7300 | 8000)
+			# OK
+			;;
+		*)
+			echo "Unknown processor used in --with-schedule=$with_schedule." 1>&2
+			exit 1
+			;;
+		esac
+		;;
+
+	i[34567]86-*-* | x86_64-*-*)
+		supported_defaults="arch cpu tune"
+		for which in arch cpu tune; do
+			eval "val=\$with_$which"
+			case ${val} in
+			"" | i386 | i486 \
+			| i586 | pentium | pentium-mmx | winchip-c6 | winchip2 \
+			| c3 | c3-2 | i686 | pentiumpro | pentium2 | pentium3 \
+			| pentium4 | k6 | k6-2 | k6-3 | athlon | athlon-tbird \
+			| athlon-4 | athlon-xp | athlon-mp | k8 | opteron \
+			| athlon64 | athlon-fx | prescott | pentium-m \
+			| pentium4m | pentium3m| nocona)
+				# OK
+				;;
+			*)
+				echo "Unknown CPU given in --with-$which=$val." 1>&2
+				exit 1
+				;;
+			esac
+		done
+		;;
+
+	mips*-*-*)
+		supported_defaults="abi arch float tune"
+
+		case ${with_float} in
+		"" | soft | hard)
+			# OK
+			;;
+		*)
+			echo "Unknown floating point type used in --with-float=$with_float" 1>&2
+			exit 1
+			;;
+		esac
+
+		case ${with_abi} in
+		"" | 32 | o64 | n32 | 64 | eabi)
+			# OK
+			;;
+		*)
+			echo "Unknown ABI used in --with-abi=$with_abi" 1>&2
+			exit 1
+			;;
+		esac
+		;;
+
+	powerpc*-*-* | rs6000-*-*)
+		supported_defaults="cpu float tune"
+
+		for which in cpu tune; do
+			eval "val=\$with_$which"
+			case ${val} in
+			default32 | default64)
+				with_which="with_$which"
+				eval $with_which=
+				;;
+			"" | common \
+			| power | power[2345] | powerpc | powerpc64 \
+			| rios | rios1 | rios2 | rsc | rsc1 | rs64a \
+			| 401 | 403 | 405 | 405fp | 440 | 440fp | 505 \
+			| 601 | 602 | 603 | 603e | ec603e | 604 \
+			| 604e | 620 | 630 | 740 | 750 | 7400 | 7450 \
+			| 8540 | 801 | 821 | 823 | 860 | 970 | G3 | G4 | G5)
+				# OK
+				;;
+			*)
+				echo "Unknown cpu used in --with-$which=$val." 1>&2
+				exit 1
+				;;
+			esac
+		done
+		;;
+
+	s390*-*-*)
+		supported_defaults="arch mode tune"
+
+		for which in arch tune; do
+			eval "val=\$with_$which"
+			case ${val} in
+			"" | g5 | g6 | z900 | z990)
+				# OK
+				;;
+			*)
+				echo "Unknown cpu used in --with-$which=$val." 1>&2
+				exit 1
+				;;
+			esac
+		done
+
+		case ${with_mode} in
+		"" | esa | zarch)
+			# OK
+			;;
+		*)
+			echo "Unknown architecture mode used in --with-mode=$with_mode." 1>&2
+			exit 1
+			;;
+		esac
+		;;
+
+	sparc*-*-*)
+		supported_defaults="cpu float tune"
+
+		for which in cpu tune; do
+			eval "val=\$with_$which"
+			case ${val} in
+			"" | sparc | sparcv9 | sparc64 | sparc86x \
+			| v7 | cypress | v8 | supersparc | sparclite | f930 \
+			| f934 | hypersparc | sparclite86x | sparclet | tsc701 \
+			| v9 | ultrasparc | ultrasparc3)
+				# OK
+				;;
+			*)
+				echo "Unknown cpu used in --with-$which=$val" 1>&2
+				exit 1
+				;;
+			esac
+		done
+
+		case ${with_float} in
+		"" | soft | hard)
+			# OK
+			;;
+		*)
+			echo "Unknown floating point type used in --with-float=$with_float" 1>&2
+			exit 1
+			;;
+		esac
+		;;
+
+	v850*-*-*)
+		supported_defaults=cpu
+		case ${with_cpu} in
+		"" | v850e | v850e1)
+			# OK
+			;;
+		*)
+			echo "Unknown cpu used in --with-cpu=$with_cpu" 1>&2
+			exit 1
+			;;
+		esac
+		;;
+esac
+
+# Set some miscellaneous flags for particular targets.
+target_cpu_default2=
+case ${target} in
+	alpha*-*-*)
+		if test x$gas = xyes
+		then
+			target_cpu_default2="MASK_GAS"
+		fi
+		;;
+
+	arm*-*-*)
+		case "x$with_cpu" in
+		x)
+			# The most generic
+			target_cpu_default2="TARGET_CPU_generic"
+			;;
+
+		*)
+			target_cpu_default2="TARGET_CPU_$with_cpu"
+			;;
+		esac
+		;;
+
+	hppa*-*-* | parisc*-*-*)
+		if test x$gas = xyes
+		then
+			target_cpu_default2="MASK_GAS|MASK_JUMP_IN_DELAY"
+		fi
+		;;
+
+	mips*-*-*)
+		case ${target} in
+		mips*-*-ecoff* | mips*-*-elf*)
+			if test x$gas = xyes
+			then
+				if test x$gnu_ld = xyes
+				then
+					target_cpu_default2="MASK_GAS|MASK_SPLIT_ADDR"
+				else
+					target_cpu_default2="MASK_GAS"
+				fi
+			fi
+			;;
+		mips*-*-*)
+			if test x$gas = xyes
+			then
+				target_cpu_default2="MASK_GAS"
+			fi
+			;;
+		esac
+		case ${target} in
+			mips*el-*-*)
+				tm_defines="TARGET_ENDIAN_DEFAULT=0 $tm_defines"
+				;;
+		esac
+		case $tm_file in
+			*mips/elf.h* | *mips/elf64.h*)
+				tm_defines="OBJECT_FORMAT_ELF $tm_defines"
+				;;
+		esac
+		if test "x$enable_gofast" = xyes
+		then
+			tm_defines="US_SOFTWARE_GOFAST $tm_defines"
+			tmake_file="mips/t-gofast $tmake_file"
+		else
+			tmake_file="mips/t-mips $tmake_file"
+		fi
+		;;
+
+	powerpc*-*-* | rs6000-*-*)
+		if test x$enable_altivec = xyes
+		then
+			tm_file="$tm_file rs6000/altivec-defs.h"
+		fi
+		# FIXME: The PowerPC port uses the value set at compile time,
+		# although it's only cosmetic.
+		if test "x$with_cpu" != x
+		then
+			target_cpu_default2="\\\"$with_cpu\\\""
+		fi
+		out_file=rs6000/rs6000.c
+		c_target_objs="${c_target_objs} rs6000-c.o"
+		cxx_target_objs="${cxx_target_objs} rs6000-c.o"
+		tmake_file="rs6000/t-rs6000 ${tmake_file}"
+		;;
+
+	sparc*-*-*)
+		# Some standard aliases.
+		case x$with_cpu in
+		xsparc)
+			with_cpu=v7
+			;;
+		xsparc86x)
+			with_cpu=sparclite86x
+			;;
+		xsparcv9 | xsparc64)
+			with_cpu=v9
+			;;
+		esac
+
+		# The Sparc port checks this value at compile-time.
+		target_cpu_default2="TARGET_CPU_$with_cpu"
+		;;
+	v850*-*-*)
+		# FIXME: The v850 is "special" in that it does not support
+		# runtime CPU selection, only --with-cpu.
+		case "x$with_cpu" in
+		x)
+			;;
+		xv850e)
+			target_cpu_default2="TARGET_CPU_$with_cpu"
+			;;
+		esac
+		;;
+esac
+
+t=
+all_defaults="abi cpu arch tune schedule float mode"
+for option in $all_defaults
+do
+	eval "val=\$with_$option"
+	if test -n "$val"; then
+		case " $supported_defaults " in
+		*" $option "*)
+			;;
+		*)
+			echo "This target does not support --with-$option." 2>&1
+			exit 1
+			;;
+		esac
+
+		if test "x$t" = x
+		then
+			t="{ \"$option\", \"$val\" }"
+		else
+			t="${t}, { \"$option\", \"$val\" }"
+		fi
+	fi
+done
+
+if test "x$t" = x
+then
+	configure_default_options="{ { NULL, NULL} }"
+else
+	configure_default_options="{ ${t} }"
+fi
+
+if test "$target_cpu_default2" != ""
+then
+	if test "$target_cpu_default" != ""
+	then
+		target_cpu_default="(${target_cpu_default}|${target_cpu_default2})"
+	else
+		target_cpu_default=$target_cpu_default2
+	fi
+fi
diff -Nurp gcc-3.4.6.orig/libstdc++-v3/config/locale/generic/c_locale.h gcc-3.4.6/libstdc++-v3/config/locale/generic/c_locale.h
--- gcc-3.4.6.orig/libstdc++-v3/config/locale/generic/c_locale.h	2005-02-02 17:46:40.000000000 +0100
+++ gcc-3.4.6/libstdc++-v3/config/locale/generic/c_locale.h	2006-11-08 18:56:53.000000000 +0100
@@ -41,12 +41,18 @@
 #include <clocale>
 #include <cstring>   // get std::strlen
 #include <cstdio>    // get std::snprintf or std::sprintf
+#include <features.h>
+#include <ctype.h>
 
 #define _GLIBCXX_NUM_CATEGORIES 0
 
 namespace std
 {
+#ifdef __UCLIBC__
+  typedef __ctype_touplow_t*			__c_locale;
+#else
   typedef int*			__c_locale;
+#endif
 
   // Convert numeric value of type _Tv to string and return length of
   // string.  If snprintf is available use it, otherwise fall back to
diff -Nurp gcc-3.4.6.orig/libstdc++-v3/config/os/gnu-linux/ctype_base.h gcc-3.4.6/libstdc++-v3/config/os/gnu-linux/ctype_base.h
--- gcc-3.4.6.orig/libstdc++-v3/config/os/gnu-linux/ctype_base.h	2003-10-09 21:10:56.000000000 +0200
+++ gcc-3.4.6/libstdc++-v3/config/os/gnu-linux/ctype_base.h	2006-11-08 18:56:53.000000000 +0100
@@ -31,13 +31,20 @@
 //
 // ISO C++ 14882: 22.1  Locales
 //
+
+#include <features.h>
+#include <ctype.h>
   
 // Information as gleaned from /usr/include/ctype.h
   
   struct ctype_base
   {
     // Non-standard typedefs.
-    typedef const int* 		__to_type;
+#ifdef __UCLIBC__
+    typedef const __ctype_touplow_t*	__to_type;
+#else
+    typedef const int*			__to_type;
+#endif
 
     // NB: Offsets into ctype<char>::_M_table force a particular size
     // on the mask type. Because of this, we don't use an enum.
diff -Nurp gcc-3.4.6.orig/libstdc++-v3/configure gcc-3.4.6/libstdc++-v3/configure
--- gcc-3.4.6.orig/libstdc++-v3/configure	2005-02-01 07:31:23.000000000 +0100
+++ gcc-3.4.6/libstdc++-v3/configure	2006-11-08 18:57:51.000000000 +0100
@@ -4012,6 +4012,10 @@ linux-gnu*)
   lt_cv_file_magic_test_file=`echo /lib/libc.so* /lib/libc-*.so`
   ;;
 
+linux-uclibc*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
 netbsd*)
   if echo __ELF__ | $CC -E - | grep __ELF__ > /dev/null; then
     lt_cv_deplibs_check_method='match_pattern /lib[^/\.]+\.so\.[0-9]+\.[0-9]+$'
diff -Nurp gcc-3.4.6.orig/libstdc++-v3/include/ext/rope gcc-3.4.6/libstdc++-v3/include/ext/rope
--- gcc-3.4.6.orig/libstdc++-v3/include/ext/rope	2005-01-16 23:08:43.000000000 +0100
+++ gcc-3.4.6/libstdc++-v3/include/ext/rope	2006-11-08 18:56:53.000000000 +0100
@@ -58,6 +58,9 @@
 #include <bits/allocator.h>
 #include <ext/hash_fun.h>
 
+/* cope w/ index defined as macro, SuSv3 proposal */
+#undef index
+
 # ifdef __GC
 #   define __GC_CONST const
 # else
diff -Nurp gcc-3.4.6.orig/libstdc++-v3/include/ext/ropeimpl.h gcc-3.4.6/libstdc++-v3/include/ext/ropeimpl.h
--- gcc-3.4.6.orig/libstdc++-v3/include/ext/ropeimpl.h	2004-09-08 15:36:04.000000000 +0200
+++ gcc-3.4.6/libstdc++-v3/include/ext/ropeimpl.h	2006-11-08 18:56:53.000000000 +0100
@@ -53,6 +53,9 @@
 #include <ext/memory> // For uninitialized_copy_n
 #include <ext/numeric> // For power
 
+/* cope w/ index defined as macro, SuSv3 proposal */
+#undef index
+
 namespace __gnu_cxx
 {
   using std::size_t;
diff -Nurp gcc-3.4.6.orig/libstdc++-v3/include/ext/rope.orig gcc-3.4.6/libstdc++-v3/include/ext/rope.orig
--- gcc-3.4.6.orig/libstdc++-v3/include/ext/rope.orig	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/libstdc++-v3/include/ext/rope.orig	2005-01-16 23:08:43.000000000 +0100
@@ -0,0 +1,2494 @@
+// SGI's rope class -*- C++ -*-
+
+// Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING.  If not, write to the Free
+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+// USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+/*
+ * Copyright (c) 1997
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/** @file ext/rope
+ *  This file is a GNU extension to the Standard C++ Library (possibly
+ *  containing extensions from the HP/SGI STL subset).  You should only
+ *  include this header if you are using GCC 3 or later.
+ */
+
+#ifndef _ROPE
+#define _ROPE 1
+
+#include <bits/stl_algobase.h>
+#include <bits/stl_construct.h>
+#include <bits/stl_uninitialized.h>
+#include <bits/stl_algo.h>
+#include <bits/stl_function.h>
+#include <bits/stl_numeric.h>
+#include <bits/allocator.h>
+#include <ext/hash_fun.h>
+
+# ifdef __GC
+#   define __GC_CONST const
+# else
+#   include <bits/gthr.h>
+#   define __GC_CONST   // constant except for deallocation
+# endif
+
+#include <ext/memory> // For uninitialized_copy_n
+
+namespace __gnu_cxx
+{
+using std::size_t;
+using std::ptrdiff_t;
+using std::allocator;
+using std::iterator;
+using std::reverse_iterator;
+using std::_Destroy;
+
+// The _S_eos function is used for those functions that
+// convert to/from C-like strings to detect the end of the string.
+
+// The end-of-C-string character.
+// This is what the draft standard says it should be.
+template <class _CharT>
+inline _CharT _S_eos(_CharT*) { return _CharT(); }
+
+// Test for basic character types.
+// For basic character types leaves having a trailing eos.
+template <class _CharT>
+inline bool _S_is_basic_char_type(_CharT*) { return false; }
+template <class _CharT>
+inline bool _S_is_one_byte_char_type(_CharT*) { return false; }
+
+inline bool _S_is_basic_char_type(char*) { return true; }
+inline bool _S_is_one_byte_char_type(char*) { return true; }
+inline bool _S_is_basic_char_type(wchar_t*) { return true; }
+
+// Store an eos iff _CharT is a basic character type.
+// Do not reference _S_eos if it isn't.
+template <class _CharT>
+inline void _S_cond_store_eos(_CharT&) {}
+
+inline void _S_cond_store_eos(char& __c) { __c = 0; }
+inline void _S_cond_store_eos(wchar_t& __c) { __c = 0; }
+
+// char_producers are logically functions that generate a section of
+// a string.  These can be convereted to ropes.  The resulting rope
+// invokes the char_producer on demand.  This allows, for example,
+// files to be viewed as ropes without reading the entire file.
+template <class _CharT>
+class char_producer {
+    public:
+        virtual ~char_producer() {};
+        virtual void operator()(size_t __start_pos, size_t __len,
+                                _CharT* __buffer) = 0;
+        // Buffer should really be an arbitrary output iterator.
+        // That way we could flatten directly into an ostream, etc.
+        // This is thoroughly impossible, since iterator types don't
+        // have runtime descriptions.
+};
+
+// Sequence buffers:
+//
+// Sequence must provide an append operation that appends an
+// array to the sequence.  Sequence buffers are useful only if
+// appending an entire array is cheaper than appending element by element.
+// This is true for many string representations.
+// This should  perhaps inherit from ostream<sequence::value_type>
+// and be implemented correspondingly, so that they can be used
+// for formatted.  For the sake of portability, we don't do this yet.
+//
+// For now, sequence buffers behave as output iterators.  But they also
+// behave a little like basic_ostringstream<sequence::value_type> and a
+// little like containers.
+
+template<class _Sequence, size_t _Buf_sz = 100>
+class sequence_buffer : public iterator<std::output_iterator_tag,void,void,void,void>
+{
+    public:
+        typedef typename _Sequence::value_type value_type;
+    protected:
+        _Sequence* _M_prefix;
+        value_type _M_buffer[_Buf_sz];
+        size_t     _M_buf_count;
+    public:
+        void flush() {
+            _M_prefix->append(_M_buffer, _M_buffer + _M_buf_count);
+            _M_buf_count = 0;
+        }
+        ~sequence_buffer() { flush(); }
+        sequence_buffer() : _M_prefix(0), _M_buf_count(0) {}
+        sequence_buffer(const sequence_buffer& __x) {
+            _M_prefix = __x._M_prefix;
+            _M_buf_count = __x._M_buf_count;
+            std::copy(__x._M_buffer, __x._M_buffer + __x._M_buf_count, _M_buffer);
+        }
+        sequence_buffer(sequence_buffer& __x) {
+            __x.flush();
+            _M_prefix = __x._M_prefix;
+            _M_buf_count = 0;
+        }
+        sequence_buffer(_Sequence& __s) : _M_prefix(&__s), _M_buf_count(0) {}
+        sequence_buffer& operator= (sequence_buffer& __x) {
+            __x.flush();
+            _M_prefix = __x._M_prefix;
+            _M_buf_count = 0;
+            return *this;
+        }
+        sequence_buffer& operator= (const sequence_buffer& __x) {
+            _M_prefix = __x._M_prefix;
+            _M_buf_count = __x._M_buf_count;
+            std::copy(__x._M_buffer, __x._M_buffer + __x._M_buf_count, _M_buffer);
+            return *this;
+        }
+        void push_back(value_type __x)
+        {
+            if (_M_buf_count < _Buf_sz) {
+                _M_buffer[_M_buf_count] = __x;
+                ++_M_buf_count;
+            } else {
+                flush();
+                _M_buffer[0] = __x;
+                _M_buf_count = 1;
+            }
+        }
+        void append(value_type* __s, size_t __len)
+        {
+            if (__len + _M_buf_count <= _Buf_sz) {
+                size_t __i = _M_buf_count;
+                for (size_t __j = 0; __j < __len; __i++, __j++) {
+                    _M_buffer[__i] = __s[__j];
+                }
+                _M_buf_count += __len;
+            } else if (0 == _M_buf_count) {
+                _M_prefix->append(__s, __s + __len);
+            } else {
+                flush();
+                append(__s, __len);
+            }
+        }
+        sequence_buffer& write(value_type* __s, size_t __len)
+        {
+            append(__s, __len);
+            return *this;
+        }
+        sequence_buffer& put(value_type __x)
+        {
+            push_back(__x);
+            return *this;
+        }
+        sequence_buffer& operator=(const value_type& __rhs)
+        {
+            push_back(__rhs);
+            return *this;
+        }
+        sequence_buffer& operator*() { return *this; }
+        sequence_buffer& operator++() { return *this; }
+        sequence_buffer operator++(int) { return *this; }
+};
+
+// The following should be treated as private, at least for now.
+template<class _CharT>
+class _Rope_char_consumer {
+    public:
+        // If we had member templates, these should not be virtual.
+        // For now we need to use run-time parametrization where
+        // compile-time would do.  Hence this should all be private
+        // for now.
+        // The symmetry with char_producer is accidental and temporary.
+        virtual ~_Rope_char_consumer() {};
+        virtual bool operator()(const _CharT* __buffer, size_t __len) = 0;
+};
+
+// First a lot of forward declarations.  The standard seems to require
+// much stricter "declaration before use" than many of the implementations
+// that preceded it.
+template<class _CharT, class _Alloc = allocator<_CharT> > class rope;
+template<class _CharT, class _Alloc> struct _Rope_RopeConcatenation;
+template<class _CharT, class _Alloc> struct _Rope_RopeLeaf;
+template<class _CharT, class _Alloc> struct _Rope_RopeFunction;
+template<class _CharT, class _Alloc> struct _Rope_RopeSubstring;
+template<class _CharT, class _Alloc> class _Rope_iterator;
+template<class _CharT, class _Alloc> class _Rope_const_iterator;
+template<class _CharT, class _Alloc> class _Rope_char_ref_proxy;
+template<class _CharT, class _Alloc> class _Rope_char_ptr_proxy;
+
+template<class _CharT, class _Alloc>
+bool operator== (const _Rope_char_ptr_proxy<_CharT,_Alloc>& __x,
+                 const _Rope_char_ptr_proxy<_CharT,_Alloc>& __y);
+
+template<class _CharT, class _Alloc>
+_Rope_const_iterator<_CharT,_Alloc> operator-
+        (const _Rope_const_iterator<_CharT,_Alloc>& __x,
+         ptrdiff_t __n);
+
+template<class _CharT, class _Alloc>
+_Rope_const_iterator<_CharT,_Alloc> operator+
+        (const _Rope_const_iterator<_CharT,_Alloc>& __x,
+         ptrdiff_t __n);
+
+template<class _CharT, class _Alloc>
+_Rope_const_iterator<_CharT,_Alloc> operator+
+        (ptrdiff_t __n,
+         const _Rope_const_iterator<_CharT,_Alloc>& __x);
+
+template<class _CharT, class _Alloc>
+bool operator==
+        (const _Rope_const_iterator<_CharT,_Alloc>& __x,
+         const _Rope_const_iterator<_CharT,_Alloc>& __y);
+
+template<class _CharT, class _Alloc>
+bool operator<
+        (const _Rope_const_iterator<_CharT,_Alloc>& __x,
+         const _Rope_const_iterator<_CharT,_Alloc>& __y);
+
+template<class _CharT, class _Alloc>
+ptrdiff_t operator-
+        (const _Rope_const_iterator<_CharT,_Alloc>& __x,
+         const _Rope_const_iterator<_CharT,_Alloc>& __y);
+
+template<class _CharT, class _Alloc>
+_Rope_iterator<_CharT,_Alloc> operator-
+        (const _Rope_iterator<_CharT,_Alloc>& __x,
+         ptrdiff_t __n);
+
+template<class _CharT, class _Alloc>
+_Rope_iterator<_CharT,_Alloc> operator+
+        (const _Rope_iterator<_CharT,_Alloc>& __x,
+         ptrdiff_t __n);
+
+template<class _CharT, class _Alloc>
+_Rope_iterator<_CharT,_Alloc> operator+
+        (ptrdiff_t __n,
+         const _Rope_iterator<_CharT,_Alloc>& __x);
+
+template<class _CharT, class _Alloc>
+bool operator==
+        (const _Rope_iterator<_CharT,_Alloc>& __x,
+         const _Rope_iterator<_CharT,_Alloc>& __y);
+
+template<class _CharT, class _Alloc>
+bool operator<
+        (const _Rope_iterator<_CharT,_Alloc>& __x,
+         const _Rope_iterator<_CharT,_Alloc>& __y);
+
+template<class _CharT, class _Alloc>
+ptrdiff_t operator-
+        (const _Rope_iterator<_CharT,_Alloc>& __x,
+         const _Rope_iterator<_CharT,_Alloc>& __y);
+
+template<class _CharT, class _Alloc>
+rope<_CharT,_Alloc> operator+ (const rope<_CharT,_Alloc>& __left,
+                               const rope<_CharT,_Alloc>& __right);
+
+template<class _CharT, class _Alloc>
+rope<_CharT,_Alloc> operator+ (const rope<_CharT,_Alloc>& __left,
+                               const _CharT* __right);
+
+template<class _CharT, class _Alloc>
+rope<_CharT,_Alloc> operator+ (const rope<_CharT,_Alloc>& __left,
+                               _CharT __right);
+
+// Some helpers, so we can use power on ropes.
+// See below for why this isn't local to the implementation.
+
+// This uses a nonstandard refcount convention.
+// The result has refcount 0.
+template<class _CharT, class _Alloc>
+struct _Rope_Concat_fn
+       : public std::binary_function<rope<_CharT,_Alloc>, rope<_CharT,_Alloc>,
+                                     rope<_CharT,_Alloc> > {
+        rope<_CharT,_Alloc> operator() (const rope<_CharT,_Alloc>& __x,
+                                const rope<_CharT,_Alloc>& __y) {
+                    return __x + __y;
+        }
+};
+
+template <class _CharT, class _Alloc>
+inline
+rope<_CharT,_Alloc>
+identity_element(_Rope_Concat_fn<_CharT, _Alloc>)
+{
+    return rope<_CharT,_Alloc>();
+}
+
+
+  // Class _Refcount_Base provides a type, _RC_t, a data member,
+  // _M_ref_count, and member functions _M_incr and _M_decr, which perform
+  // atomic preincrement/predecrement.  The constructor initializes
+  // _M_ref_count.
+  struct _Refcount_Base
+  {
+    // The type _RC_t
+    typedef size_t _RC_t;
+
+    // The data member _M_ref_count
+    volatile _RC_t _M_ref_count;
+
+    // Constructor
+    __gthread_mutex_t _M_ref_count_lock;
+
+    _Refcount_Base(_RC_t __n) : _M_ref_count(__n), _M_ref_count_lock()
+    {
+#ifdef __GTHREAD_MUTEX_INIT
+      __gthread_mutex_t __tmp = __GTHREAD_MUTEX_INIT;
+      _M_ref_count_lock = __tmp;
+#elif defined(__GTHREAD_MUTEX_INIT_FUNCTION)
+      __GTHREAD_MUTEX_INIT_FUNCTION (&_M_ref_count_lock);
+#else
+#error __GTHREAD_MUTEX_INIT or __GTHREAD_MUTEX_INIT_FUNCTION should be defined by gthr.h abstraction layer, report problem to libstdc++@gcc.gnu.org.
+#endif
+    }
+
+    void
+    _M_incr()
+    {
+      __gthread_mutex_lock(&_M_ref_count_lock);
+      ++_M_ref_count;
+      __gthread_mutex_unlock(&_M_ref_count_lock);
+    }
+
+    _RC_t
+    _M_decr()
+    {
+      __gthread_mutex_lock(&_M_ref_count_lock);
+      volatile _RC_t __tmp = --_M_ref_count;
+      __gthread_mutex_unlock(&_M_ref_count_lock);
+      return __tmp;
+    }
+  };
+
+//
+// What follows should really be local to rope.  Unfortunately,
+// that doesn't work, since it makes it impossible to define generic
+// equality on rope iterators.  According to the draft standard, the
+// template parameters for such an equality operator cannot be inferred
+// from the occurrence of a member class as a parameter.
+// (SGI compilers in fact allow this, but the __result wouldn't be
+// portable.)
+// Similarly, some of the static member functions are member functions
+// only to avoid polluting the global namespace, and to circumvent
+// restrictions on type inference for template functions.
+//
+
+//
+// The internal data structure for representing a rope.  This is
+// private to the implementation.  A rope is really just a pointer
+// to one of these.
+//
+// A few basic functions for manipulating this data structure
+// are members of _RopeRep.  Most of the more complex algorithms
+// are implemented as rope members.
+//
+// Some of the static member functions of _RopeRep have identically
+// named functions in rope that simply invoke the _RopeRep versions.
+
+#define __ROPE_DEFINE_ALLOCS(__a) \
+        __ROPE_DEFINE_ALLOC(_CharT,_Data) /* character data */ \
+        typedef _Rope_RopeConcatenation<_CharT,__a> __C; \
+        __ROPE_DEFINE_ALLOC(__C,_C) \
+        typedef _Rope_RopeLeaf<_CharT,__a> __L; \
+        __ROPE_DEFINE_ALLOC(__L,_L) \
+        typedef _Rope_RopeFunction<_CharT,__a> __F; \
+        __ROPE_DEFINE_ALLOC(__F,_F) \
+        typedef _Rope_RopeSubstring<_CharT,__a> __S; \
+        __ROPE_DEFINE_ALLOC(__S,_S)
+
+//  Internal rope nodes potentially store a copy of the allocator
+//  instance used to allocate them.  This is mostly redundant.
+//  But the alternative would be to pass allocator instances around
+//  in some form to nearly all internal functions, since any pointer
+//  assignment may result in a zero reference count and thus require
+//  deallocation.
+
+#define __STATIC_IF_SGI_ALLOC  /* not static */
+
+template <class _CharT, class _Alloc>
+struct _Rope_rep_base
+: public _Alloc
+{
+  typedef _Alloc allocator_type;
+
+  allocator_type
+  get_allocator() const { return *static_cast<const _Alloc*>(this); }
+
+  _Rope_rep_base(size_t __size, const allocator_type&)
+  : _M_size(__size) {}
+
+  size_t _M_size;
+
+# define __ROPE_DEFINE_ALLOC(_Tp, __name) \
+        typedef typename \
+          _Alloc::template rebind<_Tp>::other __name##Alloc; \
+        static _Tp* __name##_allocate(size_t __n) \
+          { return __name##Alloc().allocate(__n); } \
+        static void __name##_deallocate(_Tp *__p, size_t __n) \
+          { __name##Alloc().deallocate(__p, __n); }
+  __ROPE_DEFINE_ALLOCS(_Alloc)
+# undef __ROPE_DEFINE_ALLOC
+};
+
+namespace _Rope_constants
+{
+  enum { _S_max_rope_depth = 45 };
+  enum _Tag {_S_leaf, _S_concat, _S_substringfn, _S_function};
+}
+
+template<class _CharT, class _Alloc>
+struct _Rope_RopeRep : public _Rope_rep_base<_CharT,_Alloc>
+# ifndef __GC
+    , _Refcount_Base
+# endif
+{
+    public:
+    _Rope_constants::_Tag _M_tag:8;
+    bool _M_is_balanced:8;
+    unsigned char _M_depth;
+    __GC_CONST _CharT* _M_c_string;
+    __gthread_mutex_t _M_c_string_lock;
+                        /* Flattened version of string, if needed.  */
+                        /* typically 0.                             */
+                        /* If it's not 0, then the memory is owned  */
+                        /* by this node.                            */
+                        /* In the case of a leaf, this may point to */
+                        /* the same memory as the data field.       */
+    typedef typename _Rope_rep_base<_CharT,_Alloc>::allocator_type
+                        allocator_type;
+    using _Rope_rep_base<_CharT,_Alloc>::get_allocator;
+    _Rope_RopeRep(_Rope_constants::_Tag __t, int __d, bool __b, size_t __size,
+                  allocator_type __a)
+        : _Rope_rep_base<_CharT,_Alloc>(__size, __a),
+#         ifndef __GC
+          _Refcount_Base(1),
+#         endif
+          _M_tag(__t), _M_is_balanced(__b), _M_depth(__d), _M_c_string(0)
+#ifdef __GTHREAD_MUTEX_INIT
+    {
+	// Do not copy a POSIX/gthr mutex once in use.  However, bits are bits.
+	__gthread_mutex_t __tmp = __GTHREAD_MUTEX_INIT;
+	_M_c_string_lock = __tmp;
+    }
+#else
+    { __GTHREAD_MUTEX_INIT_FUNCTION (&_M_c_string_lock); }
+#endif
+#   ifdef __GC
+        void _M_incr () {}
+#   endif
+        static void _S_free_string(__GC_CONST _CharT*, size_t __len,
+                                   allocator_type __a);
+#       define __STL_FREE_STRING(__s, __l, __a) _S_free_string(__s, __l, __a);
+                        // Deallocate data section of a leaf.
+                        // This shouldn't be a member function.
+                        // But its hard to do anything else at the
+                        // moment, because it's templatized w.r.t.
+                        // an allocator.
+                        // Does nothing if __GC is defined.
+#   ifndef __GC
+          void _M_free_c_string();
+          void _M_free_tree();
+                        // Deallocate t. Assumes t is not 0.
+          void _M_unref_nonnil()
+          {
+              if (0 == _M_decr()) _M_free_tree();
+          }
+          void _M_ref_nonnil()
+          {
+              _M_incr();
+          }
+          static void _S_unref(_Rope_RopeRep* __t)
+          {
+              if (0 != __t) {
+                  __t->_M_unref_nonnil();
+              }
+          }
+          static void _S_ref(_Rope_RopeRep* __t)
+          {
+              if (0 != __t) __t->_M_incr();
+          }
+          static void _S_free_if_unref(_Rope_RopeRep* __t)
+          {
+              if (0 != __t && 0 == __t->_M_ref_count) __t->_M_free_tree();
+          }
+#   else /* __GC */
+          void _M_unref_nonnil() {}
+          void _M_ref_nonnil() {}
+          static void _S_unref(_Rope_RopeRep*) {}
+          static void _S_ref(_Rope_RopeRep*) {}
+          static void _S_free_if_unref(_Rope_RopeRep*) {}
+#   endif
+protected:
+  _Rope_RopeRep&
+  operator=(const _Rope_RopeRep&);
+
+  _Rope_RopeRep(const _Rope_RopeRep&);
+};
+
+template<class _CharT, class _Alloc>
+struct _Rope_RopeLeaf : public _Rope_RopeRep<_CharT,_Alloc> {
+  public:
+    // Apparently needed by VC++
+    // The data fields of leaves are allocated with some
+    // extra space, to accommodate future growth and for basic
+    // character types, to hold a trailing eos character.
+    enum { _S_alloc_granularity = 8 };
+    static size_t _S_rounded_up_size(size_t __n) {
+        size_t __size_with_eos;
+
+        if (_S_is_basic_char_type((_CharT*)0)) {
+            __size_with_eos = __n + 1;
+        } else {
+            __size_with_eos = __n;
+        }
+#       ifdef __GC
+           return __size_with_eos;
+#       else
+           // Allow slop for in-place expansion.
+           return (__size_with_eos + _S_alloc_granularity-1)
+                        &~ (_S_alloc_granularity-1);
+#       endif
+    }
+    __GC_CONST _CharT* _M_data; /* Not necessarily 0 terminated. */
+                                /* The allocated size is         */
+                                /* _S_rounded_up_size(size), except */
+                                /* in the GC case, in which it   */
+                                /* doesn't matter.               */
+    typedef typename _Rope_rep_base<_CharT,_Alloc>::allocator_type
+                        allocator_type;
+    _Rope_RopeLeaf(__GC_CONST _CharT* __d, size_t __size, allocator_type __a)
+        : _Rope_RopeRep<_CharT,_Alloc>(_Rope_constants::_S_leaf, 0, true, __size, __a), _M_data(__d)
+        {
+        if (_S_is_basic_char_type((_CharT *)0)) {
+            // already eos terminated.
+            this->_M_c_string = __d;
+        }
+    }
+        // The constructor assumes that d has been allocated with
+        // the proper allocator and the properly padded size.
+        // In contrast, the destructor deallocates the data:
+# ifndef __GC
+    ~_Rope_RopeLeaf() throw() {
+        if (_M_data != this->_M_c_string) {
+	  this->_M_free_c_string();
+        }
+        __STL_FREE_STRING(_M_data, this->_M_size, this->get_allocator());
+    }
+# endif
+protected:
+  _Rope_RopeLeaf&
+  operator=(const _Rope_RopeLeaf&);
+
+  _Rope_RopeLeaf(const _Rope_RopeLeaf&);
+};
+
+template<class _CharT, class _Alloc>
+struct _Rope_RopeConcatenation : public _Rope_RopeRep<_CharT,_Alloc> {
+  public:
+    _Rope_RopeRep<_CharT,_Alloc>* _M_left;
+    _Rope_RopeRep<_CharT,_Alloc>* _M_right;
+    typedef typename _Rope_rep_base<_CharT,_Alloc>::allocator_type
+                        allocator_type;
+    _Rope_RopeConcatenation(_Rope_RopeRep<_CharT,_Alloc>* __l,
+                             _Rope_RopeRep<_CharT,_Alloc>* __r,
+                             allocator_type __a)
+
+      : _Rope_RopeRep<_CharT,_Alloc>(_Rope_constants::_S_concat,
+                                     std::max(__l->_M_depth, __r->_M_depth) + 1,
+                                     false,
+                                     __l->_M_size + __r->_M_size, __a),
+        _M_left(__l), _M_right(__r)
+      {}
+# ifndef __GC
+    ~_Rope_RopeConcatenation() throw() {
+      this->_M_free_c_string();
+      _M_left->_M_unref_nonnil();
+      _M_right->_M_unref_nonnil();
+    }
+# endif
+protected:
+  _Rope_RopeConcatenation&
+  operator=(const _Rope_RopeConcatenation&);
+
+  _Rope_RopeConcatenation(const _Rope_RopeConcatenation&);
+};
+
+template<class _CharT, class _Alloc>
+struct _Rope_RopeFunction : public _Rope_RopeRep<_CharT,_Alloc> {
+  public:
+    char_producer<_CharT>* _M_fn;
+#   ifndef __GC
+      bool _M_delete_when_done; // Char_producer is owned by the
+                                // rope and should be explicitly
+                                // deleted when the rope becomes
+                                // inaccessible.
+#   else
+      // In the GC case, we either register the rope for
+      // finalization, or not.  Thus the field is unnecessary;
+      // the information is stored in the collector data structures.
+      // We do need a finalization procedure to be invoked by the
+      // collector.
+      static void _S_fn_finalization_proc(void * __tree, void *) {
+        delete ((_Rope_RopeFunction *)__tree) -> _M_fn;
+      }
+#   endif
+    typedef typename _Rope_rep_base<_CharT,_Alloc>::allocator_type
+                                        allocator_type;
+    _Rope_RopeFunction(char_producer<_CharT>* __f, size_t __size,
+                        bool __d, allocator_type __a)
+      : _Rope_RopeRep<_CharT,_Alloc>(_Rope_constants::_S_function,
+				     0, true, __size, __a)
+      , _M_fn(__f)
+#       ifndef __GC
+      , _M_delete_when_done(__d)
+#       endif
+    {
+#       ifdef __GC
+            if (__d) {
+                GC_REGISTER_FINALIZER(
+                  this, _Rope_RopeFunction::_S_fn_finalization_proc, 0, 0, 0);
+            }
+#       endif
+    }
+# ifndef __GC
+    ~_Rope_RopeFunction() throw() {
+          this->_M_free_c_string();
+          if (_M_delete_when_done) {
+              delete _M_fn;
+          }
+    }
+# endif
+protected:
+  _Rope_RopeFunction&
+  operator=(const _Rope_RopeFunction&);
+
+  _Rope_RopeFunction(const _Rope_RopeFunction&);
+};
+// Substring results are usually represented using just
+// concatenation nodes.  But in the case of very long flat ropes
+// or ropes with a functional representation that isn't practical.
+// In that case, we represent the __result as a special case of
+// RopeFunction, whose char_producer points back to the rope itself.
+// In all cases except repeated substring operations and
+// deallocation, we treat the __result as a RopeFunction.
+template<class _CharT, class _Alloc>
+struct _Rope_RopeSubstring : public _Rope_RopeFunction<_CharT,_Alloc>,
+                             public char_producer<_CharT> {
+  public:
+    // XXX this whole class should be rewritten.
+    _Rope_RopeRep<_CharT,_Alloc>* _M_base;      // not 0
+    size_t _M_start;
+    virtual void operator()(size_t __start_pos, size_t __req_len,
+                            _CharT* __buffer) {
+        switch(_M_base->_M_tag) {
+            case _Rope_constants::_S_function:
+            case _Rope_constants::_S_substringfn:
+              {
+                char_producer<_CharT>* __fn =
+                        ((_Rope_RopeFunction<_CharT,_Alloc>*)_M_base)->_M_fn;
+                (*__fn)(__start_pos + _M_start, __req_len, __buffer);
+              }
+              break;
+            case _Rope_constants::_S_leaf:
+              {
+                __GC_CONST _CharT* __s =
+                        ((_Rope_RopeLeaf<_CharT,_Alloc>*)_M_base)->_M_data;
+                uninitialized_copy_n(__s + __start_pos + _M_start, __req_len,
+                                     __buffer);
+              }
+              break;
+            default:
+	      break;
+        }
+    }
+    typedef typename _Rope_rep_base<_CharT,_Alloc>::allocator_type
+        allocator_type;
+    _Rope_RopeSubstring(_Rope_RopeRep<_CharT,_Alloc>* __b, size_t __s,
+                          size_t __l, allocator_type __a)
+      : _Rope_RopeFunction<_CharT,_Alloc>(this, __l, false, __a),
+        char_producer<_CharT>(),
+        _M_base(__b),
+        _M_start(__s)
+    {
+#       ifndef __GC
+            _M_base->_M_ref_nonnil();
+#       endif
+        this->_M_tag = _Rope_constants::_S_substringfn;
+    }
+    virtual ~_Rope_RopeSubstring() throw()
+      {
+#       ifndef __GC
+          _M_base->_M_unref_nonnil();
+          // _M_free_c_string();  -- done by parent class
+#       endif
+      }
+};
+
+
+// Self-destructing pointers to Rope_rep.
+// These are not conventional smart pointers.  Their
+// only purpose in life is to ensure that unref is called
+// on the pointer either at normal exit or if an exception
+// is raised.  It is the caller's responsibility to
+// adjust reference counts when these pointers are initialized
+// or assigned to.  (This convention significantly reduces
+// the number of potentially expensive reference count
+// updates.)
+#ifndef __GC
+  template<class _CharT, class _Alloc>
+  struct _Rope_self_destruct_ptr {
+    _Rope_RopeRep<_CharT,_Alloc>* _M_ptr;
+    ~_Rope_self_destruct_ptr()
+      { _Rope_RopeRep<_CharT,_Alloc>::_S_unref(_M_ptr); }
+#ifdef __EXCEPTIONS
+        _Rope_self_destruct_ptr() : _M_ptr(0) {};
+#else
+        _Rope_self_destruct_ptr() {};
+#endif
+    _Rope_self_destruct_ptr(_Rope_RopeRep<_CharT,_Alloc>* __p) : _M_ptr(__p) {}
+    _Rope_RopeRep<_CharT,_Alloc>& operator*() { return *_M_ptr; }
+    _Rope_RopeRep<_CharT,_Alloc>* operator->() { return _M_ptr; }
+    operator _Rope_RopeRep<_CharT,_Alloc>*() { return _M_ptr; }
+    _Rope_self_destruct_ptr& operator= (_Rope_RopeRep<_CharT,_Alloc>* __x)
+        { _M_ptr = __x; return *this; }
+  };
+#endif
+
+// Dereferencing a nonconst iterator has to return something
+// that behaves almost like a reference.  It's not possible to
+// return an actual reference since assignment requires extra
+// work.  And we would get into the same problems as with the
+// CD2 version of basic_string.
+template<class _CharT, class _Alloc>
+class _Rope_char_ref_proxy {
+    friend class rope<_CharT,_Alloc>;
+    friend class _Rope_iterator<_CharT,_Alloc>;
+    friend class _Rope_char_ptr_proxy<_CharT,_Alloc>;
+#   ifdef __GC
+        typedef _Rope_RopeRep<_CharT,_Alloc>* _Self_destruct_ptr;
+#   else
+        typedef _Rope_self_destruct_ptr<_CharT,_Alloc> _Self_destruct_ptr;
+#   endif
+    typedef _Rope_RopeRep<_CharT,_Alloc> _RopeRep;
+    typedef rope<_CharT,_Alloc> _My_rope;
+    size_t _M_pos;
+    _CharT _M_current;
+    bool _M_current_valid;
+    _My_rope* _M_root;     // The whole rope.
+  public:
+    _Rope_char_ref_proxy(_My_rope* __r, size_t __p)
+    :  _M_pos(__p), _M_current(), _M_current_valid(false), _M_root(__r) {}
+
+    _Rope_char_ref_proxy(const _Rope_char_ref_proxy& __x)
+    : _M_pos(__x._M_pos), _M_current(__x._M_current), _M_current_valid(false), 
+      _M_root(__x._M_root) {}
+
+  // Don't preserve cache if the reference can outlive the
+  // expression.  We claim that's not possible without calling
+  // a copy constructor or generating reference to a proxy
+  // reference.  We declare the latter to have undefined semantics.
+    _Rope_char_ref_proxy(_My_rope* __r, size_t __p, _CharT __c)
+      : _M_pos(__p), _M_current(__c), _M_current_valid(true), _M_root(__r) {}
+    inline operator _CharT () const;
+    _Rope_char_ref_proxy& operator= (_CharT __c);
+    _Rope_char_ptr_proxy<_CharT,_Alloc> operator& () const;
+    _Rope_char_ref_proxy& operator= (const _Rope_char_ref_proxy& __c) {
+        return operator=((_CharT)__c);
+    }
+};
+
+template<class _CharT, class __Alloc>
+inline void swap(_Rope_char_ref_proxy <_CharT, __Alloc > __a,
+                 _Rope_char_ref_proxy <_CharT, __Alloc > __b) {
+    _CharT __tmp = __a;
+    __a = __b;
+    __b = __tmp;
+}
+
+template<class _CharT, class _Alloc>
+class _Rope_char_ptr_proxy {
+    // XXX this class should be rewritten.
+    friend class _Rope_char_ref_proxy<_CharT,_Alloc>;
+    size_t _M_pos;
+    rope<_CharT,_Alloc>* _M_root;     // The whole rope.
+  public:
+    _Rope_char_ptr_proxy(const _Rope_char_ref_proxy<_CharT,_Alloc>& __x)
+      : _M_pos(__x._M_pos), _M_root(__x._M_root) {}
+    _Rope_char_ptr_proxy(const _Rope_char_ptr_proxy& __x)
+      : _M_pos(__x._M_pos), _M_root(__x._M_root) {}
+    _Rope_char_ptr_proxy() {}
+    _Rope_char_ptr_proxy(_CharT* __x) : _M_root(0), _M_pos(0) {
+    }
+    _Rope_char_ptr_proxy&
+    operator= (const _Rope_char_ptr_proxy& __x) {
+        _M_pos = __x._M_pos;
+        _M_root = __x._M_root;
+        return *this;
+    }
+    template<class _CharT2, class _Alloc2>
+    friend bool operator== (const _Rope_char_ptr_proxy<_CharT2,_Alloc2>& __x,
+                            const _Rope_char_ptr_proxy<_CharT2,_Alloc2>& __y);
+    _Rope_char_ref_proxy<_CharT,_Alloc> operator*() const {
+        return _Rope_char_ref_proxy<_CharT,_Alloc>(_M_root, _M_pos);
+    }
+};
+
+
+// Rope iterators:
+// Unlike in the C version, we cache only part of the stack
+// for rope iterators, since they must be efficiently copyable.
+// When we run out of cache, we have to reconstruct the iterator
+// value.
+// Pointers from iterators are not included in reference counts.
+// Iterators are assumed to be thread private.  Ropes can
+// be shared.
+
+template<class _CharT, class _Alloc>
+class _Rope_iterator_base
+  : public iterator<std::random_access_iterator_tag, _CharT>
+{
+    friend class rope<_CharT,_Alloc>;
+  public:
+    typedef _Alloc _allocator_type; // used in _Rope_rotate, VC++ workaround
+    typedef _Rope_RopeRep<_CharT,_Alloc> _RopeRep;
+        // Borland doesn't want this to be protected.
+  protected:
+    enum { _S_path_cache_len = 4 }; // Must be <= 9.
+    enum { _S_iterator_buf_len = 15 };
+    size_t _M_current_pos;
+    _RopeRep* _M_root;     // The whole rope.
+    size_t _M_leaf_pos;    // Starting position for current leaf
+    __GC_CONST _CharT* _M_buf_start;
+                        // Buffer possibly
+                        // containing current char.
+    __GC_CONST _CharT* _M_buf_ptr;
+                        // Pointer to current char in buffer.
+                        // != 0 ==> buffer valid.
+    __GC_CONST _CharT* _M_buf_end;
+                        // One past __last valid char in buffer.
+    // What follows is the path cache.  We go out of our
+    // way to make this compact.
+    // Path_end contains the bottom section of the path from
+    // the root to the current leaf.
+    const _RopeRep* _M_path_end[_S_path_cache_len];
+    int _M_leaf_index;     // Last valid __pos in path_end;
+                        // _M_path_end[0] ... _M_path_end[leaf_index-1]
+                        // point to concatenation nodes.
+    unsigned char _M_path_directions;
+                          // (path_directions >> __i) & 1 is 1
+                          // iff we got from _M_path_end[leaf_index - __i - 1]
+                          // to _M_path_end[leaf_index - __i] by going to the
+                          // __right. Assumes path_cache_len <= 9.
+    _CharT _M_tmp_buf[_S_iterator_buf_len];
+                        // Short buffer for surrounding chars.
+                        // This is useful primarily for
+                        // RopeFunctions.  We put the buffer
+                        // here to avoid locking in the
+                        // multithreaded case.
+    // The cached path is generally assumed to be valid
+    // only if the buffer is valid.
+    static void _S_setbuf(_Rope_iterator_base& __x);
+                                        // Set buffer contents given
+                                        // path cache.
+    static void _S_setcache(_Rope_iterator_base& __x);
+                                        // Set buffer contents and
+                                        // path cache.
+    static void _S_setcache_for_incr(_Rope_iterator_base& __x);
+                                        // As above, but assumes path
+                                        // cache is valid for previous posn.
+    _Rope_iterator_base() {}
+    _Rope_iterator_base(_RopeRep* __root, size_t __pos)
+      : _M_current_pos(__pos), _M_root(__root), _M_buf_ptr(0) {}
+    void _M_incr(size_t __n);
+    void _M_decr(size_t __n);
+  public:
+    size_t index() const { return _M_current_pos; }
+    _Rope_iterator_base(const _Rope_iterator_base& __x) {
+        if (0 != __x._M_buf_ptr) {
+            *this = __x;
+        } else {
+            _M_current_pos = __x._M_current_pos;
+            _M_root = __x._M_root;
+            _M_buf_ptr = 0;
+        }
+    }
+};
+
+template<class _CharT, class _Alloc> class _Rope_iterator;
+
+template<class _CharT, class _Alloc>
+class _Rope_const_iterator : public _Rope_iterator_base<_CharT,_Alloc> {
+    friend class rope<_CharT,_Alloc>;
+  protected:
+      typedef _Rope_RopeRep<_CharT,_Alloc> _RopeRep;
+      // The one from the base class may not be directly visible.
+    _Rope_const_iterator(const _RopeRep* __root, size_t __pos):
+                   _Rope_iterator_base<_CharT,_Alloc>(
+                     const_cast<_RopeRep*>(__root), __pos)
+                   // Only nonconst iterators modify root ref count
+    {}
+  public:
+    typedef _CharT reference;   // Really a value.  Returning a reference
+                                // Would be a mess, since it would have
+                                // to be included in refcount.
+    typedef const _CharT* pointer;
+
+  public:
+    _Rope_const_iterator() {};
+    _Rope_const_iterator(const _Rope_const_iterator& __x) :
+                                _Rope_iterator_base<_CharT,_Alloc>(__x) { }
+    _Rope_const_iterator(const _Rope_iterator<_CharT,_Alloc>& __x);
+    _Rope_const_iterator(const rope<_CharT,_Alloc>& __r, size_t __pos) :
+        _Rope_iterator_base<_CharT,_Alloc>(__r._M_tree_ptr, __pos) {}
+    _Rope_const_iterator& operator= (const _Rope_const_iterator& __x) {
+        if (0 != __x._M_buf_ptr) {
+            *(static_cast<_Rope_iterator_base<_CharT,_Alloc>*>(this)) = __x;
+        } else {
+            this->_M_current_pos = __x._M_current_pos;
+            this->_M_root = __x._M_root;
+            this->_M_buf_ptr = 0;
+        }
+        return(*this);
+    }
+    reference operator*() {
+        if (0 == this->_M_buf_ptr) _S_setcache(*this);
+        return *this->_M_buf_ptr;
+    }
+    _Rope_const_iterator& operator++() {
+        __GC_CONST _CharT* __next;
+        if (0 != this->_M_buf_ptr
+	    && (__next = this->_M_buf_ptr + 1) < this->_M_buf_end) {
+            this->_M_buf_ptr = __next;
+            ++this->_M_current_pos;
+        } else {
+            this->_M_incr(1);
+        }
+        return *this;
+    }
+    _Rope_const_iterator& operator+=(ptrdiff_t __n) {
+        if (__n >= 0) {
+            this->_M_incr(__n);
+        } else {
+	    this->_M_decr(-__n);
+        }
+        return *this;
+    }
+    _Rope_const_iterator& operator--() {
+        this->_M_decr(1);
+        return *this;
+    }
+    _Rope_const_iterator& operator-=(ptrdiff_t __n) {
+        if (__n >= 0) {
+            this->_M_decr(__n);
+        } else {
+            this->_M_incr(-__n);
+        }
+        return *this;
+    }
+    _Rope_const_iterator operator++(int) {
+        size_t __old_pos = this->_M_current_pos;
+        this->_M_incr(1);
+        return _Rope_const_iterator<_CharT,_Alloc>(this->_M_root, __old_pos);
+        // This makes a subsequent dereference expensive.
+        // Perhaps we should instead copy the iterator
+        // if it has a valid cache?
+    }
+    _Rope_const_iterator operator--(int) {
+        size_t __old_pos = this->_M_current_pos;
+        this->_M_decr(1);
+        return _Rope_const_iterator<_CharT,_Alloc>(this->_M_root, __old_pos);
+    }
+    template<class _CharT2, class _Alloc2>
+    friend _Rope_const_iterator<_CharT2,_Alloc2> operator-
+        (const _Rope_const_iterator<_CharT2,_Alloc2>& __x,
+         ptrdiff_t __n);
+    template<class _CharT2, class _Alloc2>
+    friend _Rope_const_iterator<_CharT2,_Alloc2> operator+
+        (const _Rope_const_iterator<_CharT2,_Alloc2>& __x,
+         ptrdiff_t __n);
+    template<class _CharT2, class _Alloc2>
+    friend _Rope_const_iterator<_CharT2,_Alloc2> operator+
+        (ptrdiff_t __n,
+         const _Rope_const_iterator<_CharT2,_Alloc2>& __x);
+    reference operator[](size_t __n) {
+        return rope<_CharT,_Alloc>::_S_fetch(this->_M_root,
+					     this->_M_current_pos + __n);
+    }
+
+    template<class _CharT2, class _Alloc2>
+    friend bool operator==
+        (const _Rope_const_iterator<_CharT2,_Alloc2>& __x,
+         const _Rope_const_iterator<_CharT2,_Alloc2>& __y);
+    template<class _CharT2, class _Alloc2>
+    friend bool operator<
+        (const _Rope_const_iterator<_CharT2,_Alloc2>& __x,
+         const _Rope_const_iterator<_CharT2,_Alloc2>& __y);
+    template<class _CharT2, class _Alloc2>
+    friend ptrdiff_t operator-
+        (const _Rope_const_iterator<_CharT2,_Alloc2>& __x,
+         const _Rope_const_iterator<_CharT2,_Alloc2>& __y);
+};
+
+template<class _CharT, class _Alloc>
+class _Rope_iterator : public _Rope_iterator_base<_CharT,_Alloc> {
+    friend class rope<_CharT,_Alloc>;
+  protected:
+    typedef typename _Rope_iterator_base<_CharT,_Alloc>::_RopeRep _RopeRep;
+    rope<_CharT,_Alloc>* _M_root_rope;
+        // root is treated as a cached version of this,
+        // and is used to detect changes to the underlying
+        // rope.
+        // Root is included in the reference count.
+        // This is necessary so that we can detect changes reliably.
+        // Unfortunately, it requires careful bookkeeping for the
+        // nonGC case.
+    _Rope_iterator(rope<_CharT,_Alloc>* __r, size_t __pos)
+      : _Rope_iterator_base<_CharT,_Alloc>(__r->_M_tree_ptr, __pos),
+        _M_root_rope(__r)
+      { _RopeRep::_S_ref(this->_M_root);
+        if (!(__r -> empty()))_S_setcache(*this); }
+
+    void _M_check();
+  public:
+    typedef _Rope_char_ref_proxy<_CharT,_Alloc>  reference;
+    typedef _Rope_char_ref_proxy<_CharT,_Alloc>* pointer;
+
+  public:
+    rope<_CharT,_Alloc>& container() { return *_M_root_rope; }
+    _Rope_iterator() {
+        this->_M_root = 0;  // Needed for reference counting.
+    };
+    _Rope_iterator(const _Rope_iterator& __x) :
+        _Rope_iterator_base<_CharT,_Alloc>(__x) {
+        _M_root_rope = __x._M_root_rope;
+        _RopeRep::_S_ref(this->_M_root);
+    }
+    _Rope_iterator(rope<_CharT,_Alloc>& __r, size_t __pos);
+    ~_Rope_iterator() {
+        _RopeRep::_S_unref(this->_M_root);
+    }
+    _Rope_iterator& operator= (const _Rope_iterator& __x) {
+        _RopeRep* __old = this->_M_root;
+
+        _RopeRep::_S_ref(__x._M_root);
+        if (0 != __x._M_buf_ptr) {
+            _M_root_rope = __x._M_root_rope;
+            *(static_cast<_Rope_iterator_base<_CharT,_Alloc>*>(this)) = __x;
+        } else {
+	    this->_M_current_pos = __x._M_current_pos;
+            this->_M_root = __x._M_root;
+            _M_root_rope = __x._M_root_rope;
+            this->_M_buf_ptr = 0;
+        }
+        _RopeRep::_S_unref(__old);
+        return(*this);
+    }
+    reference operator*() {
+        _M_check();
+        if (0 == this->_M_buf_ptr) {
+            return _Rope_char_ref_proxy<_CharT,_Alloc>(
+               _M_root_rope, this->_M_current_pos);
+        } else {
+            return _Rope_char_ref_proxy<_CharT,_Alloc>(
+               _M_root_rope, this->_M_current_pos, *this->_M_buf_ptr);
+        }
+    }
+    _Rope_iterator& operator++() {
+        this->_M_incr(1);
+        return *this;
+    }
+    _Rope_iterator& operator+=(ptrdiff_t __n) {
+        if (__n >= 0) {
+            this->_M_incr(__n);
+        } else {
+            this->_M_decr(-__n);
+        }
+        return *this;
+    }
+    _Rope_iterator& operator--() {
+        this->_M_decr(1);
+        return *this;
+    }
+    _Rope_iterator& operator-=(ptrdiff_t __n) {
+        if (__n >= 0) {
+            this->_M_decr(__n);
+        } else {
+            this->_M_incr(-__n);
+        }
+        return *this;
+    }
+    _Rope_iterator operator++(int) {
+        size_t __old_pos = this->_M_current_pos;
+        this->_M_incr(1);
+        return _Rope_iterator<_CharT,_Alloc>(_M_root_rope, __old_pos);
+    }
+    _Rope_iterator operator--(int) {
+        size_t __old_pos = this->_M_current_pos;
+        this->_M_decr(1);
+        return _Rope_iterator<_CharT,_Alloc>(_M_root_rope, __old_pos);
+    }
+    reference operator[](ptrdiff_t __n) {
+        return _Rope_char_ref_proxy<_CharT,_Alloc>(
+          _M_root_rope, this->_M_current_pos + __n);
+    }
+
+    template<class _CharT2, class _Alloc2>
+    friend bool operator==
+        (const _Rope_iterator<_CharT2,_Alloc2>& __x,
+         const _Rope_iterator<_CharT2,_Alloc2>& __y);
+    template<class _CharT2, class _Alloc2>
+    friend bool operator<
+        (const _Rope_iterator<_CharT2,_Alloc2>& __x,
+         const _Rope_iterator<_CharT2,_Alloc2>& __y);
+    template<class _CharT2, class _Alloc2>
+    friend ptrdiff_t operator-
+        (const _Rope_iterator<_CharT2,_Alloc2>& __x,
+         const _Rope_iterator<_CharT2,_Alloc2>& __y);
+    template<class _CharT2, class _Alloc2>
+    friend _Rope_iterator<_CharT2,_Alloc2> operator-
+        (const _Rope_iterator<_CharT2,_Alloc2>& __x,
+         ptrdiff_t __n);
+    template<class _CharT2, class _Alloc2>
+    friend _Rope_iterator<_CharT2,_Alloc2> operator+
+        (const _Rope_iterator<_CharT2,_Alloc2>& __x,
+         ptrdiff_t __n);
+    template<class _CharT2, class _Alloc2>
+    friend _Rope_iterator<_CharT2,_Alloc2> operator+
+        (ptrdiff_t __n,
+         const _Rope_iterator<_CharT2,_Alloc2>& __x);
+};
+
+
+template <class _CharT, class _Alloc>
+struct _Rope_base
+: public _Alloc
+{
+  typedef _Alloc allocator_type;
+
+  allocator_type
+  get_allocator() const { return *static_cast<const _Alloc*>(this); }
+
+  typedef _Rope_RopeRep<_CharT,_Alloc> _RopeRep;
+  // The one in _Base may not be visible due to template rules.
+
+  _Rope_base(_RopeRep* __t, const allocator_type&)
+  : _M_tree_ptr(__t) {}
+  _Rope_base(const allocator_type&) {}
+
+  // The only data member of a rope:
+  _RopeRep *_M_tree_ptr;
+
+# define __ROPE_DEFINE_ALLOC(_Tp, __name) \
+        typedef typename \
+          _Alloc::template rebind<_Tp>::other __name##Alloc; \
+        static _Tp* __name##_allocate(size_t __n) \
+          { return __name##Alloc().allocate(__n); } \
+        static void __name##_deallocate(_Tp *__p, size_t __n) \
+          { __name##Alloc().deallocate(__p, __n); }
+  __ROPE_DEFINE_ALLOCS(_Alloc)
+# undef __ROPE_DEFINE_ALLOC
+
+protected:
+  _Rope_base&
+  operator=(const _Rope_base&);
+
+  _Rope_base(const _Rope_base&);
+};
+
+
+/**
+ *  This is an SGI extension.
+ *  @ingroup SGIextensions
+ *  @doctodo
+*/
+template <class _CharT, class _Alloc>
+class rope : public _Rope_base<_CharT,_Alloc> {
+    public:
+        typedef _CharT value_type;
+        typedef ptrdiff_t difference_type;
+        typedef size_t size_type;
+        typedef _CharT const_reference;
+        typedef const _CharT* const_pointer;
+        typedef _Rope_iterator<_CharT,_Alloc> iterator;
+        typedef _Rope_const_iterator<_CharT,_Alloc> const_iterator;
+        typedef _Rope_char_ref_proxy<_CharT,_Alloc> reference;
+        typedef _Rope_char_ptr_proxy<_CharT,_Alloc> pointer;
+
+        friend class _Rope_iterator<_CharT,_Alloc>;
+        friend class _Rope_const_iterator<_CharT,_Alloc>;
+        friend struct _Rope_RopeRep<_CharT,_Alloc>;
+        friend class _Rope_iterator_base<_CharT,_Alloc>;
+        friend class _Rope_char_ptr_proxy<_CharT,_Alloc>;
+        friend class _Rope_char_ref_proxy<_CharT,_Alloc>;
+        friend struct _Rope_RopeSubstring<_CharT,_Alloc>;
+
+    protected:
+        typedef _Rope_base<_CharT,_Alloc> _Base;
+        typedef typename _Base::allocator_type allocator_type;
+        using _Base::_M_tree_ptr;
+        using _Base::get_allocator;
+        typedef __GC_CONST _CharT* _Cstrptr;
+
+        static _CharT _S_empty_c_str[1];
+
+        static bool _S_is0(_CharT __c) { return __c == _S_eos((_CharT*)0); }
+        enum { _S_copy_max = 23 };
+                // For strings shorter than _S_copy_max, we copy to
+                // concatenate.
+
+        typedef _Rope_RopeRep<_CharT,_Alloc> _RopeRep;
+        typedef _Rope_RopeConcatenation<_CharT,_Alloc> _RopeConcatenation;
+        typedef _Rope_RopeLeaf<_CharT,_Alloc> _RopeLeaf;
+        typedef _Rope_RopeFunction<_CharT,_Alloc> _RopeFunction;
+        typedef _Rope_RopeSubstring<_CharT,_Alloc> _RopeSubstring;
+
+        // Retrieve a character at the indicated position.
+        static _CharT _S_fetch(_RopeRep* __r, size_type __pos);
+
+#       ifndef __GC
+            // Obtain a pointer to the character at the indicated position.
+            // The pointer can be used to change the character.
+            // If such a pointer cannot be produced, as is frequently the
+            // case, 0 is returned instead.
+            // (Returns nonzero only if all nodes in the path have a refcount
+            // of 1.)
+            static _CharT* _S_fetch_ptr(_RopeRep* __r, size_type __pos);
+#       endif
+
+        static bool _S_apply_to_pieces(
+                                // should be template parameter
+                                _Rope_char_consumer<_CharT>& __c,
+                                const _RopeRep* __r,
+                                size_t __begin, size_t __end);
+                                // begin and end are assumed to be in range.
+
+#       ifndef __GC
+          static void _S_unref(_RopeRep* __t)
+          {
+              _RopeRep::_S_unref(__t);
+          }
+          static void _S_ref(_RopeRep* __t)
+          {
+              _RopeRep::_S_ref(__t);
+          }
+#       else /* __GC */
+          static void _S_unref(_RopeRep*) {}
+          static void _S_ref(_RopeRep*) {}
+#       endif
+
+
+#       ifdef __GC
+            typedef _Rope_RopeRep<_CharT,_Alloc>* _Self_destruct_ptr;
+#       else
+            typedef _Rope_self_destruct_ptr<_CharT,_Alloc> _Self_destruct_ptr;
+#       endif
+
+        // _Result is counted in refcount.
+        static _RopeRep* _S_substring(_RopeRep* __base,
+                                    size_t __start, size_t __endp1);
+
+        static _RopeRep* _S_concat_char_iter(_RopeRep* __r,
+                                          const _CharT* __iter, size_t __slen);
+                // Concatenate rope and char ptr, copying __s.
+                // Should really take an arbitrary iterator.
+                // Result is counted in refcount.
+        static _RopeRep* _S_destr_concat_char_iter(_RopeRep* __r,
+                                          const _CharT* __iter, size_t __slen)
+                // As above, but one reference to __r is about to be
+                // destroyed.  Thus the pieces may be recycled if all
+                // relevant reference counts are 1.
+#           ifdef __GC
+                // We can't really do anything since refcounts are unavailable.
+                { return _S_concat_char_iter(__r, __iter, __slen); }
+#           else
+                ;
+#           endif
+
+        static _RopeRep* _S_concat(_RopeRep* __left, _RopeRep* __right);
+                // General concatenation on _RopeRep.  _Result
+                // has refcount of 1.  Adjusts argument refcounts.
+
+   public:
+        void apply_to_pieces( size_t __begin, size_t __end,
+                              _Rope_char_consumer<_CharT>& __c) const {
+            _S_apply_to_pieces(__c, this->_M_tree_ptr, __begin, __end);
+        }
+
+
+   protected:
+
+        static size_t _S_rounded_up_size(size_t __n) {
+            return _RopeLeaf::_S_rounded_up_size(__n);
+        }
+
+        static size_t _S_allocated_capacity(size_t __n) {
+            if (_S_is_basic_char_type((_CharT*)0)) {
+                return _S_rounded_up_size(__n) - 1;
+            } else {
+                return _S_rounded_up_size(__n);
+            }
+        }
+
+        // Allocate and construct a RopeLeaf using the supplied allocator
+        // Takes ownership of s instead of copying.
+        static _RopeLeaf* _S_new_RopeLeaf(__GC_CONST _CharT *__s,
+                                          size_t __size, allocator_type __a)
+        {
+            _RopeLeaf* __space = typename _Base::_LAlloc(__a).allocate(1);
+            return new(__space) _RopeLeaf(__s, __size, __a);
+        }
+
+        static _RopeConcatenation* _S_new_RopeConcatenation(
+                        _RopeRep* __left, _RopeRep* __right,
+                        allocator_type __a)
+        {
+            _RopeConcatenation* __space = typename _Base::_CAlloc(__a).allocate(1);
+            return new(__space) _RopeConcatenation(__left, __right, __a);
+        }
+
+        static _RopeFunction* _S_new_RopeFunction(char_producer<_CharT>* __f,
+                size_t __size, bool __d, allocator_type __a)
+        {
+            _RopeFunction* __space = typename _Base::_FAlloc(__a).allocate(1);
+            return new(__space) _RopeFunction(__f, __size, __d, __a);
+        }
+
+        static _RopeSubstring* _S_new_RopeSubstring(
+                _Rope_RopeRep<_CharT,_Alloc>* __b, size_t __s,
+                size_t __l, allocator_type __a)
+        {
+            _RopeSubstring* __space = typename _Base::_SAlloc(__a).allocate(1);
+            return new(__space) _RopeSubstring(__b, __s, __l, __a);
+        }
+
+          static
+          _RopeLeaf* _S_RopeLeaf_from_unowned_char_ptr(const _CharT *__s,
+                       size_t __size, allocator_type __a)
+#         define __STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __size, __a) \
+                _S_RopeLeaf_from_unowned_char_ptr(__s, __size, __a)
+        {
+            if (0 == __size) return 0;
+            _CharT* __buf = __a.allocate(_S_rounded_up_size(__size));
+
+            uninitialized_copy_n(__s, __size, __buf);
+            _S_cond_store_eos(__buf[__size]);
+            try {
+              return _S_new_RopeLeaf(__buf, __size, __a);
+            }
+            catch(...)
+	      {
+		_RopeRep::__STL_FREE_STRING(__buf, __size, __a);
+		__throw_exception_again;
+	      }
+        }
+
+
+        // Concatenation of nonempty strings.
+        // Always builds a concatenation node.
+        // Rebalances if the result is too deep.
+        // Result has refcount 1.
+        // Does not increment left and right ref counts even though
+        // they are referenced.
+        static _RopeRep*
+        _S_tree_concat(_RopeRep* __left, _RopeRep* __right);
+
+        // Concatenation helper functions
+        static _RopeLeaf*
+        _S_leaf_concat_char_iter(_RopeLeaf* __r,
+                                 const _CharT* __iter, size_t __slen);
+                // Concatenate by copying leaf.
+                // should take an arbitrary iterator
+                // result has refcount 1.
+#       ifndef __GC
+          static _RopeLeaf* _S_destr_leaf_concat_char_iter
+                        (_RopeLeaf* __r, const _CharT* __iter, size_t __slen);
+          // A version that potentially clobbers __r if __r->_M_ref_count == 1.
+#       endif
+
+        private:
+
+        static size_t _S_char_ptr_len(const _CharT* __s);
+                        // slightly generalized strlen
+
+        rope(_RopeRep* __t, const allocator_type& __a = allocator_type())
+          : _Base(__t,__a) { }
+
+
+        // Copy __r to the _CharT buffer.
+        // Returns __buffer + __r->_M_size.
+        // Assumes that buffer is uninitialized.
+        static _CharT* _S_flatten(_RopeRep* __r, _CharT* __buffer);
+
+        // Again, with explicit starting position and length.
+        // Assumes that buffer is uninitialized.
+        static _CharT* _S_flatten(_RopeRep* __r,
+                                  size_t __start, size_t __len,
+                                  _CharT* __buffer);
+
+        static const unsigned long
+          _S_min_len[_Rope_constants::_S_max_rope_depth + 1];
+
+        static bool _S_is_balanced(_RopeRep* __r)
+                { return (__r->_M_size >= _S_min_len[__r->_M_depth]); }
+
+        static bool _S_is_almost_balanced(_RopeRep* __r)
+                { return (__r->_M_depth == 0 ||
+                          __r->_M_size >= _S_min_len[__r->_M_depth - 1]); }
+
+        static bool _S_is_roughly_balanced(_RopeRep* __r)
+                { return (__r->_M_depth <= 1 ||
+                          __r->_M_size >= _S_min_len[__r->_M_depth - 2]); }
+
+        // Assumes the result is not empty.
+        static _RopeRep* _S_concat_and_set_balanced(_RopeRep* __left,
+                                                     _RopeRep* __right)
+        {
+            _RopeRep* __result = _S_concat(__left, __right);
+            if (_S_is_balanced(__result)) __result->_M_is_balanced = true;
+            return __result;
+        }
+
+        // The basic rebalancing operation.  Logically copies the
+        // rope.  The result has refcount of 1.  The client will
+        // usually decrement the reference count of __r.
+        // The result is within height 2 of balanced by the above
+        // definition.
+        static _RopeRep* _S_balance(_RopeRep* __r);
+
+        // Add all unbalanced subtrees to the forest of balanceed trees.
+        // Used only by balance.
+        static void _S_add_to_forest(_RopeRep*__r, _RopeRep** __forest);
+
+        // Add __r to forest, assuming __r is already balanced.
+        static void _S_add_leaf_to_forest(_RopeRep* __r, _RopeRep** __forest);
+
+        // Print to stdout, exposing structure
+        static void _S_dump(_RopeRep* __r, int __indent = 0);
+
+        // Return -1, 0, or 1 if __x < __y, __x == __y, or __x > __y resp.
+        static int _S_compare(const _RopeRep* __x, const _RopeRep* __y);
+
+   public:
+        bool empty() const { return 0 == this->_M_tree_ptr; }
+
+        // Comparison member function.  This is public only for those
+        // clients that need a ternary comparison.  Others
+        // should use the comparison operators below.
+        int compare(const rope& __y) const {
+            return _S_compare(this->_M_tree_ptr, __y._M_tree_ptr);
+        }
+
+        rope(const _CharT* __s, const allocator_type& __a = allocator_type())
+        : _Base(__STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, _S_char_ptr_len(__s),
+                                                 __a),__a)
+        { }
+
+        rope(const _CharT* __s, size_t __len,
+             const allocator_type& __a = allocator_type())
+        : _Base(__STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __len, __a), __a)
+        { }
+
+        // Should perhaps be templatized with respect to the iterator type
+        // and use Sequence_buffer.  (It should perhaps use sequence_buffer
+        // even now.)
+        rope(const _CharT *__s, const _CharT *__e,
+             const allocator_type& __a = allocator_type())
+        : _Base(__STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __e - __s, __a), __a)
+        { }
+
+        rope(const const_iterator& __s, const const_iterator& __e,
+             const allocator_type& __a = allocator_type())
+        : _Base(_S_substring(__s._M_root, __s._M_current_pos,
+                             __e._M_current_pos), __a)
+        { }
+
+        rope(const iterator& __s, const iterator& __e,
+             const allocator_type& __a = allocator_type())
+        : _Base(_S_substring(__s._M_root, __s._M_current_pos,
+                             __e._M_current_pos), __a)
+        { }
+
+        rope(_CharT __c, const allocator_type& __a = allocator_type())
+        : _Base(__a)
+        {
+	    _CharT* __buf = this->_Data_allocate(_S_rounded_up_size(1));
+
+            std::_Construct(__buf, __c);
+            try {
+                this->_M_tree_ptr = _S_new_RopeLeaf(__buf, 1, __a);
+            }
+            catch(...)
+	      {
+		_RopeRep::__STL_FREE_STRING(__buf, 1, __a);
+		__throw_exception_again;
+	      }
+        }
+
+        rope(size_t __n, _CharT __c,
+             const allocator_type& __a = allocator_type());
+
+        rope(const allocator_type& __a = allocator_type())
+        : _Base(0, __a) {}
+
+        // Construct a rope from a function that can compute its members
+        rope(char_producer<_CharT> *__fn, size_t __len, bool __delete_fn,
+             const allocator_type& __a = allocator_type())
+            : _Base(__a)
+        {
+            this->_M_tree_ptr = (0 == __len) ?
+               0 : _S_new_RopeFunction(__fn, __len, __delete_fn, __a);
+        }
+
+        rope(const rope& __x, const allocator_type& __a = allocator_type())
+        : _Base(__x._M_tree_ptr, __a)
+        {
+            _S_ref(this->_M_tree_ptr);
+        }
+
+      ~rope() throw()
+       { _S_unref(this->_M_tree_ptr); }
+
+        rope& operator=(const rope& __x)
+        {
+            _RopeRep* __old = this->_M_tree_ptr;
+            this->_M_tree_ptr = __x._M_tree_ptr;
+            _S_ref(this->_M_tree_ptr);
+            _S_unref(__old);
+            return *this;
+        }
+
+        void clear()
+        {
+            _S_unref(this->_M_tree_ptr);
+            this->_M_tree_ptr = 0;
+        }
+
+        void push_back(_CharT __x)
+        {
+            _RopeRep* __old = this->_M_tree_ptr;
+            this->_M_tree_ptr
+	      = _S_destr_concat_char_iter(this->_M_tree_ptr, &__x, 1);
+            _S_unref(__old);
+        }
+
+        void pop_back()
+        {
+            _RopeRep* __old = this->_M_tree_ptr;
+            this->_M_tree_ptr =
+              _S_substring(this->_M_tree_ptr,
+			   0,
+			   this->_M_tree_ptr->_M_size - 1);
+            _S_unref(__old);
+        }
+
+        _CharT back() const
+        {
+            return _S_fetch(this->_M_tree_ptr, this->_M_tree_ptr->_M_size - 1);
+        }
+
+        void push_front(_CharT __x)
+        {
+            _RopeRep* __old = this->_M_tree_ptr;
+            _RopeRep* __left =
+              __STL_ROPE_FROM_UNOWNED_CHAR_PTR(&__x, 1, this->get_allocator());
+            try {
+              this->_M_tree_ptr = _S_concat(__left, this->_M_tree_ptr);
+              _S_unref(__old);
+              _S_unref(__left);
+            }
+            catch(...)
+	      {
+		_S_unref(__left);
+		__throw_exception_again;
+	      }
+        }
+
+        void pop_front()
+        {
+            _RopeRep* __old = this->_M_tree_ptr;
+            this->_M_tree_ptr
+	      = _S_substring(this->_M_tree_ptr, 1, this->_M_tree_ptr->_M_size);
+            _S_unref(__old);
+        }
+
+        _CharT front() const
+        {
+            return _S_fetch(this->_M_tree_ptr, 0);
+        }
+
+        void balance()
+        {
+            _RopeRep* __old = this->_M_tree_ptr;
+            this->_M_tree_ptr = _S_balance(this->_M_tree_ptr);
+            _S_unref(__old);
+        }
+
+        void copy(_CharT* __buffer) const {
+            _Destroy(__buffer, __buffer + size());
+            _S_flatten(this->_M_tree_ptr, __buffer);
+        }
+
+        // This is the copy function from the standard, but
+        // with the arguments reordered to make it consistent with the
+        // rest of the interface.
+        // Note that this guaranteed not to compile if the draft standard
+        // order is assumed.
+        size_type copy(size_type __pos, size_type __n, _CharT* __buffer) const
+        {
+            size_t __size = size();
+            size_t __len = (__pos + __n > __size? __size - __pos : __n);
+
+            _Destroy(__buffer, __buffer + __len);
+            _S_flatten(this->_M_tree_ptr, __pos, __len, __buffer);
+            return __len;
+        }
+
+        // Print to stdout, exposing structure.  May be useful for
+        // performance debugging.
+        void dump() {
+            _S_dump(this->_M_tree_ptr);
+        }
+
+        // Convert to 0 terminated string in new allocated memory.
+        // Embedded 0s in the input do not terminate the copy.
+        const _CharT* c_str() const;
+
+        // As above, but lso use the flattened representation as the
+        // the new rope representation.
+        const _CharT* replace_with_c_str();
+
+        // Reclaim memory for the c_str generated flattened string.
+        // Intentionally undocumented, since it's hard to say when this
+        // is safe for multiple threads.
+        void delete_c_str () {
+            if (0 == this->_M_tree_ptr) return;
+            if (_Rope_constants::_S_leaf == this->_M_tree_ptr->_M_tag &&
+                ((_RopeLeaf*)this->_M_tree_ptr)->_M_data ==
+                      this->_M_tree_ptr->_M_c_string) {
+                // Representation shared
+                return;
+            }
+#           ifndef __GC
+              this->_M_tree_ptr->_M_free_c_string();
+#           endif
+            this->_M_tree_ptr->_M_c_string = 0;
+        }
+
+        _CharT operator[] (size_type __pos) const {
+            return _S_fetch(this->_M_tree_ptr, __pos);
+        }
+
+        _CharT at(size_type __pos) const {
+           // if (__pos >= size()) throw out_of_range;  // XXX
+           return (*this)[__pos];
+        }
+
+        const_iterator begin() const {
+            return(const_iterator(this->_M_tree_ptr, 0));
+        }
+
+        // An easy way to get a const iterator from a non-const container.
+        const_iterator const_begin() const {
+            return(const_iterator(this->_M_tree_ptr, 0));
+        }
+
+        const_iterator end() const {
+            return(const_iterator(this->_M_tree_ptr, size()));
+        }
+
+        const_iterator const_end() const {
+            return(const_iterator(this->_M_tree_ptr, size()));
+        }
+
+        size_type size() const {
+            return(0 == this->_M_tree_ptr? 0 : this->_M_tree_ptr->_M_size);
+        }
+
+        size_type length() const {
+            return size();
+        }
+
+        size_type max_size() const {
+            return _S_min_len[_Rope_constants::_S_max_rope_depth - 1] - 1;
+            //  Guarantees that the result can be sufficirntly
+            //  balanced.  Longer ropes will probably still work,
+            //  but it's harder to make guarantees.
+        }
+
+        typedef reverse_iterator<const_iterator> const_reverse_iterator;
+
+        const_reverse_iterator rbegin() const {
+            return const_reverse_iterator(end());
+        }
+
+        const_reverse_iterator const_rbegin() const {
+            return const_reverse_iterator(end());
+        }
+
+        const_reverse_iterator rend() const {
+            return const_reverse_iterator(begin());
+        }
+
+        const_reverse_iterator const_rend() const {
+            return const_reverse_iterator(begin());
+        }
+
+        template<class _CharT2, class _Alloc2>
+        friend rope<_CharT2,_Alloc2>
+        operator+ (const rope<_CharT2,_Alloc2>& __left,
+                   const rope<_CharT2,_Alloc2>& __right);
+
+        template<class _CharT2, class _Alloc2>
+        friend rope<_CharT2,_Alloc2>
+        operator+ (const rope<_CharT2,_Alloc2>& __left,
+                   const _CharT2* __right);
+
+        template<class _CharT2, class _Alloc2>
+        friend rope<_CharT2,_Alloc2>
+        operator+ (const rope<_CharT2,_Alloc2>& __left, _CharT2 __right);
+        // The symmetric cases are intentionally omitted, since they're presumed
+        // to be less common, and we don't handle them as well.
+
+        // The following should really be templatized.
+        // The first argument should be an input iterator or
+        // forward iterator with value_type _CharT.
+        rope& append(const _CharT* __iter, size_t __n) {
+            _RopeRep* __result =
+              _S_destr_concat_char_iter(this->_M_tree_ptr, __iter, __n);
+            _S_unref(this->_M_tree_ptr);
+            this->_M_tree_ptr = __result;
+            return *this;
+        }
+
+        rope& append(const _CharT* __c_string) {
+            size_t __len = _S_char_ptr_len(__c_string);
+            append(__c_string, __len);
+            return(*this);
+        }
+
+        rope& append(const _CharT* __s, const _CharT* __e) {
+            _RopeRep* __result =
+                _S_destr_concat_char_iter(this->_M_tree_ptr, __s, __e - __s);
+            _S_unref(this->_M_tree_ptr);
+            this->_M_tree_ptr = __result;
+            return *this;
+        }
+
+        rope& append(const_iterator __s, const_iterator __e) {
+            _Self_destruct_ptr __appendee(_S_substring(
+              __s._M_root, __s._M_current_pos, __e._M_current_pos));
+            _RopeRep* __result =
+              _S_concat(this->_M_tree_ptr, (_RopeRep*)__appendee);
+            _S_unref(this->_M_tree_ptr);
+            this->_M_tree_ptr = __result;
+            return *this;
+        }
+
+        rope& append(_CharT __c) {
+            _RopeRep* __result =
+              _S_destr_concat_char_iter(this->_M_tree_ptr, &__c, 1);
+            _S_unref(this->_M_tree_ptr);
+            this->_M_tree_ptr = __result;
+            return *this;
+        }
+
+        rope& append() { return append(_CharT()); }  // XXX why?
+
+        rope& append(const rope& __y) {
+            _RopeRep* __result = _S_concat(this->_M_tree_ptr, __y._M_tree_ptr);
+            _S_unref(this->_M_tree_ptr);
+            this->_M_tree_ptr = __result;
+            return *this;
+        }
+
+        rope& append(size_t __n, _CharT __c) {
+            rope<_CharT,_Alloc> __last(__n, __c);
+            return append(__last);
+        }
+
+        void swap(rope& __b) {
+            _RopeRep* __tmp = this->_M_tree_ptr;
+            this->_M_tree_ptr = __b._M_tree_ptr;
+            __b._M_tree_ptr = __tmp;
+        }
+
+
+    protected:
+        // Result is included in refcount.
+        static _RopeRep* replace(_RopeRep* __old, size_t __pos1,
+                                  size_t __pos2, _RopeRep* __r) {
+            if (0 == __old) { _S_ref(__r); return __r; }
+            _Self_destruct_ptr __left(
+              _S_substring(__old, 0, __pos1));
+            _Self_destruct_ptr __right(
+              _S_substring(__old, __pos2, __old->_M_size));
+            _RopeRep* __result;
+
+            if (0 == __r) {
+                __result = _S_concat(__left, __right);
+            } else {
+                _Self_destruct_ptr __left_result(_S_concat(__left, __r));
+                __result = _S_concat(__left_result, __right);
+            }
+            return __result;
+        }
+
+    public:
+        void insert(size_t __p, const rope& __r) {
+            _RopeRep* __result =
+              replace(this->_M_tree_ptr, __p, __p, __r._M_tree_ptr);
+            _S_unref(this->_M_tree_ptr);
+            this->_M_tree_ptr = __result;
+        }
+
+        void insert(size_t __p, size_t __n, _CharT __c) {
+            rope<_CharT,_Alloc> __r(__n,__c);
+            insert(__p, __r);
+        }
+
+        void insert(size_t __p, const _CharT* __i, size_t __n) {
+            _Self_destruct_ptr __left(_S_substring(this->_M_tree_ptr, 0, __p));
+            _Self_destruct_ptr __right(_S_substring(this->_M_tree_ptr,
+						    __p, size()));
+            _Self_destruct_ptr __left_result(
+              _S_concat_char_iter(__left, __i, __n));
+                // _S_ destr_concat_char_iter should be safe here.
+                // But as it stands it's probably not a win, since __left
+                // is likely to have additional references.
+            _RopeRep* __result = _S_concat(__left_result, __right);
+            _S_unref(this->_M_tree_ptr);
+            this->_M_tree_ptr = __result;
+        }
+
+        void insert(size_t __p, const _CharT* __c_string) {
+            insert(__p, __c_string, _S_char_ptr_len(__c_string));
+        }
+
+        void insert(size_t __p, _CharT __c) {
+            insert(__p, &__c, 1);
+        }
+
+        void insert(size_t __p) {
+            _CharT __c = _CharT();
+            insert(__p, &__c, 1);
+        }
+
+        void insert(size_t __p, const _CharT* __i, const _CharT* __j) {
+            rope __r(__i, __j);
+            insert(__p, __r);
+        }
+
+        void insert(size_t __p, const const_iterator& __i,
+                              const const_iterator& __j) {
+            rope __r(__i, __j);
+            insert(__p, __r);
+        }
+
+        void insert(size_t __p, const iterator& __i,
+                              const iterator& __j) {
+            rope __r(__i, __j);
+            insert(__p, __r);
+        }
+
+        // (position, length) versions of replace operations:
+
+        void replace(size_t __p, size_t __n, const rope& __r) {
+            _RopeRep* __result =
+              replace(this->_M_tree_ptr, __p, __p + __n, __r._M_tree_ptr);
+            _S_unref(this->_M_tree_ptr);
+            this->_M_tree_ptr = __result;
+        }
+
+        void replace(size_t __p, size_t __n,
+                     const _CharT* __i, size_t __i_len) {
+            rope __r(__i, __i_len);
+            replace(__p, __n, __r);
+        }
+
+        void replace(size_t __p, size_t __n, _CharT __c) {
+            rope __r(__c);
+            replace(__p, __n, __r);
+        }
+
+        void replace(size_t __p, size_t __n, const _CharT* __c_string) {
+            rope __r(__c_string);
+            replace(__p, __n, __r);
+        }
+
+        void replace(size_t __p, size_t __n,
+                     const _CharT* __i, const _CharT* __j) {
+            rope __r(__i, __j);
+            replace(__p, __n, __r);
+        }
+
+        void replace(size_t __p, size_t __n,
+                     const const_iterator& __i, const const_iterator& __j) {
+            rope __r(__i, __j);
+            replace(__p, __n, __r);
+        }
+
+        void replace(size_t __p, size_t __n,
+                     const iterator& __i, const iterator& __j) {
+            rope __r(__i, __j);
+            replace(__p, __n, __r);
+        }
+
+        // Single character variants:
+        void replace(size_t __p, _CharT __c) {
+            iterator __i(this, __p);
+            *__i = __c;
+        }
+
+        void replace(size_t __p, const rope& __r) {
+            replace(__p, 1, __r);
+        }
+
+        void replace(size_t __p, const _CharT* __i, size_t __i_len) {
+            replace(__p, 1, __i, __i_len);
+        }
+
+        void replace(size_t __p, const _CharT* __c_string) {
+            replace(__p, 1, __c_string);
+        }
+
+        void replace(size_t __p, const _CharT* __i, const _CharT* __j) {
+            replace(__p, 1, __i, __j);
+        }
+
+        void replace(size_t __p, const const_iterator& __i,
+                               const const_iterator& __j) {
+            replace(__p, 1, __i, __j);
+        }
+
+        void replace(size_t __p, const iterator& __i,
+                               const iterator& __j) {
+            replace(__p, 1, __i, __j);
+        }
+
+        // Erase, (position, size) variant.
+        void erase(size_t __p, size_t __n) {
+            _RopeRep* __result = replace(this->_M_tree_ptr, __p, __p + __n, 0);
+            _S_unref(this->_M_tree_ptr);
+            this->_M_tree_ptr = __result;
+        }
+
+        // Erase, single character
+        void erase(size_t __p) {
+            erase(__p, __p + 1);
+        }
+
+        // Insert, iterator variants.
+        iterator insert(const iterator& __p, const rope& __r)
+                { insert(__p.index(), __r); return __p; }
+        iterator insert(const iterator& __p, size_t __n, _CharT __c)
+                { insert(__p.index(), __n, __c); return __p; }
+        iterator insert(const iterator& __p, _CharT __c)
+                { insert(__p.index(), __c); return __p; }
+        iterator insert(const iterator& __p )
+                { insert(__p.index()); return __p; }
+        iterator insert(const iterator& __p, const _CharT* c_string)
+                { insert(__p.index(), c_string); return __p; }
+        iterator insert(const iterator& __p, const _CharT* __i, size_t __n)
+                { insert(__p.index(), __i, __n); return __p; }
+        iterator insert(const iterator& __p, const _CharT* __i,
+                        const _CharT* __j)
+                { insert(__p.index(), __i, __j);  return __p; }
+        iterator insert(const iterator& __p,
+                        const const_iterator& __i, const const_iterator& __j)
+                { insert(__p.index(), __i, __j); return __p; }
+        iterator insert(const iterator& __p,
+                        const iterator& __i, const iterator& __j)
+                { insert(__p.index(), __i, __j); return __p; }
+
+        // Replace, range variants.
+        void replace(const iterator& __p, const iterator& __q,
+                     const rope& __r)
+                { replace(__p.index(), __q.index() - __p.index(), __r); }
+        void replace(const iterator& __p, const iterator& __q, _CharT __c)
+                { replace(__p.index(), __q.index() - __p.index(), __c); }
+        void replace(const iterator& __p, const iterator& __q,
+                     const _CharT* __c_string)
+                { replace(__p.index(), __q.index() - __p.index(), __c_string); }
+        void replace(const iterator& __p, const iterator& __q,
+                     const _CharT* __i, size_t __n)
+                { replace(__p.index(), __q.index() - __p.index(), __i, __n); }
+        void replace(const iterator& __p, const iterator& __q,
+                     const _CharT* __i, const _CharT* __j)
+                { replace(__p.index(), __q.index() - __p.index(), __i, __j); }
+        void replace(const iterator& __p, const iterator& __q,
+                     const const_iterator& __i, const const_iterator& __j)
+                { replace(__p.index(), __q.index() - __p.index(), __i, __j); }
+        void replace(const iterator& __p, const iterator& __q,
+                     const iterator& __i, const iterator& __j)
+                { replace(__p.index(), __q.index() - __p.index(), __i, __j); }
+
+        // Replace, iterator variants.
+        void replace(const iterator& __p, const rope& __r)
+                { replace(__p.index(), __r); }
+        void replace(const iterator& __p, _CharT __c)
+                { replace(__p.index(), __c); }
+        void replace(const iterator& __p, const _CharT* __c_string)
+                { replace(__p.index(), __c_string); }
+        void replace(const iterator& __p, const _CharT* __i, size_t __n)
+                { replace(__p.index(), __i, __n); }
+        void replace(const iterator& __p, const _CharT* __i, const _CharT* __j)
+                { replace(__p.index(), __i, __j); }
+        void replace(const iterator& __p, const_iterator __i,
+                     const_iterator __j)
+                { replace(__p.index(), __i, __j); }
+        void replace(const iterator& __p, iterator __i, iterator __j)
+                { replace(__p.index(), __i, __j); }
+
+        // Iterator and range variants of erase
+        iterator erase(const iterator& __p, const iterator& __q) {
+            size_t __p_index = __p.index();
+            erase(__p_index, __q.index() - __p_index);
+            return iterator(this, __p_index);
+        }
+        iterator erase(const iterator& __p) {
+            size_t __p_index = __p.index();
+            erase(__p_index, 1);
+            return iterator(this, __p_index);
+        }
+
+        rope substr(size_t __start, size_t __len = 1) const {
+            return rope<_CharT,_Alloc>(
+                        _S_substring(this->_M_tree_ptr,
+				     __start,
+				     __start + __len));
+        }
+
+        rope substr(iterator __start, iterator __end) const {
+            return rope<_CharT,_Alloc>(
+                _S_substring(this->_M_tree_ptr,
+			     __start.index(),
+			     __end.index()));
+        }
+
+        rope substr(iterator __start) const {
+            size_t __pos = __start.index();
+            return rope<_CharT,_Alloc>(
+                        _S_substring(this->_M_tree_ptr, __pos, __pos + 1));
+        }
+
+        rope substr(const_iterator __start, const_iterator __end) const {
+            // This might eventually take advantage of the cache in the
+            // iterator.
+            return rope<_CharT,_Alloc>(
+              _S_substring(this->_M_tree_ptr, __start.index(), __end.index()));
+        }
+
+        rope<_CharT,_Alloc> substr(const_iterator __start) {
+            size_t __pos = __start.index();
+            return rope<_CharT,_Alloc>(
+              _S_substring(this->_M_tree_ptr, __pos, __pos + 1));
+        }
+
+        static const size_type npos;
+
+        size_type find(_CharT __c, size_type __pos = 0) const;
+        size_type find(const _CharT* __s, size_type __pos = 0) const {
+            size_type __result_pos;
+            const_iterator __result =
+	      std::search(const_begin() + __pos, const_end(),
+			  __s, __s + _S_char_ptr_len(__s));
+            __result_pos = __result.index();
+#           ifndef __STL_OLD_ROPE_SEMANTICS
+                if (__result_pos == size()) __result_pos = npos;
+#           endif
+            return __result_pos;
+        }
+
+        iterator mutable_begin() {
+            return(iterator(this, 0));
+        }
+
+        iterator mutable_end() {
+            return(iterator(this, size()));
+        }
+
+        typedef reverse_iterator<iterator> reverse_iterator;
+
+        reverse_iterator mutable_rbegin() {
+            return reverse_iterator(mutable_end());
+        }
+
+        reverse_iterator mutable_rend() {
+            return reverse_iterator(mutable_begin());
+        }
+
+        reference mutable_reference_at(size_type __pos) {
+            return reference(this, __pos);
+        }
+
+#       ifdef __STD_STUFF
+            reference operator[] (size_type __pos) {
+                return _char_ref_proxy(this, __pos);
+            }
+
+            reference at(size_type __pos) {
+                // if (__pos >= size()) throw out_of_range;  // XXX
+                return (*this)[__pos];
+            }
+
+            void resize(size_type __n, _CharT __c) {}
+            void resize(size_type __n) {}
+            void reserve(size_type __res_arg = 0) {}
+            size_type capacity() const {
+                return max_size();
+            }
+
+          // Stuff below this line is dangerous because it's error prone.
+          // I would really like to get rid of it.
+            // copy function with funny arg ordering.
+              size_type copy(_CharT* __buffer, size_type __n,
+                             size_type __pos = 0) const {
+                return copy(__pos, __n, __buffer);
+              }
+
+            iterator end() { return mutable_end(); }
+
+            iterator begin() { return mutable_begin(); }
+
+            reverse_iterator rend() { return mutable_rend(); }
+
+            reverse_iterator rbegin() { return mutable_rbegin(); }
+
+#       else
+
+            const_iterator end() { return const_end(); }
+
+            const_iterator begin() { return const_begin(); }
+
+            const_reverse_iterator rend() { return const_rend(); }
+
+            const_reverse_iterator rbegin() { return const_rbegin(); }
+
+#       endif
+
+};
+
+template <class _CharT, class _Alloc>
+const typename rope<_CharT, _Alloc>::size_type rope<_CharT, _Alloc>::npos =
+                        (size_type)(-1);
+
+template <class _CharT, class _Alloc>
+inline bool operator== (const _Rope_const_iterator<_CharT,_Alloc>& __x,
+                        const _Rope_const_iterator<_CharT,_Alloc>& __y) {
+  return (__x._M_current_pos == __y._M_current_pos &&
+          __x._M_root == __y._M_root);
+}
+
+template <class _CharT, class _Alloc>
+inline bool operator< (const _Rope_const_iterator<_CharT,_Alloc>& __x,
+                       const _Rope_const_iterator<_CharT,_Alloc>& __y) {
+  return (__x._M_current_pos < __y._M_current_pos);
+}
+
+template <class _CharT, class _Alloc>
+inline bool operator!= (const _Rope_const_iterator<_CharT,_Alloc>& __x,
+                        const _Rope_const_iterator<_CharT,_Alloc>& __y) {
+  return !(__x == __y);
+}
+
+template <class _CharT, class _Alloc>
+inline bool operator> (const _Rope_const_iterator<_CharT,_Alloc>& __x,
+                       const _Rope_const_iterator<_CharT,_Alloc>& __y) {
+  return __y < __x;
+}
+
+template <class _CharT, class _Alloc>
+inline bool operator<= (const _Rope_const_iterator<_CharT,_Alloc>& __x,
+                        const _Rope_const_iterator<_CharT,_Alloc>& __y) {
+  return !(__y < __x);
+}
+
+template <class _CharT, class _Alloc>
+inline bool operator>= (const _Rope_const_iterator<_CharT,_Alloc>& __x,
+                        const _Rope_const_iterator<_CharT,_Alloc>& __y) {
+  return !(__x < __y);
+}
+
+template <class _CharT, class _Alloc>
+inline ptrdiff_t operator-(const _Rope_const_iterator<_CharT,_Alloc>& __x,
+                           const _Rope_const_iterator<_CharT,_Alloc>& __y) {
+  return (ptrdiff_t)__x._M_current_pos - (ptrdiff_t)__y._M_current_pos;
+}
+
+template <class _CharT, class _Alloc>
+inline _Rope_const_iterator<_CharT,_Alloc>
+operator-(const _Rope_const_iterator<_CharT,_Alloc>& __x, ptrdiff_t __n) {
+  return _Rope_const_iterator<_CharT,_Alloc>(
+            __x._M_root, __x._M_current_pos - __n);
+}
+
+template <class _CharT, class _Alloc>
+inline _Rope_const_iterator<_CharT,_Alloc>
+operator+(const _Rope_const_iterator<_CharT,_Alloc>& __x, ptrdiff_t __n) {
+  return _Rope_const_iterator<_CharT,_Alloc>(
+           __x._M_root, __x._M_current_pos + __n);
+}
+
+template <class _CharT, class _Alloc>
+inline _Rope_const_iterator<_CharT,_Alloc>
+operator+(ptrdiff_t __n, const _Rope_const_iterator<_CharT,_Alloc>& __x) {
+  return _Rope_const_iterator<_CharT,_Alloc>(
+           __x._M_root, __x._M_current_pos + __n);
+}
+
+template <class _CharT, class _Alloc>
+inline bool operator== (const _Rope_iterator<_CharT,_Alloc>& __x,
+                        const _Rope_iterator<_CharT,_Alloc>& __y) {
+  return (__x._M_current_pos == __y._M_current_pos &&
+          __x._M_root_rope == __y._M_root_rope);
+}
+
+template <class _CharT, class _Alloc>
+inline bool operator< (const _Rope_iterator<_CharT,_Alloc>& __x,
+                       const _Rope_iterator<_CharT,_Alloc>& __y) {
+  return (__x._M_current_pos < __y._M_current_pos);
+}
+
+template <class _CharT, class _Alloc>
+inline bool operator!= (const _Rope_iterator<_CharT,_Alloc>& __x,
+                        const _Rope_iterator<_CharT,_Alloc>& __y) {
+  return !(__x == __y);
+}
+
+template <class _CharT, class _Alloc>
+inline bool operator> (const _Rope_iterator<_CharT,_Alloc>& __x,
+                       const _Rope_iterator<_CharT,_Alloc>& __y) {
+  return __y < __x;
+}
+
+template <class _CharT, class _Alloc>
+inline bool operator<= (const _Rope_iterator<_CharT,_Alloc>& __x,
+                        const _Rope_iterator<_CharT,_Alloc>& __y) {
+  return !(__y < __x);
+}
+
+template <class _CharT, class _Alloc>
+inline bool operator>= (const _Rope_iterator<_CharT,_Alloc>& __x,
+                        const _Rope_iterator<_CharT,_Alloc>& __y) {
+  return !(__x < __y);
+}
+
+template <class _CharT, class _Alloc>
+inline ptrdiff_t operator-(const _Rope_iterator<_CharT,_Alloc>& __x,
+                           const _Rope_iterator<_CharT,_Alloc>& __y) {
+  return (ptrdiff_t)__x._M_current_pos - (ptrdiff_t)__y._M_current_pos;
+}
+
+template <class _CharT, class _Alloc>
+inline _Rope_iterator<_CharT,_Alloc>
+operator-(const _Rope_iterator<_CharT,_Alloc>& __x,
+          ptrdiff_t __n) {
+  return _Rope_iterator<_CharT,_Alloc>(
+    __x._M_root_rope, __x._M_current_pos - __n);
+}
+
+template <class _CharT, class _Alloc>
+inline _Rope_iterator<_CharT,_Alloc>
+operator+(const _Rope_iterator<_CharT,_Alloc>& __x,
+          ptrdiff_t __n) {
+  return _Rope_iterator<_CharT,_Alloc>(
+    __x._M_root_rope, __x._M_current_pos + __n);
+}
+
+template <class _CharT, class _Alloc>
+inline _Rope_iterator<_CharT,_Alloc>
+operator+(ptrdiff_t __n, const _Rope_iterator<_CharT,_Alloc>& __x) {
+  return _Rope_iterator<_CharT,_Alloc>(
+    __x._M_root_rope, __x._M_current_pos + __n);
+}
+
+template <class _CharT, class _Alloc>
+inline
+rope<_CharT,_Alloc>
+operator+ (const rope<_CharT,_Alloc>& __left,
+           const rope<_CharT,_Alloc>& __right)
+{
+    return rope<_CharT,_Alloc>(
+      rope<_CharT,_Alloc>::_S_concat(__left._M_tree_ptr, __right._M_tree_ptr));
+    // Inlining this should make it possible to keep __left and
+    // __right in registers.
+}
+
+template <class _CharT, class _Alloc>
+inline
+rope<_CharT,_Alloc>&
+operator+= (rope<_CharT,_Alloc>& __left,
+      const rope<_CharT,_Alloc>& __right)
+{
+    __left.append(__right);
+    return __left;
+}
+
+template <class _CharT, class _Alloc>
+inline
+rope<_CharT,_Alloc>
+operator+ (const rope<_CharT,_Alloc>& __left,
+           const _CharT* __right) {
+    size_t __rlen = rope<_CharT,_Alloc>::_S_char_ptr_len(__right);
+    return rope<_CharT,_Alloc>(
+      rope<_CharT,_Alloc>::_S_concat_char_iter(
+        __left._M_tree_ptr, __right, __rlen));
+}
+
+template <class _CharT, class _Alloc>
+inline
+rope<_CharT,_Alloc>&
+operator+= (rope<_CharT,_Alloc>& __left,
+            const _CharT* __right) {
+    __left.append(__right);
+    return __left;
+}
+
+template <class _CharT, class _Alloc>
+inline
+rope<_CharT,_Alloc>
+operator+ (const rope<_CharT,_Alloc>& __left, _CharT __right) {
+    return rope<_CharT,_Alloc>(
+      rope<_CharT,_Alloc>::_S_concat_char_iter(
+        __left._M_tree_ptr, &__right, 1));
+}
+
+template <class _CharT, class _Alloc>
+inline
+rope<_CharT,_Alloc>&
+operator+= (rope<_CharT,_Alloc>& __left, _CharT __right) {
+    __left.append(__right);
+    return __left;
+}
+
+template <class _CharT, class _Alloc>
+bool
+operator< (const rope<_CharT,_Alloc>& __left,
+           const rope<_CharT,_Alloc>& __right) {
+    return __left.compare(__right) < 0;
+}
+
+template <class _CharT, class _Alloc>
+bool
+operator== (const rope<_CharT,_Alloc>& __left,
+            const rope<_CharT,_Alloc>& __right) {
+    return __left.compare(__right) == 0;
+}
+
+template <class _CharT, class _Alloc>
+inline bool operator== (const _Rope_char_ptr_proxy<_CharT,_Alloc>& __x,
+                        const _Rope_char_ptr_proxy<_CharT,_Alloc>& __y) {
+        return (__x._M_pos == __y._M_pos && __x._M_root == __y._M_root);
+}
+
+template <class _CharT, class _Alloc>
+inline bool
+operator!= (const rope<_CharT,_Alloc>& __x, const rope<_CharT,_Alloc>& __y) {
+  return !(__x == __y);
+}
+
+template <class _CharT, class _Alloc>
+inline bool
+operator> (const rope<_CharT,_Alloc>& __x, const rope<_CharT,_Alloc>& __y) {
+  return __y < __x;
+}
+
+template <class _CharT, class _Alloc>
+inline bool
+operator<= (const rope<_CharT,_Alloc>& __x, const rope<_CharT,_Alloc>& __y) {
+  return !(__y < __x);
+}
+
+template <class _CharT, class _Alloc>
+inline bool
+operator>= (const rope<_CharT,_Alloc>& __x, const rope<_CharT,_Alloc>& __y) {
+  return !(__x < __y);
+}
+
+template <class _CharT, class _Alloc>
+inline bool operator!= (const _Rope_char_ptr_proxy<_CharT,_Alloc>& __x,
+                        const _Rope_char_ptr_proxy<_CharT,_Alloc>& __y) {
+  return !(__x == __y);
+}
+
+template<class _CharT, class _Traits, class _Alloc>
+std::basic_ostream<_CharT, _Traits>& operator<<
+                                        (std::basic_ostream<_CharT, _Traits>& __o,
+                                         const rope<_CharT, _Alloc>& __r);
+
+typedef rope<char> crope;
+typedef rope<wchar_t> wrope;
+
+inline crope::reference __mutable_reference_at(crope& __c, size_t __i)
+{
+    return __c.mutable_reference_at(__i);
+}
+
+inline wrope::reference __mutable_reference_at(wrope& __c, size_t __i)
+{
+    return __c.mutable_reference_at(__i);
+}
+
+template <class _CharT, class _Alloc>
+inline void swap(rope<_CharT,_Alloc>& __x, rope<_CharT,_Alloc>& __y) {
+  __x.swap(__y);
+}
+
+// Hash functions should probably be revisited later:
+template<> struct hash<crope>
+{
+  size_t operator()(const crope& __str) const
+  {
+    size_t __size = __str.size();
+
+    if (0 == __size) return 0;
+    return 13*__str[0] + 5*__str[__size - 1] + __size;
+  }
+};
+
+
+template<> struct hash<wrope>
+{
+  size_t operator()(const wrope& __str) const
+  {
+    size_t __size = __str.size();
+
+    if (0 == __size) return 0;
+    return 13*__str[0] + 5*__str[__size - 1] + __size;
+  }
+};
+
+} // namespace __gnu_cxx
+
+# include <ext/ropeimpl.h>
+
+#endif
diff -Nurp gcc-3.4.6.orig/libtool.m4 gcc-3.4.6/libtool.m4
--- gcc-3.4.6.orig/libtool.m4	2004-05-18 11:09:14.000000000 +0200
+++ gcc-3.4.6/libtool.m4	2006-11-08 18:56:53.000000000 +0100
@@ -689,6 +689,11 @@ linux-gnu*)
   lt_cv_file_magic_test_file=`echo /lib/libc.so* /lib/libc-*.so`
   ;;
 
+linux-uclibc*)
+  lt_cv_deplibs_check_method=pass_all
+  lt_cv_file_magic_test_file=`echo /lib/libuClibc-*.so`
+  ;;
+
 netbsd*)
   if echo __ELF__ | $CC -E - | grep __ELF__ > /dev/null; then
     [lt_cv_deplibs_check_method='match_pattern /lib[^/\.]+\.so\.[0-9]+\.[0-9]+$']
diff -Nurp gcc-3.4.6.orig/ltconfig gcc-3.4.6/ltconfig
--- gcc-3.4.6.orig/ltconfig	2004-03-05 22:05:41.000000000 +0100
+++ gcc-3.4.6/ltconfig	2006-11-08 18:56:53.000000000 +0100
@@ -602,6 +602,7 @@ host_os=`echo $host | sed 's/^\([^-]*\)-
 
 # Transform linux* to *-*-linux-gnu*, to support old configure scripts.
 case $host_os in
+linux-uclibc*) ;;
 linux-gnu*) ;;
 linux*) host=`echo $host | sed 's/^\(.*-.*-linux\)\(.*\)$/\1-gnu\2/'`
 esac
@@ -1262,6 +1263,24 @@ linux-gnu*)
   dynamic_linker='GNU/Linux ld.so'
   ;;
 
+linux-uclibc*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so$major $libname.so'
+  soname_spec='${libname}${release}.so$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  # This implies no fast_install, which is unacceptable.
+  # Some rework will be needed to allow for fast_install
+  # before this can be enabled.
+  # Note: copied from linux-gnu, and may not be appropriate.
+  hardcode_into_libs=yes
+  # Assume using the uClibc dynamic linker.
+  dynamic_linker="uClibc ld.so"
+  ;;
+
 netbsd*)
   need_lib_prefix=no
   need_version=no
