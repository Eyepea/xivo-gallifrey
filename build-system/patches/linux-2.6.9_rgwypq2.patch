diff -Nurp linux-2.6.9.orig/arch/ppc/8260_io/fcc_enet.c linux-2.6.9/arch/ppc/8260_io/fcc_enet.c
--- linux-2.6.9.orig/arch/ppc/8260_io/fcc_enet.c	2004-10-18 23:54:07.000000000 +0200
+++ linux-2.6.9/arch/ppc/8260_io/fcc_enet.c	2006-09-07 18:57:01.000000000 +0200
@@ -16,6 +16,12 @@
  * small packets.  Since this is a cache coherent processor and CPM,
  * I could also preallocate SKB's and use them directly on the interface.
  *
+ * Version 1.0.0
+ *  Add LXT971 PHY management
+ *  Add ETHTOOL and SIOC ioctls 
+ * Version 1.1.0
+ *  Add POWER_DOWN while ETHTOOL_SSET 
+ *  to always get PHY interrupt and restart FCC
  */
 
 #include <linux/config.h>
@@ -34,6 +40,10 @@
 #include <linux/etherdevice.h>
 #include <linux/skbuff.h>
 #include <linux/spinlock.h>
+#include <linux/sockios.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/workqueue.h>
 
 #include <asm/immap_cpm2.h>
 #include <asm/pgtable.h>
@@ -42,13 +52,116 @@
 #include <asm/bitops.h>
 #include <asm/uaccess.h>
 #include <asm/cpm2.h>
+#include <platforms/rgwypq2.h>
 
-/* The transmitter timeout
- */
-#define TX_TIMEOUT	(2*HZ)
+/*--------------------------------------------------------------------------*/
+/*    DEFINITIONS AND STRUCTURES FOR MII PHY                                */
+/*--------------------------------------------------------------------------*/
+#ifdef CONFIG_USE_MDIO
+/* Register definitions for the PHY. */
+#define MII_LXT971_CR			0			/* Control Register				*/
+#define MII_LXT971_SR			1			/* Status Register				*/
+#define MII_LXT971_IR1			2			/* Identification Register 1	*/
+#define MII_LXT971_IR2			3			/* Identification Register 2	*/
+#define MII_LXT971_AR			4			/* A-N Advertisement Register	*/
+#define MII_LXT971_SR2			17			/* Status Register 2			*/
+#define MII_LXT971_IER			18			/* Interrupt Enable Register	*/
+#define MII_LXT971_ISR			19			/* Interrupt Status Register	*/
+
+/* MII_LXT971_CR definitions */
+#define MII_CR_RESET			0x8000		 /* Reset the MII chip			*/
+#define MII_CR_LBK_MODE			0x4000		 /* The MII PHY is in loopback	*/
+#define MII_CR_SPEED_100M		0x2000		 /* 100Mbps speed selected		*/
+#define MII_CR_ENABLE_NEG		0x1000		 /* Enable autonegociation		*/
+#define MII_CR_POWERDOWN		0x0800		 /* Power down mode				*/
+#define MII_CR_ISOEN			0x0400		 /* Enable isolate mode			*/
+#define MII_CR_RENEGOTIATE		0x0200		 /* Re-negotiate the link speed	*/
+#define MII_CR_FULLDUPLEX		0x0100		 /* Link in Full duplex mode	*/
+#define MII_CR_COLEN			0x0080		 /* Collision test control		*/
+
+/* MII_LXT971_SR definitions */
+#define MII_SR_100FULLDUPLEX	0x4000		/* Link is 100Mbps full duplex	*/
+#define MII_SR_100HALFDUPLEX	0x2000		/* Link is 100Mbps half duplex	*/
+#define MII_SR_10FULLDUPLEX		0x1000		/* Link is 10Mbps full duplex	*/
+#define MII_SR_10HALFDUPLEX		0x0800		/* Link is 10Mbps half duplex	*/
+#define MII_SR_AUTONEG_DONE		0x0020		/* Autonegotiation is complete	*/
+#define MII_SR_REMOTE_FAULT		0x0010		/* Remote fault detected		*/
+#define MII_SR_LINKUP			0x0004		/* The Link is up				*/
+
+/* MII_LXT971_IR1 definitions */
+#define MII_IR1_ID				0x0013		/* LXT971 ident part1			*/
+
+/* MII_LXT971_IR2 definitions */
+#define MII_IR2_ID				0x78E0		/* LXT971 ident part2 			*/
+
+/* MII_LXT971_AR definitions */
+#define MII_AR_REMOTEFAULT		0x2000		/* Remote fault 				*/
+#define MII_AR_CTRL_PAUSE_ASY	0x0800		/* Assymetric pause				*/
+#define MII_AR_CRTL_PAUSE		0x0400	 	/* Pause						*/
+#define MII_AR_100MB_FULLDUP	0x0100		/* 100Mbs full duplex capable	*/
+#define MII_AR_100MB_HALFDUP	0x0080		/* 100Mbs half duplex capable	*/
+#define MII_AR_10MB_FULLDUP		0x0040		/* 10Mbs full duplex capable	*/
+#define MII_AR_10MB_HALFDUP		0x0020		/* 10Mbs half duplex capable	*/
+#define MII_AR_SELECTOR			0x0001		/* 802.3 protocol               */
+
+/* MII_LXT971_SR2 definitions */
+#define MII_SR2_100_TX			0x4000		/* 100Mbs TX mode				*/
+#define MII_SR2_LINK_UP			0x0400		/* Link is up					*/
+#define MII_SR2_FULL_DUP		0x0200		/* Full duplex mode				*/
+#define MII_SR2_AUTO_EN			0x0100		/* A-N enabled					*/
+#define MII_SR2_AUTO_COMPL		0x0080		/* A-N complete					*/
+#define MII_SR2_ERROR			0x0008		/* Error        				*/
+
+/* MII_LXT971_IER definitions */
+#define MII_IER_TINT			0x0001		/* Force it on #MDINT pin		*/
+#define MII_IER_INTEN			0x0002		/* Enable/Disable it			*/
+#define MII_IER_LNK_MSK			0x0010		/* Mask for link status it		*/
+#define MII_IER_DUP_MSK			0x0020		/* Mask for duplex status it	*/
+#define MII_IER_SPD_MSK			0x0040		/* Mask for speed status it		*/
+#define MII_IER_ANC_MSK			0x0080		/* Mask for A-N Complete		*/
+
+/* MII_LXT971_ISR definitions */
+#define MII_ISR_MDINT			0x0040		/* MII it pending				*/
+#define MII_ISR_LNK_CHG			0x0010		/* Link Status change			*/
+#define MII_ISR_DUP_CHG			0x0020		/* Duplex Status change			*/
+#define MII_ISR_SPD_CHG			0x0040		/* Speed Status change			*/
+#define MII_ISR_ANC_CHG			0x0080		/* A-N Status change			*/
+
+/* Values for phy_status, not register bit definitions */
+#define PHY_CONF_ANE			0x0001		/* 1 auto-negotiation enabled	*/
+#define PHY_CONF_LOOP			0x0002		/* 1 loopback mode enabled		*/
+#define PHY_CONF_SPMASK			0x00f0		/* mask for speed				*/
+#define PHY_CONF_10HDX			0x0010		/* 10Mbs half duplex supported 	*/
+#define PHY_CONF_10FDX			0x0020		/* 10Mbs full duplex supported 	*/
+#define PHY_CONF_100HDX			0x0040		/* 100Mbs half duplex supported */
+#define PHY_CONF_100FDX			0x0080		/* 100Mbs full duplex supported */
+
+#define PHY_STAT_LINK			0x0100		/* 1 up - 0 down 				*/
+#define PHY_STAT_FAULT			0x0200		/* 1 remote fault 				*/
+#define PHY_STAT_ANC			0x0400		/* 1 auto-negotiation complete	*/
+#define PHY_STAT_SPMASK			0xf000		/* mask for speed 				*/
+#define PHY_STAT_10HDX			0x1000		/* 10Mbs half duplex selected	*/
+#define PHY_STAT_10FDX			0x2000		/* 10Mbs full duplex selected	*/
+#define PHY_STAT_100HDX			0x4000		/* 100Mbs half duplex selected 	*/
+#define PHY_STAT_100FDX			0x8000		/* 100Mbs full duplex selected 	*/
 
-#ifdef	CONFIG_USE_MDIO
-/* Forward declarations of some structures to support different PHYs */
+/* Make MII read/write commands for the FCC. */
+#define mk_mii_read(REG)		(0x60020000 | ((REG & 0x1f) << 18))
+#define mk_mii_write(REG, VAL)	(0x50020000 | ((REG & 0x1f) << 18) | \
+								(VAL & 0xffff))
+#define mk_mii_end				0
+
+#define FCC_PDATD_MDIO(bit)				\
+	if (bit)							\
+		io->iop_pdatd |= fip->fc_mdio;	\
+	else								\
+		io->iop_pdatd &= ~fip->fc_mdio;
+
+#define FCC_PDATD_MDC(bit)				\
+	if (bit)							\
+		io->iop_pdatd |= fip->fc_mdck;	\
+	else								\
+		io->iop_pdatd &= ~fip->fc_mdck;
 
 typedef struct {
 	uint mii_data;
@@ -58,45 +171,32 @@ typedef struct {
 typedef struct {
 	uint id;
 	char *name;
-
 	const phy_cmd_t *config;
 	const phy_cmd_t *startup;
 	const phy_cmd_t *ack_int;
 	const phy_cmd_t *shutdown;
 } phy_info_t;
 
-/* Register definitions for the PHY. */
-
-#define MII_REG_CR          0  /* Control Register                         */
-#define MII_REG_SR          1  /* Status Register                          */
-#define MII_REG_PHYIR1      2  /* PHY Identification Register 1            */
-#define MII_REG_PHYIR2      3  /* PHY Identification Register 2            */
-#define MII_REG_ANAR        4  /* A-N Advertisement Register               */
-#define MII_REG_ANLPAR      5  /* A-N Link Partner Ability Register        */
-#define MII_REG_ANER        6  /* A-N Expansion Register                   */
-#define MII_REG_ANNPTR      7  /* A-N Next Page Transmit Register          */
-#define MII_REG_ANLPRNPR    8  /* A-N Link Partner Received Next Page Reg. */
-
-/* values for phy_status */
-
-#define PHY_CONF_ANE	0x0001  /* 1 auto-negotiation enabled */
-#define PHY_CONF_LOOP	0x0002  /* 1 loopback mode enabled */
-#define PHY_CONF_SPMASK	0x00f0  /* mask for speed */
-#define PHY_CONF_10HDX	0x0010  /* 10 Mbit half duplex supported */
-#define PHY_CONF_10FDX	0x0020  /* 10 Mbit full duplex supported */
-#define PHY_CONF_100HDX	0x0040  /* 100 Mbit half duplex supported */
-#define PHY_CONF_100FDX	0x0080  /* 100 Mbit full duplex supported */
-
-#define PHY_STAT_LINK	0x0100  /* 1 up - 0 down */
-#define PHY_STAT_FAULT	0x0200  /* 1 remote fault */
-#define PHY_STAT_ANC	0x0400  /* 1 auto-negotiation complete	*/
-#define PHY_STAT_SPMASK	0xf000  /* mask for speed */
-#define PHY_STAT_10HDX	0x1000  /* 10 Mbit half duplex selected	*/
-#define PHY_STAT_10FDX	0x2000  /* 10 Mbit full duplex selected	*/
-#define PHY_STAT_100HDX	0x4000  /* 100 Mbit half duplex selected */
-#define PHY_STAT_100FDX	0x8000  /* 100 Mbit full duplex selected */
 #endif	/* CONFIG_USE_MDIO */
 
+#ifdef CONFIG_USE_MDIO
+#define PC_MDIO		((uint)(1 << (31 - 11)))	/* PD11 */
+#define PC_MDCK		((uint)(1 << (31 - 10)))	/* PD10 */
+#if !defined(PC_MDIO) || !defined(PC_MDCK)
+#error Must define PC_MDIO and PC_MDCK if using MDIO
+#endif
+#else	/* ifdef CONFIG_USE_MDIO */
+#undef	PC_MDIO
+#undef	PC_MDCK
+#define PC_MDIO		((uint)0x00000000)
+#define PC_MDCK		((uint)0x00000000)
+#endif	/* ifdef CONFIG_USE_MDIO */
+
+/*--------------------------------------------------------------------------*/
+/*    DEFINITIONS AND STRUCTURES FOR FCC                                    */
+/*--------------------------------------------------------------------------*/
+#define TX_TIMEOUT  (2*HZ) /* The transmitter timeout */
+
 /* The number of Tx and Rx buffers.  These are allocated from the page
  * pool.  The code may assume these are power of two, so it is best
  * to keep them that size.
@@ -123,129 +223,75 @@ typedef struct {
 */
 #define PKT_MAXBLR_SIZE		1536
 
-static int fcc_enet_open(struct net_device *dev);
-static int fcc_enet_start_xmit(struct sk_buff *skb, struct net_device *dev);
-static int fcc_enet_rx(struct net_device *dev);
-static irqreturn_t fcc_enet_interrupt(int irq, void *dev_id, struct pt_regs *);
-static int fcc_enet_close(struct net_device *dev);
-static struct net_device_stats *fcc_enet_get_stats(struct net_device *dev);
-static void set_multicast_list(struct net_device *dev);
-static void fcc_restart(struct net_device *dev, int duplex);
-static int fcc_enet_set_mac_address(struct net_device *dev, void *addr);
-
-/* These will be configurable for the FCC choice.
- * Multiple ports can be configured.  There is little choice among the
- * I/O pins to the PHY, except the clocks.  We will need some board
- * dependent clock selection.
- * Why in the hell did I put these inside #ifdef's?  I dunno, maybe to
- * help show what pins are used for each device.
- */
-
-/* I/O Pin assignment for FCC1.  I don't yet know the best way to do this,
- * but there is little variation among the choices.
- */
-#define PA1_COL		((uint)0x00000001)
-#define PA1_CRS		((uint)0x00000002)
-#define PA1_TXER	((uint)0x00000004)
-#define PA1_TXEN	((uint)0x00000008)
-#define PA1_RXDV	((uint)0x00000010)
-#define PA1_RXER	((uint)0x00000020)
-#define PA1_TXDAT	((uint)0x00003c00)
-#define PA1_RXDAT	((uint)0x0003c000)
-#define PA1_PSORA0	(PA1_RXDAT | PA1_TXDAT)
-#define PA1_PSORA1	(PA1_COL | PA1_CRS | PA1_TXER | PA1_TXEN | \
-				PA1_RXDV | PA1_RXER)
-#define PA1_DIRA0	(PA1_RXDAT | PA1_CRS | PA1_COL | PA1_RXER | PA1_RXDV)
-#define PA1_DIRA1	(PA1_TXDAT | PA1_TXEN | PA1_TXER)
-
-#ifdef CONFIG_SBC82xx
-/* rx is clk9, tx is clk10 */
-#define PC_F1RXCLK     ((uint)0x00000100)
-#define PC_F1TXCLK     ((uint)0x00000200)
-#define CMX1_CLK_ROUTE ((uint)0x25000000)
-#define CMX1_CLK_MASK  ((uint)0xff000000)
-#elif defined(CONFIG_ADS8272)
-#define PC_F1RXCLK	((uint)0x00000400)
-#define PC_F1TXCLK	((uint)0x00000200)
-#define CMX1_CLK_ROUTE	((uint)0x36000000)
-#define CMX1_CLK_MASK	((uint)0xff000000)
-#else /* other boards */
-/* CLK12 is receive, CLK11 is transmit.  These are board specific. */
-#define PC_F1RXCLK	((uint)0x00000800)
-#define PC_F1TXCLK	((uint)0x00000400)
-#define CMX1_CLK_ROUTE	((uint)0x3e000000)
-#define CMX1_CLK_MASK	((uint)0xff000000)
-#endif
-
-/* I/O Pin assignment for FCC2.  I don't yet know the best way to do this,
- * but there is little variation among the choices.
- */
-#define PB2_TXER	((uint)0x00000001)
-#define PB2_RXDV	((uint)0x00000002)
-#define PB2_TXEN	((uint)0x00000004)
-#define PB2_RXER	((uint)0x00000008)
-#define PB2_COL		((uint)0x00000010)
-#define PB2_CRS		((uint)0x00000020)
-#define PB2_TXDAT	((uint)0x000003c0)
-#define PB2_RXDAT	((uint)0x00003c00)
-#define PB2_PSORB0	(PB2_RXDAT | PB2_TXDAT | PB2_CRS | PB2_COL | \
-				PB2_RXER | PB2_RXDV | PB2_TXER)
-#define PB2_PSORB1	(PB2_TXEN)
-#define PB2_DIRB0	(PB2_RXDAT | PB2_CRS | PB2_COL | PB2_RXER | PB2_RXDV)
-#define PB2_DIRB1	(PB2_TXDAT | PB2_TXEN | PB2_TXER)
-
-/* CLK13 is receive, CLK14 is transmit.  These are board dependent.
-*/
-#ifdef CONFIG_ADS8272
-#define PC_F2RXCLK	((uint)0x00004000)
-#define PC_F2TXCLK	((uint)0x00008000)
-#define CMX2_CLK_ROUTE	((uint)0x00370000)
+/*******************************/
+/* I/O Pin assignment for FCC1 */
+/*******************************/
+#define PA1_COL			((uint)0x00000001)
+#define PA1_CRS			((uint)0x00000002)
+#define PA1_TXER		((uint)0x00000004)
+#define PA1_TXEN		((uint)0x00000008)
+#define PA1_RXDV		((uint)0x00000010)
+#define PA1_RXER		((uint)0x00000020)
+#define PA1_TXDAT		((uint)0x00003c00)
+#define PA1_RXDAT		((uint)0x0003c000)
+#define PA1_PSORA0		(PA1_RXDAT | PA1_TXDAT)
+#define PA1_PSORA1		(PA1_COL | PA1_CRS | PA1_TXER | PA1_TXEN | \
+						PA1_RXDV | PA1_RXER)
+#define PA1_DIRA0		(PA1_RXDAT | PA1_CRS | PA1_COL | PA1_RXER | PA1_RXDV)
+#define PA1_DIRA1		(PA1_TXDAT | PA1_TXEN | PA1_TXER)
+
+/* CLK10 is receive, CLK9 is transmit.	These are board specific. */
+#define PC_F1RXCLK		((uint)0x00000200)
+#define PC_F1TXCLK		((uint)0x00000100)
+#define CMX1_CLK_ROUTE	((uint)0x2C000000)
+#define CMX1_CLK_MASK	 ((uint)0xff000000)
+
+/*******************************/
+/* I/O Pin assignment for FCC2 */
+/*******************************/
+#define PB2_TXER		((uint)0x00000001)
+#define PB2_RXDV		((uint)0x00000002)
+#define PB2_TXEN		((uint)0x00000004)
+#define PB2_RXER		((uint)0x00000008)
+#define PB2_COL			((uint)0x00000010)
+#define PB2_CRS			((uint)0x00000020)
+#define PB2_TXDAT		((uint)0x000003c0)
+#define PB2_RXDAT		((uint)0x00003c00)
+#define PB2_PSORB0		(PB2_RXDAT | PB2_TXDAT | PB2_CRS | PB2_COL | \
+						PB2_RXER | PB2_RXDV | PB2_TXER)
+#define PB2_PSORB1		(PB2_TXEN)
+#define PB2_DIRB0		(PB2_RXDAT | PB2_CRS | PB2_COL | PB2_RXER | PB2_RXDV)
+#define PB2_DIRB1		(PB2_TXDAT | PB2_TXEN | PB2_TXER)
+
+/* CLK14 is receive, CLK13 is transmit.	These are board dependent. */
+#define PC_F2RXCLK		((uint)0x00002000)
+#define PC_F2TXCLK		((uint)0x00001000)
+#define CMX2_CLK_ROUTE	((uint)0x002C0000)
 #define CMX2_CLK_MASK	((uint)0x00ff0000)
-#else
-#define PC_F2RXCLK	((uint)0x00001000)
-#define PC_F2TXCLK	((uint)0x00002000)
-#define CMX2_CLK_ROUTE	((uint)0x00250000)
-#define CMX2_CLK_MASK	((uint)0x00ff0000)
-#endif
-
-/* I/O Pin assignment for FCC3.  I don't yet know the best way to do this,
- * but there is little variation among the choices.
- */
-#define PB3_RXDV	((uint)0x00004000)
-#define PB3_RXER	((uint)0x00008000)
-#define PB3_TXER	((uint)0x00010000)
-#define PB3_TXEN	((uint)0x00020000)
-#define PB3_COL		((uint)0x00040000)
-#define PB3_CRS		((uint)0x00080000)
-#define PB3_TXDAT	((uint)0x0f000000)
-#define PB3_RXDAT	((uint)0x00f00000)
-#define PB3_PSORB0	(PB3_RXDAT | PB3_TXDAT | PB3_CRS | PB3_COL | \
-				PB3_RXER | PB3_RXDV | PB3_TXER | PB3_TXEN)
-#define PB3_PSORB1	(0)
-#define PB3_DIRB0	(PB3_RXDAT | PB3_CRS | PB3_COL | PB3_RXER | PB3_RXDV)
-#define PB3_DIRB1	(PB3_TXDAT | PB3_TXEN | PB3_TXER)
 
-/* CLK15 is receive, CLK16 is transmit.  These are board dependent.
-*/
-#define PC_F3RXCLK	((uint)0x00004000)
-#define PC_F3TXCLK	((uint)0x00008000)
-#define CMX3_CLK_ROUTE	((uint)0x00003700)
+/*******************************/
+/* I/O Pin assignment for FCC3 */
+/*******************************/
+#define PB3_RXDV		((uint)0x00004000)
+#define PB3_RXER		((uint)0x00008000)
+#define PB3_TXER		((uint)0x00010000)
+#define PB3_TXEN		((uint)0x00020000)
+#define PB3_COL			((uint)0x00040000)
+#define PB3_CRS			((uint)0x00080000)
+#define PB3_TXDAT		((uint)0x0f000000)
+#define PB3_RXDAT		((uint)0x00f00000)
+#define PB3_PSORB0		(PB3_RXDAT | PB3_TXDAT | PB3_CRS | PB3_COL | \
+						PB3_RXER | PB3_RXDV | PB3_TXER | PB3_TXEN)
+#define PB3_PSORB1		(0)
+#define PB3_DIRB0		(PB3_RXDAT | PB3_CRS | PB3_COL | PB3_RXER | PB3_RXDV)
+#define PB3_DIRB1		(PB3_TXDAT | PB3_TXEN | PB3_TXER)
+
+/* CLK16 is receive, CLK15 is transmit.	These are board dependent. */
+#define PC_F3RXCLK		((uint)0x00008000)
+#define PC_F3TXCLK		((uint)0x00004000)
+#define CMX3_CLK_ROUTE	((uint)0x00003E00)
 #define CMX3_CLK_MASK	((uint)0x0000ff00)
 
-/* MII status/control serial interface.
-*/
-#ifdef	CONFIG_TQM8260
-/* TQM8260 has MDIO and MDCK on PC30 and PC31 respectively */
-#define PC_MDIO		((uint)0x00000002)
-#define PC_MDCK		((uint)0x00000001)
-#elif defined(CONFIG_ADS8272)
-#define PC_MDIO		((uint)0x00002000)
-#define PC_MDCK		((uint)0x00001000)
-#else
-#define PC_MDIO		((uint)0x00000004)
-#define PC_MDCK		((uint)0x00000020)
-#endif
-
 /* A table of information for supporting FCCs.  This does two things.
  * First, we know how many FCCs we have and they are always externally
  * numbered from zero.  Second, it holds control register and I/O
@@ -262,40 +308,9 @@ typedef struct fcc_info {
 	uint	fc_clockmask;
 	uint	fc_mdio;
 	uint	fc_mdck;
+	uint	fc_phy_interrupt;
 } fcc_info_t;
 
-static fcc_info_t fcc_ports[] = {
-#ifdef CONFIG_FCC1_ENET
-	{ 0, CPM_CR_FCC1_SBLOCK, CPM_CR_FCC1_PAGE, PROFF_FCC1, SIU_INT_FCC1,
-		(PC_F1RXCLK | PC_F1TXCLK), CMX1_CLK_ROUTE, CMX1_CLK_MASK,
-# if defined(CONFIG_TQM8260) || defined(CONFIG_ADS8272)
-		PC_MDIO, PC_MDCK },
-# else
-		0x00000004, 0x00000100 },
-# endif
-#endif
-#ifdef CONFIG_FCC2_ENET
-	{ 1, CPM_CR_FCC2_SBLOCK, CPM_CR_FCC2_PAGE, PROFF_FCC2, SIU_INT_FCC2,
-		(PC_F2RXCLK | PC_F2TXCLK), CMX2_CLK_ROUTE, CMX2_CLK_MASK,
-# if defined(CONFIG_TQM8260) || defined(CONFIG_ADS8272)
-		PC_MDIO, PC_MDCK },
-# elif defined(CONFIG_EST8260) || defined(CONFIG_ADS8260)
-		0x00400000, 0x00200000 },
-# else
-		0x00000002, 0x00000080 },
-# endif
-#endif
-#ifdef CONFIG_FCC3_ENET
-	{ 2, CPM_CR_FCC3_SBLOCK, CPM_CR_FCC3_PAGE, PROFF_FCC3, SIU_INT_FCC3,
-		(PC_F3RXCLK | PC_F3TXCLK), CMX3_CLK_ROUTE, CMX3_CLK_MASK,
-# if defined(CONFIG_TQM8260) || defined(CONFIG_ADS8272)
-		PC_MDIO, PC_MDCK },
-# else
-		0x00000001, 0x00000040 },
-# endif
-#endif
-};
-
 /* The FCC buffer descriptors track the ring buffers.  The rx_bd_base and
  * tx_bd_base always point to the base of the buffer descriptors.  The
  * cur_rx and cur_tx point to the currently available buffer.
@@ -310,8 +325,6 @@ struct fcc_enet_private {
 	ushort	skb_cur;
 	ushort	skb_dirty;
 
-	atomic_t n_pkts;  /* Number of packets in tx ring */
-
 	/* CPM dual port RAM relative addresses.
 	*/
 	cbd_t	*rx_bd_base;		/* Address of Rx and Tx buffers. */
@@ -321,7 +334,7 @@ struct fcc_enet_private {
 	volatile fcc_t	*fccp;
 	volatile fcc_enet_t	*ep;
 	struct	net_device_stats stats;
-	uint	tx_full;
+	uint	tx_free;
 	spinlock_t lock;
 
 #ifdef	CONFIG_USE_MDIO
@@ -329,10 +342,9 @@ struct fcc_enet_private {
 	uint	phy_id_done;
 	uint	phy_status;
 	phy_info_t	*phy;
-	struct tq_struct phy_task;
-
+	struct work_struct phy_relink;
+	struct work_struct phy_display_config;
 	uint	sequence_done;
-
 	uint	phy_addr;
 #endif	/* CONFIG_USE_MDIO */
 
@@ -343,48 +355,167 @@ struct fcc_enet_private {
 	fcc_info_t	*fip;
 };
 
-static void init_fcc_shutdown(fcc_info_t *fip, struct fcc_enet_private *cep,
-	volatile cpm2_map_t *immap);
-static void init_fcc_startup(fcc_info_t *fip, struct net_device *dev);
-static void init_fcc_ioports(fcc_info_t *fip, volatile iop_cpm2_t *io,
-	volatile cpm2_map_t *immap);
-static void init_fcc_param(fcc_info_t *fip, struct net_device *dev,
-	volatile cpm2_map_t *immap);
+/*--------------------------------------------------------------------------*/
+/*						PROTOTYPES FOR MII PHY								*/
+/*--------------------------------------------------------------------------*/
+#ifdef  CONFIG_USE_MDIO
+static	int		mii_queue
+				(struct net_device *dev, int request, 
+				 void (*func)(uint, struct net_device *));
+static	void	mii_do_cmd			
+				(struct net_device *dev, const phy_cmd_t *c);
+static	void	mii_parse_sr		(uint mii_reg, struct net_device *dev);
+static	void	mii_parse_cr		(uint mii_reg, struct net_device *dev);
+static	void	mii_parse_ar		(uint mii_reg, struct net_device *dev);
+static	void	mii_parse_sr2		(uint mii_reg, struct net_device *dev);
+static	void	mii_display_status	(struct net_device *dev);
+static	void	mii_display_config	(struct net_device *dev);
+static	void	mii_relink			(struct net_device *dev);
+static	void	mii_queue_relink	(uint mii_reg, struct net_device *dev);
+static	void	mii_queue_config	(uint mii_reg, struct net_device *dev);
+static	void	mii_discover_phy3	(uint mii_reg, struct net_device *dev);
+static	void	mii_discover_phy	(uint mii_reg, struct net_device *dev);
+static	irqreturn_t mii_link_interrupt
+				(int irq, void * dev_id, struct pt_regs * regs);
+static	uint	mii_send_receive(fcc_info_t *fip, uint cmd);
+
+static	int		fcc_enet_ioctl		
+				(struct net_device *dev, struct ifreq *rq, int cmd);
+static	int		fcc_ethtool_ioctl	(struct net_device *dev, void *useraddr);
+#endif	/* CONFIG_USE_MDIO */
 
-#ifdef	CONFIG_USE_MDIO
-static int	mii_queue(struct net_device *dev, int request, void (*func)(uint, struct net_device *));
-static uint	mii_send_receive(fcc_info_t *fip, uint cmd);
+/*--------------------------------------------------------------------------*/
+/*						PROTOTYPES FOR FCC									*/
+/*--------------------------------------------------------------------------*/
+static	int		fcc_enet_start_xmit		
+				(struct sk_buff *skb, struct net_device *dev);
+static	void	fcc_enet_timeout	(struct net_device *dev);
+static	irqreturn_t fcc_enet_interrupt
+				(int irq, void *dev_id, struct pt_regs *);
+static	int		fcc_enet_rx			(struct net_device *dev);
+static	int		fcc_enet_close		(struct net_device *dev);
+static	struct net_device_stats 
+				*fcc_enet_get_stats	(struct net_device *dev);
+static	void	set_multicast_list			(struct net_device *dev);
+static	int		fcc_enet_set_mac_address	
+				(struct net_device *dev, void *addr);
+static	int		fec_enet_init				(void);
+static	void	init_fcc_shutdown	
+				(fcc_info_t *fip, struct fcc_enet_private *cep,
+				volatile cpm2_map_t *immap);
+static	void	init_fcc_ioports
+				(fcc_info_t *fip, volatile iop_cpm2_t *io,
+				volatile cpm2_map_t *immap);
+static	void	init_fcc_param				
+				(fcc_info_t *fip, struct net_device *dev, 
+				volatile cpm2_map_t *immap);
+static	void	init_fcc_startup
+				(fcc_info_t *fip, struct net_device *dev);
+
+static	void	fcc_stop			(struct net_device *dev);
+static	void	fcc_restart			(struct net_device *dev, int duplex);
+static	int		fcc_enet_open		(struct net_device *dev);
+
+/*--------------------------------------------------------------------------*/
+/*                      GLOBAL VARIABLES FOR MII PHY                        */
+/*--------------------------------------------------------------------------*/
+#ifdef CONFIG_USE_MDIO
+static phy_info_t phy_info_lxt971 = {
+	0x0001378e,
+	"LXT971",
 
-static void	fcc_stop(struct net_device *dev);
+	(const phy_cmd_t []) {	/* config */
+		/* 10 Mbps half duplex, 802.3 */
+		/* GG NO keep boot init */
+		/* { mk_mii_write(MII_LXT971_AR, 0x021), NULL }, */
+		{ mk_mii_read(MII_LXT971_CR), mii_parse_cr },
+		{ mk_mii_read(MII_LXT971_AR), mii_parse_ar },
+		/* read status to display right status */
+		{ mk_mii_read(MII_LXT971_SR), mii_parse_sr },
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) {	/* startup */
+		/* enable only phy link interrupt */
+		{ mk_mii_write(MII_LXT971_IER, (MII_IER_INTEN | MII_IER_LNK_MSK)), NULL },
+		/* enable autoneg , restart autoneg */
+		/* GG NO keep boot init */
+		/* { mk_mii_write(MII_LXT971_CR, 0x1200), NULL }, */
 
-/* Make MII read/write commands for the FCC.
-*/
-#define mk_mii_read(REG)	(0x60020000 | ((REG & 0x1f) << 18))
-#define mk_mii_write(REG, VAL)	(0x50020000 | ((REG & 0x1f) << 18) | \
-						(VAL & 0xffff))
-#define mk_mii_end	0
-#endif	/* CONFIG_USE_MDIO */
+		/* Somehow does the 971 tell me that the link is down
+		 * the first read after power-up.
+		 * read here to get a valid value in ack_int */
+		{ mk_mii_read(MII_LXT971_SR), mii_parse_sr },
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) { /* ack_int */
+		/* find out the current status */
+		{ mk_mii_read(MII_LXT971_SR), mii_parse_sr },
+		{ mk_mii_read(MII_LXT971_SR2), mii_parse_sr2 },
+
+		/* we only need to read ISR to acknowledge */
+		{ mk_mii_read(MII_LXT971_ISR), NULL },
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) {	/* shutdown */
+		/* disable all interrupts */
+		/* link, duplex, speed and autoneg complete */
+		{ mk_mii_write(MII_LXT971_IER, 0x0000), NULL },
+		{ mk_mii_end, }
+	},
+};
+
+static phy_info_t *phy_info[] = {
+	&phy_info_lxt971,
+	NULL
+};
+
+phy_cmd_t phy_cmd_relink[] = { { mk_mii_read(MII_LXT971_CR), mii_queue_relink },
+						 { mk_mii_end, } };
+phy_cmd_t phy_cmd_config[] = { { mk_mii_read(MII_LXT971_CR), mii_queue_config },
+						 { mk_mii_end, } };
+#endif 
+
+static fcc_info_t fcc_ports[] = {
+#ifdef CONFIG_FCC1_ENET
+	{ 0, CPM_CR_FCC1_SBLOCK, CPM_CR_FCC1_PAGE, PROFF_FCC1, SIU_INT_FCC1,
+		(PC_F1RXCLK | PC_F1TXCLK), CMX1_CLK_ROUTE, CMX1_CLK_MASK,
+		PC_MDIO, PC_MDCK, SIU_INT_IRQ2 },
+#endif
+#ifdef CONFIG_FCC2_ENET
+	{ 1, CPM_CR_FCC2_SBLOCK, CPM_CR_FCC2_PAGE, PROFF_FCC2, SIU_INT_FCC2,
+		(PC_F2RXCLK | PC_F2TXCLK), CMX2_CLK_ROUTE, CMX2_CLK_MASK,
+		PC_MDIO, PC_MDCK, SIU_INT_IRQ3 },
+#endif
+#ifdef CONFIG_FCC3_ENET
+	{ 2, CPM_CR_FCC3_SBLOCK, CPM_CR_FCC3_PAGE, PROFF_FCC3, SIU_INT_FCC3,
+		(PC_F3RXCLK | PC_F3TXCLK), CMX3_CLK_ROUTE, CMX3_CLK_MASK,
+		PC_MDIO, PC_MDCK, SIU_INT_IRQ4 },
+#endif
+};
 
+/*--------------------------------------------------------------------------*/
+/*                          FUNCTIONS                                       */
+/*--------------------------------------------------------------------------*/
 
 static int
 fcc_enet_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct fcc_enet_private *cep = (struct fcc_enet_private *)dev->priv;
 	volatile cbd_t	*bdp;
-	int idx;
 
-	if (!cep->link) {
-		/* Link is down or autonegotiation is in progress. */
-		return 1;
-	}
+	/* GG what to do if link is down ?	*/
+	/* nothing or						*/
+	/* just return 1					*/
+	/* or netif_stop_queue and return 1	*/
+	/* nothing per default				*/
 
 	/* Fill in a Tx ring entry */
 	bdp = cep->cur_tx;
 
 #ifndef final_version
-	if (bdp->cbd_sc & BD_ENET_TX_READY) {
+	if (!cep->tx_free || (bdp->cbd_sc & BD_ENET_TX_READY)) {
 		/* Ooops.  All transmit buffers are full.  Bail out.
-		 * This should not happen, since cep->tx_full should be set.
+		 * This should not happen, since the tx queue should be stopped.
 		 */
 		printk("%s: tx queue full!.\n", dev->name);
 		return 1;
@@ -407,21 +538,10 @@ fcc_enet_start_xmit(struct sk_buff *skb,
 	spin_lock_irq(&cep->lock);
 
 	/* Save skb pointer. */
-	idx = cep->skb_cur & TX_RING_MOD_MASK;
-	if (cep->tx_skbuff[idx]) {
-		/* This should never happen (any more).
-		   Leave the sanity check in for now... */
-		printk(KERN_ERR "EEP. cep->tx_skbuff[%d] is %p not NULL in %s\n", 
-		       idx, cep->tx_skbuff[idx], __func__);
-		printk(KERN_ERR "Expect to lose %d bytes of sock space", 
-		       cep->tx_skbuff[idx]->truesize);
-	}
-	cep->tx_skbuff[idx] = skb;
+	cep->tx_skbuff[cep->skb_cur] = skb;
 
 	cep->stats.tx_bytes += skb->len;
-	cep->skb_cur++;
-
-	atomic_inc(&cep->n_pkts);
+	cep->skb_cur = (cep->skb_cur+1) & TX_RING_MOD_MASK;
 
 	/* Send it on its way.  Tell CPM its ready, interrupt when done,
 	 * its the last BD of the frame, and to put the CRC on the end.
@@ -440,14 +560,8 @@ fcc_enet_start_xmit(struct sk_buff *skb,
 	else
 		bdp++;
 
-
-	/* If the tx_ring is full, stop the queue */
-	if (atomic_read(&cep->n_pkts) >= (TX_RING_SIZE-1)) {
-	  if (!netif_queue_stopped(dev)) {
-		netif_stop_queue(dev);	  
-		cep->tx_full = 1;
-	  }
-	}
+	if (!--cep->tx_free)
+		netif_stop_queue(dev);
 
 	cep->cur_tx = (cbd_t *)bdp;
 
@@ -456,39 +570,136 @@ fcc_enet_start_xmit(struct sk_buff *skb,
 	return 0;
 }
 
-
 static void
 fcc_enet_timeout(struct net_device *dev)
 {
-	struct fcc_enet_private *cep = (struct fcc_enet_private *)dev->priv;
+	volatile cbd_t			*bdp;
+	struct fcc_enet_private *cep;
+	volatile	fcc_enet_t	*ep;
+	volatile cpm_cpm2_t *cp;
 
-	printk("%s: transmit timed out.\n", dev->name);
-	cep->stats.tx_errors++;
-#ifndef final_version
-	{
-		int	i;
-		cbd_t	*bdp;
-		printk(" Ring data dump: cur_tx %p%s cur_rx %p.\n",
-		       cep->cur_tx, cep->tx_full ? " (full)" : "",
-		       cep->cur_rx);
-		bdp = cep->tx_bd_base;
-		printk(" Tx @base %p :\n", bdp);
-		for (i = 0 ; i < TX_RING_SIZE; i++, bdp++)
-			printk("%04x %04x %08x\n",
-			       bdp->cbd_sc,
-			       bdp->cbd_datlen,
-			       bdp->cbd_bufaddr);
-		bdp = cep->rx_bd_base;
-		printk(" Rx @base %p :\n", bdp);
-		for (i = 0 ; i < RX_RING_SIZE; i++, bdp++)
-			printk("%04x %04x %08x\n",
-			       bdp->cbd_sc,
-			       bdp->cbd_datlen,
-			       bdp->cbd_bufaddr);
+	int 					i;
+	int						must_restart = 0;
+
+	cep = (struct fcc_enet_private *)(dev->priv);
+	ep = cep->ep;
+	cp = cpmp;
+
+#if 0
+	printk("cur_tx=%p tx_free=%d tbptr=%08x dirty_tx=%p cur_rx=%p rbptr=%08x\n",
+		cep->cur_tx, cep->tx_free,
+		ep->fen_genfcc.fcc_tbptr, cep->dirty_tx,
+		cep->cur_rx, ep->fen_genfcc.fcc_rbptr);
+
+	/* display tx bd */
+	bdp = cep->tx_bd_base;
+	printk("TX bdp      sc   len  buff\n");
+	for (i = 0 ; i < TX_RING_SIZE; i++, bdp++) {
+		printk("   %p %04x %04x %08x\n",
+				bdp, bdp->cbd_sc, bdp->cbd_datlen, bdp->cbd_bufaddr);
+		printk("|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|\n",
+				((bdp->cbd_sc & BD_ENET_TX_READY)  ? "RDY " : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_PAD)    ? "PAD " : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_WRAP)   ? "WRAP" : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_INTR)   ? "INTR" : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_LAST)   ? "LAST" : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_TC)     ? "TC  " : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_DEF)    ? "DEF " : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_HB)     ? "HB  " : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_LC)     ? "LC  " : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_RL)     ? "RL  " : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_RCMASK) ? "RCMK" : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_UN)     ? "UN  " : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_CSL)    ? "CSL " : "    "));
 	}
-#endif
-	if (!cep->tx_full)
-		netif_wake_queue(dev);
+
+	bdp = cep->rx_bd_base;
+	printk("RX bdp      sc   len  buff\n");
+	for (i = 0 ; i < RX_RING_SIZE; i++, bdp++) {
+		printk("   %p %04x %04x %08x\n",
+				bdp, bdp->cbd_sc, bdp->cbd_datlen, bdp->cbd_bufaddr);
+	}
+#endif /* GG */
+
+	/* GG start of workaround for the CPM112 bug */
+	spin_lock_irq(&cep->lock);
+
+	/* stop TX */
+	cp->cp_cpcr = mk_cr_cmd(cep->fip->fc_cpmpage, cep->fip->fc_cpmblock,
+							0x0c, CPM_CR_STOP_TX) | CPM_CR_FLG;
+	while (cp->cp_cpcr & CPM_CR_FLG);
+
+	/* disable TX */
+	cep->fccp->fcc_gfmr &= ~FCC_GFMR_ENT;
+
+	/* clear all bds */
+	bdp = cep->tx_bd_base;
+	for (i = 0 ; i < TX_RING_SIZE; i++, bdp++) {
+		if (bdp->cbd_sc & BD_ENET_TX_READY) {
+			cep->stats.tx_packets++;
+			bdp->cbd_sc &= ~BD_ENET_TX_READY;
+		}
+
+		if (bdp->cbd_sc & BD_ENET_TX_HB) {	/* warning : no heartbeat */
+			cep->stats.tx_heartbeat_errors++;
+			bdp->cbd_sc &= ~BD_ENET_TX_HB;
+		}
+		if (bdp->cbd_sc & BD_ENET_TX_LC) {	/* error : late collision */
+			must_restart = 1;
+			cep->stats.tx_errors++;
+			cep->stats.tx_window_errors++;
+			bdp->cbd_sc &= ~BD_ENET_TX_LC;
+		}
+		if (bdp->cbd_sc & BD_ENET_TX_RL) {	/* error : retrans limit */
+			must_restart = 1;
+			cep->stats.tx_errors++;
+			cep->stats.tx_aborted_errors++;
+			bdp->cbd_sc &= ~BD_ENET_TX_RL;
+		}
+		if (bdp->cbd_sc & BD_ENET_TX_UN) {	/* error : underrun */
+			must_restart = 1;
+			cep->stats.tx_errors++;
+			cep->stats.tx_fifo_errors++;
+			bdp->cbd_sc &= ~BD_ENET_TX_UN;
+		}
+		if (bdp->cbd_sc & BD_ENET_TX_CSL) {	/* warning : carrier lost */
+			cep->stats.tx_carrier_errors++;
+			bdp->cbd_sc &= ~BD_ENET_TX_CSL;
+		}
+		if (bdp->cbd_sc & BD_ENET_TX_DEF) { /* warning : deferred */
+			cep->stats.collisions++;
+			bdp->cbd_sc &= ~BD_ENET_TX_DEF;
+		}
+
+		/* free the sk buffer associated with this last transmit. */
+		if (cep->tx_skbuff[cep->skb_dirty] != NULL) {
+			dev_kfree_skb_irq(cep->tx_skbuff[cep->skb_dirty]);
+			cep->tx_skbuff[cep->skb_dirty] = NULL;
+			cep->skb_dirty = (cep->skb_dirty + 1) & TX_RING_MOD_MASK;
+		}
+	}
+
+	/* reinit all params */
+	dev->trans_start = jiffies;
+	cep->dirty_tx = cep->cur_tx = cep->tx_bd_base;
+	ep->fen_genfcc.fcc_tbptr = __pa(cep->tx_bd_base);
+	
+	/* enable TX */
+	cep->fccp->fcc_gfmr |= FCC_GFMR_ENT;
+	
+	/* restart TX */
+	cp->cp_cpcr = mk_cr_cmd(cep->fip->fc_cpmpage, cep->fip->fc_cpmblock,
+							0x0c, CPM_CR_RESTART_TX) | CPM_CR_FLG;
+	while (cp->cp_cpcr & CPM_CR_FLG);
+
+	/* release interrupt */
+	spin_unlock(&cep->lock);
+
+	/* GG end of workaround for the CPM112 bug */
+
+	/* all bds are fee */
+	cep->tx_free = TX_RING_SIZE;
+	netif_wake_queue(dev);
 }
 
 /* The interrupt handler. */
@@ -500,16 +711,22 @@ fcc_enet_interrupt(int irq, void * dev_i
 	volatile cbd_t	*bdp;
 	ushort	int_events;
 	int	must_restart;
-	int idx;
 
 	cep = (struct fcc_enet_private *)dev->priv;
 
 	/* Get the interrupt events that caused us to be here.
 	*/
 	int_events = cep->fccp->fcc_fcce;
-	cep->fccp->fcc_fcce = int_events;
+	cep->fccp->fcc_fcce = (int_events & cep->fccp->fcc_fccm);
 	must_restart = 0;
 
+#ifdef CONFIG_USE_MDIO
+	/* We have to be careful here to make sure that we aren't
+	 * interrupted by a PHY interrupt.
+	 */
+	disable_irq_nosync(cep->fip->fc_phy_interrupt);
+#endif
+
 	/* Handle receive event in its own function.
 	*/
 	if (int_events & FCC_ENET_RXF)
@@ -530,7 +747,7 @@ fcc_enet_interrupt(int irq, void * dev_i
 	    spin_lock(&cep->lock);
 	    bdp = cep->dirty_tx;
 	    while ((bdp->cbd_sc&BD_ENET_TX_READY)==0) {
-		if ((bdp==cep->cur_tx) && (cep->tx_full == 0))
+		if (cep->tx_free == TX_RING_SIZE)
 		    break;
 
 		if (bdp->cbd_sc & BD_ENET_TX_HB)	/* No heartbeat */
@@ -563,12 +780,9 @@ fcc_enet_interrupt(int irq, void * dev_i
 			cep->stats.collisions++;
 
 		/* Free the sk buffer associated with this last transmit. */
-		idx = cep->skb_dirty & TX_RING_MOD_MASK;
-		dev_kfree_skb_irq(cep->tx_skbuff[idx]);
-		cep->tx_skbuff[idx] = NULL;
-		cep->skb_dirty++;
-
-		atomic_dec(&cep->n_pkts);
+		dev_kfree_skb_irq(cep->tx_skbuff[cep->skb_dirty]);
+		cep->tx_skbuff[cep->skb_dirty] = NULL;
+		cep->skb_dirty = (cep->skb_dirty + 1) & TX_RING_MOD_MASK;
 
 		/* Update pointer to next buffer descriptor to be transmitted. */
 		if (bdp->cbd_sc & BD_ENET_TX_WRAP)
@@ -588,8 +802,7 @@ fcc_enet_interrupt(int irq, void * dev_i
 		/* Since we have freed up a buffer, the ring is no longer
 		 * full.
 		 */
-		if (cep->tx_full) {
-			cep->tx_full = 0;
+		if (!cep->tx_free++) {
 			if (netif_queue_stopped(dev)) {
 				netif_wake_queue(dev);
 			}
@@ -626,8 +839,13 @@ fcc_enet_interrupt(int irq, void * dev_i
 	 * put them.
 	 */
 	if (int_events & FCC_ENET_BSY) {
+		cep->fccp->fcc_fcce = FCC_ENET_BSY;
 		cep->stats.rx_dropped++;
 	}
+
+#ifdef CONFIG_USE_MDIO
+	enable_irq(cep->fip->fc_phy_interrupt);
+#endif
 	return IRQ_HANDLED;
 }
 
@@ -726,8 +944,16 @@ for (;;) {
 static int
 fcc_enet_close(struct net_device *dev)
 {
-	/* Don't know what to do yet. */
+#ifdef	CONFIG_USE_MDIO
+	struct fcc_enet_private *fep = dev->priv;
+#endif
+
 	netif_stop_queue(dev);
+	fcc_stop(dev);
+#ifdef	CONFIG_USE_MDIO
+	if (fep->phy)
+		mii_do_cmd(dev, fep->phy->shutdown);
+#endif
 
 	return 0;
 }
@@ -751,419 +977,135 @@ static int
 mii_queue(struct net_device *dev, int regval, void (*func)(uint, struct net_device *))
 {
 	struct fcc_enet_private *fep;
-	int		retval, tmp;
-
-	/* Add PHY address to register command. */
-	fep = dev->priv;
-	regval |= fep->phy_addr << 23;
-
-	retval = 0;
-
-	tmp = mii_send_receive(fep->fip, regval);
-	if (func)
-		func(tmp, dev);
-
-	return retval;
-}
-
-static void mii_do_cmd(struct net_device *dev, const phy_cmd_t *c)
-{
-	int k;
-
-	if(!c)
-		return;
-
-	for(k = 0; (c+k)->mii_data != mk_mii_end; k++)
-		mii_queue(dev, (c+k)->mii_data, (c+k)->funct);
-}
-
-static void mii_parse_sr(uint mii_reg, struct net_device *dev)
-{
-	volatile struct fcc_enet_private *fep = dev->priv;
-	uint s = fep->phy_status;
-
-	s &= ~(PHY_STAT_LINK | PHY_STAT_FAULT | PHY_STAT_ANC);
-
-	if (mii_reg & 0x0004)
-		s |= PHY_STAT_LINK;
-	if (mii_reg & 0x0010)
-		s |= PHY_STAT_FAULT;
-	if (mii_reg & 0x0020)
-		s |= PHY_STAT_ANC;
-
-	fep->phy_status = s;
-	fep->link = (s & PHY_STAT_LINK) ? 1 : 0;
-}
-
-static void mii_parse_cr(uint mii_reg, struct net_device *dev)
-{
-	volatile struct fcc_enet_private *fep = dev->priv;
-	uint s = fep->phy_status;
-
-	s &= ~(PHY_CONF_ANE | PHY_CONF_LOOP);
-
-	if (mii_reg & 0x1000)
-		s |= PHY_CONF_ANE;
-	if (mii_reg & 0x4000)
-		s |= PHY_CONF_LOOP;
-
-	fep->phy_status = s;
-}
-
-static void mii_parse_anar(uint mii_reg, struct net_device *dev)
-{
-	volatile struct fcc_enet_private *fep = dev->priv;
-	uint s = fep->phy_status;
-
-	s &= ~(PHY_CONF_SPMASK);
-
-	if (mii_reg & 0x0020)
-		s |= PHY_CONF_10HDX;
-	if (mii_reg & 0x0040)
-		s |= PHY_CONF_10FDX;
-	if (mii_reg & 0x0080)
-		s |= PHY_CONF_100HDX;
-	if (mii_reg & 0x00100)
-		s |= PHY_CONF_100FDX;
-
-	fep->phy_status = s;
-}
-/* ------------------------------------------------------------------------- */
-/* The Level one LXT970 is used by many boards				     */
-
-#ifdef CONFIG_FCC_LXT970
-
-#define MII_LXT970_MIRROR    16  /* Mirror register           */
-#define MII_LXT970_IER       17  /* Interrupt Enable Register */
-#define MII_LXT970_ISR       18  /* Interrupt Status Register */
-#define MII_LXT970_CONFIG    19  /* Configuration Register    */
-#define MII_LXT970_CSR       20  /* Chip Status Register      */
-
-static void mii_parse_lxt970_csr(uint mii_reg, struct net_device *dev)
-{
-	volatile struct fcc_enet_private *fep = dev->priv;
-	uint s = fep->phy_status;
-
-	s &= ~(PHY_STAT_SPMASK);
-
-	if (mii_reg & 0x0800) {
-		if (mii_reg & 0x1000)
-			s |= PHY_STAT_100FDX;
-		else
-			s |= PHY_STAT_100HDX;
-	} else {
-		if (mii_reg & 0x1000)
-			s |= PHY_STAT_10FDX;
-		else
-			s |= PHY_STAT_10HDX;
-	}
-
-	fep->phy_status = s;
-}
-
-static phy_info_t phy_info_lxt970 = {
-	0x07810000,
-	"LXT970",
-
-	(const phy_cmd_t []) {  /* config */
-#if 0
-//		{ mk_mii_write(MII_REG_ANAR, 0x0021), NULL },
-
-		/* Set default operation of 100-TX....for some reason
-		 * some of these bits are set on power up, which is wrong.
-		 */
-		{ mk_mii_write(MII_LXT970_CONFIG, 0), NULL },
-#endif
-		{ mk_mii_read(MII_REG_CR), mii_parse_cr },
-		{ mk_mii_read(MII_REG_ANAR), mii_parse_anar },
-		{ mk_mii_end, }
-	},
-	(const phy_cmd_t []) {  /* startup - enable interrupts */
-		{ mk_mii_write(MII_LXT970_IER, 0x0002), NULL },
-		{ mk_mii_write(MII_REG_CR, 0x1200), NULL }, /* autonegotiate */
-		{ mk_mii_end, }
-	},
-	(const phy_cmd_t []) { /* ack_int */
-		/* read SR and ISR to acknowledge */
-
-		{ mk_mii_read(MII_REG_SR), mii_parse_sr },
-		{ mk_mii_read(MII_LXT970_ISR), NULL },
-
-		/* find out the current status */
-
-		{ mk_mii_read(MII_LXT970_CSR), mii_parse_lxt970_csr },
-		{ mk_mii_end, }
-	},
-	(const phy_cmd_t []) {  /* shutdown - disable interrupts */
-		{ mk_mii_write(MII_LXT970_IER, 0x0000), NULL },
-		{ mk_mii_end, }
-	},
-};
-
-#endif /* CONFIG_FEC_LXT970 */
-
-/* ------------------------------------------------------------------------- */
-/* The Level one LXT971 is used on some of my custom boards                  */
-
-#ifdef CONFIG_FCC_LXT971
-
-/* register definitions for the 971 */
-
-#define MII_LXT971_PCR       16  /* Port Control Register     */
-#define MII_LXT971_SR2       17  /* Status Register 2         */
-#define MII_LXT971_IER       18  /* Interrupt Enable Register */
-#define MII_LXT971_ISR       19  /* Interrupt Status Register */
-#define MII_LXT971_LCR       20  /* LED Control Register      */
-#define MII_LXT971_TCR       30  /* Transmit Control Register */
-
-/*
- * I had some nice ideas of running the MDIO faster...
- * The 971 should support 8MHz and I tried it, but things acted really
- * weird, so 2.5 MHz ought to be enough for anyone...
- */
-
-static void mii_parse_lxt971_sr2(uint mii_reg, struct net_device *dev)
-{
-	volatile struct fcc_enet_private *fep = dev->priv;
-	uint s = fep->phy_status;
-
-	s &= ~(PHY_STAT_SPMASK);
-
-	if (mii_reg & 0x4000) {
-		if (mii_reg & 0x0200)
-			s |= PHY_STAT_100FDX;
-		else
-			s |= PHY_STAT_100HDX;
-	} else {
-		if (mii_reg & 0x0200)
-			s |= PHY_STAT_10FDX;
-		else
-			s |= PHY_STAT_10HDX;
-	}
-	if (mii_reg & 0x0008)
-		s |= PHY_STAT_FAULT;
-
-	fep->phy_status = s;
-}
-
-static phy_info_t phy_info_lxt971 = {
-	0x0001378e,
-	"LXT971",
-
-	(const phy_cmd_t []) {  /* config */
-//		{ mk_mii_write(MII_REG_ANAR, 0x021), NULL }, /* 10  Mbps, HD */
-		{ mk_mii_read(MII_REG_CR), mii_parse_cr },
-		{ mk_mii_read(MII_REG_ANAR), mii_parse_anar },
-		{ mk_mii_end, }
-	},
-	(const phy_cmd_t []) {  /* startup - enable interrupts */
-		{ mk_mii_write(MII_LXT971_IER, 0x00f2), NULL },
-		{ mk_mii_write(MII_REG_CR, 0x1200), NULL }, /* autonegotiate */
-
-		/* Somehow does the 971 tell me that the link is down
-		 * the first read after power-up.
-		 * read here to get a valid value in ack_int */
-
-		{ mk_mii_read(MII_REG_SR), mii_parse_sr },
-		{ mk_mii_end, }
-	},
-	(const phy_cmd_t []) { /* ack_int */
-		/* find out the current status */
-
-		{ mk_mii_read(MII_REG_SR), mii_parse_sr },
-		{ mk_mii_read(MII_LXT971_SR2), mii_parse_lxt971_sr2 },
-
-		/* we only need to read ISR to acknowledge */
-
-		{ mk_mii_read(MII_LXT971_ISR), NULL },
-		{ mk_mii_end, }
-	},
-	(const phy_cmd_t []) {  /* shutdown - disable interrupts */
-		{ mk_mii_write(MII_LXT971_IER, 0x0000), NULL },
-		{ mk_mii_end, }
-	},
-};
-
-#endif /* CONFIG_FEC_LXT970 */
-
-
-/* ------------------------------------------------------------------------- */
-/* The Quality Semiconductor QS6612 is used on the RPX CLLF                  */
-
-#ifdef CONFIG_FCC_QS6612
-
-/* register definitions */
-
-#define MII_QS6612_MCR       17  /* Mode Control Register      */
-#define MII_QS6612_FTR       27  /* Factory Test Register      */
-#define MII_QS6612_MCO       28  /* Misc. Control Register     */
-#define MII_QS6612_ISR       29  /* Interrupt Source Register  */
-#define MII_QS6612_IMR       30  /* Interrupt Mask Register    */
-#define MII_QS6612_PCR       31  /* 100BaseTx PHY Control Reg. */
-
-static void mii_parse_qs6612_pcr(uint mii_reg, struct net_device *dev)
-{
-	volatile struct fcc_enet_private *fep = dev->priv;
-	uint s = fep->phy_status;
-
-	s &= ~(PHY_STAT_SPMASK);
-
-	switch((mii_reg >> 2) & 7) {
-	case 1: s |= PHY_STAT_10HDX;  break;
-	case 2: s |= PHY_STAT_100HDX; break;
-	case 5: s |= PHY_STAT_10FDX;  break;
-	case 6: s |= PHY_STAT_100FDX; break;
-	}
-
-	fep->phy_status = s;
-}
-
-static phy_info_t phy_info_qs6612 = {
-	0x00181440,
-	"QS6612",
-
-	(const phy_cmd_t []) {  /* config */
-//	{ mk_mii_write(MII_REG_ANAR, 0x061), NULL }, /* 10  Mbps */
-
-		/* The PHY powers up isolated on the RPX,
-		 * so send a command to allow operation.
-		 */
-
-		{ mk_mii_write(MII_QS6612_PCR, 0x0dc0), NULL },
-
-		/* parse cr and anar to get some info */
-
-		{ mk_mii_read(MII_REG_CR), mii_parse_cr },
-		{ mk_mii_read(MII_REG_ANAR), mii_parse_anar },
-		{ mk_mii_end, }
-	},
-	(const phy_cmd_t []) {  /* startup - enable interrupts */
-		{ mk_mii_write(MII_QS6612_IMR, 0x003a), NULL },
-		{ mk_mii_write(MII_REG_CR, 0x1200), NULL }, /* autonegotiate */
-		{ mk_mii_end, }
-	},
-	(const phy_cmd_t []) { /* ack_int */
-
-		/* we need to read ISR, SR and ANER to acknowledge */
+	int		retval, tmp;
 
-		{ mk_mii_read(MII_QS6612_ISR), NULL },
-		{ mk_mii_read(MII_REG_SR), mii_parse_sr },
-		{ mk_mii_read(MII_REG_ANER), NULL },
+	/* Add PHY address to register command. */
+	fep = dev->priv;
+	regval |= fep->phy_addr << 23;
 
-		/* read pcr to get info */
+	retval = 0;
 
-		{ mk_mii_read(MII_QS6612_PCR), mii_parse_qs6612_pcr },
-		{ mk_mii_end, }
-	},
-	(const phy_cmd_t []) {  /* shutdown - disable interrupts */
-		{ mk_mii_write(MII_QS6612_IMR, 0x0000), NULL },
-		{ mk_mii_end, }
-	},
-};
+	tmp = mii_send_receive(fep->fip, regval);
+	if (func)
+		func(tmp, dev);
 
+	return retval;
+}
 
-#endif /* CONFIG_FEC_QS6612 */
+static int
+mii_read(struct net_device *dev, int regval)
+{
+	struct fcc_enet_private *fep;
 
+	/* Add PHY address to register command. */
+	fep = dev->priv;
+	regval |= fep->phy_addr << 23;
 
-/* ------------------------------------------------------------------------- */
-/* The Davicom DM9131 is used on the HYMOD board			     */
+	return(mii_send_receive(fep->fip, regval));
+}
 
-#ifdef CONFIG_FCC_DM9131
+static void mii_do_cmd(struct net_device *dev, const phy_cmd_t *c)
+{
+	int k;
 
-/* register definitions */
+	if(!c)
+		return;
 
-#define MII_DM9131_ACR		16	/* Aux. Config Register		*/
-#define MII_DM9131_ACSR		17	/* Aux. Config/Status Register	*/
-#define MII_DM9131_10TCSR	18	/* 10BaseT Config/Status Reg.	*/
-#define MII_DM9131_INTR		21	/* Interrupt Register		*/
-#define MII_DM9131_RECR		22	/* Receive Error Counter Reg.	*/
-#define MII_DM9131_DISCR	23	/* Disconnect Counter Register	*/
+	for(k = 0; (c+k)->mii_data != mk_mii_end; k++)
+		mii_queue(dev, (c+k)->mii_data, (c+k)->funct);
+}
 
-static void mii_parse_dm9131_acsr(uint mii_reg, struct net_device *dev)
+static void mii_parse_sr(uint mii_reg, struct net_device *dev)
 {
 	volatile struct fcc_enet_private *fep = dev->priv;
 	uint s = fep->phy_status;
 
-	s &= ~(PHY_STAT_SPMASK);
+	s &= ~(PHY_STAT_FAULT | PHY_STAT_ANC);
 
-	switch ((mii_reg >> 12) & 0xf) {
-	case 1: s |= PHY_STAT_10HDX;  break;
-	case 2: s |= PHY_STAT_10FDX;  break;
-	case 4: s |= PHY_STAT_100HDX; break;
-	case 8: s |= PHY_STAT_100FDX; break;
-	}
+	if (mii_reg & MII_SR_REMOTE_FAULT)
+		s |= PHY_STAT_FAULT;
+
+	if (mii_reg & MII_SR_AUTONEG_DONE)
+		s |= PHY_STAT_ANC;
 
 	fep->phy_status = s;
 }
 
-static phy_info_t phy_info_dm9131 = {
-	0x00181b80,
-	"DM9131",
-
-	(const phy_cmd_t []) {  /* config */
-		/* parse cr and anar to get some info */
-		{ mk_mii_read(MII_REG_CR), mii_parse_cr },
-		{ mk_mii_read(MII_REG_ANAR), mii_parse_anar },
-		{ mk_mii_end, }
-	},
-	(const phy_cmd_t []) {  /* startup - enable interrupts */
-		{ mk_mii_write(MII_DM9131_INTR, 0x0002), NULL },
-		{ mk_mii_write(MII_REG_CR, 0x1200), NULL }, /* autonegotiate */
-		{ mk_mii_end, }
-	},
-	(const phy_cmd_t []) { /* ack_int */
+static void mii_parse_cr(uint mii_reg, struct net_device *dev)
+{
+	volatile struct fcc_enet_private *fep = dev->priv;
+	uint s = fep->phy_status;
 
-		/* we need to read INTR, SR and ANER to acknowledge */
+	s &= ~(PHY_CONF_ANE | PHY_CONF_LOOP);
 
-		{ mk_mii_read(MII_DM9131_INTR), NULL },
-		{ mk_mii_read(MII_REG_SR), mii_parse_sr },
-		{ mk_mii_read(MII_REG_ANER), NULL },
+	if (mii_reg & MII_CR_ENABLE_NEG)
+		s |= PHY_CONF_ANE;
 
-		/* read acsr to get info */
+	if (mii_reg & MII_CR_LBK_MODE)
+		s |= PHY_CONF_LOOP;
 
-		{ mk_mii_read(MII_DM9131_ACSR), mii_parse_dm9131_acsr },
-		{ mk_mii_end, }
-	},
-	(const phy_cmd_t []) {  /* shutdown - disable interrupts */
-		{ mk_mii_write(MII_DM9131_INTR, 0x0f00), NULL },
-		{ mk_mii_end, }
-	},
-};
+	fep->phy_status = s;
+}
 
+static void mii_parse_ar(uint mii_reg, struct net_device *dev)
+{
+	volatile struct fcc_enet_private *fep = dev->priv;
+	uint s = fep->phy_status;
 
-#endif /* CONFIG_FEC_DM9131 */
+	s &= ~(PHY_CONF_SPMASK);
 
+	if (mii_reg & MII_AR_10MB_HALFDUP)
+		s |= PHY_CONF_10HDX;
+	if (mii_reg & MII_AR_10MB_FULLDUP)
+		s |= PHY_CONF_10FDX;
+	if (mii_reg & MII_AR_100MB_HALFDUP)
+		s |= PHY_CONF_100HDX;
+	if (mii_reg & MII_AR_100MB_FULLDUP)
+		s |= PHY_CONF_100FDX;
 
-static phy_info_t *phy_info[] = {
+	fep->phy_status = s;
+}
 
-#ifdef CONFIG_FCC_LXT970
-	&phy_info_lxt970,
-#endif /* CONFIG_FEC_LXT970 */
+static void mii_parse_sr2(uint mii_reg, struct net_device *dev)
+{
+	volatile struct fcc_enet_private 	*fep = dev->priv;
+	uint 								s = fep->phy_status;
 
-#ifdef CONFIG_FCC_LXT971
-	&phy_info_lxt971,
-#endif /* CONFIG_FEC_LXT971 */
+	s &= ~(PHY_STAT_LINK | PHY_STAT_SPMASK);
 
-#ifdef CONFIG_FCC_QS6612
-	&phy_info_qs6612,
-#endif /* CONFIG_FEC_QS6612 */
-
-#ifdef CONFIG_FCC_DM9131
-	&phy_info_dm9131,
-#endif /* CONFIG_FEC_DM9131 */
+	if (mii_reg & MII_SR2_LINK_UP)
+		s |= PHY_STAT_LINK;
 
-	NULL
-};
+	if (mii_reg & MII_SR2_100_TX) {
+		if (mii_reg & MII_SR2_FULL_DUP)
+			s |= PHY_STAT_100FDX;
+		else
+			s |= PHY_STAT_100HDX;
+	} else {
+		if (mii_reg & MII_SR2_FULL_DUP)
+			s |= PHY_STAT_10FDX;
+		else
+			s |= PHY_STAT_10HDX;
+	}
+
+	if (mii_reg & MII_SR2_ERROR)
+		s |= PHY_STAT_FAULT;
+
+	fep->phy_status = s;
+	fep->link = (s & PHY_STAT_LINK) ? 1 : 0;
+}
 
 static void mii_display_status(struct net_device *dev)
 {
 	volatile struct fcc_enet_private *fep = dev->priv;
 	uint s = fep->phy_status;
 
+#if 0
 	if (!fep->link && !fep->old_link) {
 		/* Link is still down - don't print anything */
 		return;
 	}
+#endif /* GG */
 
 	printk("%s: status: ", dev->name);
 
@@ -1225,20 +1167,28 @@ static void mii_display_config(struct ne
 static void mii_relink(struct net_device *dev)
 {
 	struct fcc_enet_private *fep = dev->priv;
-	int duplex;
+	int duplex = 0;
 
+	fep->old_link = fep->link; /* GG */
 	fep->link = (fep->phy_status & PHY_STAT_LINK) ? 1 : 0;
-	mii_display_status(dev);
-	fep->old_link = fep->link;
+
+#ifdef MDIO_DEBUG
+	printk("  mii_relink:  link=%d\n", fep->link);
+#endif
 
 	if (fep->link) {
-		duplex = 0;
 		if (fep->phy_status
 		    & (PHY_STAT_100FDX | PHY_STAT_10FDX))
 			duplex = 1;
 		fcc_restart(dev, duplex);
+#ifdef MDIO_DEBUG
+		printk("  mii_relink:  duplex=%d\n", duplex);
+#endif
+#if 0
+	/* useful ?? */
 	} else {
 		fcc_stop(dev);
+#endif /* GG */
 	}
 }
 
@@ -1246,28 +1196,18 @@ static void mii_queue_relink(uint mii_re
 {
 	struct fcc_enet_private *fep = dev->priv;
 
-	fep->phy_task.routine = (void *)mii_relink;
-	fep->phy_task.data = dev;
-	schedule_task(&fep->phy_task);
+	mii_relink(dev);
+
+	schedule_work(&fep->phy_relink);
 }
 
 static void mii_queue_config(uint mii_reg, struct net_device *dev)
 {
 	struct fcc_enet_private *fep = dev->priv;
 
-	fep->phy_task.routine = (void *)mii_display_config;
-	fep->phy_task.data = dev;
-	schedule_task(&fep->phy_task);
+	schedule_work(&fep->phy_display_config);
 }
 
-
-
-phy_cmd_t phy_cmd_relink[] = { { mk_mii_read(MII_REG_CR), mii_queue_relink },
-			       { mk_mii_end, } };
-phy_cmd_t phy_cmd_config[] = { { mk_mii_read(MII_REG_CR), mii_queue_config },
-			       { mk_mii_end, } };
-
-
 /* Read remainder of PHY ID.
 */
 static void
@@ -1277,10 +1217,11 @@ mii_discover_phy3(uint mii_reg, struct n
 	int	i;
 
 	fep = dev->priv;
+	// GG printk("mii_reg: %08x\n", mii_reg);
 	fep->phy_id |= (mii_reg & 0xffff);
 
 	for(i = 0; phy_info[i]; i++)
-		if(phy_info[i]->id == (fep->phy_id >> 4))
+		if((phy_info[i]->id == (fep->phy_id >> 4)) || !phy_info[i]->id)
 			break;
 
 	if(!phy_info[i])
@@ -1288,6 +1229,7 @@ mii_discover_phy3(uint mii_reg, struct n
 		      dev->name, fep->phy_id);
 
 	fep->phy = phy_info[i];
+	fep->phy_id_done = 1;
 
 	printk("%s: Phy @ 0x%x, type %s (0x%08x)\n",
 		dev->name, fep->phy_addr, fep->phy->name, fep->phy_id);
@@ -1304,15 +1246,15 @@ mii_discover_phy(uint mii_reg, struct ne
 
 	fep = dev->priv;
 
-	if ((phytype = (mii_reg & 0xfff)) != 0xfff) {
+	if ((phytype = (mii_reg & 0xffff)) != 0xffff) {
 
 		/* Got first part of ID, now get remainder. */
 		fep->phy_id = phytype << 16;
-		mii_queue(dev, mk_mii_read(MII_REG_PHYIR2), mii_discover_phy3);
+		mii_queue(dev, mk_mii_read(MII_LXT971_IR2), mii_discover_phy3);
 	} else {
 		fep->phy_addr++;
 		if (fep->phy_addr < 32) {
-			mii_queue(dev, mk_mii_read(MII_REG_PHYIR1),
+			mii_queue(dev, mk_mii_read(MII_LXT971_IR1),
 							mii_discover_phy);
 		} else {
 			printk("fec: No PHY device found.\n");
@@ -1326,12 +1268,22 @@ mii_link_interrupt(int irq, void * dev_i
 {
 	struct	net_device *dev = dev_id;
 	struct fcc_enet_private *fep = dev->priv;
+	fcc_info_t *fip = fep->fip;
+
+	if (fep->phy) {
+		/* We don't want to be interrupted by an FCC
+		 * interrupt here.
+		 */
+		disable_irq_nosync(fip->fc_interrupt);
+
+		mii_do_cmd(dev, fep->phy->ack_int);
+		/* restart and display status */
+		mii_do_cmd(dev, phy_cmd_relink);
 
-	mii_do_cmd(dev, fep->phy->ack_int);
-	mii_do_cmd(dev, phy_cmd_relink);  /* restart and display status */
+		enable_irq(fip->fc_interrupt);
+	}
 	return IRQ_HANDLED;
 }
-
 #endif	/* CONFIG_USE_MDIO */
 
 /* Set or clear the multicast filter for this adaptor.
@@ -1354,7 +1306,6 @@ set_multicast_list(struct net_device *de
 
 	cep = (struct fcc_enet_private *)dev->priv;
 
-return;
 	/* Get pointer to FCC area in parameter RAM.
 	*/
 	ep = (fcc_enet_t *)dev->base_addr;
@@ -1383,8 +1334,8 @@ return;
 
 			dmi = dev->mc_list;
 
-			for (i=0; i<dev->mc_count; i++) {
-		
+			for (i=0; i<dev->mc_count; i++, dmi = dmi->next) {
+				
 				/* Only support group multicast for now.
 				*/
 				if (!(dmi->dmi_addr[0] & 1))
@@ -1412,7 +1363,6 @@ return;
 	}
 }
 
-
 /* Set the individual MAC address.
  */
 int fcc_enet_set_mac_address(struct net_device *dev, void *p)
@@ -1484,6 +1434,9 @@ static int __init fec_enet_init(void)
 		dev->get_stats = fcc_enet_get_stats;
 		dev->set_multicast_list = set_multicast_list;
 		dev->set_mac_address = fcc_enet_set_mac_address;
+#ifdef  CONFIG_USE_MDIO
+		dev->do_ioctl		= fcc_enet_ioctl;
+#endif  /* CONFIG_USE_MDIO */
 
 		init_fcc_startup(fip, dev);
 
@@ -1493,19 +1446,29 @@ static int __init fec_enet_init(void)
 			return err;
 		}
 
-		printk("%s: FCC ENET Version 0.3, ", dev->name);
-		for (i=0; i<5; i++)
-			printk("%02x:", dev->dev_addr[i]);
-		printk("%02x\n", dev->dev_addr[5]);
-
 #ifdef	CONFIG_USE_MDIO
 		/* Queue up command to detect the PHY and initialize the
 	 	* remainder of the interface.
 	 	*/
+		cep->phy_id_done = 0;
+#if 0
 		cep->phy_addr = 0;
-		mii_queue(dev, mk_mii_read(MII_REG_PHYIR1), mii_discover_phy);
+#else
+		/* PHY address is the same as FCC number */
+		cep->phy_addr = cep->fip->fc_fccnum;
+#endif /* GG */
+		mii_queue(dev, mk_mii_read(MII_LXT971_IR1), mii_discover_phy);
+		INIT_WORK(&cep->phy_relink, 
+				(void (*)(void *))mii_display_status, (void *)dev);
+		INIT_WORK(&cep->phy_display_config, 
+				(void (*)(void *))mii_display_config, (void *)dev);
 #endif	/* CONFIG_USE_MDIO */
 
+		printk("%s: FCC ENET Version 1.1.0, ", dev->name);
+		for (i=0; i<5; i++)
+			printk("%02x:", dev->dev_addr[i]);
+		printk("%02x\n", dev->dev_addr[5]);
+
 		fip++;
 	}
 
@@ -1583,9 +1546,10 @@ init_fcc_ioports(fcc_info_t *fip, volati
 #ifdef	CONFIG_USE_MDIO
 	/* ....and the MII serial clock/data.
 	*/
-	io->iop_pdatc |= (fip->fc_mdio | fip->fc_mdck);
-	io->iop_podrc &= ~(fip->fc_mdio | fip->fc_mdck);
-	io->iop_pdirc |= (fip->fc_mdio | fip->fc_mdck);
+	io->iop_pdatc &= ~(fip->fc_mdio | fip->fc_mdck);
+	io->iop_podrc &= ~(fip->fc_mdck | fip->fc_mdio);
+	io->iop_pdirc |= fip->fc_mdck;
+	io->iop_pdirc &= ~(fip->fc_mdio);
 	io->iop_pparc &= ~(fip->fc_mdio | fip->fc_mdck);
 #endif	/* CONFIG_USE_MDIO */
 
@@ -1697,27 +1661,19 @@ init_fcc_param(fcc_info_t *fip, struct n
 	 * it unique by setting a few bits in the upper byte of the
 	 * non-static part of the address.
 	 */
+#ifdef CONFIG_RGWYPQ2
 	eap = (unsigned char *)&(ep->fen_paddrh);
 	for (i=5; i>=0; i--) {
-#ifdef CONFIG_SBC82xx
 		if (i == 5) {
-			/* bd->bi_enetaddr holds the SCC0 address; the FCC
-			   devices count up from there */
-			dev->dev_addr[i] = bd->bi_enetaddr[i] & ~3;
-			dev->dev_addr[i] += 1 + fip->fc_fccnum;
-			*eap++ = dev->dev_addr[i];
-		}
-#else
-		if (i == 3) {
 			dev->dev_addr[i] = bd->bi_enetaddr[i];
-			dev->dev_addr[i] |= (1 << (7 - fip->fc_fccnum));
+			dev->dev_addr[i] += fip->fc_fccnum;
 			*eap++ = dev->dev_addr[i];
 		}
-#endif
 		else {
 			*eap++ = dev->dev_addr[i] = bd->bi_enetaddr[i];
 		}
 	}
+#endif /* CONFIG_RGWYPQ2 */
 
 	ep->fen_taddrh = 0;
 	ep->fen_taddrm = 0;
@@ -1798,7 +1754,6 @@ init_fcc_param(fcc_info_t *fip, struct n
 	while (cp->cp_cpcr & CPM_CR_FLG);
 
 	cep->skb_cur = cep->skb_dirty = 0;
-	atomic_set(&cep->n_pkts, 0);
 }
 
 /* Let 'er rip.
@@ -1808,33 +1763,40 @@ init_fcc_startup(fcc_info_t *fip, struct
 {
 	volatile fcc_t	*fccp;
 	struct fcc_enet_private *cep;
+	int                     duplex;
 
 	cep = (struct fcc_enet_private *)(dev->priv);
 	fccp = cep->fccp;
 
 	fccp->fcc_fcce = 0xffff;	/* Clear any pending events */
 
-	/* Enable interrupts for transmit error, complete frame
-	 * received, and any transmit buffer we have also set the
-	 * interrupt flag.
+	/* Leave FCC interrupts masked for now.  Will be unmasked by
+	 * fcc_restart().
 	 */
-	fccp->fcc_fccm = (FCC_ENET_TXE | FCC_ENET_RXF | FCC_ENET_TXB);
+	fccp->fcc_fccm = 0;
 
 	/* Install our interrupt handler.
 	*/
-	if (request_irq(fip->fc_interrupt, fcc_enet_interrupt, 0,
-							"fenet", dev) < 0)
+	if (request_irq(fip->fc_interrupt, fcc_enet_interrupt, 0, "fenet",
+				dev) < 0)
 		printk("Can't get FCC IRQ %d\n", fip->fc_interrupt);
 
 #ifdef	CONFIG_USE_MDIO
-	if (request_irq(PHY_INTERRUPT, mii_link_interrupt, 0,
+	/* ack pending PHY interrupts and read PHY current status */
+	// GG mii_do_cmd(dev, cep->phy->ack_int);
+
+	if (request_irq(fip->fc_phy_interrupt, mii_link_interrupt, 0,
 							"mii", dev) < 0)
-		printk("Can't get MII IRQ %d\n", fip->fc_interrupt);
+		printk("Can't get MII IRQ %d\n", fip->fc_phy_interrupt);
 #endif	/* CONFIG_USE_MDIO */
 
 	/* Set GFMR to enable Ethernet operating mode.
 	 */
+#if 0
 	fccp->fcc_gfmr = (FCC_GFMR_TCI | FCC_GFMR_MODE_ENET);
+#else
+	fccp->fcc_gfmr = FCC_GFMR_MODE_ENET;
+#endif /* GG */
 
 	/* Set sync/delimiters.
 	*/
@@ -1853,143 +1815,197 @@ init_fcc_startup(fcc_info_t *fip, struct
         *(volatile uint *)(BCSR_ADDR + 4) |=  BCSR1_FETH_RST;
 #endif
 
-#if defined(CONFIG_USE_MDIO) || defined(CONFIG_TQM8260)
-	/* start in full duplex mode, and negotiate speed
-	 */
-	fcc_restart (dev, 1);
+#ifdef CONFIG_USE_MDIO
+	if (cep->phy_status & (PHY_STAT_100FDX | PHY_STAT_10FDX)) {
+		duplex = 1;
+	} else {
+		duplex = 0;
+	}
+	fcc_restart(dev, duplex);
 #else
-	/* start in half duplex mode
-	 */
-	fcc_restart (dev, 0);
+	/* start in half duplex mode */
+	duplex = 0;
+	fcc_restart (dev, duplex);
 #endif
 }
 
-#ifdef	CONFIG_USE_MDIO
-/* MII command/status interface.
- * I'm not going to describe all of the details.  You can find the
- * protocol definition in many other places, including the data sheet
- * of most PHY parts.
- * I wonder what "they" were thinking (maybe weren't) when they leave
- * the I2C in the CPM but I have to toggle these bits......
- */
-
-#define FCC_PDATC_MDIO(bit)					\
-	if (bit)						\
-		io->iop_pdatc |= fip->fc_mdio;			\
-	else							\
-		io->iop_pdatc &= ~fip->fc_mdio;
-
-#define FCC_PDATC_MDC(bit)					\
-	if (bit)						\
-		io->iop_pdatc |= fip->fc_mdck;			\
-	else							\
-		io->iop_pdatc &= ~fip->fc_mdck;
-
+#ifdef CONFIG_USE_MDIO
 static uint
 mii_send_receive(fcc_info_t *fip, uint cmd)
 {
-	uint		retval;
-	int		read_op, i, off;
-	volatile	cpm2_map_t		*immap;
-	volatile	iop_cpm2_t	*io;
+	uint				retval;
+	int					read_op, i, off;
+	volatile cpm2_map_t	*immap;
+	volatile iop_cpm2_t	*io;
 
 	immap = (cpm2_map_t *)CPM_MAP_ADDR;
 	io = &immap->im_ioport;
 
-	io->iop_pdirc |= (fip->fc_mdio | fip->fc_mdck);
-
+	/* check if read operation */
 	read_op = ((cmd & 0xf0000000) == 0x60000000);
 
-	/* Write preamble
-	 */
-	for (i = 0; i < 32; i++)
-	{
-		FCC_PDATC_MDC(0);
-		FCC_PDATC_MDIO(1);
+	/* set mdc as output */
+	io->iop_pdird |= (fip->fc_mdck);
+	FCC_PDATD_MDC(1);
+
+	/* set mdio as output */
+	io->iop_pdird |= (fip->fc_mdio);
+	FCC_PDATD_MDIO(1);
+
+	/* write preamble */
+	for (i = 0; i < 32; i++) {
+		FCC_PDATD_MDC(0);
 		udelay(1);
-		FCC_PDATC_MDC(1);
+		FCC_PDATD_MDC(1);
 		udelay(1);
 	}
 
-	/* Write data
-	 */
+	/* reset clock state */
+	FCC_PDATD_MDC(0);
+	udelay(1);
+
+	/* set mdio as output */
+	io->iop_pdird |= (fip->fc_mdio);
+	FCC_PDATD_MDIO(1);
+
+	/* write data */
 	for (i = 0, off = 31; i < (read_op ? 14 : 32); i++, --off)
 	{
-		FCC_PDATC_MDC(0);
-		FCC_PDATC_MDIO((cmd >> off) & 0x00000001);
+		FCC_PDATD_MDIO((cmd >> off) & 0x00000001);
+		FCC_PDATD_MDC(0);
 		udelay(1);
-		FCC_PDATC_MDC(1);
+		FCC_PDATD_MDC(1);
 		udelay(1);
 	}
 
+	/* reset clock state */
+	FCC_PDATD_MDC(0);
+	udelay(1);
+
 	retval = cmd;
 
 	if (read_op)
 	{
 		retval >>= 16;
 
-		FCC_PDATC_MDC(0);
-		io->iop_pdirc &= ~fip->fc_mdio;
-		udelay(1);
-		FCC_PDATC_MDC(1);
+		/* set mdio as input */
+		io->iop_pdird &= ~(fip->fc_mdio);
+
+		FCC_PDATD_MDC(1);
 		udelay(1);
-		FCC_PDATC_MDC(0);
+		FCC_PDATD_MDC(0);
 		udelay(1);
 
 		for (i = 0, off = 15; i < 16; i++, off--)
 		{
-			FCC_PDATC_MDC(1);
+			FCC_PDATD_MDC(1);
+			udelay(1);
+
 			retval <<= 1;
-			if (io->iop_pdatc & fip->fc_mdio)
+			if (io->iop_pdatd & fip->fc_mdio)
 				retval++;
-			udelay(1);
-			FCC_PDATC_MDC(0);
+
+			FCC_PDATD_MDC(0);
 			udelay(1);
 		}
+		FCC_PDATD_MDC(1);
+		udelay(1);
 	}
 
-	io->iop_pdirc |= (fip->fc_mdio | fip->fc_mdck);
+	/* set mdio as input */
+	io->iop_pdird &= ~(fip->fc_mdio);
 
-	for (i = 0; i < 32; i++)
-	{
-		FCC_PDATC_MDC(0);
-		FCC_PDATC_MDIO(1);
-		udelay(1);
-		FCC_PDATC_MDC(1);
-		udelay(1);
-	}
+	/* put the bus in idle state */
+	FCC_PDATD_MDC(0);
+	udelay(1);
+	FCC_PDATD_MDC(1);
+	udelay(1);
+	FCC_PDATD_MDC(0);
+	udelay(1);
+	FCC_PDATD_MDC(1);
+	udelay(1);
 
 	return retval;
 }
+#endif	/* CONFIG_USE_MDIO */
 
 static void
 fcc_stop(struct net_device *dev)
 {
-	volatile fcc_t	*fccp;
-	struct fcc_enet_private	*fcp;
+	struct fcc_enet_private	*fep= (struct fcc_enet_private *)(dev->priv);
+	volatile fcc_t	*fccp = fep->fccp;
+	fcc_info_t *fip = fep->fip;
+	volatile fcc_enet_t *ep = fep->ep;
+	volatile cpm_cpm2_t *cp = cpmp;
+	volatile cbd_t *bdp;
+	int i;
+
+	if ((fccp->fcc_gfmr & (FCC_GFMR_ENR | FCC_GFMR_ENT)) == 0)
+		return;	/* already down */
 
-	fcp = (struct fcc_enet_private *)(dev->priv);
-	fccp = fcp->fccp;
+	fccp->fcc_fccm = 0;
+
+	/* issue the graceful stop tx command */
+	while (cp->cp_cpcr & CPM_CR_FLG);
+	cp->cp_cpcr = mk_cr_cmd(fip->fc_cpmpage, fip->fc_cpmblock,
+				0x0c, CPM_CR_GRA_STOP_TX) | CPM_CR_FLG;
+	while (cp->cp_cpcr & CPM_CR_FLG);
 
 	/* Disable transmit/receive */
 	fccp->fcc_gfmr &= ~(FCC_GFMR_ENR | FCC_GFMR_ENT);
+
+	/* issue the restart tx command */
+	fccp->fcc_fcce = FCC_ENET_GRA;
+	while (cp->cp_cpcr & CPM_CR_FLG);
+	cp->cp_cpcr = mk_cr_cmd(fip->fc_cpmpage, fip->fc_cpmblock,
+				0x0c, CPM_CR_RESTART_TX) | CPM_CR_FLG;
+	while (cp->cp_cpcr & CPM_CR_FLG);
+
+	/* free tx buffers */
+	fep->skb_cur = fep->skb_dirty = 0;
+	for (i=0; i<=TX_RING_MOD_MASK; i++) {
+		if (fep->tx_skbuff[i] != NULL) {
+			dev_kfree_skb(fep->tx_skbuff[i]);
+			fep->tx_skbuff[i] = NULL;
+		}
+	}
+	fep->dirty_tx = fep->cur_tx = fep->tx_bd_base;
+	fep->tx_free = TX_RING_SIZE;
+	ep->fen_genfcc.fcc_tbptr = ep->fen_genfcc.fcc_tbase;
+
+	/* Initialize the tx buffer descriptors. */
+	bdp = fep->tx_bd_base;
+	for (i=0; i<TX_RING_SIZE; i++) {
+		bdp->cbd_sc = 0;
+		bdp->cbd_datlen = 0;
+		bdp->cbd_bufaddr = 0;
+		bdp++;
+	}
+	/* Set the last buffer to wrap. */
+	bdp--;
+	bdp->cbd_sc |= BD_SC_WRAP;
 }
-#endif	/* CONFIG_USE_MDIO */
 
 static void
 fcc_restart(struct net_device *dev, int duplex)
 {
-	volatile fcc_t	*fccp;
-	struct fcc_enet_private	*fcp;
+	struct fcc_enet_private	*fep = (struct fcc_enet_private *)(dev->priv);
+	volatile fcc_t	*fccp = fep->fccp;
 
-	fcp = (struct fcc_enet_private *)(dev->priv);
-	fccp = fcp->fccp;
+	/* stop any transmissions in progress */
+	fcc_stop(dev);
 
 	if (duplex)
 		fccp->fcc_fpsmr |= FCC_PSMR_FDE | FCC_PSMR_LPB;
 	else
 		fccp->fcc_fpsmr &= ~(FCC_PSMR_FDE | FCC_PSMR_LPB);
 
+	/* Enable interrupts for transmit error, complete frame
+	 * received, and any transmit buffer we have also set the
+	 * interrupt flag.
+	 */
+	fccp->fcc_fccm = (FCC_ENET_TXE | FCC_ENET_RXF | FCC_ENET_TXB);
+
 	/* Enable transmit/receive */
 	fccp->fcc_gfmr |= FCC_GFMR_ENR | FCC_GFMR_ENT;
 }
@@ -2004,6 +2020,7 @@ fcc_enet_open(struct net_device *dev)
 	fep->link = 0;
 
 	if (fep->phy) {
+		fcc_restart(dev, 0);	/* always start in half-duplex */
 		mii_do_cmd(dev, fep->phy->ack_int);
 		mii_do_cmd(dev, fep->phy->config);
 		mii_do_cmd(dev, phy_cmd_config);  /* display configuration */
@@ -2017,8 +2034,274 @@ fcc_enet_open(struct net_device *dev)
 	return -ENODEV;		/* No PHY we understand */
 #else
 	fep->link = 1;
+	fcc_restart(dev, 0);	/* always start in half-duplex */
 	netif_start_queue(dev);
 	return 0;					/* Always succeed */
 #endif	/* CONFIG_USE_MDIO */
 }
 
+#ifdef	CONFIG_USE_MDIO
+static int
+fcc_enet_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	int rc = 0;
+	u16	tmp;
+	struct mii_ioctl_data *data = (struct mii_ioctl_data *)&ifr->ifr_data;
+	volatile struct fcc_enet_private 	*fep = dev->priv;
+
+	switch (cmd) {
+	case SIOCETHTOOL:
+		rc = fcc_ethtool_ioctl(dev, (void *)ifr->ifr_data);
+		break;
+
+	case SIOCGMIIPHY:	/* Get address of MII PHY in use. */
+	case SIOCGMIIREG:	/* Read MII PHY register. */
+		if (data->reg_num != 1) {
+			if (cmd == SIOCGMIIPHY) {
+				data->phy_id = (u16)fep->phy_addr;
+			}
+			data->val_out = (u16)mii_read(dev, 
+							mk_mii_read(data->reg_num & 0x1f));
+		} else {
+			/* just for bonding call */
+			/* read status register */
+			data->val_out = (u16)mii_read(dev, mk_mii_read(MII_LXT971_SR));
+			/* clear link status */
+			data->val_out &= ~MII_SR_LINKUP;
+			/* read status2 for link status */
+			tmp = (u16)mii_read(dev, mk_mii_read(MII_LXT971_SR2));
+			if (tmp & MII_SR2_LINK_UP) {
+				data->val_out |= MII_SR_LINKUP;
+			}
+		}
+		break;
+
+	case SIOCSMIIREG:	/* Write MII PHY register. */
+		/* check privilege */
+		if (!capable(CAP_NET_ADMIN)) {
+			return -EPERM;
+		}
+		mii_queue(dev, mk_mii_write(data->reg_num & 0x1f, data->val_in), NULL);
+		break;
+
+	default:
+		rc = -EOPNOTSUPP;
+		break;
+	}
+
+	return rc;
+}
+
+static int fcc_ethtool_ioctl(struct net_device *dev, void *arg)
+{
+	int									rc = 0;
+	int									advertise;
+	int									control;
+	struct ethtool_cmd					ecmd;
+	struct ethtool_value				evalue;
+	volatile struct fcc_enet_private 	*fep = dev->priv;
+
+	if (copy_from_user(&ecmd, arg, sizeof(ecmd))) {
+		return -EFAULT;
+	}
+
+	switch (ecmd.cmd) {
+	case ETHTOOL_GSET:		/* Get settings. */
+		mii_queue(dev, mk_mii_read(MII_LXT971_CR), mii_parse_cr);
+		mii_queue(dev, mk_mii_read(MII_LXT971_AR), mii_parse_ar);
+		mii_queue(dev, mk_mii_read(MII_LXT971_SR), mii_parse_sr);
+		mii_queue(dev, mk_mii_read(MII_LXT971_SR2), mii_parse_sr2);
+
+		/* supported features */
+		ecmd.supported = 
+			(SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |
+			SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full | 
+			SUPPORTED_Autoneg | SUPPORTED_TP);
+
+		/* advertised features */
+		ecmd.advertising = ADVERTISED_TP;
+		ecmd.autoneg = AUTONEG_DISABLE;
+		if (fep->phy_status & PHY_CONF_ANE) {
+			ecmd.advertising |= ADVERTISED_Autoneg;
+			ecmd.autoneg = AUTONEG_ENABLE;
+		}
+		if (fep->phy_status & PHY_CONF_100FDX) {
+			ecmd.advertising |= ADVERTISED_100baseT_Full;
+		}
+		if (fep->phy_status & PHY_CONF_100HDX) {
+			ecmd.advertising |= ADVERTISED_100baseT_Half;
+		}
+		if (fep->phy_status & PHY_CONF_10FDX) {
+			ecmd.advertising |= ADVERTISED_10baseT_Full;
+		}
+		if (fep->phy_status & PHY_CONF_10HDX) {
+			ecmd.advertising |= ADVERTISED_10baseT_Half;
+		}
+
+		/* speed and duplex */
+		switch(fep->phy_status & PHY_STAT_SPMASK) {
+		case PHY_STAT_100FDX:
+			ecmd.speed = SPEED_100;
+			ecmd.duplex = DUPLEX_FULL;
+			break;
+		case PHY_STAT_100HDX:
+			ecmd.speed = SPEED_100;
+			ecmd.duplex = DUPLEX_HALF;
+			break;
+		case PHY_STAT_10FDX:
+			ecmd.speed = SPEED_10;
+			ecmd.duplex = DUPLEX_FULL;
+			break;
+		case PHY_STAT_10HDX:
+		default:
+			ecmd.speed = SPEED_10;
+			ecmd.duplex = DUPLEX_HALF;
+			break;
+		}
+
+		/* port, phy_address, transceiver */
+		ecmd.port = PORT_TP;
+		ecmd.phy_address = fep->phy_addr;
+		ecmd.transceiver = XCVR_INTERNAL;
+
+		/* autoneg is set previously while advertised features */
+
+		if (copy_to_user(arg, &ecmd, sizeof(ecmd))) {
+			return -EFAULT;
+		}
+		break;
+
+	case ETHTOOL_SSET:		/* Set settings, privileged. */
+		/* check privilege */
+		if (!capable(CAP_NET_ADMIN)) {
+			return -EPERM;
+		}
+
+		/* verify the settings we care about. */
+		if (ecmd.autoneg != AUTONEG_ENABLE &&
+			ecmd.autoneg != AUTONEG_DISABLE) {
+			return -EINVAL;
+		}
+
+		if (ecmd.autoneg == AUTONEG_DISABLE && 
+			((ecmd.speed != SPEED_100 && ecmd.speed != SPEED_10) ||
+			 (ecmd.duplex != DUPLEX_HALF && ecmd.duplex != DUPLEX_FULL))) {
+			return -EINVAL;
+		}
+
+		/* stop FCC driver */
+		/* don't stop PHY to keep interupts */
+		fcc_stop(dev);
+
+		/* force PHY power down */
+		control = mii_read(dev, mk_mii_read(MII_LXT971_CR));
+		control |= MII_CR_POWERDOWN;
+		mii_queue(dev, mk_mii_write(MII_LXT971_CR, control), NULL);
+
+		/* prepare new advertissements */
+		advertise =	mii_read(dev, mk_mii_read(MII_LXT971_AR));
+
+		if (ecmd.autoneg == AUTONEG_ENABLE){
+			/* no flow control */
+			advertise &= ~(MII_AR_CRTL_PAUSE | MII_AR_CTRL_PAUSE_ASY);
+
+			/* set speed and duplex */
+			if (ecmd.advertising & ADVERTISED_100baseT_Full) {
+				advertise |= MII_AR_100MB_FULLDUP;
+			} else {
+				advertise &= ~MII_AR_100MB_FULLDUP;
+			}
+			if (ecmd.advertising & ADVERTISED_100baseT_Half) {
+				advertise |= MII_AR_100MB_HALFDUP;
+			} else {
+				advertise &= ~MII_AR_100MB_HALFDUP;
+			}
+			if (ecmd.advertising & ADVERTISED_10baseT_Full) {
+				advertise |= MII_AR_10MB_FULLDUP;
+			} else {
+				advertise &= ~MII_AR_10MB_FULLDUP;
+			}
+			if (ecmd.advertising & ADVERTISED_10baseT_Half) {
+				advertise |= MII_AR_10MB_HALFDUP;
+			} else {
+				advertise &= ~MII_AR_10MB_HALFDUP;
+			}
+		} else {
+			/* erase all advertisements if autoneg is disabled */
+			advertise &= ~(MII_AR_CRTL_PAUSE | MII_AR_CTRL_PAUSE_ASY |
+						MII_AR_100MB_FULLDUP | MII_AR_100MB_HALFDUP | 
+						MII_AR_10MB_FULLDUP | MII_AR_10MB_HALFDUP);
+		}
+
+		mii_queue(dev, mk_mii_write(MII_LXT971_AR, advertise), NULL);
+
+		/* prepare new controls */
+		control =	mii_read(dev, mk_mii_read(MII_LXT971_CR));
+
+		/* force power up */
+		control &= ~MII_CR_POWERDOWN;
+
+		/* set autoneg */
+		if (ecmd.autoneg == AUTONEG_ENABLE) {
+			/* force autoneg */
+			/* don't touch speed and duplex */
+			control |= (MII_CR_ENABLE_NEG | MII_CR_RENEGOTIATE);
+		} else {
+			control &= ~(MII_CR_ENABLE_NEG | MII_CR_RENEGOTIATE);
+
+			/* force speed */
+			switch (ecmd.speed) {
+			case SPEED_100 :
+				control |= MII_CR_SPEED_100M;
+				break;
+			case SPEED_10 :
+			default :
+				control &= ~MII_CR_SPEED_100M;
+				break;
+			}
+
+			/* force duplex */
+			switch (ecmd.duplex) {
+			case DUPLEX_FULL :
+				control |= MII_CR_FULLDUPLEX;
+				break;
+			case DUPLEX_HALF :
+			default :
+				control &= ~MII_CR_FULLDUPLEX;
+				break;
+			}
+		}
+
+		/* force no loopback */
+		control &= ~MII_CR_LBK_MODE;
+
+		mii_queue(dev, mk_mii_write(MII_LXT971_CR, control), NULL);
+		/* changes must generate a link interrupt with a call */
+		/* to mii_relink which restarts the fcc */
+		break;
+
+	case ETHTOOL_GLINK:		/* Get link status */
+		mii_queue(dev, mk_mii_read(MII_LXT971_SR), mii_parse_sr);
+		evalue.data = fep->link;
+		if (copy_to_user(arg, &evalue, sizeof(evalue))) {
+			return -EFAULT;
+		}
+		break;
+
+	case ETHTOOL_GDRVINFO:	/* Get driver info. */
+	case ETHTOOL_GREGS:		/* Get NIC registers, privileged. */
+	case ETHTOOL_GWOL:		/* Get wake-on-lan options. */
+	case ETHTOOL_SWOL:		/* Set wake-on-lan options, priv. */
+	case ETHTOOL_GMSGLVL:	/* Get driver message level */
+	case ETHTOOL_SMSGLVL:	/* Set driver msg level, priv. */
+	case ETHTOOL_NWAY_RST:	/* Restart autonegotiation, priv. */
+	case ETHTOOL_GEEPROM:	/* Get EEPROM data */
+	case ETHTOOL_SEEPROM:	/* Set EEPROM data */
+	default:
+		rc = -EOPNOTSUPP;
+		break;
+	}
+
+	return rc;
+}
+#endif	/* CONFIG_USE_MDIO */
diff -Nurp linux-2.6.9.orig/arch/ppc/8260_io/fcc_enet.c.v100 linux-2.6.9/arch/ppc/8260_io/fcc_enet.c.v100
--- linux-2.6.9.orig/arch/ppc/8260_io/fcc_enet.c.v100	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.9/arch/ppc/8260_io/fcc_enet.c.v100	2006-09-07 18:57:01.000000000 +0200
@@ -0,0 +1,2296 @@
+/*
+ * Fast Ethernet Controller (FCC) driver for Motorola MPC8260.
+ * Copyright (c) 2000 MontaVista Software, Inc.   Dan Malek (dmalek@jlc.net)
+ *
+ * This version of the driver is a combination of the 8xx fec and
+ * 8260 SCC Ethernet drivers.  This version has some additional
+ * configuration options, which should probably be moved out of
+ * here.  This driver currently works for the EST SBC8260,
+ * SBS Diablo/BCM, Embedded Planet RPX6, TQM8260, and others.
+ *
+ * Right now, I am very watseful with the buffers.  I allocate memory
+ * pages and then divide them into 2K frame buffers.  This way I know I
+ * have buffers large enough to hold one frame within one buffer descriptor.
+ * Once I get this working, I will use 64 or 128 byte CPM buffers, which
+ * will be much more memory efficient and will easily handle lots of
+ * small packets.  Since this is a cache coherent processor and CPM,
+ * I could also preallocate SKB's and use them directly on the interface.
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/ptrace.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/sockios.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/workqueue.h>
+
+#include <asm/immap_cpm2.h>
+#include <asm/pgtable.h>
+#include <asm/mpc8260.h>
+#include <asm/irq.h>
+#include <asm/bitops.h>
+#include <asm/uaccess.h>
+#include <asm/cpm2.h>
+#include <platforms/pq2pmca.h>
+
+/*--------------------------------------------------------------------------*/
+/*    DEFINITIONS AND STRUCTURES FOR MII PHY                                */
+/*--------------------------------------------------------------------------*/
+#ifdef CONFIG_USE_MDIO
+/* Register definitions for the PHY. */
+#define MII_LXT971_CR			0			/* Control Register				*/
+#define MII_LXT971_SR			1			/* Status Register				*/
+#define MII_LXT971_IR1			2			/* Identification Register 1	*/
+#define MII_LXT971_IR2			3			/* Identification Register 2	*/
+#define MII_LXT971_AR			4			/* A-N Advertisement Register	*/
+#define MII_LXT971_SR2			17			/* Status Register 2			*/
+#define MII_LXT971_IER			18			/* Interrupt Enable Register	*/
+#define MII_LXT971_ISR			19			/* Interrupt Status Register	*/
+
+/* MII_LXT971_CR definitions */
+#define MII_CR_RESET			0x8000		 /* Reset the MII chip			*/
+#define MII_CR_LBK_MODE			0x4000		 /* The MII PHY is in loopback	*/
+#define MII_CR_SPEED_100M		0x2000		 /* 100Mbps speed selected		*/
+#define MII_CR_ENABLE_NEG		0x1000		 /* Enable autonegociation		*/
+#define MII_CR_POWERDOWN		0x0800		 /* Power down mode				*/
+#define MII_CR_ISOEN			0x0400		 /* Enable isolate mode			*/
+#define MII_CR_RENEGOTIATE		0x0200		 /* Re-negotiate the link speed	*/
+#define MII_CR_FULLDUPLEX		0x0100		 /* Link in Full duplex mode	*/
+#define MII_CR_COLEN			0x0080		 /* Collision test control		*/
+
+/* MII_LXT971_SR definitions */
+#define MII_SR_100FULLDUPLEX	0x4000		/* Link is 100Mbps full duplex	*/
+#define MII_SR_100HALFDUPLEX	0x2000		/* Link is 100Mbps half duplex	*/
+#define MII_SR_10FULLDUPLEX		0x1000		/* Link is 10Mbps full duplex	*/
+#define MII_SR_10HALFDUPLEX		0x0800		/* Link is 10Mbps half duplex	*/
+#define MII_SR_AUTONEG_DONE		0x0020		/* Autonegotiation is complete	*/
+#define MII_SR_REMOTE_FAULT		0x0010		/* Remote fault detected		*/
+#define MII_SR_LINKUP			0x0004		/* The Link is up				*/
+
+/* MII_LXT971_IR1 definitions */
+#define MII_IR1_ID				0x0013		/* LXT971 ident part1			*/
+
+/* MII_LXT971_IR2 definitions */
+#define MII_IR2_ID				0x78E0		/* LXT971 ident part2 			*/
+
+/* MII_LXT971_AR definitions */
+#define MII_AR_REMOTEFAULT		0x2000		/* Remote fault 				*/
+#define MII_AR_CTRL_PAUSE_ASY	0x0800		/* Assymetric pause				*/
+#define MII_AR_CRTL_PAUSE		0x0400	 	/* Pause						*/
+#define MII_AR_100MB_FULLDUP	0x0100		/* 100Mbs full duplex capable	*/
+#define MII_AR_100MB_HALFDUP	0x0080		/* 100Mbs half duplex capable	*/
+#define MII_AR_10MB_FULLDUP		0x0040		/* 10Mbs full duplex capable	*/
+#define MII_AR_10MB_HALFDUP		0x0020		/* 10Mbs half duplex capable	*/
+#define MII_AR_SELECTOR			0x0001		/* 802.3 protocol               */
+
+/* MII_LXT971_SR2 definitions */
+#define MII_SR2_100_TX			0x4000		/* 100Mbs TX mode				*/
+#define MII_SR2_LINK_UP			0x0400		/* Link is up					*/
+#define MII_SR2_FULL_DUP		0x0200		/* Full duplex mode				*/
+#define MII_SR2_AUTO_EN			0x0100		/* A-N enabled					*/
+#define MII_SR2_AUTO_COMPL		0x0080		/* A-N complete					*/
+#define MII_SR2_ERROR			0x0008		/* Error        				*/
+
+/* MII_LXT971_IER definitions */
+#define MII_IER_TINT			0x0001		/* Force it on #MDINT pin		*/
+#define MII_IER_INTEN			0x0002		/* Enable/Disable it			*/
+#define MII_IER_LNK_MSK			0x0010		/* Mask for link status it		*/
+#define MII_IER_DUP_MSK			0x0020		/* Mask for duplex status it	*/
+#define MII_IER_SPD_MSK			0x0040		/* Mask for speed status it		*/
+#define MII_IER_ANC_MSK			0x0080		/* Mask for A-N Complete		*/
+
+/* MII_LXT971_ISR definitions */
+#define MII_ISR_MDINT			0x0040		/* MII it pending				*/
+#define MII_ISR_LNK_CHG			0x0010		/* Link Status change			*/
+#define MII_ISR_DUP_CHG			0x0020		/* Duplex Status change			*/
+#define MII_ISR_SPD_CHG			0x0040		/* Speed Status change			*/
+#define MII_ISR_ANC_CHG			0x0080		/* A-N Status change			*/
+
+/* Values for phy_status, not register bit definitions */
+#define PHY_CONF_ANE			0x0001		/* 1 auto-negotiation enabled	*/
+#define PHY_CONF_LOOP			0x0002		/* 1 loopback mode enabled		*/
+#define PHY_CONF_SPMASK			0x00f0		/* mask for speed				*/
+#define PHY_CONF_10HDX			0x0010		/* 10Mbs half duplex supported 	*/
+#define PHY_CONF_10FDX			0x0020		/* 10Mbs full duplex supported 	*/
+#define PHY_CONF_100HDX			0x0040		/* 100Mbs half duplex supported */
+#define PHY_CONF_100FDX			0x0080		/* 100Mbs full duplex supported */
+
+#define PHY_STAT_LINK			0x0100		/* 1 up - 0 down 				*/
+#define PHY_STAT_FAULT			0x0200		/* 1 remote fault 				*/
+#define PHY_STAT_ANC			0x0400		/* 1 auto-negotiation complete	*/
+#define PHY_STAT_SPMASK			0xf000		/* mask for speed 				*/
+#define PHY_STAT_10HDX			0x1000		/* 10Mbs half duplex selected	*/
+#define PHY_STAT_10FDX			0x2000		/* 10Mbs full duplex selected	*/
+#define PHY_STAT_100HDX			0x4000		/* 100Mbs half duplex selected 	*/
+#define PHY_STAT_100FDX			0x8000		/* 100Mbs full duplex selected 	*/
+
+/* Make MII read/write commands for the FCC. */
+#define mk_mii_read(REG)		(0x60020000 | ((REG & 0x1f) << 18))
+#define mk_mii_write(REG, VAL)	(0x50020000 | ((REG & 0x1f) << 18) | \
+								(VAL & 0xffff))
+#define mk_mii_end				0
+
+#define FCC_PDATD_MDIO(bit)				\
+	if (bit)							\
+		io->iop_pdatd |= fip->fc_mdio;	\
+	else								\
+		io->iop_pdatd &= ~fip->fc_mdio;
+
+#define FCC_PDATD_MDC(bit)				\
+	if (bit)							\
+		io->iop_pdatd |= fip->fc_mdck;	\
+	else								\
+		io->iop_pdatd &= ~fip->fc_mdck;
+
+typedef struct {
+	uint mii_data;
+	void (*funct)(uint mii_reg, struct net_device *dev);
+} phy_cmd_t;
+
+typedef struct {
+	uint id;
+	char *name;
+	const phy_cmd_t *config;
+	const phy_cmd_t *startup;
+	const phy_cmd_t *ack_int;
+	const phy_cmd_t *shutdown;
+} phy_info_t;
+
+#endif	/* CONFIG_USE_MDIO */
+
+#ifdef CONFIG_USE_MDIO
+#define PC_MDIO		((uint)(1 << (31 - 11)))	/* PD11 */
+#define PC_MDCK		((uint)(1 << (31 - 10)))	/* PD10 */
+#if !defined(PC_MDIO) || !defined(PC_MDCK)
+#error Must define PC_MDIO and PC_MDCK if using MDIO
+#endif
+#else	/* ifdef CONFIG_USE_MDIO */
+#undef	PC_MDIO
+#undef	PC_MDCK
+#define PC_MDIO		((uint)0x00000000)
+#define PC_MDCK		((uint)0x00000000)
+#endif	/* ifdef CONFIG_USE_MDIO */
+
+/*--------------------------------------------------------------------------*/
+/*    DEFINITIONS AND STRUCTURES FOR FCC                                    */
+/*--------------------------------------------------------------------------*/
+#define TX_TIMEOUT  (2*HZ) /* The transmitter timeout */
+
+/* The number of Tx and Rx buffers.  These are allocated from the page
+ * pool.  The code may assume these are power of two, so it is best
+ * to keep them that size.
+ * We don't need to allocate pages for the transmitter.  We just use
+ * the skbuffer directly.
+ */
+#define FCC_ENET_RX_PAGES	16
+#define FCC_ENET_RX_FRSIZE	2048
+#define FCC_ENET_RX_FRPPG	(PAGE_SIZE / FCC_ENET_RX_FRSIZE)
+#define RX_RING_SIZE		(FCC_ENET_RX_FRPPG * FCC_ENET_RX_PAGES)
+#define TX_RING_SIZE		16	/* Must be power of two */
+#define TX_RING_MOD_MASK	15	/*   for this to work */
+
+/* The FCC stores dest/src/type, data, and checksum for receive packets.
+ */
+#define PKT_MAXBUF_SIZE		1518
+#define PKT_MINBUF_SIZE		64
+
+/* Maximum input DMA size.  Must be a should(?) be a multiple of 4.
+*/
+#define PKT_MAXDMA_SIZE		1520
+
+/* Maximum input buffer size.  Must be a multiple of 32.
+*/
+#define PKT_MAXBLR_SIZE		1536
+
+/*******************************/
+/* I/O Pin assignment for FCC1 */
+/*******************************/
+#define PA1_COL			((uint)0x00000001)
+#define PA1_CRS			((uint)0x00000002)
+#define PA1_TXER		((uint)0x00000004)
+#define PA1_TXEN		((uint)0x00000008)
+#define PA1_RXDV		((uint)0x00000010)
+#define PA1_RXER		((uint)0x00000020)
+#define PA1_TXDAT		((uint)0x00003c00)
+#define PA1_RXDAT		((uint)0x0003c000)
+#define PA1_PSORA0		(PA1_RXDAT | PA1_TXDAT)
+#define PA1_PSORA1		(PA1_COL | PA1_CRS | PA1_TXER | PA1_TXEN | \
+						PA1_RXDV | PA1_RXER)
+#define PA1_DIRA0		(PA1_RXDAT | PA1_CRS | PA1_COL | PA1_RXER | PA1_RXDV)
+#define PA1_DIRA1		(PA1_TXDAT | PA1_TXEN | PA1_TXER)
+
+/* CLK10 is receive, CLK9 is transmit.	These are board specific. */
+#define PC_F1RXCLK		((uint)0x00000200)
+#define PC_F1TXCLK		((uint)0x00000100)
+#define CMX1_CLK_ROUTE	((uint)0x2C000000)
+#define CMX1_CLK_MASK	 ((uint)0xff000000)
+
+/*******************************/
+/* I/O Pin assignment for FCC2 */
+/*******************************/
+#define PB2_TXER		((uint)0x00000001)
+#define PB2_RXDV		((uint)0x00000002)
+#define PB2_TXEN		((uint)0x00000004)
+#define PB2_RXER		((uint)0x00000008)
+#define PB2_COL			((uint)0x00000010)
+#define PB2_CRS			((uint)0x00000020)
+#define PB2_TXDAT		((uint)0x000003c0)
+#define PB2_RXDAT		((uint)0x00003c00)
+#define PB2_PSORB0		(PB2_RXDAT | PB2_TXDAT | PB2_CRS | PB2_COL | \
+						PB2_RXER | PB2_RXDV | PB2_TXER)
+#define PB2_PSORB1		(PB2_TXEN)
+#define PB2_DIRB0		(PB2_RXDAT | PB2_CRS | PB2_COL | PB2_RXER | PB2_RXDV)
+#define PB2_DIRB1		(PB2_TXDAT | PB2_TXEN | PB2_TXER)
+
+/* CLK14 is receive, CLK13 is transmit.	These are board dependent. */
+#define PC_F2RXCLK		((uint)0x00002000)
+#define PC_F2TXCLK		((uint)0x00001000)
+#define CMX2_CLK_ROUTE	((uint)0x002C0000)
+#define CMX2_CLK_MASK	((uint)0x00ff0000)
+
+/*******************************/
+/* I/O Pin assignment for FCC3 */
+/*******************************/
+#define PB3_RXDV		((uint)0x00004000)
+#define PB3_RXER		((uint)0x00008000)
+#define PB3_TXER		((uint)0x00010000)
+#define PB3_TXEN		((uint)0x00020000)
+#define PB3_COL			((uint)0x00040000)
+#define PB3_CRS			((uint)0x00080000)
+#define PB3_TXDAT		((uint)0x0f000000)
+#define PB3_RXDAT		((uint)0x00f00000)
+#define PB3_PSORB0		(PB3_RXDAT | PB3_TXDAT | PB3_CRS | PB3_COL | \
+						PB3_RXER | PB3_RXDV | PB3_TXER | PB3_TXEN)
+#define PB3_PSORB1		(0)
+#define PB3_DIRB0		(PB3_RXDAT | PB3_CRS | PB3_COL | PB3_RXER | PB3_RXDV)
+#define PB3_DIRB1		(PB3_TXDAT | PB3_TXEN | PB3_TXER)
+
+/* CLK16 is receive, CLK15 is transmit.	These are board dependent. */
+#define PC_F3RXCLK		((uint)0x00008000)
+#define PC_F3TXCLK		((uint)0x00004000)
+#define CMX3_CLK_ROUTE	((uint)0x00003E00)
+#define CMX3_CLK_MASK	((uint)0x0000ff00)
+
+/* A table of information for supporting FCCs.  This does two things.
+ * First, we know how many FCCs we have and they are always externally
+ * numbered from zero.  Second, it holds control register and I/O
+ * information that could be different among board designs.
+ */
+typedef struct fcc_info {
+	uint	fc_fccnum;
+	uint	fc_cpmblock;
+	uint	fc_cpmpage;
+	uint	fc_proff;
+	uint	fc_interrupt;
+	uint	fc_trxclocks;
+	uint	fc_clockroute;
+	uint	fc_clockmask;
+	uint	fc_mdio;
+	uint	fc_mdck;
+	uint	fc_phy_interrupt;
+} fcc_info_t;
+
+/* The FCC buffer descriptors track the ring buffers.  The rx_bd_base and
+ * tx_bd_base always point to the base of the buffer descriptors.  The
+ * cur_rx and cur_tx point to the currently available buffer.
+ * The dirty_tx tracks the current buffer that is being sent by the
+ * controller.  The cur_tx and dirty_tx are equal under both completely
+ * empty and completely full conditions.  The empty/ready indicator in
+ * the buffer descriptor determines the actual condition.
+ */
+struct fcc_enet_private {
+	/* The saved address of a sent-in-place packet/buffer, for skfree(). */
+	struct	sk_buff* tx_skbuff[TX_RING_SIZE];
+	ushort	skb_cur;
+	ushort	skb_dirty;
+
+	/* CPM dual port RAM relative addresses.
+	*/
+	cbd_t	*rx_bd_base;		/* Address of Rx and Tx buffers. */
+	cbd_t	*tx_bd_base;
+	cbd_t	*cur_rx, *cur_tx;		/* The next free ring entry */
+	cbd_t	*dirty_tx;	/* The ring entries to be free()ed. */
+	volatile fcc_t	*fccp;
+	volatile fcc_enet_t	*ep;
+	struct	net_device_stats stats;
+	uint	tx_free;
+	spinlock_t lock;
+
+#ifdef	CONFIG_USE_MDIO
+	uint	phy_id;
+	uint	phy_id_done;
+	uint	phy_status;
+	phy_info_t	*phy;
+	struct work_struct phy_relink;
+	struct work_struct phy_display_config;
+	uint	sequence_done;
+	uint	phy_addr;
+#endif	/* CONFIG_USE_MDIO */
+
+	int	link;
+	int	old_link;
+	int	full_duplex;
+
+	fcc_info_t	*fip;
+};
+
+/*--------------------------------------------------------------------------*/
+/*						PROTOTYPES FOR MII PHY								*/
+/*--------------------------------------------------------------------------*/
+#ifdef  CONFIG_USE_MDIO
+static	int		mii_queue
+				(struct net_device *dev, int request, 
+				 void (*func)(uint, struct net_device *));
+static	void	mii_do_cmd			
+				(struct net_device *dev, const phy_cmd_t *c);
+static	void	mii_parse_sr		(uint mii_reg, struct net_device *dev);
+static	void	mii_parse_cr		(uint mii_reg, struct net_device *dev);
+static	void	mii_parse_ar		(uint mii_reg, struct net_device *dev);
+static	void	mii_parse_sr2		(uint mii_reg, struct net_device *dev);
+static	void	mii_display_status	(struct net_device *dev);
+static	void	mii_display_config	(struct net_device *dev);
+static	void	mii_relink			(struct net_device *dev);
+static	void	mii_queue_relink	(uint mii_reg, struct net_device *dev);
+static	void	mii_queue_config	(uint mii_reg, struct net_device *dev);
+static	void	mii_discover_phy3	(uint mii_reg, struct net_device *dev);
+static	void	mii_discover_phy	(uint mii_reg, struct net_device *dev);
+static	irqreturn_t mii_link_interrupt
+				(int irq, void * dev_id, struct pt_regs * regs);
+static	uint	mii_send_receive(fcc_info_t *fip, uint cmd);
+
+static	int		fcc_enet_ioctl		
+				(struct net_device *dev, struct ifreq *rq, int cmd);
+static	int		fcc_ethtool_ioctl	(struct net_device *dev, void *useraddr);
+#endif	/* CONFIG_USE_MDIO */
+
+/*--------------------------------------------------------------------------*/
+/*						PROTOTYPES FOR FCC									*/
+/*--------------------------------------------------------------------------*/
+static	int		fcc_enet_start_xmit		
+				(struct sk_buff *skb, struct net_device *dev);
+static	void	fcc_enet_timeout	(struct net_device *dev);
+static	irqreturn_t fcc_enet_interrupt
+				(int irq, void *dev_id, struct pt_regs *);
+static	int		fcc_enet_rx			(struct net_device *dev);
+static	int		fcc_enet_close		(struct net_device *dev);
+static	struct net_device_stats 
+				*fcc_enet_get_stats	(struct net_device *dev);
+static	void	set_multicast_list			(struct net_device *dev);
+static	int		fcc_enet_set_mac_address	
+				(struct net_device *dev, void *addr);
+static	int		fec_enet_init				(void);
+static	void	init_fcc_shutdown	
+				(fcc_info_t *fip, struct fcc_enet_private *cep,
+				volatile cpm2_map_t *immap);
+static	void	init_fcc_ioports
+				(fcc_info_t *fip, volatile iop_cpm2_t *io,
+				volatile cpm2_map_t *immap);
+static	void	init_fcc_param				
+				(fcc_info_t *fip, struct net_device *dev, 
+				volatile cpm2_map_t *immap);
+static	void	init_fcc_startup
+				(fcc_info_t *fip, struct net_device *dev);
+
+static	void	fcc_stop			(struct net_device *dev);
+static	void	fcc_restart			(struct net_device *dev, int duplex);
+static	int		fcc_enet_open		(struct net_device *dev);
+
+/*--------------------------------------------------------------------------*/
+/*                      GLOBAL VARIABLES FOR MII PHY                        */
+/*--------------------------------------------------------------------------*/
+#ifdef CONFIG_USE_MDIO
+static phy_info_t phy_info_lxt971 = {
+	0x0001378e,
+	"LXT971",
+
+	(const phy_cmd_t []) {	/* config */
+		/* 10 Mbps half duplex, 802.3 */
+		/* GG NO keep boot init */
+		/* { mk_mii_write(MII_LXT971_AR, 0x021), NULL }, */
+		{ mk_mii_read(MII_LXT971_CR), mii_parse_cr },
+		{ mk_mii_read(MII_LXT971_AR), mii_parse_ar },
+		/* read status to display right status */
+		{ mk_mii_read(MII_LXT971_SR), mii_parse_sr },
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) {	/* startup */
+		/* enable only phy link interrupt */
+		{ mk_mii_write(MII_LXT971_IER, (MII_IER_INTEN | MII_IER_LNK_MSK)), NULL },
+		/* enable autoneg , restart autoneg */
+		/* GG NO keep boot init */
+		/* { mk_mii_write(MII_LXT971_CR, 0x1200), NULL }, */
+
+		/* Somehow does the 971 tell me that the link is down
+		 * the first read after power-up.
+		 * read here to get a valid value in ack_int */
+		{ mk_mii_read(MII_LXT971_SR), mii_parse_sr },
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) { /* ack_int */
+		/* find out the current status */
+		{ mk_mii_read(MII_LXT971_SR), mii_parse_sr },
+		{ mk_mii_read(MII_LXT971_SR2), mii_parse_sr2 },
+
+		/* we only need to read ISR to acknowledge */
+		{ mk_mii_read(MII_LXT971_ISR), NULL },
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) {	/* shutdown */
+		/* disable all interrupts */
+		/* link, duplex, speed and autoneg complete */
+		{ mk_mii_write(MII_LXT971_IER, 0x0000), NULL },
+		{ mk_mii_end, }
+	},
+};
+
+static phy_info_t *phy_info[] = {
+	&phy_info_lxt971,
+	NULL
+};
+
+phy_cmd_t phy_cmd_relink[] = { { mk_mii_read(MII_LXT971_CR), mii_queue_relink },
+						 { mk_mii_end, } };
+phy_cmd_t phy_cmd_config[] = { { mk_mii_read(MII_LXT971_CR), mii_queue_config },
+						 { mk_mii_end, } };
+#endif 
+
+static fcc_info_t fcc_ports[] = {
+#ifdef CONFIG_FCC1_ENET
+	{ 0, CPM_CR_FCC1_SBLOCK, CPM_CR_FCC1_PAGE, PROFF_FCC1, SIU_INT_FCC1,
+		(PC_F1RXCLK | PC_F1TXCLK), CMX1_CLK_ROUTE, CMX1_CLK_MASK,
+		PC_MDIO, PC_MDCK, SIU_INT_IRQ2 },
+#endif
+#ifdef CONFIG_FCC2_ENET
+	{ 1, CPM_CR_FCC2_SBLOCK, CPM_CR_FCC2_PAGE, PROFF_FCC2, SIU_INT_FCC2,
+		(PC_F2RXCLK | PC_F2TXCLK), CMX2_CLK_ROUTE, CMX2_CLK_MASK,
+		PC_MDIO, PC_MDCK, SIU_INT_IRQ3 },
+#endif
+#ifdef CONFIG_FCC3_ENET
+	{ 2, CPM_CR_FCC3_SBLOCK, CPM_CR_FCC3_PAGE, PROFF_FCC3, SIU_INT_FCC3,
+		(PC_F3RXCLK | PC_F3TXCLK), CMX3_CLK_ROUTE, CMX3_CLK_MASK,
+		PC_MDIO, PC_MDCK, SIU_INT_IRQ4 },
+#endif
+};
+
+/*--------------------------------------------------------------------------*/
+/*                          FUNCTIONS                                       */
+/*--------------------------------------------------------------------------*/
+
+static int
+fcc_enet_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct fcc_enet_private *cep = (struct fcc_enet_private *)dev->priv;
+	volatile cbd_t	*bdp;
+
+	/* GG what to do if link is down ?	*/
+	/* nothing or						*/
+	/* just return 1					*/
+	/* or netif_stop_queue and return 1	*/
+	/* nothing per default				*/
+
+	/* Fill in a Tx ring entry */
+	bdp = cep->cur_tx;
+
+#ifndef final_version
+	if (!cep->tx_free || (bdp->cbd_sc & BD_ENET_TX_READY)) {
+		/* Ooops.  All transmit buffers are full.  Bail out.
+		 * This should not happen, since the tx queue should be stopped.
+		 */
+		printk("%s: tx queue full!.\n", dev->name);
+		return 1;
+	}
+#endif
+
+	/* Clear all of the status flags. */
+	bdp->cbd_sc &= ~BD_ENET_TX_STATS;
+
+	/* If the frame is short, tell CPM to pad it. */
+	if (skb->len <= ETH_ZLEN)
+		bdp->cbd_sc |= BD_ENET_TX_PAD;
+	else
+		bdp->cbd_sc &= ~BD_ENET_TX_PAD;
+
+	/* Set buffer length and buffer pointer. */
+	bdp->cbd_datlen = skb->len;
+	bdp->cbd_bufaddr = __pa(skb->data);
+
+	spin_lock_irq(&cep->lock);
+
+	/* Save skb pointer. */
+	cep->tx_skbuff[cep->skb_cur] = skb;
+
+	cep->stats.tx_bytes += skb->len;
+	cep->skb_cur = (cep->skb_cur+1) & TX_RING_MOD_MASK;
+
+	/* Send it on its way.  Tell CPM its ready, interrupt when done,
+	 * its the last BD of the frame, and to put the CRC on the end.
+	 */
+	bdp->cbd_sc |= (BD_ENET_TX_READY | BD_ENET_TX_INTR | BD_ENET_TX_LAST | BD_ENET_TX_TC);
+
+#if 0
+	/* Errata says don't do this. */
+	cep->fccp->fcc_ftodr = 0x8000;
+#endif
+	dev->trans_start = jiffies;
+
+	/* If this was the last BD in the ring, start at the beginning again. */
+	if (bdp->cbd_sc & BD_ENET_TX_WRAP)
+		bdp = cep->tx_bd_base;
+	else
+		bdp++;
+
+	if (!--cep->tx_free)
+		netif_stop_queue(dev);
+
+	cep->cur_tx = (cbd_t *)bdp;
+
+	spin_unlock_irq(&cep->lock);
+
+	return 0;
+}
+
+static void
+fcc_enet_timeout(struct net_device *dev)
+{
+	volatile cbd_t			*bdp;
+	struct fcc_enet_private *cep;
+	volatile	fcc_enet_t	*ep;
+	volatile cpm_cpm2_t *cp;
+
+	int 					i;
+	int						must_restart = 0;
+
+	cep = (struct fcc_enet_private *)(dev->priv);
+	ep = cep->ep;
+	cp = cpmp;
+
+#if 0
+	printk("cur_tx=%p tx_free=%d tbptr=%08x dirty_tx=%p cur_rx=%p rbptr=%08x\n",
+		cep->cur_tx, cep->tx_free,
+		ep->fen_genfcc.fcc_tbptr, cep->dirty_tx,
+		cep->cur_rx, ep->fen_genfcc.fcc_rbptr);
+
+	/* display tx bd */
+	bdp = cep->tx_bd_base;
+	printk("TX bdp      sc   len  buff\n");
+	for (i = 0 ; i < TX_RING_SIZE; i++, bdp++) {
+		printk("   %p %04x %04x %08x\n",
+				bdp, bdp->cbd_sc, bdp->cbd_datlen, bdp->cbd_bufaddr);
+		printk("|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|\n",
+				((bdp->cbd_sc & BD_ENET_TX_READY)  ? "RDY " : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_PAD)    ? "PAD " : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_WRAP)   ? "WRAP" : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_INTR)   ? "INTR" : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_LAST)   ? "LAST" : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_TC)     ? "TC  " : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_DEF)    ? "DEF " : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_HB)     ? "HB  " : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_LC)     ? "LC  " : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_RL)     ? "RL  " : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_RCMASK) ? "RCMK" : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_UN)     ? "UN  " : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_CSL)    ? "CSL " : "    "));
+	}
+
+	bdp = cep->rx_bd_base;
+	printk("RX bdp      sc   len  buff\n");
+	for (i = 0 ; i < RX_RING_SIZE; i++, bdp++) {
+		printk("   %p %04x %04x %08x\n",
+				bdp, bdp->cbd_sc, bdp->cbd_datlen, bdp->cbd_bufaddr);
+	}
+#endif /* GG */
+
+	/* GG start of workaround for the CPM112 bug */
+	spin_lock_irq(&cep->lock);
+
+	/* stop TX */
+	cp->cp_cpcr = mk_cr_cmd(cep->fip->fc_cpmpage, cep->fip->fc_cpmblock,
+							0x0c, CPM_CR_STOP_TX) | CPM_CR_FLG;
+	while (cp->cp_cpcr & CPM_CR_FLG);
+
+	/* disable TX */
+	cep->fccp->fcc_gfmr &= ~FCC_GFMR_ENT;
+
+	/* clear all bds */
+	bdp = cep->tx_bd_base;
+	for (i = 0 ; i < TX_RING_SIZE; i++, bdp++) {
+		if (bdp->cbd_sc & BD_ENET_TX_READY) {
+			cep->stats.tx_packets++;
+			bdp->cbd_sc &= ~BD_ENET_TX_READY;
+		}
+
+		if (bdp->cbd_sc & BD_ENET_TX_HB) {	/* warning : no heartbeat */
+			cep->stats.tx_heartbeat_errors++;
+			bdp->cbd_sc &= ~BD_ENET_TX_HB;
+		}
+		if (bdp->cbd_sc & BD_ENET_TX_LC) {	/* error : late collision */
+			must_restart = 1;
+			cep->stats.tx_errors++;
+			cep->stats.tx_window_errors++;
+			bdp->cbd_sc &= ~BD_ENET_TX_LC;
+		}
+		if (bdp->cbd_sc & BD_ENET_TX_RL) {	/* error : retrans limit */
+			must_restart = 1;
+			cep->stats.tx_errors++;
+			cep->stats.tx_aborted_errors++;
+			bdp->cbd_sc &= ~BD_ENET_TX_RL;
+		}
+		if (bdp->cbd_sc & BD_ENET_TX_UN) {	/* error : underrun */
+			must_restart = 1;
+			cep->stats.tx_errors++;
+			cep->stats.tx_fifo_errors++;
+			bdp->cbd_sc &= ~BD_ENET_TX_UN;
+		}
+		if (bdp->cbd_sc & BD_ENET_TX_CSL) {	/* warning : carrier lost */
+			cep->stats.tx_carrier_errors++;
+			bdp->cbd_sc &= ~BD_ENET_TX_CSL;
+		}
+		if (bdp->cbd_sc & BD_ENET_TX_DEF) { /* warning : deferred */
+			cep->stats.collisions++;
+			bdp->cbd_sc &= ~BD_ENET_TX_DEF;
+		}
+
+		/* free the sk buffer associated with this last transmit. */
+		if (cep->tx_skbuff[cep->skb_dirty] != NULL) {
+			dev_kfree_skb_irq(cep->tx_skbuff[cep->skb_dirty]);
+			cep->tx_skbuff[cep->skb_dirty] = NULL;
+			cep->skb_dirty = (cep->skb_dirty + 1) & TX_RING_MOD_MASK;
+		}
+	}
+
+	/* reinit all params */
+	dev->trans_start = jiffies;
+	cep->dirty_tx = cep->cur_tx = cep->tx_bd_base;
+	ep->fen_genfcc.fcc_tbptr = __pa(cep->tx_bd_base);
+	
+	/* enable TX */
+	cep->fccp->fcc_gfmr |= FCC_GFMR_ENT;
+	
+	/* restart TX */
+	cp->cp_cpcr = mk_cr_cmd(cep->fip->fc_cpmpage, cep->fip->fc_cpmblock,
+							0x0c, CPM_CR_RESTART_TX) | CPM_CR_FLG;
+	while (cp->cp_cpcr & CPM_CR_FLG);
+
+	/* release interrupt */
+	spin_unlock(&cep->lock);
+
+	/* GG end of workaround for the CPM112 bug */
+
+	/* all bds are fee */
+	cep->tx_free = TX_RING_SIZE;
+	netif_wake_queue(dev);
+}
+
+/* The interrupt handler. */
+static irqreturn_t
+fcc_enet_interrupt(int irq, void * dev_id, struct pt_regs * regs)
+{
+	struct	net_device *dev = dev_id;
+	volatile struct	fcc_enet_private *cep;
+	volatile cbd_t	*bdp;
+	ushort	int_events;
+	int	must_restart;
+
+	cep = (struct fcc_enet_private *)dev->priv;
+
+	/* Get the interrupt events that caused us to be here.
+	*/
+	int_events = cep->fccp->fcc_fcce;
+	cep->fccp->fcc_fcce = (int_events & cep->fccp->fcc_fccm);
+	must_restart = 0;
+
+#ifdef CONFIG_USE_MDIO
+	/* We have to be careful here to make sure that we aren't
+	 * interrupted by a PHY interrupt.
+	 */
+	disable_irq_nosync(cep->fip->fc_phy_interrupt);
+#endif
+
+	/* Handle receive event in its own function.
+	*/
+	if (int_events & FCC_ENET_RXF)
+		fcc_enet_rx(dev_id);
+
+	/* Check for a transmit error.  The manual is a little unclear
+	 * about this, so the debug code until I get it figured out.  It
+	 * appears that if TXE is set, then TXB is not set.  However,
+	 * if carrier sense is lost during frame transmission, the TXE
+	 * bit is set, "and continues the buffer transmission normally."
+	 * I don't know if "normally" implies TXB is set when the buffer
+	 * descriptor is closed.....trial and error :-).
+	 */
+
+	/* Transmit OK, or non-fatal error.  Update the buffer descriptors.
+	*/
+	if (int_events & (FCC_ENET_TXE | FCC_ENET_TXB)) {
+	    spin_lock(&cep->lock);
+	    bdp = cep->dirty_tx;
+	    while ((bdp->cbd_sc&BD_ENET_TX_READY)==0) {
+		if (cep->tx_free == TX_RING_SIZE)
+		    break;
+
+		if (bdp->cbd_sc & BD_ENET_TX_HB)	/* No heartbeat */
+			cep->stats.tx_heartbeat_errors++;
+		if (bdp->cbd_sc & BD_ENET_TX_LC)	/* Late collision */
+			cep->stats.tx_window_errors++;
+		if (bdp->cbd_sc & BD_ENET_TX_RL)	/* Retrans limit */
+			cep->stats.tx_aborted_errors++;
+		if (bdp->cbd_sc & BD_ENET_TX_UN)	/* Underrun */
+			cep->stats.tx_fifo_errors++;
+		if (bdp->cbd_sc & BD_ENET_TX_CSL)	/* Carrier lost */
+			cep->stats.tx_carrier_errors++;
+
+
+		/* No heartbeat or Lost carrier are not really bad errors.
+		 * The others require a restart transmit command.
+		 */
+		if (bdp->cbd_sc &
+		    (BD_ENET_TX_LC | BD_ENET_TX_RL | BD_ENET_TX_UN)) {
+			must_restart = 1;
+			cep->stats.tx_errors++;
+		}
+
+		cep->stats.tx_packets++;
+
+		/* Deferred means some collisions occurred during transmit,
+		 * but we eventually sent the packet OK.
+		 */
+		if (bdp->cbd_sc & BD_ENET_TX_DEF)
+			cep->stats.collisions++;
+
+		/* Free the sk buffer associated with this last transmit. */
+		dev_kfree_skb_irq(cep->tx_skbuff[cep->skb_dirty]);
+		cep->tx_skbuff[cep->skb_dirty] = NULL;
+		cep->skb_dirty = (cep->skb_dirty + 1) & TX_RING_MOD_MASK;
+
+		/* Update pointer to next buffer descriptor to be transmitted. */
+		if (bdp->cbd_sc & BD_ENET_TX_WRAP)
+			bdp = cep->tx_bd_base;
+		else
+			bdp++;
+
+		/* I don't know if we can be held off from processing these
+		 * interrupts for more than one frame time.  I really hope
+		 * not.  In such a case, we would now want to check the
+		 * currently available BD (cur_tx) and determine if any
+		 * buffers between the dirty_tx and cur_tx have also been
+		 * sent.  We would want to process anything in between that
+		 * does not have BD_ENET_TX_READY set.
+		 */
+
+		/* Since we have freed up a buffer, the ring is no longer
+		 * full.
+		 */
+		if (!cep->tx_free++) {
+			if (netif_queue_stopped(dev)) {
+				netif_wake_queue(dev);
+			}
+		}
+
+		cep->dirty_tx = (cbd_t *)bdp;
+	    }
+
+	    if (must_restart) {
+		volatile cpm_cpm2_t *cp;
+
+		/* Some transmit errors cause the transmitter to shut
+		 * down.  We now issue a restart transmit.  Since the
+		 * errors close the BD and update the pointers, the restart
+		 * _should_ pick up without having to reset any of our
+		 * pointers either.  Also, To workaround 8260 device erratum
+		 * CPM37, we must disable and then re-enable the transmitter
+		 * following a Late Collision, Underrun, or Retry Limit error.
+		 */
+		cep->fccp->fcc_gfmr &= ~FCC_GFMR_ENT;
+		udelay(10); /* wait a few microseconds just on principle */
+		cep->fccp->fcc_gfmr |=  FCC_GFMR_ENT;
+
+		cp = cpmp;
+		cp->cp_cpcr =
+		    mk_cr_cmd(cep->fip->fc_cpmpage, cep->fip->fc_cpmblock,
+		    		0x0c, CPM_CR_RESTART_TX) | CPM_CR_FLG;
+		while (cp->cp_cpcr & CPM_CR_FLG);
+	    }
+	    spin_unlock(&cep->lock);
+	}
+
+	/* Check for receive busy, i.e. packets coming but no place to
+	 * put them.
+	 */
+	if (int_events & FCC_ENET_BSY) {
+		cep->fccp->fcc_fcce = FCC_ENET_BSY;
+		cep->stats.rx_dropped++;
+	}
+
+#ifdef CONFIG_USE_MDIO
+	enable_irq(cep->fip->fc_phy_interrupt);
+#endif
+	return IRQ_HANDLED;
+}
+
+/* During a receive, the cur_rx points to the current incoming buffer.
+ * When we update through the ring, if the next incoming buffer has
+ * not been given to the system, we just set the empty indicator,
+ * effectively tossing the packet.
+ */
+static int
+fcc_enet_rx(struct net_device *dev)
+{
+	struct	fcc_enet_private *cep;
+	volatile cbd_t	*bdp;
+	struct	sk_buff *skb;
+	ushort	pkt_len;
+
+	cep = (struct fcc_enet_private *)dev->priv;
+
+	/* First, grab all of the stats for the incoming packet.
+	 * These get messed up if we get called due to a busy condition.
+	 */
+	bdp = cep->cur_rx;
+
+for (;;) {
+	if (bdp->cbd_sc & BD_ENET_RX_EMPTY)
+		break;
+
+#ifndef final_version
+	/* Since we have allocated space to hold a complete frame, both
+	 * the first and last indicators should be set.
+	 */
+	if ((bdp->cbd_sc & (BD_ENET_RX_FIRST | BD_ENET_RX_LAST)) !=
+		(BD_ENET_RX_FIRST | BD_ENET_RX_LAST))
+			printk("CPM ENET: rcv is not first+last\n");
+#endif
+
+	/* Frame too long or too short. */
+	if (bdp->cbd_sc & (BD_ENET_RX_LG | BD_ENET_RX_SH))
+		cep->stats.rx_length_errors++;
+	if (bdp->cbd_sc & BD_ENET_RX_NO)	/* Frame alignment */
+		cep->stats.rx_frame_errors++;
+	if (bdp->cbd_sc & BD_ENET_RX_CR)	/* CRC Error */
+		cep->stats.rx_crc_errors++;
+	if (bdp->cbd_sc & BD_ENET_RX_OV)	/* FIFO overrun */
+		cep->stats.rx_crc_errors++;
+	if (bdp->cbd_sc & BD_ENET_RX_CL)	/* Late Collision */
+		cep->stats.rx_frame_errors++;
+
+	if (!(bdp->cbd_sc &
+	      (BD_ENET_RX_LG | BD_ENET_RX_SH | BD_ENET_RX_NO | BD_ENET_RX_CR
+	       | BD_ENET_RX_OV | BD_ENET_RX_CL)))
+	{
+		/* Process the incoming frame. */
+		cep->stats.rx_packets++;
+
+		/* Remove the FCS from the packet length. */
+		pkt_len = bdp->cbd_datlen - 4;
+		cep->stats.rx_bytes += pkt_len;
+
+		/* This does 16 byte alignment, much more than we need. */
+		skb = dev_alloc_skb(pkt_len);
+
+		if (skb == NULL) {
+			printk("%s: Memory squeeze, dropping packet.\n", dev->name);
+			cep->stats.rx_dropped++;
+		}
+		else {
+			skb->dev = dev;
+			skb_put(skb,pkt_len);	/* Make room */
+			eth_copy_and_sum(skb,
+				(unsigned char *)__va(bdp->cbd_bufaddr),
+				pkt_len, 0);
+			skb->protocol=eth_type_trans(skb,dev);
+			netif_rx(skb);
+		}
+	}
+
+	/* Clear the status flags for this buffer. */
+	bdp->cbd_sc &= ~BD_ENET_RX_STATS;
+
+	/* Mark the buffer empty. */
+	bdp->cbd_sc |= BD_ENET_RX_EMPTY;
+
+	/* Update BD pointer to next entry. */
+	if (bdp->cbd_sc & BD_ENET_RX_WRAP)
+		bdp = cep->rx_bd_base;
+	else
+		bdp++;
+
+   }
+	cep->cur_rx = (cbd_t *)bdp;
+
+	return 0;
+}
+
+static int
+fcc_enet_close(struct net_device *dev)
+{
+#ifdef	CONFIG_USE_MDIO
+	struct fcc_enet_private *fep = dev->priv;
+#endif
+
+	netif_stop_queue(dev);
+	fcc_stop(dev);
+#ifdef	CONFIG_USE_MDIO
+	if (fep->phy)
+		mii_do_cmd(dev, fep->phy->shutdown);
+#endif
+
+	return 0;
+}
+
+static struct net_device_stats *fcc_enet_get_stats(struct net_device *dev)
+{
+	struct fcc_enet_private *cep = (struct fcc_enet_private *)dev->priv;
+
+	return &cep->stats;
+}
+
+#ifdef	CONFIG_USE_MDIO
+
+/* NOTE: Most of the following comes from the FEC driver for 860. The
+ * overall structure of MII code has been retained (as it's proved stable
+ * and well-tested), but actual transfer requests are processed "at once"
+ * instead of being queued (there's no interrupt-driven MII transfer
+ * mechanism, one has to toggle the data/clock bits manually).
+ */
+static int
+mii_queue(struct net_device *dev, int regval, void (*func)(uint, struct net_device *))
+{
+	struct fcc_enet_private *fep;
+	int		retval, tmp;
+
+	/* Add PHY address to register command. */
+	fep = dev->priv;
+	regval |= fep->phy_addr << 23;
+
+	retval = 0;
+
+	tmp = mii_send_receive(fep->fip, regval);
+	if (func)
+		func(tmp, dev);
+
+	return retval;
+}
+
+static int
+mii_read(struct net_device *dev, int regval)
+{
+	struct fcc_enet_private *fep;
+
+	/* Add PHY address to register command. */
+	fep = dev->priv;
+	regval |= fep->phy_addr << 23;
+
+	return(mii_send_receive(fep->fip, regval));
+}
+
+static void mii_do_cmd(struct net_device *dev, const phy_cmd_t *c)
+{
+	int k;
+
+	if(!c)
+		return;
+
+	for(k = 0; (c+k)->mii_data != mk_mii_end; k++)
+		mii_queue(dev, (c+k)->mii_data, (c+k)->funct);
+}
+
+static void mii_parse_sr(uint mii_reg, struct net_device *dev)
+{
+	volatile struct fcc_enet_private *fep = dev->priv;
+	uint s = fep->phy_status;
+
+	s &= ~(PHY_STAT_FAULT | PHY_STAT_ANC);
+
+	if (mii_reg & MII_SR_REMOTE_FAULT)
+		s |= PHY_STAT_FAULT;
+
+	if (mii_reg & MII_SR_AUTONEG_DONE)
+		s |= PHY_STAT_ANC;
+
+	fep->phy_status = s;
+}
+
+static void mii_parse_cr(uint mii_reg, struct net_device *dev)
+{
+	volatile struct fcc_enet_private *fep = dev->priv;
+	uint s = fep->phy_status;
+
+	s &= ~(PHY_CONF_ANE | PHY_CONF_LOOP);
+
+	if (mii_reg & MII_CR_ENABLE_NEG)
+		s |= PHY_CONF_ANE;
+
+	if (mii_reg & MII_CR_LBK_MODE)
+		s |= PHY_CONF_LOOP;
+
+	fep->phy_status = s;
+}
+
+static void mii_parse_ar(uint mii_reg, struct net_device *dev)
+{
+	volatile struct fcc_enet_private *fep = dev->priv;
+	uint s = fep->phy_status;
+
+	s &= ~(PHY_CONF_SPMASK);
+
+	if (mii_reg & MII_AR_10MB_HALFDUP)
+		s |= PHY_CONF_10HDX;
+	if (mii_reg & MII_AR_10MB_FULLDUP)
+		s |= PHY_CONF_10FDX;
+	if (mii_reg & MII_AR_100MB_HALFDUP)
+		s |= PHY_CONF_100HDX;
+	if (mii_reg & MII_AR_100MB_FULLDUP)
+		s |= PHY_CONF_100FDX;
+
+	fep->phy_status = s;
+}
+
+static void mii_parse_sr2(uint mii_reg, struct net_device *dev)
+{
+	volatile struct fcc_enet_private 	*fep = dev->priv;
+	uint 								s = fep->phy_status;
+
+	s &= ~(PHY_STAT_LINK | PHY_STAT_SPMASK);
+
+	if (mii_reg & MII_SR2_LINK_UP)
+		s |= PHY_STAT_LINK;
+
+	if (mii_reg & MII_SR2_100_TX) {
+		if (mii_reg & MII_SR2_FULL_DUP)
+			s |= PHY_STAT_100FDX;
+		else
+			s |= PHY_STAT_100HDX;
+	} else {
+		if (mii_reg & MII_SR2_FULL_DUP)
+			s |= PHY_STAT_10FDX;
+		else
+			s |= PHY_STAT_10HDX;
+	}
+
+	if (mii_reg & MII_SR2_ERROR)
+		s |= PHY_STAT_FAULT;
+
+	fep->phy_status = s;
+	fep->link = (s & PHY_STAT_LINK) ? 1 : 0;
+}
+
+static void mii_display_status(struct net_device *dev)
+{
+	volatile struct fcc_enet_private *fep = dev->priv;
+	uint s = fep->phy_status;
+
+#if 0
+	if (!fep->link && !fep->old_link) {
+		/* Link is still down - don't print anything */
+		return;
+	}
+#endif /* GG */
+
+	printk("%s: status: ", dev->name);
+
+	if (!fep->link) {
+		printk("link down");
+	} else {
+		printk("link up");
+
+		switch(s & PHY_STAT_SPMASK) {
+		case PHY_STAT_100FDX: printk(", 100 Mbps Full Duplex"); break;
+		case PHY_STAT_100HDX: printk(", 100 Mbps Half Duplex"); break;
+		case PHY_STAT_10FDX:  printk(", 10 Mbps Full Duplex");  break;
+		case PHY_STAT_10HDX:  printk(", 10 Mbps Half Duplex");  break;
+		default:
+			printk(", Unknown speed/duplex");
+		}
+
+		if (s & PHY_STAT_ANC)
+			printk(", auto-negotiation complete");
+	}
+
+	if (s & PHY_STAT_FAULT)
+		printk(", remote fault");
+
+	printk(".\n");
+}
+
+static void mii_display_config(struct net_device *dev)
+{
+	volatile struct fcc_enet_private *fep = dev->priv;
+	uint s = fep->phy_status;
+
+	printk("%s: config: auto-negotiation ", dev->name);
+
+	if (s & PHY_CONF_ANE)
+		printk("on");
+	else
+		printk("off");
+
+	if (s & PHY_CONF_100FDX)
+		printk(", 100FDX");
+	if (s & PHY_CONF_100HDX)
+		printk(", 100HDX");
+	if (s & PHY_CONF_10FDX)
+		printk(", 10FDX");
+	if (s & PHY_CONF_10HDX)
+		printk(", 10HDX");
+	if (!(s & PHY_CONF_SPMASK))
+		printk(", No speed/duplex selected?");
+
+	if (s & PHY_CONF_LOOP)
+		printk(", loopback enabled");
+
+	printk(".\n");
+
+	fep->sequence_done = 1;
+}
+
+static void mii_relink(struct net_device *dev)
+{
+	struct fcc_enet_private *fep = dev->priv;
+	int duplex = 0;
+
+	fep->old_link = fep->link; /* GG */
+	fep->link = (fep->phy_status & PHY_STAT_LINK) ? 1 : 0;
+
+#ifdef MDIO_DEBUG
+	printk("  mii_relink:  link=%d\n", fep->link);
+#endif
+
+	if (fep->link) {
+		if (fep->phy_status
+		    & (PHY_STAT_100FDX | PHY_STAT_10FDX))
+			duplex = 1;
+		fcc_restart(dev, duplex);
+#ifdef MDIO_DEBUG
+		printk("  mii_relink:  duplex=%d\n", duplex);
+#endif
+#if 0
+	/* useful ?? */
+	} else {
+		fcc_stop(dev);
+#endif /* GG */
+	}
+}
+
+static void mii_queue_relink(uint mii_reg, struct net_device *dev)
+{
+	struct fcc_enet_private *fep = dev->priv;
+
+	mii_relink(dev);
+
+	schedule_work(&fep->phy_relink);
+}
+
+static void mii_queue_config(uint mii_reg, struct net_device *dev)
+{
+	struct fcc_enet_private *fep = dev->priv;
+
+	schedule_work(&fep->phy_display_config);
+}
+
+/* Read remainder of PHY ID.
+*/
+static void
+mii_discover_phy3(uint mii_reg, struct net_device *dev)
+{
+	struct fcc_enet_private *fep;
+	int	i;
+
+	fep = dev->priv;
+	// GG printk("mii_reg: %08x\n", mii_reg);
+	fep->phy_id |= (mii_reg & 0xffff);
+
+	for(i = 0; phy_info[i]; i++)
+		if((phy_info[i]->id == (fep->phy_id >> 4)) || !phy_info[i]->id)
+			break;
+
+	if(!phy_info[i])
+		panic("%s: PHY id 0x%08x is not supported!\n",
+		      dev->name, fep->phy_id);
+
+	fep->phy = phy_info[i];
+	fep->phy_id_done = 1;
+
+	printk("%s: Phy @ 0x%x, type %s (0x%08x)\n",
+		dev->name, fep->phy_addr, fep->phy->name, fep->phy_id);
+}
+
+/* Scan all of the MII PHY addresses looking for someone to respond
+ * with a valid ID.  This usually happens quickly.
+ */
+static void
+mii_discover_phy(uint mii_reg, struct net_device *dev)
+{
+	struct fcc_enet_private *fep;
+	uint	phytype;
+
+	fep = dev->priv;
+
+	if ((phytype = (mii_reg & 0xffff)) != 0xffff) {
+
+		/* Got first part of ID, now get remainder. */
+		fep->phy_id = phytype << 16;
+		mii_queue(dev, mk_mii_read(MII_LXT971_IR2), mii_discover_phy3);
+	} else {
+		fep->phy_addr++;
+		if (fep->phy_addr < 32) {
+			mii_queue(dev, mk_mii_read(MII_LXT971_IR1),
+							mii_discover_phy);
+		} else {
+			printk("fec: No PHY device found.\n");
+		}
+	}
+}
+
+/* This interrupt occurs when the PHY detects a link change. */
+static irqreturn_t
+mii_link_interrupt(int irq, void * dev_id, struct pt_regs * regs)
+{
+	struct	net_device *dev = dev_id;
+	struct fcc_enet_private *fep = dev->priv;
+	fcc_info_t *fip = fep->fip;
+
+	if (fep->phy) {
+		/* We don't want to be interrupted by an FCC
+		 * interrupt here.
+		 */
+		disable_irq_nosync(fip->fc_interrupt);
+
+		mii_do_cmd(dev, fep->phy->ack_int);
+		/* restart and display status */
+		mii_do_cmd(dev, phy_cmd_relink);
+
+		enable_irq(fip->fc_interrupt);
+	}
+	return IRQ_HANDLED;
+}
+#endif	/* CONFIG_USE_MDIO */
+
+/* Set or clear the multicast filter for this adaptor.
+ * Skeleton taken from sunlance driver.
+ * The CPM Ethernet implementation allows Multicast as well as individual
+ * MAC address filtering.  Some of the drivers check to make sure it is
+ * a group multicast address, and discard those that are not.  I guess I
+ * will do the same for now, but just remove the test if you want
+ * individual filtering as well (do the upper net layers want or support
+ * this kind of feature?).
+ */
+static void
+set_multicast_list(struct net_device *dev)
+{
+	struct	fcc_enet_private *cep;
+	struct	dev_mc_list *dmi;
+	u_char	*mcptr, *tdptr;
+	volatile fcc_enet_t *ep;
+	int	i, j;
+
+	cep = (struct fcc_enet_private *)dev->priv;
+
+	/* Get pointer to FCC area in parameter RAM.
+	*/
+	ep = (fcc_enet_t *)dev->base_addr;
+
+	if (dev->flags&IFF_PROMISC) {
+	
+		/* Log any net taps. */
+		printk("%s: Promiscuous mode enabled.\n", dev->name);
+		cep->fccp->fcc_fpsmr |= FCC_PSMR_PRO;
+	} else {
+
+		cep->fccp->fcc_fpsmr &= ~FCC_PSMR_PRO;
+
+		if (dev->flags & IFF_ALLMULTI) {
+			/* Catch all multicast addresses, so set the
+			 * filter to all 1's.
+			 */
+			ep->fen_gaddrh = 0xffffffff;
+			ep->fen_gaddrl = 0xffffffff;
+		}
+		else {
+			/* Clear filter and add the addresses in the list.
+			*/
+			ep->fen_gaddrh = 0;
+			ep->fen_gaddrl = 0;
+
+			dmi = dev->mc_list;
+
+			for (i=0; i<dev->mc_count; i++, dmi = dmi->next) {
+				
+				/* Only support group multicast for now.
+				*/
+				if (!(dmi->dmi_addr[0] & 1))
+					continue;
+
+				/* The address in dmi_addr is LSB first,
+				 * and taddr is MSB first.  We have to
+				 * copy bytes MSB first from dmi_addr.
+				 */
+				mcptr = (u_char *)dmi->dmi_addr + 5;
+				tdptr = (u_char *)&ep->fen_taddrh;
+				for (j=0; j<6; j++)
+					*tdptr++ = *mcptr--;
+
+				/* Ask CPM to run CRC and set bit in
+				 * filter mask.
+				 */
+				cpmp->cp_cpcr = mk_cr_cmd(cep->fip->fc_cpmpage,
+						cep->fip->fc_cpmblock, 0x0c,
+						CPM_CR_SET_GADDR) | CPM_CR_FLG;
+				udelay(10);
+				while (cpmp->cp_cpcr & CPM_CR_FLG);
+			}
+		}
+	}
+}
+
+/* Set the individual MAC address.
+ */
+int fcc_enet_set_mac_address(struct net_device *dev, void *p)
+{
+	struct sockaddr *addr= (struct sockaddr *) p;
+	struct fcc_enet_private *cep;
+	volatile fcc_enet_t *ep;
+	unsigned char *eap;
+	int i;
+
+	cep = (struct fcc_enet_private *)(dev->priv);
+	ep = cep->ep;
+
+        if (netif_running(dev))
+                return -EBUSY;
+
+        memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
+
+	eap = (unsigned char *) &(ep->fen_paddrh);
+	for (i=5; i>=0; i--)
+		*eap++ = addr->sa_data[i];
+
+        return 0;
+}
+
+
+/* Initialize the CPM Ethernet on FCC.
+ */
+static int __init fec_enet_init(void)
+{
+	struct net_device *dev;
+	struct fcc_enet_private *cep;
+	fcc_info_t	*fip;
+	int	i, np, err;
+	volatile	cpm2_map_t		*immap;
+	volatile	iop_cpm2_t	*io;
+
+	immap = (cpm2_map_t *)CPM_MAP_ADDR;	/* and to internal registers */
+	io = &immap->im_ioport;
+
+	np = sizeof(fcc_ports) / sizeof(fcc_info_t);
+	fip = fcc_ports;
+
+	while (np-- > 0) {
+		/* Create an Ethernet device instance.
+		*/
+		dev = alloc_etherdev(sizeof(*cep));
+		if (!dev)
+			return -ENOMEM;
+
+		cep = dev->priv;
+		spin_lock_init(&cep->lock);
+		cep->fip = fip;
+
+		init_fcc_shutdown(fip, cep, immap);
+		init_fcc_ioports(fip, io, immap);
+		init_fcc_param(fip, dev, immap);
+
+		dev->base_addr = (unsigned long)(cep->ep);
+
+		/* The CPM Ethernet specific entries in the device
+		 * structure.
+		 */
+		dev->open = fcc_enet_open;
+		dev->hard_start_xmit = fcc_enet_start_xmit;
+		dev->tx_timeout = fcc_enet_timeout;
+		dev->watchdog_timeo = TX_TIMEOUT;
+		dev->stop = fcc_enet_close;
+		dev->get_stats = fcc_enet_get_stats;
+		dev->set_multicast_list = set_multicast_list;
+		dev->set_mac_address = fcc_enet_set_mac_address;
+#ifdef  CONFIG_USE_MDIO
+		dev->do_ioctl		= fcc_enet_ioctl;
+#endif  /* CONFIG_USE_MDIO */
+
+		init_fcc_startup(fip, dev);
+
+		err = register_netdev(dev);
+		if (err) {
+			free_netdev(dev);
+			return err;
+		}
+
+#ifdef	CONFIG_USE_MDIO
+		/* Queue up command to detect the PHY and initialize the
+	 	* remainder of the interface.
+	 	*/
+		cep->phy_id_done = 0;
+#if 0
+		cep->phy_addr = 0;
+#else
+		/* PHY address is the same as FCC number */
+		cep->phy_addr = cep->fip->fc_fccnum;
+#endif /* GG */
+		mii_queue(dev, mk_mii_read(MII_LXT971_IR1), mii_discover_phy);
+		INIT_WORK(&cep->phy_relink, 
+				(void (*)(void *))mii_display_status, (void *)dev);
+		INIT_WORK(&cep->phy_display_config, 
+				(void (*)(void *))mii_display_config, (void *)dev);
+#endif	/* CONFIG_USE_MDIO */
+
+		printk("%s: FCC ENET Version 1.0.0, ", dev->name);
+		for (i=0; i<5; i++)
+			printk("%02x:", dev->dev_addr[i]);
+		printk("%02x\n", dev->dev_addr[5]);
+
+		fip++;
+	}
+
+	return 0;
+}
+module_init(fec_enet_init);
+
+/* Make sure the device is shut down during initialization.
+*/
+static void __init
+init_fcc_shutdown(fcc_info_t *fip, struct fcc_enet_private *cep,
+						volatile cpm2_map_t *immap)
+{
+	volatile	fcc_enet_t	*ep;
+	volatile	fcc_t		*fccp;
+
+	/* Get pointer to FCC area in parameter RAM.
+	*/
+	ep = (fcc_enet_t *)(&immap->im_dprambase[fip->fc_proff]);
+
+	/* And another to the FCC register area.
+	*/
+	fccp = (volatile fcc_t *)(&immap->im_fcc[fip->fc_fccnum]);
+	cep->fccp = fccp;		/* Keep the pointers handy */
+	cep->ep = ep;
+
+	/* Disable receive and transmit in case someone left it running.
+	*/
+	fccp->fcc_gfmr &= ~(FCC_GFMR_ENR | FCC_GFMR_ENT);
+}
+
+/* Initialize the I/O pins for the FCC Ethernet.
+*/
+static void __init
+init_fcc_ioports(fcc_info_t *fip, volatile iop_cpm2_t *io,
+						volatile cpm2_map_t *immap)
+{
+
+	/* FCC1 pins are on port A/C.  FCC2/3 are port B/C.
+	*/
+	if (fip->fc_proff == PROFF_FCC1) {
+		/* Configure port A and C pins for FCC1 Ethernet.
+		 */
+		io->iop_pdira &= ~PA1_DIRA0;
+		io->iop_pdira |= PA1_DIRA1;
+		io->iop_psora &= ~PA1_PSORA0;
+		io->iop_psora |= PA1_PSORA1;
+		io->iop_ppara |= (PA1_DIRA0 | PA1_DIRA1);
+	}
+	if (fip->fc_proff == PROFF_FCC2) {
+		/* Configure port B and C pins for FCC Ethernet.
+		 */
+		io->iop_pdirb &= ~PB2_DIRB0;
+		io->iop_pdirb |= PB2_DIRB1;
+		io->iop_psorb &= ~PB2_PSORB0;
+		io->iop_psorb |= PB2_PSORB1;
+		io->iop_pparb |= (PB2_DIRB0 | PB2_DIRB1);
+	}
+	if (fip->fc_proff == PROFF_FCC3) {
+		/* Configure port B and C pins for FCC Ethernet.
+		 */
+		io->iop_pdirb &= ~PB3_DIRB0;
+		io->iop_pdirb |= PB3_DIRB1;
+		io->iop_psorb &= ~PB3_PSORB0;
+		io->iop_psorb |= PB3_PSORB1;
+		io->iop_pparb |= (PB3_DIRB0 | PB3_DIRB1);
+	}
+
+	/* Port C has clocks......
+	*/
+	io->iop_psorc &= ~(fip->fc_trxclocks);
+	io->iop_pdirc &= ~(fip->fc_trxclocks);
+	io->iop_pparc |= fip->fc_trxclocks;
+
+#ifdef	CONFIG_USE_MDIO
+	/* ....and the MII serial clock/data.
+	*/
+	io->iop_pdatc &= ~(fip->fc_mdio | fip->fc_mdck);
+	io->iop_podrc &= ~(fip->fc_mdck | fip->fc_mdio);
+	io->iop_pdirc |= fip->fc_mdck;
+	io->iop_pdirc &= ~(fip->fc_mdio);
+	io->iop_pparc &= ~(fip->fc_mdio | fip->fc_mdck);
+#endif	/* CONFIG_USE_MDIO */
+
+	/* Configure Serial Interface clock routing.
+	 * First, clear all FCC bits to zero,
+	 * then set the ones we want.
+	 */
+	immap->im_cpmux.cmx_fcr &= ~(fip->fc_clockmask);
+	immap->im_cpmux.cmx_fcr |= fip->fc_clockroute;
+}
+
+static void __init
+init_fcc_param(fcc_info_t *fip, struct net_device *dev,
+						volatile cpm2_map_t *immap)
+{
+	unsigned char	*eap;
+	unsigned long	mem_addr;
+	bd_t		*bd;
+	int		i, j;
+	struct		fcc_enet_private *cep;
+	volatile	fcc_enet_t	*ep;
+	volatile	cbd_t		*bdp;
+	volatile	cpm_cpm2_t	*cp;
+
+	cep = (struct fcc_enet_private *)(dev->priv);
+	ep = cep->ep;
+	cp = cpmp;
+
+	bd = (bd_t *)__res;
+
+	/* Zero the whole thing.....I must have missed some individually.
+	 * It works when I do this.
+	 */
+	memset((char *)ep, 0, sizeof(fcc_enet_t));
+
+	/* Allocate space for the buffer descriptors from regular memory.
+	 * Initialize base addresses for the buffer descriptors.
+	 */
+	cep->rx_bd_base = (cbd_t *)kmalloc(sizeof(cbd_t) * RX_RING_SIZE,
+			GFP_KERNEL | GFP_DMA);
+	ep->fen_genfcc.fcc_rbase = __pa(cep->rx_bd_base);
+	cep->tx_bd_base = (cbd_t *)kmalloc(sizeof(cbd_t) * TX_RING_SIZE,
+			GFP_KERNEL | GFP_DMA);
+	ep->fen_genfcc.fcc_tbase = __pa(cep->tx_bd_base);
+
+	cep->dirty_tx = cep->cur_tx = cep->tx_bd_base;
+	cep->cur_rx = cep->rx_bd_base;
+
+	ep->fen_genfcc.fcc_rstate = (CPMFCR_GBL | CPMFCR_EB) << 24;
+	ep->fen_genfcc.fcc_tstate = (CPMFCR_GBL | CPMFCR_EB) << 24;
+
+	/* Set maximum bytes per receive buffer.
+	 * It must be a multiple of 32.
+	 */
+	ep->fen_genfcc.fcc_mrblr = PKT_MAXBLR_SIZE;
+
+	/* Allocate space in the reserved FCC area of DPRAM for the
+	 * internal buffers.  No one uses this space (yet), so we
+	 * can do this.  Later, we will add resource management for
+	 * this area.
+	 */
+	mem_addr = CPM_FCC_SPECIAL_BASE + (fip->fc_fccnum * 128);
+	ep->fen_genfcc.fcc_riptr = mem_addr;
+	ep->fen_genfcc.fcc_tiptr = mem_addr+32;
+	ep->fen_padptr = mem_addr+64;
+	memset((char *)(&(immap->im_dprambase[(mem_addr+64)])), 0x88, 32);
+
+	ep->fen_genfcc.fcc_rbptr = 0;
+	ep->fen_genfcc.fcc_tbptr = 0;
+	ep->fen_genfcc.fcc_rcrc = 0;
+	ep->fen_genfcc.fcc_tcrc = 0;
+	ep->fen_genfcc.fcc_res1 = 0;
+	ep->fen_genfcc.fcc_res2 = 0;
+
+	ep->fen_camptr = 0;	/* CAM isn't used in this driver */
+
+	/* Set CRC preset and mask.
+	*/
+	ep->fen_cmask = 0xdebb20e3;
+	ep->fen_cpres = 0xffffffff;
+
+	ep->fen_crcec = 0;	/* CRC Error counter */
+	ep->fen_alec = 0;	/* alignment error counter */
+	ep->fen_disfc = 0;	/* discard frame counter */
+	ep->fen_retlim = 15;	/* Retry limit threshold */
+	ep->fen_pper = 0;	/* Normal persistence */
+
+	/* Clear hash filter tables.
+	*/
+	ep->fen_gaddrh = 0;
+	ep->fen_gaddrl = 0;
+	ep->fen_iaddrh = 0;
+	ep->fen_iaddrl = 0;
+
+	/* Clear the Out-of-sequence TxBD.
+	*/
+	ep->fen_tfcstat = 0;
+	ep->fen_tfclen = 0;
+	ep->fen_tfcptr = 0;
+
+	ep->fen_mflr = PKT_MAXBUF_SIZE;   /* maximum frame length register */
+	ep->fen_minflr = PKT_MINBUF_SIZE;  /* minimum frame length register */
+
+	/* Set Ethernet station address.
+	 *
+	 * This is supplied in the board information structure, so we
+	 * copy that into the controller.
+	 * So, far we have only been given one Ethernet address. We make
+	 * it unique by setting a few bits in the upper byte of the
+	 * non-static part of the address.
+	 */
+#ifdef CONFIG_PQ2PMCA
+	eap = (unsigned char *)&(ep->fen_paddrh);
+	for (i=5; i>=0; i--) {
+		if (i == 5) {
+			dev->dev_addr[i] = bd->bi_enetaddr[i];
+			dev->dev_addr[i] += fip->fc_fccnum;
+			*eap++ = dev->dev_addr[i];
+		}
+		else {
+			*eap++ = dev->dev_addr[i] = bd->bi_enetaddr[i];
+		}
+	}
+#endif /* CONFIG_PQ2PMCA */
+
+	ep->fen_taddrh = 0;
+	ep->fen_taddrm = 0;
+	ep->fen_taddrl = 0;
+
+	ep->fen_maxd1 = PKT_MAXDMA_SIZE;	/* maximum DMA1 length */
+	ep->fen_maxd2 = PKT_MAXDMA_SIZE;	/* maximum DMA2 length */
+
+	/* Clear stat counters, in case we ever enable RMON.
+	*/
+	ep->fen_octc = 0;
+	ep->fen_colc = 0;
+	ep->fen_broc = 0;
+	ep->fen_mulc = 0;
+	ep->fen_uspc = 0;
+	ep->fen_frgc = 0;
+	ep->fen_ospc = 0;
+	ep->fen_jbrc = 0;
+	ep->fen_p64c = 0;
+	ep->fen_p65c = 0;
+	ep->fen_p128c = 0;
+	ep->fen_p256c = 0;
+	ep->fen_p512c = 0;
+	ep->fen_p1024c = 0;
+
+	ep->fen_rfthr = 0;	/* Suggested by manual */
+	ep->fen_rfcnt = 0;
+	ep->fen_cftype = 0;
+
+	/* Now allocate the host memory pages and initialize the
+	 * buffer descriptors.
+	 */
+	bdp = cep->tx_bd_base;
+	for (i=0; i<TX_RING_SIZE; i++) {
+
+		/* Initialize the BD for every fragment in the page.
+		*/
+		bdp->cbd_sc = 0;
+		bdp->cbd_datlen = 0;
+		bdp->cbd_bufaddr = 0;
+		bdp++;
+	}
+
+	/* Set the last buffer to wrap.
+	*/
+	bdp--;
+	bdp->cbd_sc |= BD_SC_WRAP;
+
+	bdp = cep->rx_bd_base;
+	for (i=0; i<FCC_ENET_RX_PAGES; i++) {
+
+		/* Allocate a page.
+		*/
+		mem_addr = __get_free_page(GFP_KERNEL);
+
+		/* Initialize the BD for every fragment in the page.
+		*/
+		for (j=0; j<FCC_ENET_RX_FRPPG; j++) {
+			bdp->cbd_sc = BD_ENET_RX_EMPTY | BD_ENET_RX_INTR;
+			bdp->cbd_datlen = 0;
+			bdp->cbd_bufaddr = __pa(mem_addr);
+			mem_addr += FCC_ENET_RX_FRSIZE;
+			bdp++;
+		}
+	}
+
+	/* Set the last buffer to wrap.
+	*/
+	bdp--;
+	bdp->cbd_sc |= BD_SC_WRAP;
+
+	/* Let's re-initialize the channel now.  We have to do it later
+	 * than the manual describes because we have just now finished
+	 * the BD initialization.
+	 */
+	cp->cp_cpcr = mk_cr_cmd(fip->fc_cpmpage, fip->fc_cpmblock, 0x0c,
+			CPM_CR_INIT_TRX) | CPM_CR_FLG;
+	while (cp->cp_cpcr & CPM_CR_FLG);
+
+	cep->skb_cur = cep->skb_dirty = 0;
+}
+
+/* Let 'er rip.
+*/
+static void __init
+init_fcc_startup(fcc_info_t *fip, struct net_device *dev)
+{
+	volatile fcc_t	*fccp;
+	struct fcc_enet_private *cep;
+	int                     duplex;
+
+	cep = (struct fcc_enet_private *)(dev->priv);
+	fccp = cep->fccp;
+
+	fccp->fcc_fcce = 0xffff;	/* Clear any pending events */
+
+	/* Leave FCC interrupts masked for now.  Will be unmasked by
+	 * fcc_restart().
+	 */
+	fccp->fcc_fccm = 0;
+
+	/* Install our interrupt handler.
+	*/
+	if (request_irq(fip->fc_interrupt, fcc_enet_interrupt, 0, "fenet",
+				dev) < 0)
+		printk("Can't get FCC IRQ %d\n", fip->fc_interrupt);
+
+#ifdef	CONFIG_USE_MDIO
+	/* ack pending PHY interrupts and read PHY current status */
+	// GG mii_do_cmd(dev, cep->phy->ack_int);
+
+	if (request_irq(fip->fc_phy_interrupt, mii_link_interrupt, 0,
+							"mii", dev) < 0)
+		printk("Can't get MII IRQ %d\n", fip->fc_phy_interrupt);
+#endif	/* CONFIG_USE_MDIO */
+
+	/* Set GFMR to enable Ethernet operating mode.
+	 */
+#if 0
+	fccp->fcc_gfmr = (FCC_GFMR_TCI | FCC_GFMR_MODE_ENET);
+#else
+	fccp->fcc_gfmr = FCC_GFMR_MODE_ENET;
+#endif /* GG */
+
+	/* Set sync/delimiters.
+	*/
+	fccp->fcc_fdsr = 0xd555;
+
+	/* Set protocol specific processing mode for Ethernet.
+	 * This has to be adjusted for Full Duplex operation after we can
+	 * determine how to detect that.
+	 */
+	fccp->fcc_fpsmr = FCC_PSMR_ENCRC;
+
+#ifdef CONFIG_PQ2ADS
+	/* Enable the PHY.
+	*/
+        *(volatile uint *)(BCSR_ADDR + 4) &= ~BCSR1_FETHIEN;
+        *(volatile uint *)(BCSR_ADDR + 4) |=  BCSR1_FETH_RST;
+#endif
+
+#ifdef CONFIG_USE_MDIO
+	if (cep->phy_status & (PHY_STAT_100FDX | PHY_STAT_10FDX)) {
+		duplex = 1;
+	} else {
+		duplex = 0;
+	}
+	fcc_restart(dev, duplex);
+#else
+	/* start in half duplex mode */
+	duplex = 0;
+	fcc_restart (dev, duplex);
+#endif
+}
+
+#ifdef CONFIG_USE_MDIO
+static uint
+mii_send_receive(fcc_info_t *fip, uint cmd)
+{
+	uint				retval;
+	int					read_op, i, off;
+	volatile cpm2_map_t	*immap;
+	volatile iop_cpm2_t	*io;
+
+	immap = (cpm2_map_t *)CPM_MAP_ADDR;
+	io = &immap->im_ioport;
+
+	/* check if read operation */
+	read_op = ((cmd & 0xf0000000) == 0x60000000);
+
+	/* set mdc as output */
+	io->iop_pdird |= (fip->fc_mdck);
+	FCC_PDATD_MDC(1);
+
+	/* set mdio as output */
+	io->iop_pdird |= (fip->fc_mdio);
+	FCC_PDATD_MDIO(1);
+
+	/* write preamble */
+	for (i = 0; i < 32; i++) {
+		FCC_PDATD_MDC(0);
+		udelay(1);
+		FCC_PDATD_MDC(1);
+		udelay(1);
+	}
+
+	/* reset clock state */
+	FCC_PDATD_MDC(0);
+	udelay(1);
+
+	/* set mdio as output */
+	io->iop_pdird |= (fip->fc_mdio);
+	FCC_PDATD_MDIO(1);
+
+	/* write data */
+	for (i = 0, off = 31; i < (read_op ? 14 : 32); i++, --off)
+	{
+		FCC_PDATD_MDIO((cmd >> off) & 0x00000001);
+		FCC_PDATD_MDC(0);
+		udelay(1);
+		FCC_PDATD_MDC(1);
+		udelay(1);
+	}
+
+	/* reset clock state */
+	FCC_PDATD_MDC(0);
+	udelay(1);
+
+	retval = cmd;
+
+	if (read_op)
+	{
+		retval >>= 16;
+
+		/* set mdio as input */
+		io->iop_pdird &= ~(fip->fc_mdio);
+
+		FCC_PDATD_MDC(1);
+		udelay(1);
+		FCC_PDATD_MDC(0);
+		udelay(1);
+
+		for (i = 0, off = 15; i < 16; i++, off--)
+		{
+			FCC_PDATD_MDC(1);
+			udelay(1);
+
+			retval <<= 1;
+			if (io->iop_pdatd & fip->fc_mdio)
+				retval++;
+
+			FCC_PDATD_MDC(0);
+			udelay(1);
+		}
+		FCC_PDATD_MDC(1);
+		udelay(1);
+	}
+
+	/* set mdio as input */
+	io->iop_pdird &= ~(fip->fc_mdio);
+
+	/* put the bus in idle state */
+	FCC_PDATD_MDC(0);
+	udelay(1);
+	FCC_PDATD_MDC(1);
+	udelay(1);
+	FCC_PDATD_MDC(0);
+	udelay(1);
+	FCC_PDATD_MDC(1);
+	udelay(1);
+
+	return retval;
+}
+#endif	/* CONFIG_USE_MDIO */
+
+static void
+fcc_stop(struct net_device *dev)
+{
+	struct fcc_enet_private	*fep= (struct fcc_enet_private *)(dev->priv);
+	volatile fcc_t	*fccp = fep->fccp;
+	fcc_info_t *fip = fep->fip;
+	volatile fcc_enet_t *ep = fep->ep;
+	volatile cpm_cpm2_t *cp = cpmp;
+	volatile cbd_t *bdp;
+	int i;
+
+	if ((fccp->fcc_gfmr & (FCC_GFMR_ENR | FCC_GFMR_ENT)) == 0)
+		return;	/* already down */
+
+	fccp->fcc_fccm = 0;
+
+	/* issue the graceful stop tx command */
+	while (cp->cp_cpcr & CPM_CR_FLG);
+	cp->cp_cpcr = mk_cr_cmd(fip->fc_cpmpage, fip->fc_cpmblock,
+				0x0c, CPM_CR_GRA_STOP_TX) | CPM_CR_FLG;
+	while (cp->cp_cpcr & CPM_CR_FLG);
+
+	/* Disable transmit/receive */
+	fccp->fcc_gfmr &= ~(FCC_GFMR_ENR | FCC_GFMR_ENT);
+
+	/* issue the restart tx command */
+	fccp->fcc_fcce = FCC_ENET_GRA;
+	while (cp->cp_cpcr & CPM_CR_FLG);
+	cp->cp_cpcr = mk_cr_cmd(fip->fc_cpmpage, fip->fc_cpmblock,
+				0x0c, CPM_CR_RESTART_TX) | CPM_CR_FLG;
+	while (cp->cp_cpcr & CPM_CR_FLG);
+
+	/* free tx buffers */
+	fep->skb_cur = fep->skb_dirty = 0;
+	for (i=0; i<=TX_RING_MOD_MASK; i++) {
+		if (fep->tx_skbuff[i] != NULL) {
+			dev_kfree_skb(fep->tx_skbuff[i]);
+			fep->tx_skbuff[i] = NULL;
+		}
+	}
+	fep->dirty_tx = fep->cur_tx = fep->tx_bd_base;
+	fep->tx_free = TX_RING_SIZE;
+	ep->fen_genfcc.fcc_tbptr = ep->fen_genfcc.fcc_tbase;
+
+	/* Initialize the tx buffer descriptors. */
+	bdp = fep->tx_bd_base;
+	for (i=0; i<TX_RING_SIZE; i++) {
+		bdp->cbd_sc = 0;
+		bdp->cbd_datlen = 0;
+		bdp->cbd_bufaddr = 0;
+		bdp++;
+	}
+	/* Set the last buffer to wrap. */
+	bdp--;
+	bdp->cbd_sc |= BD_SC_WRAP;
+}
+
+static void
+fcc_restart(struct net_device *dev, int duplex)
+{
+	struct fcc_enet_private	*fep = (struct fcc_enet_private *)(dev->priv);
+	volatile fcc_t	*fccp = fep->fccp;
+
+	/* stop any transmissions in progress */
+	fcc_stop(dev);
+
+	if (duplex)
+		fccp->fcc_fpsmr |= FCC_PSMR_FDE | FCC_PSMR_LPB;
+	else
+		fccp->fcc_fpsmr &= ~(FCC_PSMR_FDE | FCC_PSMR_LPB);
+
+	/* Enable interrupts for transmit error, complete frame
+	 * received, and any transmit buffer we have also set the
+	 * interrupt flag.
+	 */
+	fccp->fcc_fccm = (FCC_ENET_TXE | FCC_ENET_RXF | FCC_ENET_TXB);
+
+	/* Enable transmit/receive */
+	fccp->fcc_gfmr |= FCC_GFMR_ENR | FCC_GFMR_ENT;
+}
+
+static int
+fcc_enet_open(struct net_device *dev)
+{
+	struct fcc_enet_private *fep = dev->priv;
+
+#ifdef	CONFIG_USE_MDIO
+	fep->sequence_done = 0;
+	fep->link = 0;
+
+	if (fep->phy) {
+		fcc_restart(dev, 0);	/* always start in half-duplex */
+		mii_do_cmd(dev, fep->phy->ack_int);
+		mii_do_cmd(dev, fep->phy->config);
+		mii_do_cmd(dev, phy_cmd_config);  /* display configuration */
+		while(!fep->sequence_done)
+			schedule();
+
+		mii_do_cmd(dev, fep->phy->startup);
+		netif_start_queue(dev);
+		return 0;		/* Success */
+	}
+	return -ENODEV;		/* No PHY we understand */
+#else
+	fep->link = 1;
+	fcc_restart(dev, 0);	/* always start in half-duplex */
+	netif_start_queue(dev);
+	return 0;					/* Always succeed */
+#endif	/* CONFIG_USE_MDIO */
+}
+
+#ifdef	CONFIG_USE_MDIO
+static int
+fcc_enet_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	int rc = 0;
+	u16	tmp;
+	struct mii_ioctl_data *data = (struct mii_ioctl_data *)&ifr->ifr_data;
+	volatile struct fcc_enet_private 	*fep = dev->priv;
+
+	switch (cmd) {
+	case SIOCETHTOOL:
+		rc = fcc_ethtool_ioctl(dev, (void *)ifr->ifr_data);
+		break;
+
+	case SIOCGMIIPHY:	/* Get address of MII PHY in use. */
+	case SIOCGMIIREG:	/* Read MII PHY register. */
+		if (data->reg_num != 1) {
+			if (cmd == SIOCGMIIPHY) {
+				data->phy_id = (u16)fep->phy_addr;
+			}
+			data->val_out = (u16)mii_read(dev, 
+							mk_mii_read(data->reg_num & 0x1f));
+		} else {
+			/* just for bonding call */
+			/* read status register */
+			data->val_out = (u16)mii_read(dev, mk_mii_read(MII_LXT971_SR));
+			/* clear link status */
+			data->val_out &= ~MII_SR_LINKUP;
+			/* read status2 for link status */
+			tmp = (u16)mii_read(dev, mk_mii_read(MII_LXT971_SR2));
+			if (tmp & MII_SR2_LINK_UP) {
+				data->val_out |= MII_SR_LINKUP;
+			}
+		}
+		break;
+
+	case SIOCSMIIREG:	/* Write MII PHY register. */
+		/* check privilege */
+		if (!capable(CAP_NET_ADMIN)) {
+			return -EPERM;
+		}
+		mii_queue(dev, mk_mii_write(data->reg_num & 0x1f, data->val_in), NULL);
+		break;
+
+	default:
+		rc = -EOPNOTSUPP;
+		break;
+	}
+
+	return rc;
+}
+
+static int fcc_ethtool_ioctl(struct net_device *dev, void *arg)
+{
+	int									rc = 0;
+	int									advertise;
+	int									control;
+	struct ethtool_cmd					ecmd;
+	struct ethtool_value				evalue;
+	volatile struct fcc_enet_private 	*fep = dev->priv;
+
+	if (copy_from_user(&ecmd, arg, sizeof(ecmd))) {
+		return -EFAULT;
+	}
+
+	switch (ecmd.cmd) {
+	case ETHTOOL_GSET:		/* Get settings. */
+		mii_queue(dev, mk_mii_read(MII_LXT971_CR), mii_parse_cr);
+		mii_queue(dev, mk_mii_read(MII_LXT971_AR), mii_parse_ar);
+		mii_queue(dev, mk_mii_read(MII_LXT971_SR), mii_parse_sr);
+		mii_queue(dev, mk_mii_read(MII_LXT971_SR2), mii_parse_sr2);
+
+		/* supported features */
+		ecmd.supported = 
+			(SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |
+			SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full | 
+			SUPPORTED_Autoneg | SUPPORTED_TP);
+
+		/* advertised features */
+		ecmd.advertising = ADVERTISED_TP;
+		ecmd.autoneg = AUTONEG_DISABLE;
+		if (fep->phy_status & PHY_CONF_ANE) {
+			ecmd.advertising |= ADVERTISED_Autoneg;
+			ecmd.autoneg = AUTONEG_ENABLE;
+		}
+		if (fep->phy_status & PHY_CONF_100FDX) {
+			ecmd.advertising |= ADVERTISED_100baseT_Full;
+		}
+		if (fep->phy_status & PHY_CONF_100HDX) {
+			ecmd.advertising |= ADVERTISED_100baseT_Half;
+		}
+		if (fep->phy_status & PHY_CONF_10FDX) {
+			ecmd.advertising |= ADVERTISED_10baseT_Full;
+		}
+		if (fep->phy_status & PHY_CONF_10HDX) {
+			ecmd.advertising |= ADVERTISED_10baseT_Half;
+		}
+
+		/* speed and duplex */
+		switch(fep->phy_status & PHY_STAT_SPMASK) {
+		case PHY_STAT_100FDX:
+			ecmd.speed = SPEED_100;
+			ecmd.duplex = DUPLEX_FULL;
+			break;
+		case PHY_STAT_100HDX:
+			ecmd.speed = SPEED_100;
+			ecmd.duplex = DUPLEX_HALF;
+			break;
+		case PHY_STAT_10FDX:
+			ecmd.speed = SPEED_10;
+			ecmd.duplex = DUPLEX_FULL;
+			break;
+		case PHY_STAT_10HDX:
+		default:
+			ecmd.speed = SPEED_10;
+			ecmd.duplex = DUPLEX_HALF;
+			break;
+		}
+
+		/* port, phy_address, transceiver */
+		ecmd.port = PORT_TP;
+		ecmd.phy_address = fep->phy_addr;
+		ecmd.transceiver = XCVR_INTERNAL;
+
+		/* autoneg is set previously while advertised features */
+
+		if (copy_to_user(arg, &ecmd, sizeof(ecmd))) {
+			return -EFAULT;
+		}
+		break;
+
+	case ETHTOOL_SSET:		/* Set settings, privileged. */
+		/* check privilege */
+		if (!capable(CAP_NET_ADMIN)) {
+			return -EPERM;
+		}
+
+		/* verify the settings we care about. */
+		if (ecmd.autoneg != AUTONEG_ENABLE &&
+			ecmd.autoneg != AUTONEG_DISABLE) {
+			return -EINVAL;
+		}
+
+		if (ecmd.autoneg == AUTONEG_DISABLE && 
+			((ecmd.speed != SPEED_100 && ecmd.speed != SPEED_10) ||
+			 (ecmd.duplex != DUPLEX_HALF && ecmd.duplex != DUPLEX_FULL))) {
+			return -EINVAL;
+		}
+
+		/* stop FCC driver */
+		/* don't stop PHY to keep interupts */
+		fcc_stop(dev);
+
+		/* prepare new advertissements */
+		advertise =	mii_read(dev, mk_mii_read(MII_LXT971_AR));
+
+		if (ecmd.autoneg == AUTONEG_ENABLE){
+			/* no flow control */
+			advertise &= ~(MII_AR_CRTL_PAUSE | MII_AR_CTRL_PAUSE_ASY);
+
+			/* set speed and duplex */
+			if (ecmd.advertising & ADVERTISED_100baseT_Full) {
+				advertise |= MII_AR_100MB_FULLDUP;
+			} else {
+				advertise &= ~MII_AR_100MB_FULLDUP;
+			}
+			if (ecmd.advertising & ADVERTISED_100baseT_Half) {
+				advertise |= MII_AR_100MB_HALFDUP;
+			} else {
+				advertise &= ~MII_AR_100MB_HALFDUP;
+			}
+			if (ecmd.advertising & ADVERTISED_10baseT_Full) {
+				advertise |= MII_AR_10MB_FULLDUP;
+			} else {
+				advertise &= ~MII_AR_10MB_FULLDUP;
+			}
+			if (ecmd.advertising & ADVERTISED_10baseT_Half) {
+				advertise |= MII_AR_10MB_HALFDUP;
+			} else {
+				advertise &= ~MII_AR_10MB_HALFDUP;
+			}
+		} else {
+			/* erase all advertisements if autoneg is disabled */
+			advertise &= ~(MII_AR_CRTL_PAUSE | MII_AR_CTRL_PAUSE_ASY |
+						MII_AR_100MB_FULLDUP | MII_AR_100MB_HALFDUP | 
+						MII_AR_10MB_FULLDUP | MII_AR_10MB_HALFDUP);
+		}
+
+		mii_queue(dev, mk_mii_write(MII_LXT971_AR, advertise), NULL);
+
+		/* prepare new controls */
+		control =	mii_read(dev, mk_mii_read(MII_LXT971_AR));
+
+		/* force power up */
+		control &= ~MII_CR_POWERDOWN;
+
+		/* set autoneg */
+		if (ecmd.autoneg == AUTONEG_ENABLE) {
+			/* force autoneg */
+			/* don't touch speed and duplex */
+			control |= (MII_CR_ENABLE_NEG | MII_CR_RENEGOTIATE);
+		} else {
+			control &= ~(MII_CR_ENABLE_NEG | MII_CR_RENEGOTIATE);
+
+			/* force speed */
+			switch (ecmd.speed) {
+			case SPEED_100 :
+				control |= MII_CR_SPEED_100M;
+				break;
+			case SPEED_10 :
+			default :
+				control &= ~MII_CR_SPEED_100M;
+				break;
+			}
+
+			/* force duplex */
+			switch (ecmd.duplex) {
+			case DUPLEX_FULL :
+				control |= MII_CR_FULLDUPLEX;
+				break;
+			case DUPLEX_HALF :
+			default :
+				control &= ~MII_CR_FULLDUPLEX;
+				break;
+			}
+		}
+
+		/* force no loopback */
+		control &= ~MII_CR_LBK_MODE;
+
+		mii_queue(dev, mk_mii_write(MII_LXT971_CR, control), NULL);
+		/* changes must generate a link interrupt with a call */
+		/* to mii_relink which restarts the fcc */
+		break;
+
+	case ETHTOOL_GLINK:		/* Get link status */
+		mii_queue(dev, mk_mii_read(MII_LXT971_SR), mii_parse_sr);
+		evalue.data = fep->link;
+		if (copy_to_user(arg, &evalue, sizeof(evalue))) {
+			return -EFAULT;
+		}
+		break;
+
+	case ETHTOOL_GDRVINFO:	/* Get driver info. */
+	case ETHTOOL_GREGS:		/* Get NIC registers, privileged. */
+	case ETHTOOL_GWOL:		/* Get wake-on-lan options. */
+	case ETHTOOL_SWOL:		/* Set wake-on-lan options, priv. */
+	case ETHTOOL_GMSGLVL:	/* Get driver message level */
+	case ETHTOOL_SMSGLVL:	/* Set driver msg level, priv. */
+	case ETHTOOL_NWAY_RST:	/* Restart autonegotiation, priv. */
+	case ETHTOOL_GEEPROM:	/* Get EEPROM data */
+	case ETHTOOL_SEEPROM:	/* Set EEPROM data */
+	default:
+		rc = -EOPNOTSUPP;
+		break;
+	}
+
+	return rc;
+}
+#endif	/* CONFIG_USE_MDIO */
diff -Nurp linux-2.6.9.orig/arch/ppc/8260_io/fcc_enet.c.v110 linux-2.6.9/arch/ppc/8260_io/fcc_enet.c.v110
--- linux-2.6.9.orig/arch/ppc/8260_io/fcc_enet.c.v110	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.9/arch/ppc/8260_io/fcc_enet.c.v110	2006-09-07 18:57:01.000000000 +0200
@@ -0,0 +1,2307 @@
+/*
+ * Fast Ethernet Controller (FCC) driver for Motorola MPC8260.
+ * Copyright (c) 2000 MontaVista Software, Inc.   Dan Malek (dmalek@jlc.net)
+ *
+ * This version of the driver is a combination of the 8xx fec and
+ * 8260 SCC Ethernet drivers.  This version has some additional
+ * configuration options, which should probably be moved out of
+ * here.  This driver currently works for the EST SBC8260,
+ * SBS Diablo/BCM, Embedded Planet RPX6, TQM8260, and others.
+ *
+ * Right now, I am very watseful with the buffers.  I allocate memory
+ * pages and then divide them into 2K frame buffers.  This way I know I
+ * have buffers large enough to hold one frame within one buffer descriptor.
+ * Once I get this working, I will use 64 or 128 byte CPM buffers, which
+ * will be much more memory efficient and will easily handle lots of
+ * small packets.  Since this is a cache coherent processor and CPM,
+ * I could also preallocate SKB's and use them directly on the interface.
+ *
+ * Version 1.0.0
+ *  Add LXT971 PHY management
+ *  Add ETHTOOL and SIOC ioctls 
+ * Version 1.1.0
+ *  Add POWER_DOWN while ETHTOOL_SSET 
+ *  to always get PHY interrupt and restart FCC
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/ptrace.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/sockios.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/workqueue.h>
+
+#include <asm/immap_cpm2.h>
+#include <asm/pgtable.h>
+#include <asm/mpc8260.h>
+#include <asm/irq.h>
+#include <asm/bitops.h>
+#include <asm/uaccess.h>
+#include <asm/cpm2.h>
+#include <platforms/pq2pmca.h>
+
+/*--------------------------------------------------------------------------*/
+/*    DEFINITIONS AND STRUCTURES FOR MII PHY                                */
+/*--------------------------------------------------------------------------*/
+#ifdef CONFIG_USE_MDIO
+/* Register definitions for the PHY. */
+#define MII_LXT971_CR			0			/* Control Register				*/
+#define MII_LXT971_SR			1			/* Status Register				*/
+#define MII_LXT971_IR1			2			/* Identification Register 1	*/
+#define MII_LXT971_IR2			3			/* Identification Register 2	*/
+#define MII_LXT971_AR			4			/* A-N Advertisement Register	*/
+#define MII_LXT971_SR2			17			/* Status Register 2			*/
+#define MII_LXT971_IER			18			/* Interrupt Enable Register	*/
+#define MII_LXT971_ISR			19			/* Interrupt Status Register	*/
+
+/* MII_LXT971_CR definitions */
+#define MII_CR_RESET			0x8000		 /* Reset the MII chip			*/
+#define MII_CR_LBK_MODE			0x4000		 /* The MII PHY is in loopback	*/
+#define MII_CR_SPEED_100M		0x2000		 /* 100Mbps speed selected		*/
+#define MII_CR_ENABLE_NEG		0x1000		 /* Enable autonegociation		*/
+#define MII_CR_POWERDOWN		0x0800		 /* Power down mode				*/
+#define MII_CR_ISOEN			0x0400		 /* Enable isolate mode			*/
+#define MII_CR_RENEGOTIATE		0x0200		 /* Re-negotiate the link speed	*/
+#define MII_CR_FULLDUPLEX		0x0100		 /* Link in Full duplex mode	*/
+#define MII_CR_COLEN			0x0080		 /* Collision test control		*/
+
+/* MII_LXT971_SR definitions */
+#define MII_SR_100FULLDUPLEX	0x4000		/* Link is 100Mbps full duplex	*/
+#define MII_SR_100HALFDUPLEX	0x2000		/* Link is 100Mbps half duplex	*/
+#define MII_SR_10FULLDUPLEX		0x1000		/* Link is 10Mbps full duplex	*/
+#define MII_SR_10HALFDUPLEX		0x0800		/* Link is 10Mbps half duplex	*/
+#define MII_SR_AUTONEG_DONE		0x0020		/* Autonegotiation is complete	*/
+#define MII_SR_REMOTE_FAULT		0x0010		/* Remote fault detected		*/
+#define MII_SR_LINKUP			0x0004		/* The Link is up				*/
+
+/* MII_LXT971_IR1 definitions */
+#define MII_IR1_ID				0x0013		/* LXT971 ident part1			*/
+
+/* MII_LXT971_IR2 definitions */
+#define MII_IR2_ID				0x78E0		/* LXT971 ident part2 			*/
+
+/* MII_LXT971_AR definitions */
+#define MII_AR_REMOTEFAULT		0x2000		/* Remote fault 				*/
+#define MII_AR_CTRL_PAUSE_ASY	0x0800		/* Assymetric pause				*/
+#define MII_AR_CRTL_PAUSE		0x0400	 	/* Pause						*/
+#define MII_AR_100MB_FULLDUP	0x0100		/* 100Mbs full duplex capable	*/
+#define MII_AR_100MB_HALFDUP	0x0080		/* 100Mbs half duplex capable	*/
+#define MII_AR_10MB_FULLDUP		0x0040		/* 10Mbs full duplex capable	*/
+#define MII_AR_10MB_HALFDUP		0x0020		/* 10Mbs half duplex capable	*/
+#define MII_AR_SELECTOR			0x0001		/* 802.3 protocol               */
+
+/* MII_LXT971_SR2 definitions */
+#define MII_SR2_100_TX			0x4000		/* 100Mbs TX mode				*/
+#define MII_SR2_LINK_UP			0x0400		/* Link is up					*/
+#define MII_SR2_FULL_DUP		0x0200		/* Full duplex mode				*/
+#define MII_SR2_AUTO_EN			0x0100		/* A-N enabled					*/
+#define MII_SR2_AUTO_COMPL		0x0080		/* A-N complete					*/
+#define MII_SR2_ERROR			0x0008		/* Error        				*/
+
+/* MII_LXT971_IER definitions */
+#define MII_IER_TINT			0x0001		/* Force it on #MDINT pin		*/
+#define MII_IER_INTEN			0x0002		/* Enable/Disable it			*/
+#define MII_IER_LNK_MSK			0x0010		/* Mask for link status it		*/
+#define MII_IER_DUP_MSK			0x0020		/* Mask for duplex status it	*/
+#define MII_IER_SPD_MSK			0x0040		/* Mask for speed status it		*/
+#define MII_IER_ANC_MSK			0x0080		/* Mask for A-N Complete		*/
+
+/* MII_LXT971_ISR definitions */
+#define MII_ISR_MDINT			0x0040		/* MII it pending				*/
+#define MII_ISR_LNK_CHG			0x0010		/* Link Status change			*/
+#define MII_ISR_DUP_CHG			0x0020		/* Duplex Status change			*/
+#define MII_ISR_SPD_CHG			0x0040		/* Speed Status change			*/
+#define MII_ISR_ANC_CHG			0x0080		/* A-N Status change			*/
+
+/* Values for phy_status, not register bit definitions */
+#define PHY_CONF_ANE			0x0001		/* 1 auto-negotiation enabled	*/
+#define PHY_CONF_LOOP			0x0002		/* 1 loopback mode enabled		*/
+#define PHY_CONF_SPMASK			0x00f0		/* mask for speed				*/
+#define PHY_CONF_10HDX			0x0010		/* 10Mbs half duplex supported 	*/
+#define PHY_CONF_10FDX			0x0020		/* 10Mbs full duplex supported 	*/
+#define PHY_CONF_100HDX			0x0040		/* 100Mbs half duplex supported */
+#define PHY_CONF_100FDX			0x0080		/* 100Mbs full duplex supported */
+
+#define PHY_STAT_LINK			0x0100		/* 1 up - 0 down 				*/
+#define PHY_STAT_FAULT			0x0200		/* 1 remote fault 				*/
+#define PHY_STAT_ANC			0x0400		/* 1 auto-negotiation complete	*/
+#define PHY_STAT_SPMASK			0xf000		/* mask for speed 				*/
+#define PHY_STAT_10HDX			0x1000		/* 10Mbs half duplex selected	*/
+#define PHY_STAT_10FDX			0x2000		/* 10Mbs full duplex selected	*/
+#define PHY_STAT_100HDX			0x4000		/* 100Mbs half duplex selected 	*/
+#define PHY_STAT_100FDX			0x8000		/* 100Mbs full duplex selected 	*/
+
+/* Make MII read/write commands for the FCC. */
+#define mk_mii_read(REG)		(0x60020000 | ((REG & 0x1f) << 18))
+#define mk_mii_write(REG, VAL)	(0x50020000 | ((REG & 0x1f) << 18) | \
+								(VAL & 0xffff))
+#define mk_mii_end				0
+
+#define FCC_PDATD_MDIO(bit)				\
+	if (bit)							\
+		io->iop_pdatd |= fip->fc_mdio;	\
+	else								\
+		io->iop_pdatd &= ~fip->fc_mdio;
+
+#define FCC_PDATD_MDC(bit)				\
+	if (bit)							\
+		io->iop_pdatd |= fip->fc_mdck;	\
+	else								\
+		io->iop_pdatd &= ~fip->fc_mdck;
+
+typedef struct {
+	uint mii_data;
+	void (*funct)(uint mii_reg, struct net_device *dev);
+} phy_cmd_t;
+
+typedef struct {
+	uint id;
+	char *name;
+	const phy_cmd_t *config;
+	const phy_cmd_t *startup;
+	const phy_cmd_t *ack_int;
+	const phy_cmd_t *shutdown;
+} phy_info_t;
+
+#endif	/* CONFIG_USE_MDIO */
+
+#ifdef CONFIG_USE_MDIO
+#define PC_MDIO		((uint)(1 << (31 - 11)))	/* PD11 */
+#define PC_MDCK		((uint)(1 << (31 - 10)))	/* PD10 */
+#if !defined(PC_MDIO) || !defined(PC_MDCK)
+#error Must define PC_MDIO and PC_MDCK if using MDIO
+#endif
+#else	/* ifdef CONFIG_USE_MDIO */
+#undef	PC_MDIO
+#undef	PC_MDCK
+#define PC_MDIO		((uint)0x00000000)
+#define PC_MDCK		((uint)0x00000000)
+#endif	/* ifdef CONFIG_USE_MDIO */
+
+/*--------------------------------------------------------------------------*/
+/*    DEFINITIONS AND STRUCTURES FOR FCC                                    */
+/*--------------------------------------------------------------------------*/
+#define TX_TIMEOUT  (2*HZ) /* The transmitter timeout */
+
+/* The number of Tx and Rx buffers.  These are allocated from the page
+ * pool.  The code may assume these are power of two, so it is best
+ * to keep them that size.
+ * We don't need to allocate pages for the transmitter.  We just use
+ * the skbuffer directly.
+ */
+#define FCC_ENET_RX_PAGES	16
+#define FCC_ENET_RX_FRSIZE	2048
+#define FCC_ENET_RX_FRPPG	(PAGE_SIZE / FCC_ENET_RX_FRSIZE)
+#define RX_RING_SIZE		(FCC_ENET_RX_FRPPG * FCC_ENET_RX_PAGES)
+#define TX_RING_SIZE		16	/* Must be power of two */
+#define TX_RING_MOD_MASK	15	/*   for this to work */
+
+/* The FCC stores dest/src/type, data, and checksum for receive packets.
+ */
+#define PKT_MAXBUF_SIZE		1518
+#define PKT_MINBUF_SIZE		64
+
+/* Maximum input DMA size.  Must be a should(?) be a multiple of 4.
+*/
+#define PKT_MAXDMA_SIZE		1520
+
+/* Maximum input buffer size.  Must be a multiple of 32.
+*/
+#define PKT_MAXBLR_SIZE		1536
+
+/*******************************/
+/* I/O Pin assignment for FCC1 */
+/*******************************/
+#define PA1_COL			((uint)0x00000001)
+#define PA1_CRS			((uint)0x00000002)
+#define PA1_TXER		((uint)0x00000004)
+#define PA1_TXEN		((uint)0x00000008)
+#define PA1_RXDV		((uint)0x00000010)
+#define PA1_RXER		((uint)0x00000020)
+#define PA1_TXDAT		((uint)0x00003c00)
+#define PA1_RXDAT		((uint)0x0003c000)
+#define PA1_PSORA0		(PA1_RXDAT | PA1_TXDAT)
+#define PA1_PSORA1		(PA1_COL | PA1_CRS | PA1_TXER | PA1_TXEN | \
+						PA1_RXDV | PA1_RXER)
+#define PA1_DIRA0		(PA1_RXDAT | PA1_CRS | PA1_COL | PA1_RXER | PA1_RXDV)
+#define PA1_DIRA1		(PA1_TXDAT | PA1_TXEN | PA1_TXER)
+
+/* CLK10 is receive, CLK9 is transmit.	These are board specific. */
+#define PC_F1RXCLK		((uint)0x00000200)
+#define PC_F1TXCLK		((uint)0x00000100)
+#define CMX1_CLK_ROUTE	((uint)0x2C000000)
+#define CMX1_CLK_MASK	 ((uint)0xff000000)
+
+/*******************************/
+/* I/O Pin assignment for FCC2 */
+/*******************************/
+#define PB2_TXER		((uint)0x00000001)
+#define PB2_RXDV		((uint)0x00000002)
+#define PB2_TXEN		((uint)0x00000004)
+#define PB2_RXER		((uint)0x00000008)
+#define PB2_COL			((uint)0x00000010)
+#define PB2_CRS			((uint)0x00000020)
+#define PB2_TXDAT		((uint)0x000003c0)
+#define PB2_RXDAT		((uint)0x00003c00)
+#define PB2_PSORB0		(PB2_RXDAT | PB2_TXDAT | PB2_CRS | PB2_COL | \
+						PB2_RXER | PB2_RXDV | PB2_TXER)
+#define PB2_PSORB1		(PB2_TXEN)
+#define PB2_DIRB0		(PB2_RXDAT | PB2_CRS | PB2_COL | PB2_RXER | PB2_RXDV)
+#define PB2_DIRB1		(PB2_TXDAT | PB2_TXEN | PB2_TXER)
+
+/* CLK14 is receive, CLK13 is transmit.	These are board dependent. */
+#define PC_F2RXCLK		((uint)0x00002000)
+#define PC_F2TXCLK		((uint)0x00001000)
+#define CMX2_CLK_ROUTE	((uint)0x002C0000)
+#define CMX2_CLK_MASK	((uint)0x00ff0000)
+
+/*******************************/
+/* I/O Pin assignment for FCC3 */
+/*******************************/
+#define PB3_RXDV		((uint)0x00004000)
+#define PB3_RXER		((uint)0x00008000)
+#define PB3_TXER		((uint)0x00010000)
+#define PB3_TXEN		((uint)0x00020000)
+#define PB3_COL			((uint)0x00040000)
+#define PB3_CRS			((uint)0x00080000)
+#define PB3_TXDAT		((uint)0x0f000000)
+#define PB3_RXDAT		((uint)0x00f00000)
+#define PB3_PSORB0		(PB3_RXDAT | PB3_TXDAT | PB3_CRS | PB3_COL | \
+						PB3_RXER | PB3_RXDV | PB3_TXER | PB3_TXEN)
+#define PB3_PSORB1		(0)
+#define PB3_DIRB0		(PB3_RXDAT | PB3_CRS | PB3_COL | PB3_RXER | PB3_RXDV)
+#define PB3_DIRB1		(PB3_TXDAT | PB3_TXEN | PB3_TXER)
+
+/* CLK16 is receive, CLK15 is transmit.	These are board dependent. */
+#define PC_F3RXCLK		((uint)0x00008000)
+#define PC_F3TXCLK		((uint)0x00004000)
+#define CMX3_CLK_ROUTE	((uint)0x00003E00)
+#define CMX3_CLK_MASK	((uint)0x0000ff00)
+
+/* A table of information for supporting FCCs.  This does two things.
+ * First, we know how many FCCs we have and they are always externally
+ * numbered from zero.  Second, it holds control register and I/O
+ * information that could be different among board designs.
+ */
+typedef struct fcc_info {
+	uint	fc_fccnum;
+	uint	fc_cpmblock;
+	uint	fc_cpmpage;
+	uint	fc_proff;
+	uint	fc_interrupt;
+	uint	fc_trxclocks;
+	uint	fc_clockroute;
+	uint	fc_clockmask;
+	uint	fc_mdio;
+	uint	fc_mdck;
+	uint	fc_phy_interrupt;
+} fcc_info_t;
+
+/* The FCC buffer descriptors track the ring buffers.  The rx_bd_base and
+ * tx_bd_base always point to the base of the buffer descriptors.  The
+ * cur_rx and cur_tx point to the currently available buffer.
+ * The dirty_tx tracks the current buffer that is being sent by the
+ * controller.  The cur_tx and dirty_tx are equal under both completely
+ * empty and completely full conditions.  The empty/ready indicator in
+ * the buffer descriptor determines the actual condition.
+ */
+struct fcc_enet_private {
+	/* The saved address of a sent-in-place packet/buffer, for skfree(). */
+	struct	sk_buff* tx_skbuff[TX_RING_SIZE];
+	ushort	skb_cur;
+	ushort	skb_dirty;
+
+	/* CPM dual port RAM relative addresses.
+	*/
+	cbd_t	*rx_bd_base;		/* Address of Rx and Tx buffers. */
+	cbd_t	*tx_bd_base;
+	cbd_t	*cur_rx, *cur_tx;		/* The next free ring entry */
+	cbd_t	*dirty_tx;	/* The ring entries to be free()ed. */
+	volatile fcc_t	*fccp;
+	volatile fcc_enet_t	*ep;
+	struct	net_device_stats stats;
+	uint	tx_free;
+	spinlock_t lock;
+
+#ifdef	CONFIG_USE_MDIO
+	uint	phy_id;
+	uint	phy_id_done;
+	uint	phy_status;
+	phy_info_t	*phy;
+	struct work_struct phy_relink;
+	struct work_struct phy_display_config;
+	uint	sequence_done;
+	uint	phy_addr;
+#endif	/* CONFIG_USE_MDIO */
+
+	int	link;
+	int	old_link;
+	int	full_duplex;
+
+	fcc_info_t	*fip;
+};
+
+/*--------------------------------------------------------------------------*/
+/*						PROTOTYPES FOR MII PHY								*/
+/*--------------------------------------------------------------------------*/
+#ifdef  CONFIG_USE_MDIO
+static	int		mii_queue
+				(struct net_device *dev, int request, 
+				 void (*func)(uint, struct net_device *));
+static	void	mii_do_cmd			
+				(struct net_device *dev, const phy_cmd_t *c);
+static	void	mii_parse_sr		(uint mii_reg, struct net_device *dev);
+static	void	mii_parse_cr		(uint mii_reg, struct net_device *dev);
+static	void	mii_parse_ar		(uint mii_reg, struct net_device *dev);
+static	void	mii_parse_sr2		(uint mii_reg, struct net_device *dev);
+static	void	mii_display_status	(struct net_device *dev);
+static	void	mii_display_config	(struct net_device *dev);
+static	void	mii_relink			(struct net_device *dev);
+static	void	mii_queue_relink	(uint mii_reg, struct net_device *dev);
+static	void	mii_queue_config	(uint mii_reg, struct net_device *dev);
+static	void	mii_discover_phy3	(uint mii_reg, struct net_device *dev);
+static	void	mii_discover_phy	(uint mii_reg, struct net_device *dev);
+static	irqreturn_t mii_link_interrupt
+				(int irq, void * dev_id, struct pt_regs * regs);
+static	uint	mii_send_receive(fcc_info_t *fip, uint cmd);
+
+static	int		fcc_enet_ioctl		
+				(struct net_device *dev, struct ifreq *rq, int cmd);
+static	int		fcc_ethtool_ioctl	(struct net_device *dev, void *useraddr);
+#endif	/* CONFIG_USE_MDIO */
+
+/*--------------------------------------------------------------------------*/
+/*						PROTOTYPES FOR FCC									*/
+/*--------------------------------------------------------------------------*/
+static	int		fcc_enet_start_xmit		
+				(struct sk_buff *skb, struct net_device *dev);
+static	void	fcc_enet_timeout	(struct net_device *dev);
+static	irqreturn_t fcc_enet_interrupt
+				(int irq, void *dev_id, struct pt_regs *);
+static	int		fcc_enet_rx			(struct net_device *dev);
+static	int		fcc_enet_close		(struct net_device *dev);
+static	struct net_device_stats 
+				*fcc_enet_get_stats	(struct net_device *dev);
+static	void	set_multicast_list			(struct net_device *dev);
+static	int		fcc_enet_set_mac_address	
+				(struct net_device *dev, void *addr);
+static	int		fec_enet_init				(void);
+static	void	init_fcc_shutdown	
+				(fcc_info_t *fip, struct fcc_enet_private *cep,
+				volatile cpm2_map_t *immap);
+static	void	init_fcc_ioports
+				(fcc_info_t *fip, volatile iop_cpm2_t *io,
+				volatile cpm2_map_t *immap);
+static	void	init_fcc_param				
+				(fcc_info_t *fip, struct net_device *dev, 
+				volatile cpm2_map_t *immap);
+static	void	init_fcc_startup
+				(fcc_info_t *fip, struct net_device *dev);
+
+static	void	fcc_stop			(struct net_device *dev);
+static	void	fcc_restart			(struct net_device *dev, int duplex);
+static	int		fcc_enet_open		(struct net_device *dev);
+
+/*--------------------------------------------------------------------------*/
+/*                      GLOBAL VARIABLES FOR MII PHY                        */
+/*--------------------------------------------------------------------------*/
+#ifdef CONFIG_USE_MDIO
+static phy_info_t phy_info_lxt971 = {
+	0x0001378e,
+	"LXT971",
+
+	(const phy_cmd_t []) {	/* config */
+		/* 10 Mbps half duplex, 802.3 */
+		/* GG NO keep boot init */
+		/* { mk_mii_write(MII_LXT971_AR, 0x021), NULL }, */
+		{ mk_mii_read(MII_LXT971_CR), mii_parse_cr },
+		{ mk_mii_read(MII_LXT971_AR), mii_parse_ar },
+		/* read status to display right status */
+		{ mk_mii_read(MII_LXT971_SR), mii_parse_sr },
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) {	/* startup */
+		/* enable only phy link interrupt */
+		{ mk_mii_write(MII_LXT971_IER, (MII_IER_INTEN | MII_IER_LNK_MSK)), NULL },
+		/* enable autoneg , restart autoneg */
+		/* GG NO keep boot init */
+		/* { mk_mii_write(MII_LXT971_CR, 0x1200), NULL }, */
+
+		/* Somehow does the 971 tell me that the link is down
+		 * the first read after power-up.
+		 * read here to get a valid value in ack_int */
+		{ mk_mii_read(MII_LXT971_SR), mii_parse_sr },
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) { /* ack_int */
+		/* find out the current status */
+		{ mk_mii_read(MII_LXT971_SR), mii_parse_sr },
+		{ mk_mii_read(MII_LXT971_SR2), mii_parse_sr2 },
+
+		/* we only need to read ISR to acknowledge */
+		{ mk_mii_read(MII_LXT971_ISR), NULL },
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) {	/* shutdown */
+		/* disable all interrupts */
+		/* link, duplex, speed and autoneg complete */
+		{ mk_mii_write(MII_LXT971_IER, 0x0000), NULL },
+		{ mk_mii_end, }
+	},
+};
+
+static phy_info_t *phy_info[] = {
+	&phy_info_lxt971,
+	NULL
+};
+
+phy_cmd_t phy_cmd_relink[] = { { mk_mii_read(MII_LXT971_CR), mii_queue_relink },
+						 { mk_mii_end, } };
+phy_cmd_t phy_cmd_config[] = { { mk_mii_read(MII_LXT971_CR), mii_queue_config },
+						 { mk_mii_end, } };
+#endif 
+
+static fcc_info_t fcc_ports[] = {
+#ifdef CONFIG_FCC1_ENET
+	{ 0, CPM_CR_FCC1_SBLOCK, CPM_CR_FCC1_PAGE, PROFF_FCC1, SIU_INT_FCC1,
+		(PC_F1RXCLK | PC_F1TXCLK), CMX1_CLK_ROUTE, CMX1_CLK_MASK,
+		PC_MDIO, PC_MDCK, SIU_INT_IRQ2 },
+#endif
+#ifdef CONFIG_FCC2_ENET
+	{ 1, CPM_CR_FCC2_SBLOCK, CPM_CR_FCC2_PAGE, PROFF_FCC2, SIU_INT_FCC2,
+		(PC_F2RXCLK | PC_F2TXCLK), CMX2_CLK_ROUTE, CMX2_CLK_MASK,
+		PC_MDIO, PC_MDCK, SIU_INT_IRQ3 },
+#endif
+#ifdef CONFIG_FCC3_ENET
+	{ 2, CPM_CR_FCC3_SBLOCK, CPM_CR_FCC3_PAGE, PROFF_FCC3, SIU_INT_FCC3,
+		(PC_F3RXCLK | PC_F3TXCLK), CMX3_CLK_ROUTE, CMX3_CLK_MASK,
+		PC_MDIO, PC_MDCK, SIU_INT_IRQ4 },
+#endif
+};
+
+/*--------------------------------------------------------------------------*/
+/*                          FUNCTIONS                                       */
+/*--------------------------------------------------------------------------*/
+
+static int
+fcc_enet_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct fcc_enet_private *cep = (struct fcc_enet_private *)dev->priv;
+	volatile cbd_t	*bdp;
+
+	/* GG what to do if link is down ?	*/
+	/* nothing or						*/
+	/* just return 1					*/
+	/* or netif_stop_queue and return 1	*/
+	/* nothing per default				*/
+
+	/* Fill in a Tx ring entry */
+	bdp = cep->cur_tx;
+
+#ifndef final_version
+	if (!cep->tx_free || (bdp->cbd_sc & BD_ENET_TX_READY)) {
+		/* Ooops.  All transmit buffers are full.  Bail out.
+		 * This should not happen, since the tx queue should be stopped.
+		 */
+		printk("%s: tx queue full!.\n", dev->name);
+		return 1;
+	}
+#endif
+
+	/* Clear all of the status flags. */
+	bdp->cbd_sc &= ~BD_ENET_TX_STATS;
+
+	/* If the frame is short, tell CPM to pad it. */
+	if (skb->len <= ETH_ZLEN)
+		bdp->cbd_sc |= BD_ENET_TX_PAD;
+	else
+		bdp->cbd_sc &= ~BD_ENET_TX_PAD;
+
+	/* Set buffer length and buffer pointer. */
+	bdp->cbd_datlen = skb->len;
+	bdp->cbd_bufaddr = __pa(skb->data);
+
+	spin_lock_irq(&cep->lock);
+
+	/* Save skb pointer. */
+	cep->tx_skbuff[cep->skb_cur] = skb;
+
+	cep->stats.tx_bytes += skb->len;
+	cep->skb_cur = (cep->skb_cur+1) & TX_RING_MOD_MASK;
+
+	/* Send it on its way.  Tell CPM its ready, interrupt when done,
+	 * its the last BD of the frame, and to put the CRC on the end.
+	 */
+	bdp->cbd_sc |= (BD_ENET_TX_READY | BD_ENET_TX_INTR | BD_ENET_TX_LAST | BD_ENET_TX_TC);
+
+#if 0
+	/* Errata says don't do this. */
+	cep->fccp->fcc_ftodr = 0x8000;
+#endif
+	dev->trans_start = jiffies;
+
+	/* If this was the last BD in the ring, start at the beginning again. */
+	if (bdp->cbd_sc & BD_ENET_TX_WRAP)
+		bdp = cep->tx_bd_base;
+	else
+		bdp++;
+
+	if (!--cep->tx_free)
+		netif_stop_queue(dev);
+
+	cep->cur_tx = (cbd_t *)bdp;
+
+	spin_unlock_irq(&cep->lock);
+
+	return 0;
+}
+
+static void
+fcc_enet_timeout(struct net_device *dev)
+{
+	volatile cbd_t			*bdp;
+	struct fcc_enet_private *cep;
+	volatile	fcc_enet_t	*ep;
+	volatile cpm_cpm2_t *cp;
+
+	int 					i;
+	int						must_restart = 0;
+
+	cep = (struct fcc_enet_private *)(dev->priv);
+	ep = cep->ep;
+	cp = cpmp;
+
+#if 0
+	printk("cur_tx=%p tx_free=%d tbptr=%08x dirty_tx=%p cur_rx=%p rbptr=%08x\n",
+		cep->cur_tx, cep->tx_free,
+		ep->fen_genfcc.fcc_tbptr, cep->dirty_tx,
+		cep->cur_rx, ep->fen_genfcc.fcc_rbptr);
+
+	/* display tx bd */
+	bdp = cep->tx_bd_base;
+	printk("TX bdp      sc   len  buff\n");
+	for (i = 0 ; i < TX_RING_SIZE; i++, bdp++) {
+		printk("   %p %04x %04x %08x\n",
+				bdp, bdp->cbd_sc, bdp->cbd_datlen, bdp->cbd_bufaddr);
+		printk("|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|\n",
+				((bdp->cbd_sc & BD_ENET_TX_READY)  ? "RDY " : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_PAD)    ? "PAD " : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_WRAP)   ? "WRAP" : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_INTR)   ? "INTR" : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_LAST)   ? "LAST" : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_TC)     ? "TC  " : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_DEF)    ? "DEF " : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_HB)     ? "HB  " : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_LC)     ? "LC  " : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_RL)     ? "RL  " : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_RCMASK) ? "RCMK" : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_UN)     ? "UN  " : "    "),
+				((bdp->cbd_sc & BD_ENET_TX_CSL)    ? "CSL " : "    "));
+	}
+
+	bdp = cep->rx_bd_base;
+	printk("RX bdp      sc   len  buff\n");
+	for (i = 0 ; i < RX_RING_SIZE; i++, bdp++) {
+		printk("   %p %04x %04x %08x\n",
+				bdp, bdp->cbd_sc, bdp->cbd_datlen, bdp->cbd_bufaddr);
+	}
+#endif /* GG */
+
+	/* GG start of workaround for the CPM112 bug */
+	spin_lock_irq(&cep->lock);
+
+	/* stop TX */
+	cp->cp_cpcr = mk_cr_cmd(cep->fip->fc_cpmpage, cep->fip->fc_cpmblock,
+							0x0c, CPM_CR_STOP_TX) | CPM_CR_FLG;
+	while (cp->cp_cpcr & CPM_CR_FLG);
+
+	/* disable TX */
+	cep->fccp->fcc_gfmr &= ~FCC_GFMR_ENT;
+
+	/* clear all bds */
+	bdp = cep->tx_bd_base;
+	for (i = 0 ; i < TX_RING_SIZE; i++, bdp++) {
+		if (bdp->cbd_sc & BD_ENET_TX_READY) {
+			cep->stats.tx_packets++;
+			bdp->cbd_sc &= ~BD_ENET_TX_READY;
+		}
+
+		if (bdp->cbd_sc & BD_ENET_TX_HB) {	/* warning : no heartbeat */
+			cep->stats.tx_heartbeat_errors++;
+			bdp->cbd_sc &= ~BD_ENET_TX_HB;
+		}
+		if (bdp->cbd_sc & BD_ENET_TX_LC) {	/* error : late collision */
+			must_restart = 1;
+			cep->stats.tx_errors++;
+			cep->stats.tx_window_errors++;
+			bdp->cbd_sc &= ~BD_ENET_TX_LC;
+		}
+		if (bdp->cbd_sc & BD_ENET_TX_RL) {	/* error : retrans limit */
+			must_restart = 1;
+			cep->stats.tx_errors++;
+			cep->stats.tx_aborted_errors++;
+			bdp->cbd_sc &= ~BD_ENET_TX_RL;
+		}
+		if (bdp->cbd_sc & BD_ENET_TX_UN) {	/* error : underrun */
+			must_restart = 1;
+			cep->stats.tx_errors++;
+			cep->stats.tx_fifo_errors++;
+			bdp->cbd_sc &= ~BD_ENET_TX_UN;
+		}
+		if (bdp->cbd_sc & BD_ENET_TX_CSL) {	/* warning : carrier lost */
+			cep->stats.tx_carrier_errors++;
+			bdp->cbd_sc &= ~BD_ENET_TX_CSL;
+		}
+		if (bdp->cbd_sc & BD_ENET_TX_DEF) { /* warning : deferred */
+			cep->stats.collisions++;
+			bdp->cbd_sc &= ~BD_ENET_TX_DEF;
+		}
+
+		/* free the sk buffer associated with this last transmit. */
+		if (cep->tx_skbuff[cep->skb_dirty] != NULL) {
+			dev_kfree_skb_irq(cep->tx_skbuff[cep->skb_dirty]);
+			cep->tx_skbuff[cep->skb_dirty] = NULL;
+			cep->skb_dirty = (cep->skb_dirty + 1) & TX_RING_MOD_MASK;
+		}
+	}
+
+	/* reinit all params */
+	dev->trans_start = jiffies;
+	cep->dirty_tx = cep->cur_tx = cep->tx_bd_base;
+	ep->fen_genfcc.fcc_tbptr = __pa(cep->tx_bd_base);
+	
+	/* enable TX */
+	cep->fccp->fcc_gfmr |= FCC_GFMR_ENT;
+	
+	/* restart TX */
+	cp->cp_cpcr = mk_cr_cmd(cep->fip->fc_cpmpage, cep->fip->fc_cpmblock,
+							0x0c, CPM_CR_RESTART_TX) | CPM_CR_FLG;
+	while (cp->cp_cpcr & CPM_CR_FLG);
+
+	/* release interrupt */
+	spin_unlock(&cep->lock);
+
+	/* GG end of workaround for the CPM112 bug */
+
+	/* all bds are fee */
+	cep->tx_free = TX_RING_SIZE;
+	netif_wake_queue(dev);
+}
+
+/* The interrupt handler. */
+static irqreturn_t
+fcc_enet_interrupt(int irq, void * dev_id, struct pt_regs * regs)
+{
+	struct	net_device *dev = dev_id;
+	volatile struct	fcc_enet_private *cep;
+	volatile cbd_t	*bdp;
+	ushort	int_events;
+	int	must_restart;
+
+	cep = (struct fcc_enet_private *)dev->priv;
+
+	/* Get the interrupt events that caused us to be here.
+	*/
+	int_events = cep->fccp->fcc_fcce;
+	cep->fccp->fcc_fcce = (int_events & cep->fccp->fcc_fccm);
+	must_restart = 0;
+
+#ifdef CONFIG_USE_MDIO
+	/* We have to be careful here to make sure that we aren't
+	 * interrupted by a PHY interrupt.
+	 */
+	disable_irq_nosync(cep->fip->fc_phy_interrupt);
+#endif
+
+	/* Handle receive event in its own function.
+	*/
+	if (int_events & FCC_ENET_RXF)
+		fcc_enet_rx(dev_id);
+
+	/* Check for a transmit error.  The manual is a little unclear
+	 * about this, so the debug code until I get it figured out.  It
+	 * appears that if TXE is set, then TXB is not set.  However,
+	 * if carrier sense is lost during frame transmission, the TXE
+	 * bit is set, "and continues the buffer transmission normally."
+	 * I don't know if "normally" implies TXB is set when the buffer
+	 * descriptor is closed.....trial and error :-).
+	 */
+
+	/* Transmit OK, or non-fatal error.  Update the buffer descriptors.
+	*/
+	if (int_events & (FCC_ENET_TXE | FCC_ENET_TXB)) {
+	    spin_lock(&cep->lock);
+	    bdp = cep->dirty_tx;
+	    while ((bdp->cbd_sc&BD_ENET_TX_READY)==0) {
+		if (cep->tx_free == TX_RING_SIZE)
+		    break;
+
+		if (bdp->cbd_sc & BD_ENET_TX_HB)	/* No heartbeat */
+			cep->stats.tx_heartbeat_errors++;
+		if (bdp->cbd_sc & BD_ENET_TX_LC)	/* Late collision */
+			cep->stats.tx_window_errors++;
+		if (bdp->cbd_sc & BD_ENET_TX_RL)	/* Retrans limit */
+			cep->stats.tx_aborted_errors++;
+		if (bdp->cbd_sc & BD_ENET_TX_UN)	/* Underrun */
+			cep->stats.tx_fifo_errors++;
+		if (bdp->cbd_sc & BD_ENET_TX_CSL)	/* Carrier lost */
+			cep->stats.tx_carrier_errors++;
+
+
+		/* No heartbeat or Lost carrier are not really bad errors.
+		 * The others require a restart transmit command.
+		 */
+		if (bdp->cbd_sc &
+		    (BD_ENET_TX_LC | BD_ENET_TX_RL | BD_ENET_TX_UN)) {
+			must_restart = 1;
+			cep->stats.tx_errors++;
+		}
+
+		cep->stats.tx_packets++;
+
+		/* Deferred means some collisions occurred during transmit,
+		 * but we eventually sent the packet OK.
+		 */
+		if (bdp->cbd_sc & BD_ENET_TX_DEF)
+			cep->stats.collisions++;
+
+		/* Free the sk buffer associated with this last transmit. */
+		dev_kfree_skb_irq(cep->tx_skbuff[cep->skb_dirty]);
+		cep->tx_skbuff[cep->skb_dirty] = NULL;
+		cep->skb_dirty = (cep->skb_dirty + 1) & TX_RING_MOD_MASK;
+
+		/* Update pointer to next buffer descriptor to be transmitted. */
+		if (bdp->cbd_sc & BD_ENET_TX_WRAP)
+			bdp = cep->tx_bd_base;
+		else
+			bdp++;
+
+		/* I don't know if we can be held off from processing these
+		 * interrupts for more than one frame time.  I really hope
+		 * not.  In such a case, we would now want to check the
+		 * currently available BD (cur_tx) and determine if any
+		 * buffers between the dirty_tx and cur_tx have also been
+		 * sent.  We would want to process anything in between that
+		 * does not have BD_ENET_TX_READY set.
+		 */
+
+		/* Since we have freed up a buffer, the ring is no longer
+		 * full.
+		 */
+		if (!cep->tx_free++) {
+			if (netif_queue_stopped(dev)) {
+				netif_wake_queue(dev);
+			}
+		}
+
+		cep->dirty_tx = (cbd_t *)bdp;
+	    }
+
+	    if (must_restart) {
+		volatile cpm_cpm2_t *cp;
+
+		/* Some transmit errors cause the transmitter to shut
+		 * down.  We now issue a restart transmit.  Since the
+		 * errors close the BD and update the pointers, the restart
+		 * _should_ pick up without having to reset any of our
+		 * pointers either.  Also, To workaround 8260 device erratum
+		 * CPM37, we must disable and then re-enable the transmitter
+		 * following a Late Collision, Underrun, or Retry Limit error.
+		 */
+		cep->fccp->fcc_gfmr &= ~FCC_GFMR_ENT;
+		udelay(10); /* wait a few microseconds just on principle */
+		cep->fccp->fcc_gfmr |=  FCC_GFMR_ENT;
+
+		cp = cpmp;
+		cp->cp_cpcr =
+		    mk_cr_cmd(cep->fip->fc_cpmpage, cep->fip->fc_cpmblock,
+		    		0x0c, CPM_CR_RESTART_TX) | CPM_CR_FLG;
+		while (cp->cp_cpcr & CPM_CR_FLG);
+	    }
+	    spin_unlock(&cep->lock);
+	}
+
+	/* Check for receive busy, i.e. packets coming but no place to
+	 * put them.
+	 */
+	if (int_events & FCC_ENET_BSY) {
+		cep->fccp->fcc_fcce = FCC_ENET_BSY;
+		cep->stats.rx_dropped++;
+	}
+
+#ifdef CONFIG_USE_MDIO
+	enable_irq(cep->fip->fc_phy_interrupt);
+#endif
+	return IRQ_HANDLED;
+}
+
+/* During a receive, the cur_rx points to the current incoming buffer.
+ * When we update through the ring, if the next incoming buffer has
+ * not been given to the system, we just set the empty indicator,
+ * effectively tossing the packet.
+ */
+static int
+fcc_enet_rx(struct net_device *dev)
+{
+	struct	fcc_enet_private *cep;
+	volatile cbd_t	*bdp;
+	struct	sk_buff *skb;
+	ushort	pkt_len;
+
+	cep = (struct fcc_enet_private *)dev->priv;
+
+	/* First, grab all of the stats for the incoming packet.
+	 * These get messed up if we get called due to a busy condition.
+	 */
+	bdp = cep->cur_rx;
+
+for (;;) {
+	if (bdp->cbd_sc & BD_ENET_RX_EMPTY)
+		break;
+
+#ifndef final_version
+	/* Since we have allocated space to hold a complete frame, both
+	 * the first and last indicators should be set.
+	 */
+	if ((bdp->cbd_sc & (BD_ENET_RX_FIRST | BD_ENET_RX_LAST)) !=
+		(BD_ENET_RX_FIRST | BD_ENET_RX_LAST))
+			printk("CPM ENET: rcv is not first+last\n");
+#endif
+
+	/* Frame too long or too short. */
+	if (bdp->cbd_sc & (BD_ENET_RX_LG | BD_ENET_RX_SH))
+		cep->stats.rx_length_errors++;
+	if (bdp->cbd_sc & BD_ENET_RX_NO)	/* Frame alignment */
+		cep->stats.rx_frame_errors++;
+	if (bdp->cbd_sc & BD_ENET_RX_CR)	/* CRC Error */
+		cep->stats.rx_crc_errors++;
+	if (bdp->cbd_sc & BD_ENET_RX_OV)	/* FIFO overrun */
+		cep->stats.rx_crc_errors++;
+	if (bdp->cbd_sc & BD_ENET_RX_CL)	/* Late Collision */
+		cep->stats.rx_frame_errors++;
+
+	if (!(bdp->cbd_sc &
+	      (BD_ENET_RX_LG | BD_ENET_RX_SH | BD_ENET_RX_NO | BD_ENET_RX_CR
+	       | BD_ENET_RX_OV | BD_ENET_RX_CL)))
+	{
+		/* Process the incoming frame. */
+		cep->stats.rx_packets++;
+
+		/* Remove the FCS from the packet length. */
+		pkt_len = bdp->cbd_datlen - 4;
+		cep->stats.rx_bytes += pkt_len;
+
+		/* This does 16 byte alignment, much more than we need. */
+		skb = dev_alloc_skb(pkt_len);
+
+		if (skb == NULL) {
+			printk("%s: Memory squeeze, dropping packet.\n", dev->name);
+			cep->stats.rx_dropped++;
+		}
+		else {
+			skb->dev = dev;
+			skb_put(skb,pkt_len);	/* Make room */
+			eth_copy_and_sum(skb,
+				(unsigned char *)__va(bdp->cbd_bufaddr),
+				pkt_len, 0);
+			skb->protocol=eth_type_trans(skb,dev);
+			netif_rx(skb);
+		}
+	}
+
+	/* Clear the status flags for this buffer. */
+	bdp->cbd_sc &= ~BD_ENET_RX_STATS;
+
+	/* Mark the buffer empty. */
+	bdp->cbd_sc |= BD_ENET_RX_EMPTY;
+
+	/* Update BD pointer to next entry. */
+	if (bdp->cbd_sc & BD_ENET_RX_WRAP)
+		bdp = cep->rx_bd_base;
+	else
+		bdp++;
+
+   }
+	cep->cur_rx = (cbd_t *)bdp;
+
+	return 0;
+}
+
+static int
+fcc_enet_close(struct net_device *dev)
+{
+#ifdef	CONFIG_USE_MDIO
+	struct fcc_enet_private *fep = dev->priv;
+#endif
+
+	netif_stop_queue(dev);
+	fcc_stop(dev);
+#ifdef	CONFIG_USE_MDIO
+	if (fep->phy)
+		mii_do_cmd(dev, fep->phy->shutdown);
+#endif
+
+	return 0;
+}
+
+static struct net_device_stats *fcc_enet_get_stats(struct net_device *dev)
+{
+	struct fcc_enet_private *cep = (struct fcc_enet_private *)dev->priv;
+
+	return &cep->stats;
+}
+
+#ifdef	CONFIG_USE_MDIO
+
+/* NOTE: Most of the following comes from the FEC driver for 860. The
+ * overall structure of MII code has been retained (as it's proved stable
+ * and well-tested), but actual transfer requests are processed "at once"
+ * instead of being queued (there's no interrupt-driven MII transfer
+ * mechanism, one has to toggle the data/clock bits manually).
+ */
+static int
+mii_queue(struct net_device *dev, int regval, void (*func)(uint, struct net_device *))
+{
+	struct fcc_enet_private *fep;
+	int		retval, tmp;
+
+	/* Add PHY address to register command. */
+	fep = dev->priv;
+	regval |= fep->phy_addr << 23;
+
+	retval = 0;
+
+	tmp = mii_send_receive(fep->fip, regval);
+	if (func)
+		func(tmp, dev);
+
+	return retval;
+}
+
+static int
+mii_read(struct net_device *dev, int regval)
+{
+	struct fcc_enet_private *fep;
+
+	/* Add PHY address to register command. */
+	fep = dev->priv;
+	regval |= fep->phy_addr << 23;
+
+	return(mii_send_receive(fep->fip, regval));
+}
+
+static void mii_do_cmd(struct net_device *dev, const phy_cmd_t *c)
+{
+	int k;
+
+	if(!c)
+		return;
+
+	for(k = 0; (c+k)->mii_data != mk_mii_end; k++)
+		mii_queue(dev, (c+k)->mii_data, (c+k)->funct);
+}
+
+static void mii_parse_sr(uint mii_reg, struct net_device *dev)
+{
+	volatile struct fcc_enet_private *fep = dev->priv;
+	uint s = fep->phy_status;
+
+	s &= ~(PHY_STAT_FAULT | PHY_STAT_ANC);
+
+	if (mii_reg & MII_SR_REMOTE_FAULT)
+		s |= PHY_STAT_FAULT;
+
+	if (mii_reg & MII_SR_AUTONEG_DONE)
+		s |= PHY_STAT_ANC;
+
+	fep->phy_status = s;
+}
+
+static void mii_parse_cr(uint mii_reg, struct net_device *dev)
+{
+	volatile struct fcc_enet_private *fep = dev->priv;
+	uint s = fep->phy_status;
+
+	s &= ~(PHY_CONF_ANE | PHY_CONF_LOOP);
+
+	if (mii_reg & MII_CR_ENABLE_NEG)
+		s |= PHY_CONF_ANE;
+
+	if (mii_reg & MII_CR_LBK_MODE)
+		s |= PHY_CONF_LOOP;
+
+	fep->phy_status = s;
+}
+
+static void mii_parse_ar(uint mii_reg, struct net_device *dev)
+{
+	volatile struct fcc_enet_private *fep = dev->priv;
+	uint s = fep->phy_status;
+
+	s &= ~(PHY_CONF_SPMASK);
+
+	if (mii_reg & MII_AR_10MB_HALFDUP)
+		s |= PHY_CONF_10HDX;
+	if (mii_reg & MII_AR_10MB_FULLDUP)
+		s |= PHY_CONF_10FDX;
+	if (mii_reg & MII_AR_100MB_HALFDUP)
+		s |= PHY_CONF_100HDX;
+	if (mii_reg & MII_AR_100MB_FULLDUP)
+		s |= PHY_CONF_100FDX;
+
+	fep->phy_status = s;
+}
+
+static void mii_parse_sr2(uint mii_reg, struct net_device *dev)
+{
+	volatile struct fcc_enet_private 	*fep = dev->priv;
+	uint 								s = fep->phy_status;
+
+	s &= ~(PHY_STAT_LINK | PHY_STAT_SPMASK);
+
+	if (mii_reg & MII_SR2_LINK_UP)
+		s |= PHY_STAT_LINK;
+
+	if (mii_reg & MII_SR2_100_TX) {
+		if (mii_reg & MII_SR2_FULL_DUP)
+			s |= PHY_STAT_100FDX;
+		else
+			s |= PHY_STAT_100HDX;
+	} else {
+		if (mii_reg & MII_SR2_FULL_DUP)
+			s |= PHY_STAT_10FDX;
+		else
+			s |= PHY_STAT_10HDX;
+	}
+
+	if (mii_reg & MII_SR2_ERROR)
+		s |= PHY_STAT_FAULT;
+
+	fep->phy_status = s;
+	fep->link = (s & PHY_STAT_LINK) ? 1 : 0;
+}
+
+static void mii_display_status(struct net_device *dev)
+{
+	volatile struct fcc_enet_private *fep = dev->priv;
+	uint s = fep->phy_status;
+
+#if 0
+	if (!fep->link && !fep->old_link) {
+		/* Link is still down - don't print anything */
+		return;
+	}
+#endif /* GG */
+
+	printk("%s: status: ", dev->name);
+
+	if (!fep->link) {
+		printk("link down");
+	} else {
+		printk("link up");
+
+		switch(s & PHY_STAT_SPMASK) {
+		case PHY_STAT_100FDX: printk(", 100 Mbps Full Duplex"); break;
+		case PHY_STAT_100HDX: printk(", 100 Mbps Half Duplex"); break;
+		case PHY_STAT_10FDX:  printk(", 10 Mbps Full Duplex");  break;
+		case PHY_STAT_10HDX:  printk(", 10 Mbps Half Duplex");  break;
+		default:
+			printk(", Unknown speed/duplex");
+		}
+
+		if (s & PHY_STAT_ANC)
+			printk(", auto-negotiation complete");
+	}
+
+	if (s & PHY_STAT_FAULT)
+		printk(", remote fault");
+
+	printk(".\n");
+}
+
+static void mii_display_config(struct net_device *dev)
+{
+	volatile struct fcc_enet_private *fep = dev->priv;
+	uint s = fep->phy_status;
+
+	printk("%s: config: auto-negotiation ", dev->name);
+
+	if (s & PHY_CONF_ANE)
+		printk("on");
+	else
+		printk("off");
+
+	if (s & PHY_CONF_100FDX)
+		printk(", 100FDX");
+	if (s & PHY_CONF_100HDX)
+		printk(", 100HDX");
+	if (s & PHY_CONF_10FDX)
+		printk(", 10FDX");
+	if (s & PHY_CONF_10HDX)
+		printk(", 10HDX");
+	if (!(s & PHY_CONF_SPMASK))
+		printk(", No speed/duplex selected?");
+
+	if (s & PHY_CONF_LOOP)
+		printk(", loopback enabled");
+
+	printk(".\n");
+
+	fep->sequence_done = 1;
+}
+
+static void mii_relink(struct net_device *dev)
+{
+	struct fcc_enet_private *fep = dev->priv;
+	int duplex = 0;
+
+	fep->old_link = fep->link; /* GG */
+	fep->link = (fep->phy_status & PHY_STAT_LINK) ? 1 : 0;
+
+#ifdef MDIO_DEBUG
+	printk("  mii_relink:  link=%d\n", fep->link);
+#endif
+
+	if (fep->link) {
+		if (fep->phy_status
+		    & (PHY_STAT_100FDX | PHY_STAT_10FDX))
+			duplex = 1;
+		fcc_restart(dev, duplex);
+#ifdef MDIO_DEBUG
+		printk("  mii_relink:  duplex=%d\n", duplex);
+#endif
+#if 0
+	/* useful ?? */
+	} else {
+		fcc_stop(dev);
+#endif /* GG */
+	}
+}
+
+static void mii_queue_relink(uint mii_reg, struct net_device *dev)
+{
+	struct fcc_enet_private *fep = dev->priv;
+
+	mii_relink(dev);
+
+	schedule_work(&fep->phy_relink);
+}
+
+static void mii_queue_config(uint mii_reg, struct net_device *dev)
+{
+	struct fcc_enet_private *fep = dev->priv;
+
+	schedule_work(&fep->phy_display_config);
+}
+
+/* Read remainder of PHY ID.
+*/
+static void
+mii_discover_phy3(uint mii_reg, struct net_device *dev)
+{
+	struct fcc_enet_private *fep;
+	int	i;
+
+	fep = dev->priv;
+	// GG printk("mii_reg: %08x\n", mii_reg);
+	fep->phy_id |= (mii_reg & 0xffff);
+
+	for(i = 0; phy_info[i]; i++)
+		if((phy_info[i]->id == (fep->phy_id >> 4)) || !phy_info[i]->id)
+			break;
+
+	if(!phy_info[i])
+		panic("%s: PHY id 0x%08x is not supported!\n",
+		      dev->name, fep->phy_id);
+
+	fep->phy = phy_info[i];
+	fep->phy_id_done = 1;
+
+	printk("%s: Phy @ 0x%x, type %s (0x%08x)\n",
+		dev->name, fep->phy_addr, fep->phy->name, fep->phy_id);
+}
+
+/* Scan all of the MII PHY addresses looking for someone to respond
+ * with a valid ID.  This usually happens quickly.
+ */
+static void
+mii_discover_phy(uint mii_reg, struct net_device *dev)
+{
+	struct fcc_enet_private *fep;
+	uint	phytype;
+
+	fep = dev->priv;
+
+	if ((phytype = (mii_reg & 0xffff)) != 0xffff) {
+
+		/* Got first part of ID, now get remainder. */
+		fep->phy_id = phytype << 16;
+		mii_queue(dev, mk_mii_read(MII_LXT971_IR2), mii_discover_phy3);
+	} else {
+		fep->phy_addr++;
+		if (fep->phy_addr < 32) {
+			mii_queue(dev, mk_mii_read(MII_LXT971_IR1),
+							mii_discover_phy);
+		} else {
+			printk("fec: No PHY device found.\n");
+		}
+	}
+}
+
+/* This interrupt occurs when the PHY detects a link change. */
+static irqreturn_t
+mii_link_interrupt(int irq, void * dev_id, struct pt_regs * regs)
+{
+	struct	net_device *dev = dev_id;
+	struct fcc_enet_private *fep = dev->priv;
+	fcc_info_t *fip = fep->fip;
+
+	if (fep->phy) {
+		/* We don't want to be interrupted by an FCC
+		 * interrupt here.
+		 */
+		disable_irq_nosync(fip->fc_interrupt);
+
+		mii_do_cmd(dev, fep->phy->ack_int);
+		/* restart and display status */
+		mii_do_cmd(dev, phy_cmd_relink);
+
+		enable_irq(fip->fc_interrupt);
+	}
+	return IRQ_HANDLED;
+}
+#endif	/* CONFIG_USE_MDIO */
+
+/* Set or clear the multicast filter for this adaptor.
+ * Skeleton taken from sunlance driver.
+ * The CPM Ethernet implementation allows Multicast as well as individual
+ * MAC address filtering.  Some of the drivers check to make sure it is
+ * a group multicast address, and discard those that are not.  I guess I
+ * will do the same for now, but just remove the test if you want
+ * individual filtering as well (do the upper net layers want or support
+ * this kind of feature?).
+ */
+static void
+set_multicast_list(struct net_device *dev)
+{
+	struct	fcc_enet_private *cep;
+	struct	dev_mc_list *dmi;
+	u_char	*mcptr, *tdptr;
+	volatile fcc_enet_t *ep;
+	int	i, j;
+
+	cep = (struct fcc_enet_private *)dev->priv;
+
+	/* Get pointer to FCC area in parameter RAM.
+	*/
+	ep = (fcc_enet_t *)dev->base_addr;
+
+	if (dev->flags&IFF_PROMISC) {
+	
+		/* Log any net taps. */
+		printk("%s: Promiscuous mode enabled.\n", dev->name);
+		cep->fccp->fcc_fpsmr |= FCC_PSMR_PRO;
+	} else {
+
+		cep->fccp->fcc_fpsmr &= ~FCC_PSMR_PRO;
+
+		if (dev->flags & IFF_ALLMULTI) {
+			/* Catch all multicast addresses, so set the
+			 * filter to all 1's.
+			 */
+			ep->fen_gaddrh = 0xffffffff;
+			ep->fen_gaddrl = 0xffffffff;
+		}
+		else {
+			/* Clear filter and add the addresses in the list.
+			*/
+			ep->fen_gaddrh = 0;
+			ep->fen_gaddrl = 0;
+
+			dmi = dev->mc_list;
+
+			for (i=0; i<dev->mc_count; i++, dmi = dmi->next) {
+				
+				/* Only support group multicast for now.
+				*/
+				if (!(dmi->dmi_addr[0] & 1))
+					continue;
+
+				/* The address in dmi_addr is LSB first,
+				 * and taddr is MSB first.  We have to
+				 * copy bytes MSB first from dmi_addr.
+				 */
+				mcptr = (u_char *)dmi->dmi_addr + 5;
+				tdptr = (u_char *)&ep->fen_taddrh;
+				for (j=0; j<6; j++)
+					*tdptr++ = *mcptr--;
+
+				/* Ask CPM to run CRC and set bit in
+				 * filter mask.
+				 */
+				cpmp->cp_cpcr = mk_cr_cmd(cep->fip->fc_cpmpage,
+						cep->fip->fc_cpmblock, 0x0c,
+						CPM_CR_SET_GADDR) | CPM_CR_FLG;
+				udelay(10);
+				while (cpmp->cp_cpcr & CPM_CR_FLG);
+			}
+		}
+	}
+}
+
+/* Set the individual MAC address.
+ */
+int fcc_enet_set_mac_address(struct net_device *dev, void *p)
+{
+	struct sockaddr *addr= (struct sockaddr *) p;
+	struct fcc_enet_private *cep;
+	volatile fcc_enet_t *ep;
+	unsigned char *eap;
+	int i;
+
+	cep = (struct fcc_enet_private *)(dev->priv);
+	ep = cep->ep;
+
+        if (netif_running(dev))
+                return -EBUSY;
+
+        memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
+
+	eap = (unsigned char *) &(ep->fen_paddrh);
+	for (i=5; i>=0; i--)
+		*eap++ = addr->sa_data[i];
+
+        return 0;
+}
+
+
+/* Initialize the CPM Ethernet on FCC.
+ */
+static int __init fec_enet_init(void)
+{
+	struct net_device *dev;
+	struct fcc_enet_private *cep;
+	fcc_info_t	*fip;
+	int	i, np, err;
+	volatile	cpm2_map_t		*immap;
+	volatile	iop_cpm2_t	*io;
+
+	immap = (cpm2_map_t *)CPM_MAP_ADDR;	/* and to internal registers */
+	io = &immap->im_ioport;
+
+	np = sizeof(fcc_ports) / sizeof(fcc_info_t);
+	fip = fcc_ports;
+
+	while (np-- > 0) {
+		/* Create an Ethernet device instance.
+		*/
+		dev = alloc_etherdev(sizeof(*cep));
+		if (!dev)
+			return -ENOMEM;
+
+		cep = dev->priv;
+		spin_lock_init(&cep->lock);
+		cep->fip = fip;
+
+		init_fcc_shutdown(fip, cep, immap);
+		init_fcc_ioports(fip, io, immap);
+		init_fcc_param(fip, dev, immap);
+
+		dev->base_addr = (unsigned long)(cep->ep);
+
+		/* The CPM Ethernet specific entries in the device
+		 * structure.
+		 */
+		dev->open = fcc_enet_open;
+		dev->hard_start_xmit = fcc_enet_start_xmit;
+		dev->tx_timeout = fcc_enet_timeout;
+		dev->watchdog_timeo = TX_TIMEOUT;
+		dev->stop = fcc_enet_close;
+		dev->get_stats = fcc_enet_get_stats;
+		dev->set_multicast_list = set_multicast_list;
+		dev->set_mac_address = fcc_enet_set_mac_address;
+#ifdef  CONFIG_USE_MDIO
+		dev->do_ioctl		= fcc_enet_ioctl;
+#endif  /* CONFIG_USE_MDIO */
+
+		init_fcc_startup(fip, dev);
+
+		err = register_netdev(dev);
+		if (err) {
+			free_netdev(dev);
+			return err;
+		}
+
+#ifdef	CONFIG_USE_MDIO
+		/* Queue up command to detect the PHY and initialize the
+	 	* remainder of the interface.
+	 	*/
+		cep->phy_id_done = 0;
+#if 0
+		cep->phy_addr = 0;
+#else
+		/* PHY address is the same as FCC number */
+		cep->phy_addr = cep->fip->fc_fccnum;
+#endif /* GG */
+		mii_queue(dev, mk_mii_read(MII_LXT971_IR1), mii_discover_phy);
+		INIT_WORK(&cep->phy_relink, 
+				(void (*)(void *))mii_display_status, (void *)dev);
+		INIT_WORK(&cep->phy_display_config, 
+				(void (*)(void *))mii_display_config, (void *)dev);
+#endif	/* CONFIG_USE_MDIO */
+
+		printk("%s: FCC ENET Version 1.1.0, ", dev->name);
+		for (i=0; i<5; i++)
+			printk("%02x:", dev->dev_addr[i]);
+		printk("%02x\n", dev->dev_addr[5]);
+
+		fip++;
+	}
+
+	return 0;
+}
+module_init(fec_enet_init);
+
+/* Make sure the device is shut down during initialization.
+*/
+static void __init
+init_fcc_shutdown(fcc_info_t *fip, struct fcc_enet_private *cep,
+						volatile cpm2_map_t *immap)
+{
+	volatile	fcc_enet_t	*ep;
+	volatile	fcc_t		*fccp;
+
+	/* Get pointer to FCC area in parameter RAM.
+	*/
+	ep = (fcc_enet_t *)(&immap->im_dprambase[fip->fc_proff]);
+
+	/* And another to the FCC register area.
+	*/
+	fccp = (volatile fcc_t *)(&immap->im_fcc[fip->fc_fccnum]);
+	cep->fccp = fccp;		/* Keep the pointers handy */
+	cep->ep = ep;
+
+	/* Disable receive and transmit in case someone left it running.
+	*/
+	fccp->fcc_gfmr &= ~(FCC_GFMR_ENR | FCC_GFMR_ENT);
+}
+
+/* Initialize the I/O pins for the FCC Ethernet.
+*/
+static void __init
+init_fcc_ioports(fcc_info_t *fip, volatile iop_cpm2_t *io,
+						volatile cpm2_map_t *immap)
+{
+
+	/* FCC1 pins are on port A/C.  FCC2/3 are port B/C.
+	*/
+	if (fip->fc_proff == PROFF_FCC1) {
+		/* Configure port A and C pins for FCC1 Ethernet.
+		 */
+		io->iop_pdira &= ~PA1_DIRA0;
+		io->iop_pdira |= PA1_DIRA1;
+		io->iop_psora &= ~PA1_PSORA0;
+		io->iop_psora |= PA1_PSORA1;
+		io->iop_ppara |= (PA1_DIRA0 | PA1_DIRA1);
+	}
+	if (fip->fc_proff == PROFF_FCC2) {
+		/* Configure port B and C pins for FCC Ethernet.
+		 */
+		io->iop_pdirb &= ~PB2_DIRB0;
+		io->iop_pdirb |= PB2_DIRB1;
+		io->iop_psorb &= ~PB2_PSORB0;
+		io->iop_psorb |= PB2_PSORB1;
+		io->iop_pparb |= (PB2_DIRB0 | PB2_DIRB1);
+	}
+	if (fip->fc_proff == PROFF_FCC3) {
+		/* Configure port B and C pins for FCC Ethernet.
+		 */
+		io->iop_pdirb &= ~PB3_DIRB0;
+		io->iop_pdirb |= PB3_DIRB1;
+		io->iop_psorb &= ~PB3_PSORB0;
+		io->iop_psorb |= PB3_PSORB1;
+		io->iop_pparb |= (PB3_DIRB0 | PB3_DIRB1);
+	}
+
+	/* Port C has clocks......
+	*/
+	io->iop_psorc &= ~(fip->fc_trxclocks);
+	io->iop_pdirc &= ~(fip->fc_trxclocks);
+	io->iop_pparc |= fip->fc_trxclocks;
+
+#ifdef	CONFIG_USE_MDIO
+	/* ....and the MII serial clock/data.
+	*/
+	io->iop_pdatc &= ~(fip->fc_mdio | fip->fc_mdck);
+	io->iop_podrc &= ~(fip->fc_mdck | fip->fc_mdio);
+	io->iop_pdirc |= fip->fc_mdck;
+	io->iop_pdirc &= ~(fip->fc_mdio);
+	io->iop_pparc &= ~(fip->fc_mdio | fip->fc_mdck);
+#endif	/* CONFIG_USE_MDIO */
+
+	/* Configure Serial Interface clock routing.
+	 * First, clear all FCC bits to zero,
+	 * then set the ones we want.
+	 */
+	immap->im_cpmux.cmx_fcr &= ~(fip->fc_clockmask);
+	immap->im_cpmux.cmx_fcr |= fip->fc_clockroute;
+}
+
+static void __init
+init_fcc_param(fcc_info_t *fip, struct net_device *dev,
+						volatile cpm2_map_t *immap)
+{
+	unsigned char	*eap;
+	unsigned long	mem_addr;
+	bd_t		*bd;
+	int		i, j;
+	struct		fcc_enet_private *cep;
+	volatile	fcc_enet_t	*ep;
+	volatile	cbd_t		*bdp;
+	volatile	cpm_cpm2_t	*cp;
+
+	cep = (struct fcc_enet_private *)(dev->priv);
+	ep = cep->ep;
+	cp = cpmp;
+
+	bd = (bd_t *)__res;
+
+	/* Zero the whole thing.....I must have missed some individually.
+	 * It works when I do this.
+	 */
+	memset((char *)ep, 0, sizeof(fcc_enet_t));
+
+	/* Allocate space for the buffer descriptors from regular memory.
+	 * Initialize base addresses for the buffer descriptors.
+	 */
+	cep->rx_bd_base = (cbd_t *)kmalloc(sizeof(cbd_t) * RX_RING_SIZE,
+			GFP_KERNEL | GFP_DMA);
+	ep->fen_genfcc.fcc_rbase = __pa(cep->rx_bd_base);
+	cep->tx_bd_base = (cbd_t *)kmalloc(sizeof(cbd_t) * TX_RING_SIZE,
+			GFP_KERNEL | GFP_DMA);
+	ep->fen_genfcc.fcc_tbase = __pa(cep->tx_bd_base);
+
+	cep->dirty_tx = cep->cur_tx = cep->tx_bd_base;
+	cep->cur_rx = cep->rx_bd_base;
+
+	ep->fen_genfcc.fcc_rstate = (CPMFCR_GBL | CPMFCR_EB) << 24;
+	ep->fen_genfcc.fcc_tstate = (CPMFCR_GBL | CPMFCR_EB) << 24;
+
+	/* Set maximum bytes per receive buffer.
+	 * It must be a multiple of 32.
+	 */
+	ep->fen_genfcc.fcc_mrblr = PKT_MAXBLR_SIZE;
+
+	/* Allocate space in the reserved FCC area of DPRAM for the
+	 * internal buffers.  No one uses this space (yet), so we
+	 * can do this.  Later, we will add resource management for
+	 * this area.
+	 */
+	mem_addr = CPM_FCC_SPECIAL_BASE + (fip->fc_fccnum * 128);
+	ep->fen_genfcc.fcc_riptr = mem_addr;
+	ep->fen_genfcc.fcc_tiptr = mem_addr+32;
+	ep->fen_padptr = mem_addr+64;
+	memset((char *)(&(immap->im_dprambase[(mem_addr+64)])), 0x88, 32);
+
+	ep->fen_genfcc.fcc_rbptr = 0;
+	ep->fen_genfcc.fcc_tbptr = 0;
+	ep->fen_genfcc.fcc_rcrc = 0;
+	ep->fen_genfcc.fcc_tcrc = 0;
+	ep->fen_genfcc.fcc_res1 = 0;
+	ep->fen_genfcc.fcc_res2 = 0;
+
+	ep->fen_camptr = 0;	/* CAM isn't used in this driver */
+
+	/* Set CRC preset and mask.
+	*/
+	ep->fen_cmask = 0xdebb20e3;
+	ep->fen_cpres = 0xffffffff;
+
+	ep->fen_crcec = 0;	/* CRC Error counter */
+	ep->fen_alec = 0;	/* alignment error counter */
+	ep->fen_disfc = 0;	/* discard frame counter */
+	ep->fen_retlim = 15;	/* Retry limit threshold */
+	ep->fen_pper = 0;	/* Normal persistence */
+
+	/* Clear hash filter tables.
+	*/
+	ep->fen_gaddrh = 0;
+	ep->fen_gaddrl = 0;
+	ep->fen_iaddrh = 0;
+	ep->fen_iaddrl = 0;
+
+	/* Clear the Out-of-sequence TxBD.
+	*/
+	ep->fen_tfcstat = 0;
+	ep->fen_tfclen = 0;
+	ep->fen_tfcptr = 0;
+
+	ep->fen_mflr = PKT_MAXBUF_SIZE;   /* maximum frame length register */
+	ep->fen_minflr = PKT_MINBUF_SIZE;  /* minimum frame length register */
+
+	/* Set Ethernet station address.
+	 *
+	 * This is supplied in the board information structure, so we
+	 * copy that into the controller.
+	 * So, far we have only been given one Ethernet address. We make
+	 * it unique by setting a few bits in the upper byte of the
+	 * non-static part of the address.
+	 */
+#ifdef CONFIG_PQ2PMCA
+	eap = (unsigned char *)&(ep->fen_paddrh);
+	for (i=5; i>=0; i--) {
+		if (i == 5) {
+			dev->dev_addr[i] = bd->bi_enetaddr[i];
+			dev->dev_addr[i] += fip->fc_fccnum;
+			*eap++ = dev->dev_addr[i];
+		}
+		else {
+			*eap++ = dev->dev_addr[i] = bd->bi_enetaddr[i];
+		}
+	}
+#endif /* CONFIG_PQ2PMCA */
+
+	ep->fen_taddrh = 0;
+	ep->fen_taddrm = 0;
+	ep->fen_taddrl = 0;
+
+	ep->fen_maxd1 = PKT_MAXDMA_SIZE;	/* maximum DMA1 length */
+	ep->fen_maxd2 = PKT_MAXDMA_SIZE;	/* maximum DMA2 length */
+
+	/* Clear stat counters, in case we ever enable RMON.
+	*/
+	ep->fen_octc = 0;
+	ep->fen_colc = 0;
+	ep->fen_broc = 0;
+	ep->fen_mulc = 0;
+	ep->fen_uspc = 0;
+	ep->fen_frgc = 0;
+	ep->fen_ospc = 0;
+	ep->fen_jbrc = 0;
+	ep->fen_p64c = 0;
+	ep->fen_p65c = 0;
+	ep->fen_p128c = 0;
+	ep->fen_p256c = 0;
+	ep->fen_p512c = 0;
+	ep->fen_p1024c = 0;
+
+	ep->fen_rfthr = 0;	/* Suggested by manual */
+	ep->fen_rfcnt = 0;
+	ep->fen_cftype = 0;
+
+	/* Now allocate the host memory pages and initialize the
+	 * buffer descriptors.
+	 */
+	bdp = cep->tx_bd_base;
+	for (i=0; i<TX_RING_SIZE; i++) {
+
+		/* Initialize the BD for every fragment in the page.
+		*/
+		bdp->cbd_sc = 0;
+		bdp->cbd_datlen = 0;
+		bdp->cbd_bufaddr = 0;
+		bdp++;
+	}
+
+	/* Set the last buffer to wrap.
+	*/
+	bdp--;
+	bdp->cbd_sc |= BD_SC_WRAP;
+
+	bdp = cep->rx_bd_base;
+	for (i=0; i<FCC_ENET_RX_PAGES; i++) {
+
+		/* Allocate a page.
+		*/
+		mem_addr = __get_free_page(GFP_KERNEL);
+
+		/* Initialize the BD for every fragment in the page.
+		*/
+		for (j=0; j<FCC_ENET_RX_FRPPG; j++) {
+			bdp->cbd_sc = BD_ENET_RX_EMPTY | BD_ENET_RX_INTR;
+			bdp->cbd_datlen = 0;
+			bdp->cbd_bufaddr = __pa(mem_addr);
+			mem_addr += FCC_ENET_RX_FRSIZE;
+			bdp++;
+		}
+	}
+
+	/* Set the last buffer to wrap.
+	*/
+	bdp--;
+	bdp->cbd_sc |= BD_SC_WRAP;
+
+	/* Let's re-initialize the channel now.  We have to do it later
+	 * than the manual describes because we have just now finished
+	 * the BD initialization.
+	 */
+	cp->cp_cpcr = mk_cr_cmd(fip->fc_cpmpage, fip->fc_cpmblock, 0x0c,
+			CPM_CR_INIT_TRX) | CPM_CR_FLG;
+	while (cp->cp_cpcr & CPM_CR_FLG);
+
+	cep->skb_cur = cep->skb_dirty = 0;
+}
+
+/* Let 'er rip.
+*/
+static void __init
+init_fcc_startup(fcc_info_t *fip, struct net_device *dev)
+{
+	volatile fcc_t	*fccp;
+	struct fcc_enet_private *cep;
+	int                     duplex;
+
+	cep = (struct fcc_enet_private *)(dev->priv);
+	fccp = cep->fccp;
+
+	fccp->fcc_fcce = 0xffff;	/* Clear any pending events */
+
+	/* Leave FCC interrupts masked for now.  Will be unmasked by
+	 * fcc_restart().
+	 */
+	fccp->fcc_fccm = 0;
+
+	/* Install our interrupt handler.
+	*/
+	if (request_irq(fip->fc_interrupt, fcc_enet_interrupt, 0, "fenet",
+				dev) < 0)
+		printk("Can't get FCC IRQ %d\n", fip->fc_interrupt);
+
+#ifdef	CONFIG_USE_MDIO
+	/* ack pending PHY interrupts and read PHY current status */
+	// GG mii_do_cmd(dev, cep->phy->ack_int);
+
+	if (request_irq(fip->fc_phy_interrupt, mii_link_interrupt, 0,
+							"mii", dev) < 0)
+		printk("Can't get MII IRQ %d\n", fip->fc_phy_interrupt);
+#endif	/* CONFIG_USE_MDIO */
+
+	/* Set GFMR to enable Ethernet operating mode.
+	 */
+#if 0
+	fccp->fcc_gfmr = (FCC_GFMR_TCI | FCC_GFMR_MODE_ENET);
+#else
+	fccp->fcc_gfmr = FCC_GFMR_MODE_ENET;
+#endif /* GG */
+
+	/* Set sync/delimiters.
+	*/
+	fccp->fcc_fdsr = 0xd555;
+
+	/* Set protocol specific processing mode for Ethernet.
+	 * This has to be adjusted for Full Duplex operation after we can
+	 * determine how to detect that.
+	 */
+	fccp->fcc_fpsmr = FCC_PSMR_ENCRC;
+
+#ifdef CONFIG_PQ2ADS
+	/* Enable the PHY.
+	*/
+        *(volatile uint *)(BCSR_ADDR + 4) &= ~BCSR1_FETHIEN;
+        *(volatile uint *)(BCSR_ADDR + 4) |=  BCSR1_FETH_RST;
+#endif
+
+#ifdef CONFIG_USE_MDIO
+	if (cep->phy_status & (PHY_STAT_100FDX | PHY_STAT_10FDX)) {
+		duplex = 1;
+	} else {
+		duplex = 0;
+	}
+	fcc_restart(dev, duplex);
+#else
+	/* start in half duplex mode */
+	duplex = 0;
+	fcc_restart (dev, duplex);
+#endif
+}
+
+#ifdef CONFIG_USE_MDIO
+static uint
+mii_send_receive(fcc_info_t *fip, uint cmd)
+{
+	uint				retval;
+	int					read_op, i, off;
+	volatile cpm2_map_t	*immap;
+	volatile iop_cpm2_t	*io;
+
+	immap = (cpm2_map_t *)CPM_MAP_ADDR;
+	io = &immap->im_ioport;
+
+	/* check if read operation */
+	read_op = ((cmd & 0xf0000000) == 0x60000000);
+
+	/* set mdc as output */
+	io->iop_pdird |= (fip->fc_mdck);
+	FCC_PDATD_MDC(1);
+
+	/* set mdio as output */
+	io->iop_pdird |= (fip->fc_mdio);
+	FCC_PDATD_MDIO(1);
+
+	/* write preamble */
+	for (i = 0; i < 32; i++) {
+		FCC_PDATD_MDC(0);
+		udelay(1);
+		FCC_PDATD_MDC(1);
+		udelay(1);
+	}
+
+	/* reset clock state */
+	FCC_PDATD_MDC(0);
+	udelay(1);
+
+	/* set mdio as output */
+	io->iop_pdird |= (fip->fc_mdio);
+	FCC_PDATD_MDIO(1);
+
+	/* write data */
+	for (i = 0, off = 31; i < (read_op ? 14 : 32); i++, --off)
+	{
+		FCC_PDATD_MDIO((cmd >> off) & 0x00000001);
+		FCC_PDATD_MDC(0);
+		udelay(1);
+		FCC_PDATD_MDC(1);
+		udelay(1);
+	}
+
+	/* reset clock state */
+	FCC_PDATD_MDC(0);
+	udelay(1);
+
+	retval = cmd;
+
+	if (read_op)
+	{
+		retval >>= 16;
+
+		/* set mdio as input */
+		io->iop_pdird &= ~(fip->fc_mdio);
+
+		FCC_PDATD_MDC(1);
+		udelay(1);
+		FCC_PDATD_MDC(0);
+		udelay(1);
+
+		for (i = 0, off = 15; i < 16; i++, off--)
+		{
+			FCC_PDATD_MDC(1);
+			udelay(1);
+
+			retval <<= 1;
+			if (io->iop_pdatd & fip->fc_mdio)
+				retval++;
+
+			FCC_PDATD_MDC(0);
+			udelay(1);
+		}
+		FCC_PDATD_MDC(1);
+		udelay(1);
+	}
+
+	/* set mdio as input */
+	io->iop_pdird &= ~(fip->fc_mdio);
+
+	/* put the bus in idle state */
+	FCC_PDATD_MDC(0);
+	udelay(1);
+	FCC_PDATD_MDC(1);
+	udelay(1);
+	FCC_PDATD_MDC(0);
+	udelay(1);
+	FCC_PDATD_MDC(1);
+	udelay(1);
+
+	return retval;
+}
+#endif	/* CONFIG_USE_MDIO */
+
+static void
+fcc_stop(struct net_device *dev)
+{
+	struct fcc_enet_private	*fep= (struct fcc_enet_private *)(dev->priv);
+	volatile fcc_t	*fccp = fep->fccp;
+	fcc_info_t *fip = fep->fip;
+	volatile fcc_enet_t *ep = fep->ep;
+	volatile cpm_cpm2_t *cp = cpmp;
+	volatile cbd_t *bdp;
+	int i;
+
+	if ((fccp->fcc_gfmr & (FCC_GFMR_ENR | FCC_GFMR_ENT)) == 0)
+		return;	/* already down */
+
+	fccp->fcc_fccm = 0;
+
+	/* issue the graceful stop tx command */
+	while (cp->cp_cpcr & CPM_CR_FLG);
+	cp->cp_cpcr = mk_cr_cmd(fip->fc_cpmpage, fip->fc_cpmblock,
+				0x0c, CPM_CR_GRA_STOP_TX) | CPM_CR_FLG;
+	while (cp->cp_cpcr & CPM_CR_FLG);
+
+	/* Disable transmit/receive */
+	fccp->fcc_gfmr &= ~(FCC_GFMR_ENR | FCC_GFMR_ENT);
+
+	/* issue the restart tx command */
+	fccp->fcc_fcce = FCC_ENET_GRA;
+	while (cp->cp_cpcr & CPM_CR_FLG);
+	cp->cp_cpcr = mk_cr_cmd(fip->fc_cpmpage, fip->fc_cpmblock,
+				0x0c, CPM_CR_RESTART_TX) | CPM_CR_FLG;
+	while (cp->cp_cpcr & CPM_CR_FLG);
+
+	/* free tx buffers */
+	fep->skb_cur = fep->skb_dirty = 0;
+	for (i=0; i<=TX_RING_MOD_MASK; i++) {
+		if (fep->tx_skbuff[i] != NULL) {
+			dev_kfree_skb(fep->tx_skbuff[i]);
+			fep->tx_skbuff[i] = NULL;
+		}
+	}
+	fep->dirty_tx = fep->cur_tx = fep->tx_bd_base;
+	fep->tx_free = TX_RING_SIZE;
+	ep->fen_genfcc.fcc_tbptr = ep->fen_genfcc.fcc_tbase;
+
+	/* Initialize the tx buffer descriptors. */
+	bdp = fep->tx_bd_base;
+	for (i=0; i<TX_RING_SIZE; i++) {
+		bdp->cbd_sc = 0;
+		bdp->cbd_datlen = 0;
+		bdp->cbd_bufaddr = 0;
+		bdp++;
+	}
+	/* Set the last buffer to wrap. */
+	bdp--;
+	bdp->cbd_sc |= BD_SC_WRAP;
+}
+
+static void
+fcc_restart(struct net_device *dev, int duplex)
+{
+	struct fcc_enet_private	*fep = (struct fcc_enet_private *)(dev->priv);
+	volatile fcc_t	*fccp = fep->fccp;
+
+	/* stop any transmissions in progress */
+	fcc_stop(dev);
+
+	if (duplex)
+		fccp->fcc_fpsmr |= FCC_PSMR_FDE | FCC_PSMR_LPB;
+	else
+		fccp->fcc_fpsmr &= ~(FCC_PSMR_FDE | FCC_PSMR_LPB);
+
+	/* Enable interrupts for transmit error, complete frame
+	 * received, and any transmit buffer we have also set the
+	 * interrupt flag.
+	 */
+	fccp->fcc_fccm = (FCC_ENET_TXE | FCC_ENET_RXF | FCC_ENET_TXB);
+
+	/* Enable transmit/receive */
+	fccp->fcc_gfmr |= FCC_GFMR_ENR | FCC_GFMR_ENT;
+}
+
+static int
+fcc_enet_open(struct net_device *dev)
+{
+	struct fcc_enet_private *fep = dev->priv;
+
+#ifdef	CONFIG_USE_MDIO
+	fep->sequence_done = 0;
+	fep->link = 0;
+
+	if (fep->phy) {
+		fcc_restart(dev, 0);	/* always start in half-duplex */
+		mii_do_cmd(dev, fep->phy->ack_int);
+		mii_do_cmd(dev, fep->phy->config);
+		mii_do_cmd(dev, phy_cmd_config);  /* display configuration */
+		while(!fep->sequence_done)
+			schedule();
+
+		mii_do_cmd(dev, fep->phy->startup);
+		netif_start_queue(dev);
+		return 0;		/* Success */
+	}
+	return -ENODEV;		/* No PHY we understand */
+#else
+	fep->link = 1;
+	fcc_restart(dev, 0);	/* always start in half-duplex */
+	netif_start_queue(dev);
+	return 0;					/* Always succeed */
+#endif	/* CONFIG_USE_MDIO */
+}
+
+#ifdef	CONFIG_USE_MDIO
+static int
+fcc_enet_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	int rc = 0;
+	u16	tmp;
+	struct mii_ioctl_data *data = (struct mii_ioctl_data *)&ifr->ifr_data;
+	volatile struct fcc_enet_private 	*fep = dev->priv;
+
+	switch (cmd) {
+	case SIOCETHTOOL:
+		rc = fcc_ethtool_ioctl(dev, (void *)ifr->ifr_data);
+		break;
+
+	case SIOCGMIIPHY:	/* Get address of MII PHY in use. */
+	case SIOCGMIIREG:	/* Read MII PHY register. */
+		if (data->reg_num != 1) {
+			if (cmd == SIOCGMIIPHY) {
+				data->phy_id = (u16)fep->phy_addr;
+			}
+			data->val_out = (u16)mii_read(dev, 
+							mk_mii_read(data->reg_num & 0x1f));
+		} else {
+			/* just for bonding call */
+			/* read status register */
+			data->val_out = (u16)mii_read(dev, mk_mii_read(MII_LXT971_SR));
+			/* clear link status */
+			data->val_out &= ~MII_SR_LINKUP;
+			/* read status2 for link status */
+			tmp = (u16)mii_read(dev, mk_mii_read(MII_LXT971_SR2));
+			if (tmp & MII_SR2_LINK_UP) {
+				data->val_out |= MII_SR_LINKUP;
+			}
+		}
+		break;
+
+	case SIOCSMIIREG:	/* Write MII PHY register. */
+		/* check privilege */
+		if (!capable(CAP_NET_ADMIN)) {
+			return -EPERM;
+		}
+		mii_queue(dev, mk_mii_write(data->reg_num & 0x1f, data->val_in), NULL);
+		break;
+
+	default:
+		rc = -EOPNOTSUPP;
+		break;
+	}
+
+	return rc;
+}
+
+static int fcc_ethtool_ioctl(struct net_device *dev, void *arg)
+{
+	int									rc = 0;
+	int									advertise;
+	int									control;
+	struct ethtool_cmd					ecmd;
+	struct ethtool_value				evalue;
+	volatile struct fcc_enet_private 	*fep = dev->priv;
+
+	if (copy_from_user(&ecmd, arg, sizeof(ecmd))) {
+		return -EFAULT;
+	}
+
+	switch (ecmd.cmd) {
+	case ETHTOOL_GSET:		/* Get settings. */
+		mii_queue(dev, mk_mii_read(MII_LXT971_CR), mii_parse_cr);
+		mii_queue(dev, mk_mii_read(MII_LXT971_AR), mii_parse_ar);
+		mii_queue(dev, mk_mii_read(MII_LXT971_SR), mii_parse_sr);
+		mii_queue(dev, mk_mii_read(MII_LXT971_SR2), mii_parse_sr2);
+
+		/* supported features */
+		ecmd.supported = 
+			(SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |
+			SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full | 
+			SUPPORTED_Autoneg | SUPPORTED_TP);
+
+		/* advertised features */
+		ecmd.advertising = ADVERTISED_TP;
+		ecmd.autoneg = AUTONEG_DISABLE;
+		if (fep->phy_status & PHY_CONF_ANE) {
+			ecmd.advertising |= ADVERTISED_Autoneg;
+			ecmd.autoneg = AUTONEG_ENABLE;
+		}
+		if (fep->phy_status & PHY_CONF_100FDX) {
+			ecmd.advertising |= ADVERTISED_100baseT_Full;
+		}
+		if (fep->phy_status & PHY_CONF_100HDX) {
+			ecmd.advertising |= ADVERTISED_100baseT_Half;
+		}
+		if (fep->phy_status & PHY_CONF_10FDX) {
+			ecmd.advertising |= ADVERTISED_10baseT_Full;
+		}
+		if (fep->phy_status & PHY_CONF_10HDX) {
+			ecmd.advertising |= ADVERTISED_10baseT_Half;
+		}
+
+		/* speed and duplex */
+		switch(fep->phy_status & PHY_STAT_SPMASK) {
+		case PHY_STAT_100FDX:
+			ecmd.speed = SPEED_100;
+			ecmd.duplex = DUPLEX_FULL;
+			break;
+		case PHY_STAT_100HDX:
+			ecmd.speed = SPEED_100;
+			ecmd.duplex = DUPLEX_HALF;
+			break;
+		case PHY_STAT_10FDX:
+			ecmd.speed = SPEED_10;
+			ecmd.duplex = DUPLEX_FULL;
+			break;
+		case PHY_STAT_10HDX:
+		default:
+			ecmd.speed = SPEED_10;
+			ecmd.duplex = DUPLEX_HALF;
+			break;
+		}
+
+		/* port, phy_address, transceiver */
+		ecmd.port = PORT_TP;
+		ecmd.phy_address = fep->phy_addr;
+		ecmd.transceiver = XCVR_INTERNAL;
+
+		/* autoneg is set previously while advertised features */
+
+		if (copy_to_user(arg, &ecmd, sizeof(ecmd))) {
+			return -EFAULT;
+		}
+		break;
+
+	case ETHTOOL_SSET:		/* Set settings, privileged. */
+		/* check privilege */
+		if (!capable(CAP_NET_ADMIN)) {
+			return -EPERM;
+		}
+
+		/* verify the settings we care about. */
+		if (ecmd.autoneg != AUTONEG_ENABLE &&
+			ecmd.autoneg != AUTONEG_DISABLE) {
+			return -EINVAL;
+		}
+
+		if (ecmd.autoneg == AUTONEG_DISABLE && 
+			((ecmd.speed != SPEED_100 && ecmd.speed != SPEED_10) ||
+			 (ecmd.duplex != DUPLEX_HALF && ecmd.duplex != DUPLEX_FULL))) {
+			return -EINVAL;
+		}
+
+		/* stop FCC driver */
+		/* don't stop PHY to keep interupts */
+		fcc_stop(dev);
+
+		/* force PHY power down */
+		control = mii_read(dev, mk_mii_read(MII_LXT971_CR));
+		control |= MII_CR_POWERDOWN;
+		mii_queue(dev, mk_mii_write(MII_LXT971_CR, control), NULL);
+
+		/* prepare new advertissements */
+		advertise =	mii_read(dev, mk_mii_read(MII_LXT971_AR));
+
+		if (ecmd.autoneg == AUTONEG_ENABLE){
+			/* no flow control */
+			advertise &= ~(MII_AR_CRTL_PAUSE | MII_AR_CTRL_PAUSE_ASY);
+
+			/* set speed and duplex */
+			if (ecmd.advertising & ADVERTISED_100baseT_Full) {
+				advertise |= MII_AR_100MB_FULLDUP;
+			} else {
+				advertise &= ~MII_AR_100MB_FULLDUP;
+			}
+			if (ecmd.advertising & ADVERTISED_100baseT_Half) {
+				advertise |= MII_AR_100MB_HALFDUP;
+			} else {
+				advertise &= ~MII_AR_100MB_HALFDUP;
+			}
+			if (ecmd.advertising & ADVERTISED_10baseT_Full) {
+				advertise |= MII_AR_10MB_FULLDUP;
+			} else {
+				advertise &= ~MII_AR_10MB_FULLDUP;
+			}
+			if (ecmd.advertising & ADVERTISED_10baseT_Half) {
+				advertise |= MII_AR_10MB_HALFDUP;
+			} else {
+				advertise &= ~MII_AR_10MB_HALFDUP;
+			}
+		} else {
+			/* erase all advertisements if autoneg is disabled */
+			advertise &= ~(MII_AR_CRTL_PAUSE | MII_AR_CTRL_PAUSE_ASY |
+						MII_AR_100MB_FULLDUP | MII_AR_100MB_HALFDUP | 
+						MII_AR_10MB_FULLDUP | MII_AR_10MB_HALFDUP);
+		}
+
+		mii_queue(dev, mk_mii_write(MII_LXT971_AR, advertise), NULL);
+
+		/* prepare new controls */
+		control =	mii_read(dev, mk_mii_read(MII_LXT971_CR));
+
+		/* force power up */
+		control &= ~MII_CR_POWERDOWN;
+
+		/* set autoneg */
+		if (ecmd.autoneg == AUTONEG_ENABLE) {
+			/* force autoneg */
+			/* don't touch speed and duplex */
+			control |= (MII_CR_ENABLE_NEG | MII_CR_RENEGOTIATE);
+		} else {
+			control &= ~(MII_CR_ENABLE_NEG | MII_CR_RENEGOTIATE);
+
+			/* force speed */
+			switch (ecmd.speed) {
+			case SPEED_100 :
+				control |= MII_CR_SPEED_100M;
+				break;
+			case SPEED_10 :
+			default :
+				control &= ~MII_CR_SPEED_100M;
+				break;
+			}
+
+			/* force duplex */
+			switch (ecmd.duplex) {
+			case DUPLEX_FULL :
+				control |= MII_CR_FULLDUPLEX;
+				break;
+			case DUPLEX_HALF :
+			default :
+				control &= ~MII_CR_FULLDUPLEX;
+				break;
+			}
+		}
+
+		/* force no loopback */
+		control &= ~MII_CR_LBK_MODE;
+
+		mii_queue(dev, mk_mii_write(MII_LXT971_CR, control), NULL);
+		/* changes must generate a link interrupt with a call */
+		/* to mii_relink which restarts the fcc */
+		break;
+
+	case ETHTOOL_GLINK:		/* Get link status */
+		mii_queue(dev, mk_mii_read(MII_LXT971_SR), mii_parse_sr);
+		evalue.data = fep->link;
+		if (copy_to_user(arg, &evalue, sizeof(evalue))) {
+			return -EFAULT;
+		}
+		break;
+
+	case ETHTOOL_GDRVINFO:	/* Get driver info. */
+	case ETHTOOL_GREGS:		/* Get NIC registers, privileged. */
+	case ETHTOOL_GWOL:		/* Get wake-on-lan options. */
+	case ETHTOOL_SWOL:		/* Set wake-on-lan options, priv. */
+	case ETHTOOL_GMSGLVL:	/* Get driver message level */
+	case ETHTOOL_SMSGLVL:	/* Set driver msg level, priv. */
+	case ETHTOOL_NWAY_RST:	/* Restart autonegotiation, priv. */
+	case ETHTOOL_GEEPROM:	/* Get EEPROM data */
+	case ETHTOOL_SEEPROM:	/* Set EEPROM data */
+	default:
+		rc = -EOPNOTSUPP;
+		break;
+	}
+
+	return rc;
+}
+#endif	/* CONFIG_USE_MDIO */
diff -Nurp linux-2.6.9.orig/arch/ppc/boot/common/misc-common.c linux-2.6.9/arch/ppc/boot/common/misc-common.c
--- linux-2.6.9.orig/arch/ppc/boot/common/misc-common.c	2004-10-18 23:54:08.000000000 +0200
+++ linux-2.6.9/arch/ppc/boot/common/misc-common.c	2006-09-07 18:57:01.000000000 +0200
@@ -52,6 +52,7 @@ extern char _end[];
 void puts(const char *);
 void putc(const char c);
 void puthex(unsigned long val);
+void putdec(unsigned long val);
 void _bcopy(char *src, char *dst, int len);
 void gunzip(void *, int, unsigned char *, int *);
 static int _cvt(unsigned long val, char *buf, long radix, char *digits);
@@ -283,6 +284,20 @@ puthex(unsigned long val)
 	puts(buf);
 }
 
+void
+putdec(unsigned long val)
+{
+	unsigned char buf[] = "            \0";
+	int i;
+	for (i = 11;  i >= 0;  i--) {
+		buf[i] = "0123456789"[val % 10];
+		val -= val % 10;
+		val /= 10;
+		if (val == 0) break;
+	}
+	puts(&buf[i]);
+}
+
 #define FALSE 0
 #define TRUE  1
 
diff -Nurp linux-2.6.9.orig/arch/ppc/boot/simple/embed_config.c linux-2.6.9/arch/ppc/boot/simple/embed_config.c
--- linux-2.6.9.orig/arch/ppc/boot/simple/embed_config.c	2004-10-18 23:53:21.000000000 +0200
+++ linux-2.6.9/arch/ppc/boot/simple/embed_config.c	2006-09-07 18:57:01.000000000 +0200
@@ -9,970 +9,238 @@
 
 #include <linux/types.h>
 #include <linux/config.h>
-#include <linux/string.h>
-#include <asm/reg.h>
-#ifdef CONFIG_8xx
-#include <asm/mpc8xx.h>
-#endif
 #ifdef CONFIG_8260
 #include <asm/mpc8260.h>
 #include <asm/immap_cpm2.h>
+#include <asm/ppcboot.h>
 #endif
-#ifdef CONFIG_40x
-#include <asm/io.h>
-#endif
-extern unsigned long timebase_period_ns;
+#ifdef CONFIG_RGWYPQ2
+#include <platforms/rgwypq2.h>
+#endif /* CONFIG_RGWYPQ2 */
 
-/* For those boards that don't provide one.
-*/
-#if !defined(CONFIG_MBX)
 static	bd_t	bdinfo;
-#endif
-
-/* IIC functions.
- * These are just the basic master read/write operations so we can
- * examine serial EEPROM.
- */
-extern void	iic_read(uint devaddr, u_char *buf, uint offset, uint count);
-
-/* Supply a default Ethernet address for those eval boards that don't
- * ship with one.  This is an address from the MBX board I have, so
- * it is unlikely you will find it on your network.
- */
-static	ushort	def_enet_addr[] = { 0x0800, 0x3e26, 0x1559 };
-
-#if defined(CONFIG_MBX)
-
-/* The MBX hands us a pretty much ready to go board descriptor.  This
- * is where the idea started in the first place.
- */
-void
-embed_config(bd_t **bdp)
-{
-	u_char	*mp;
-	u_char	eebuf[128];
-	int i = 8;
-	bd_t    *bd;
-
-	bd = *bdp;
-
-	/* Read the first 128 bytes of the EEPROM.  There is more,
-	 * but this is all we need.
-	 */
-	iic_read(0xa4, eebuf, 0, 128);
-
-	/* All we are looking for is the Ethernet MAC address.  The
-	 * first 8 bytes are 'MOTOROLA', so check for part of that.
-	 * Next, the VPD describes a MAC 'packet' as being of type 08
-	 * and size 06.  So we look for that and the MAC must follow.
-	 * If there are more than one, we still only care about the first.
-	 * If it's there, assume we have a valid MAC address.  If not,
-	 * grab our default one.
-	 */
-	if ((*(uint *)eebuf) == 0x4d4f544f) {
-		while (i < 127 && !(eebuf[i] == 0x08 && eebuf[i + 1] == 0x06))
-			 i += eebuf[i + 1] + 2;  /* skip this packet */
-
-		if (i == 127)	/* Couldn't find. */
-			mp = (u_char *)def_enet_addr;
-		else
-			mp = &eebuf[i + 2];
-	}
-	else
-		mp = (u_char *)def_enet_addr;
-
-	for (i=0; i<6; i++)
-		bd->bi_enetaddr[i] = *mp++;
-
-	/* The boot rom passes these to us in MHz.  Linux now expects
-	 * them to be in Hz.
-	 */
-	bd->bi_intfreq *= 1000000;
-	bd->bi_busfreq *= 1000000;
-
-	/* Stuff a baud rate here as well.
-	*/
-	bd->bi_baudrate = 9600;
-}
-#endif /* CONFIG_MBX */
-
-#if defined(CONFIG_RPXLITE) || defined(CONFIG_RPXCLASSIC) || \
-	defined(CONFIG_RPX8260) || defined(CONFIG_EP405)
-/* Helper functions for Embedded Planet boards.
-*/
-/* Because I didn't find anything that would do this.......
-*/
-u_char
-aschex_to_byte(u_char *cp)
-{
-	u_char	byte, c;
-
-	c = *cp++;
-
-	if ((c >= 'A') && (c <= 'F')) {
-		c -= 'A';
-		c += 10;
-	} else if ((c >= 'a') && (c <= 'f')) {
-		c -= 'a';
-		c += 10;
-	} else
-		c -= '0';
-
-	byte = c * 16;
-
-	c = *cp;
-
-	if ((c >= 'A') && (c <= 'F')) {
-		c -= 'A';
-		c += 10;
-	} else if ((c >= 'a') && (c <= 'f')) {
-		c -= 'a';
-		c += 10;
-	} else
-		c -= '0';
-
-	byte += c;
-
-	return(byte);
-}
-
-static void
-rpx_eth(bd_t *bd, u_char *cp)
-{
-	int	i;
-
-	for (i=0; i<6; i++) {
-		bd->bi_enetaddr[i] = aschex_to_byte(cp);
-		cp += 2;
-	}
-}
-
-#ifdef CONFIG_RPX8260
-static uint
-rpx_baseten(u_char *cp)
-{
-	uint	retval;
-
-	retval = 0;
-
-	while (*cp != '\n') {
-		retval *= 10;
-		retval += (*cp) - '0';
-		cp++;
-	}
-	return(retval);
-}
-#endif
-
-#if defined(CONFIG_RPXLITE) || defined(CONFIG_RPXCLASSIC)
-static void
-rpx_brate(bd_t *bd, u_char *cp)
-{
-	uint	rate;
-
-	rate = 0;
-
-	while (*cp != '\n') {
-		rate *= 10;
-		rate += (*cp) - '0';
-		cp++;
-	}
-
-	bd->bi_baudrate = rate * 100;
-}
 
-static void
-rpx_cpuspeed(bd_t *bd, u_char *cp)
-{
-	uint	num, den;
-
-	num = den = 0;
-
-	while (*cp != '\n') {
-		num *= 10;
-		num += (*cp) - '0';
-		cp++;
-		if (*cp == '/') {
-			cp++;
-			den = (*cp) - '0';
-			break;
-		}
-	}
+#define MAGIC_CAST(a)   a = ((a/100)*100) + ((a/100)%10)*10 + ((a/100)%10)
 
-	/* I don't know why the RPX just can't state the actual
-	 * CPU speed.....
-	 */
-	if (den) {
-		num /= den;
-		num *= den;
-	}
-	bd->bi_intfreq = bd->bi_busfreq = num * 1000000;
+#define BRD_33_33MHZ_INPUT	(33333333)			/* 33.33 MHz input clock*/
+#define BRD_66_66MHZ_INPUT	(66666666)			/* 66.66 MHz input clock*/
 
-	/* The 8xx can only run a maximum 50 MHz bus speed (until
-	 * Motorola changes this :-).  Greater than 50 MHz parts
-	 * run internal/2 for bus speed.
-	 */
-	if (num > 50)
-		bd->bi_busfreq /= 2;
-}
-#endif
+#define BRD_25_00MHZ_INPUT	(25000000)			/* 25.00 MHz input clock*/
+#define BRD_50_00MHZ_INPUT	(50000000)			/* 50.00 MHz input clock*/
 
-#if defined(CONFIG_RPXLITE) || defined(CONFIG_RPXCLASSIC) || defined(CONFIG_EP405)
-static void
-rpx_memsize(bd_t *bd, u_char *cp)
-{
-	uint	size;
-
-	size = 0;
-
-	while (*cp != '\n') {
-		size *= 10;
-		size += (*cp) - '0';
-		cp++;
-	}
-
-	bd->bi_memsize = size * 1024 * 1024;
-}
-#endif /* LITE || CLASSIC || EP405 */
-#if defined(CONFIG_EP405)
-static void
-rpx_nvramsize(bd_t *bd, u_char *cp)
-{
-	uint	size;
-
-	size = 0;
-
-	while (*cp != '\n') {
-		size *= 10;
-		size += (*cp) - '0';
-		cp++;
-	}
-
-	bd->bi_nvramsize = size * 1024;
-}
-#endif /* CONFIG_EP405 */
-
-#endif	/* Embedded Planet boards */
-
-#if defined(CONFIG_RPXLITE) || defined(CONFIG_RPXCLASSIC)
-
-/* Read the EEPROM on the RPX-Lite board.
-*/
-void
-embed_config(bd_t **bdp)
-{
-	u_char	eebuf[256], *cp;
-	bd_t	*bd;
-
-	/* Read the first 256 bytes of the EEPROM.  I think this
-	 * is really all there is, and I hope if it gets bigger the
-	 * info we want is still up front.
-	 */
+#define INPUT_PCI_CLK_LOW	{	\
+	/* For CPLD version 0.x.x */ BRD_33_33MHZ_INPUT,	\
+	/* For CPLD version 1.x.x */ BRD_33_33MHZ_INPUT,	\
+	/* For CPLD version 2.x.x */ BRD_33_33MHZ_INPUT,	\
+	/* For CPLD version 3.x.x */ BRD_33_33MHZ_INPUT,	\
+	/* For CPLD version 4.x.x */ BRD_33_33MHZ_INPUT,	\
+	/* For CPLD version 5.x.x */ BRD_33_33MHZ_INPUT,	\
+	/* For CPLD version 6.x.x */ BRD_33_33MHZ_INPUT,	\
+	/* For CPLD version 7.x.x */ BRD_33_33MHZ_INPUT,	\
+	/* For CPLD version 8.x.x */ BRD_33_33MHZ_INPUT,	\
+	/* For CPLD version 9.x.x */ BRD_25_00MHZ_INPUT	 }
+		
+#define INPUT_PCI_CLK_HIGH	{	\
+	/* For CPLD version 0.x.x */ BRD_66_66MHZ_INPUT,	\
+	/* For CPLD version 1.x.x */ BRD_66_66MHZ_INPUT,	\
+	/* For CPLD version 2.x.x */ BRD_66_66MHZ_INPUT,	\
+	/* For CPLD version 3.x.x */ BRD_66_66MHZ_INPUT,	\
+	/* For CPLD version 4.x.x */ BRD_66_66MHZ_INPUT,	\
+	/* For CPLD version 5.x.x */ BRD_66_66MHZ_INPUT,	\
+	/* For CPLD version 6.x.x */ BRD_66_66MHZ_INPUT,	\
+	/* For CPLD version 7.x.x */ BRD_66_66MHZ_INPUT,	\
+	/* For CPLD version 8.x.x */ BRD_66_66MHZ_INPUT,	\
+	/* For CPLD version 9.x.x */ BRD_50_00MHZ_INPUT	}	
+
+static int Value_PCI_clock_LOW[]	= INPUT_PCI_CLK_LOW;
+static int Value_PCI_clock_HIGH[]	= INPUT_PCI_CLK_HIGH;
+
+#ifdef CONFIG_RGWYPQ2
+static  bd_t    bdinfo;
+ 
+void embed_config(bd_t **bdp) {
+	int     i;
+    cpm2_map_t  *imp = (cpm2_map_t *)IMAP_ADDR;
+	u_char  *cp;
+	bd_t    *bd;
+	uint	cpm_df;
+	uint	bus_df;
+	uint	pci_df;
+	uint	brg_df;
+	uint	core_cnf;
+	uint	pci_modck;
+	uint	main_clk;
+	uint	pci_freq;
+	u_char	cpld_ver;
+	volatile u_char   *pld_ident = 
+		(volatile u_char *)(BD_PLD_SYS_BASE_ADDR + 0x0000);
+	
 	bd = &bdinfo;
 	*bdp = bd;
+	
+	/* configure PA10 and PA11 as input GPIO */
+	imp->im_ioport.iop_pdira &= ~(0x00300000);
+	imp->im_ioport.iop_ppara &= ~(0x00300000);
+	imp->im_ioport.iop_psora &= ~(0x00300000);
+	imp->im_ioport.iop_podra &= ~(0x00300000);
 
-#if 1
-	iic_read(0xa8, eebuf, 0, 128);
-	iic_read(0xa8, &eebuf[128], 128, 128);
-
-	/* We look for two things, the Ethernet address and the
-	 * serial baud rate.  The records are separated by
-	 * newlines.
-	 */
-	cp = eebuf;
-	for (;;) {
-		if (*cp == 'E') {
-			cp++;
-			if (*cp == 'A') {
-				cp += 2;
-				rpx_eth(bd, cp);
-			}
-		}
-		if (*cp == 'S') {
-			cp++;
-			if (*cp == 'B') {
-				cp += 2;
-				rpx_brate(bd, cp);
-			}
-		}
-		if (*cp == 'D') {
-			cp++;
-			if (*cp == '1') {
-				cp += 2;
-				rpx_memsize(bd, cp);
-			}
-		}
-		if (*cp == 'H') {
-			cp++;
-			if (*cp == 'Z') {
-				cp += 2;
-				rpx_cpuspeed(bd, cp);
-			}
-		}
-
-		/* Scan to the end of the record.
-		*/
-		while ((*cp != '\n') && (*cp != 0xff))
-			cp++;
-
-		/* If the next character is a 0 or ff, we are done.
-		*/
-		cp++;
-		if ((*cp == 0) || (*cp == 0xff))
-			break;
-	}
-	bd->bi_memstart = 0;
-#else
-	/* For boards without initialized EEPROM.
-	*/
+	/* memory */
 	bd->bi_memstart = 0;
-	bd->bi_memsize = (8 * 1024 * 1024);
-	bd->bi_intfreq = 48000000;
-	bd->bi_busfreq = 48000000;
-	bd->bi_baudrate = 9600;
-#endif
-}
-#endif /* RPXLITE || RPXCLASSIC */
-
-#ifdef CONFIG_BSEIP
-/* Build a board information structure for the BSE ip-Engine.
- * There is more to come since we will add some environment
- * variables and a function to read them.
- */
-void
-embed_config(bd_t **bdp)
-{
-	u_char	*cp;
-	int	i;
-	bd_t	*bd;
+	switch (((imp->im_ioport.iop_pdata >> 20) & 0x3)) {
+	default:
+	case 0:
+		bd->bi_memsize  = (32 * 1024 * 1024);
+		break;
+	case 1:
+		bd->bi_memsize  = (64 * 1024 * 1024);
+		break;
+	case 2:
+		bd->bi_memsize  = (128 * 1024 * 1024);
+		break;
+	}
+
+	/* flash unused */
+	bd->bi_flashstart 	= 0;
+	bd->bi_flashsize 	= 0;
+	bd->bi_flashoffset 	= 0;
+
+	/* sram unused */
+	bd->bi_sramstart 	= 0;
+	bd->bi_sramsize 	= 0;
 
-	bd = &bdinfo;
-	*bdp = bd;
-
-	/* Baud rate and processor speed will eventually come
-	 * from the environment variables.
-	 */
-	bd->bi_baudrate = 9600;
+	/* immr base */
+	bd->bi_immr_base	= IMAP_ADDR;
+	
+	/* boot flags unused */
+	bd->bi_bootflags	= 0;
 
-	/* Get the Ethernet station address from the Flash ROM.
-	*/
-	cp = (u_char *)0xfe003ffa;
+	/* ip adress unused */
+	bd->bi_ip_addr 		= 0;
+	
+	/* ethernet address from icdata */
+	cp = (u_char *)(BD_BFLASH_BASE_ADDR + 0x2008);
 	for (i=0; i<6; i++) {
 		bd->bi_enetaddr[i] = *cp++;
 	}
 
-	/* The rest of this should come from the environment as well.
-	*/
-	bd->bi_memstart = 0;
-	bd->bi_memsize = (16 * 1024 * 1024);
-	bd->bi_intfreq = 48000000;
-	bd->bi_busfreq = 48000000;
-}
-#endif /* BSEIP */
-
-#ifdef CONFIG_FADS
-/* Build a board information structure for the FADS.
- */
-void
-embed_config(bd_t **bdp)
-{
-	u_char	*cp;
-	int	i;
-	bd_t	*bd;
-
-	bd = &bdinfo;
-	*bdp = bd;
+	/* ethernet speed unused */
+	bd->bi_ethspeed 	= 0;
 
-	/* Just fill in some known values.
-	 */
-	bd->bi_baudrate = 9600;
-
-	/* Use default enet.
-	*/
-	cp = (u_char *)def_enet_addr;
-	for (i=0; i<6; i++) {
-		bd->bi_enetaddr[i] = *cp++;
+	/* frequencies */
+	cpld_ver = pld_ident[5] - '0';
+	if (cpld_ver >= (sizeof(Value_PCI_clock_LOW)/sizeof(int))) {
+		cpld_ver = 0;
 	}
 
-	bd->bi_memstart = 0;
-	bd->bi_memsize = (8 * 1024 * 1024);
-	bd->bi_intfreq = 40000000;
-	bd->bi_busfreq = 40000000;
-}
-#endif /* FADS */
-
-#ifdef CONFIG_8260
-/* Compute 8260 clock values if the rom doesn't provide them.
- */
-static unsigned char bus2core_8260[] = {
-/*      0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f */
-	3,  2,  2,  2,  4,  4,  5,  9,  6, 11,  8, 10,  3, 12,  7,  2,
-	6,  5, 13,  2, 14,  4, 15,  2,  3, 11,  8, 10, 16, 12,  7,  2,
-};
-
-static void
-clk_8260(bd_t *bd)
-{
-	uint	scmr, vco_out, clkin;
-	uint	plldf, pllmf, corecnf;
-	volatile cpm2_map_t	*ip;
-
-	ip = (cpm2_map_t *)CPM_MAP_ADDR;
-	scmr = ip->im_clkrst.car_scmr;
-
-	/* The clkin is always bus frequency.
-	*/
-	clkin = bd->bi_busfreq;
-
-	/* Collect the bits from the scmr.
-	*/
-	plldf = (scmr >> 12) & 1;
-	pllmf = scmr & 0xfff;
-	corecnf = (scmr >> 24) &0x1f;
-
-	/* This is arithmetic from the 8260 manual.
-	*/
-	vco_out = clkin / (plldf + 1);
-	vco_out *= 2 * (pllmf + 1);
-	bd->bi_vco = vco_out;		/* Save for later */
-
-	bd->bi_cpmfreq = vco_out / 2;	/* CPM Freq, in MHz */
-	bd->bi_intfreq = bd->bi_busfreq * bus2core_8260[corecnf] / 2;
-
-	/* Set Baud rate divisor.  The power up default is divide by 16,
-	 * but we set it again here in case it was changed.
-	 */
-	ip->im_clkrst.car_sccr = 1;	/* DIV 16 BRG */
-	bd->bi_brgfreq = vco_out / 16;
-}
-
-static unsigned char bus2core_8280[] = {
-/*      0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f */
-	3,  2,  2,  2,  4,  4,  5,  9,  6, 11,  8, 10,  3, 12,  7,  2,
-	6,  5, 13,  2, 14,  2, 15,  2,  3,  2,  2,  2, 16,  2,  2,  2,
-};
-
-static void
-clk_8280(bd_t *bd)
-{
-	uint	scmr, main_clk, clkin;
-	uint	pllmf, corecnf;
-	volatile cpm2_map_t	*ip;
-
-	ip = (cpm2_map_t *)CPM_MAP_ADDR;
-	scmr = ip->im_clkrst.car_scmr;
-
-	/* The clkin is always bus frequency.
-	*/
-	clkin = bd->bi_busfreq;
-
-	/* Collect the bits from the scmr.
-	*/
-	pllmf = scmr & 0xf;
-	corecnf = (scmr >> 24) & 0x1f;
-
-	/* This is arithmetic from the 8280 manual.
-	*/
-	main_clk = clkin * (pllmf + 1);
-
-	bd->bi_cpmfreq = main_clk / 2;	/* CPM Freq, in MHz */
-	bd->bi_intfreq = bd->bi_busfreq * bus2core_8280[corecnf] / 2;
-
-	/* Set Baud rate divisor.  The power up default is divide by 16,
-	 * but we set it again here in case it was changed.
-	 */
-	ip->im_clkrst.car_sccr = (ip->im_clkrst.car_sccr & 0x3) | 0x1;
-	bd->bi_brgfreq = main_clk / 16;
-}
-#endif
-
-#ifdef CONFIG_SBC82xx
-void
-embed_config(bd_t **bdp)
-{
-	u_char	*cp;
-	int	i;
-	bd_t	*bd;
-	unsigned long pvr;
-
-	bd = *bdp;
-
-	bd = &bdinfo;
-	*bdp = bd;
-	bd->bi_baudrate = 9600;
-	bd->bi_memsize = 256 * 1024 * 1024;	/* just a guess */
-
-	cp = (void*)SBC82xx_MACADDR_NVRAM_SCC1;
-	memcpy(bd->bi_enetaddr, cp, 6);
-
-	/* can busfreq be calculated? */
-	pvr = mfspr(PVR);
-	if ((pvr & 0xffff0000) == 0x80820000) {
-		bd->bi_busfreq = 100000000;
-		clk_8280(bd);
+	if (imp->im_clkrst.car_sccr & (1<<(31-24))) {
+		pci_freq = Value_PCI_clock_LOW[cpld_ver];
 	} else {
-		bd->bi_busfreq = 66000000;
-		clk_8260(bd);
+		pci_freq = Value_PCI_clock_HIGH[cpld_ver];
 	}
 
-}
-#endif /* SBC82xx */
-
-#if defined(CONFIG_EST8260) || defined(CONFIG_TQM8260)
-void
-embed_config(bd_t **bdp)
-{
-	u_char	*cp;
-	int	i;
-	bd_t	*bd;
-
-	bd = *bdp;
-#if 0
-	/* This is actually provided by my boot rom.  I have it
-	 * here for those people that may load the kernel with
-	 * a JTAG/COP tool and not the rom monitor.
-	 */
-	bd->bi_baudrate = 115200;
-	bd->bi_intfreq = 200000000;
-	bd->bi_busfreq = 66666666;
-	bd->bi_cpmfreq = 66666666;
-	bd->bi_brgfreq = 33333333;
-	bd->bi_memsize = 16 * 1024 * 1024;
-#else
-	/* The boot rom passes these to us in MHz.  Linux now expects
-	 * them to be in Hz.
-	 */
-	bd->bi_intfreq *= 1000000;
-	bd->bi_busfreq *= 1000000;
-	bd->bi_cpmfreq *= 1000000;
-	bd->bi_brgfreq *= 1000000;
-#endif
-
-	cp = (u_char *)def_enet_addr;
-	for (i=0; i<6; i++) {
-		bd->bi_enetaddr[i] = *cp++;
-	}
-}
-#endif /* EST8260 */
+	cpm_df		= ((imp->im_clkrst.car_scmr	>> (31-15)) & 0x0F);
+	bus_df		= ((imp->im_clkrst.car_scmr	>> (31-11)) & 0x0F);
+	core_cnf	= ((imp->im_clkrst.car_scmr	>> (31- 7)) & 0x1F);
+	pci_modck	= ((imp->im_clkrst.car_sccr	>> (31-24)) & 0x01);
+	pci_df		= ((imp->im_clkrst.car_sccr	>> (31-28)) & 0x0F);
+	brg_df		= ((imp->im_clkrst.car_sccr	>> (0))     & 0x03);
 
-#ifdef CONFIG_SBS8260
-void
-embed_config(bd_t **bdp)
-{
-	u_char	*cp;
-	int	i;
-	bd_t	*bd;
-
-	/* This should provided by the boot rom.
-	 */
-	bd = &bdinfo;
-	*bdp = bd;
-	bd->bi_baudrate = 9600;
-	bd->bi_memsize = 64 * 1024 * 1024;
-
-	/* Set all of the clocks.  We have to know the speed of the
-	 * external clock.  The development board had 66 MHz.
-	 */
-	bd->bi_busfreq = 66666666;
-	clk_8260(bd);
-
-	/* I don't know how to compute this yet.
-	*/
-	bd->bi_intfreq = 133000000;
-
-
-	cp = (u_char *)def_enet_addr;
-	for (i=0; i<6; i++) {
-		bd->bi_enetaddr[i] = *cp++;
-	}
-}
-#endif /* SBS8260 */
-
-#ifdef CONFIG_RPX8260
-void
-embed_config(bd_t **bdp)
-{
-	u_char	*cp, *keyvals;
-	int	i;
-	bd_t	*bd;
-
-	keyvals = (u_char *)*bdp;
-
-	bd = &bdinfo;
-	*bdp = bd;
-
-	/* This is almost identical to the RPX-Lite/Classic functions
-	 * on the 8xx boards.  It would be nice to have a key lookup
-	 * function in a string, but the format of all of the fields
-	 * is slightly different.
-	 */
-	cp = keyvals;
-	for (;;) {
-		if (*cp == 'E') {
-			cp++;
-			if (*cp == 'A') {
-				cp += 2;
-				rpx_eth(bd, cp);
-			}
-		}
-		if (*cp == 'S') {
-			cp++;
-			if (*cp == 'B') {
-				cp += 2;
-				bd->bi_baudrate = rpx_baseten(cp);
-			}
-		}
-		if (*cp == 'D') {
-			cp++;
-			if (*cp == '1') {
-				cp += 2;
-				bd->bi_memsize = rpx_baseten(cp) * 1024 * 1024;
-			}
-		}
-		if (*cp == 'X') {
-			cp++;
-			if (*cp == 'T') {
-				cp += 2;
-				bd->bi_busfreq = rpx_baseten(cp);
-			}
-		}
-		if (*cp == 'N') {
-			cp++;
-			if (*cp == 'V') {
-				cp += 2;
-				bd->bi_nvsize = rpx_baseten(cp) * 1024 * 1024;
-			}
-		}
-
-		/* Scan to the end of the record.
-		*/
-		while ((*cp != '\n') && (*cp != 0xff))
-			cp++;
-
-		/* If the next character is a 0 or ff, we are done.
-		*/
-		cp++;
-		if ((*cp == 0) || (*cp == 0xff))
-			break;
+	if ((pci_df == 9) || (pci_df == 11)) {
+		main_clk = ((pci_freq + 1) * (pci_df + 1));
+	} else {
+		main_clk = ((pci_freq + 1) * (pci_df + 1) * (pci_modck + 1));
 	}
-	bd->bi_memstart = 0;
-
-	/* The memory size includes both the 60x and local bus DRAM.
-	 * I don't want to use the local bus DRAM for real memory,
-	 * so subtract it out.  It would be nice if they were separate
-	 * keys.
-	 */
-	bd->bi_memsize -= 32 * 1024 * 1024;
-
-	/* Set all of the clocks.  We have to know the speed of the
-	 * external clock.
-	 */
-	clk_8260(bd);
-
-	/* I don't know how to compute this yet.
-	*/
-	bd->bi_intfreq = 200000000;
-}
-#endif /* RPX6 for testing */
-
-#ifdef CONFIG_ADS8260
-void
-embed_config(bd_t **bdp)
-{
-	u_char	*cp;
-	int	i;
-	bd_t	*bd;
 
-	/* This should provided by the boot rom.
-	 */
-	bd = &bdinfo;
-	*bdp = bd;
-	bd->bi_baudrate = 9600;
-	bd->bi_memsize = 16 * 1024 * 1024;
+	bd->bi_cpmfreq = (main_clk / 2);
+	MAGIC_CAST( bd->bi_cpmfreq);
 
-	/* Set all of the clocks.  We have to know the speed of the
-	 * external clock.  The development board had 66 MHz.
-	 */
-	bd->bi_busfreq = 66666666;
-	clk_8260(bd);
+	bd->bi_busfreq = (main_clk / (bus_df + 1));
+	MAGIC_CAST( bd->bi_busfreq);
 
-	/* I don't know how to compute this yet.
-	*/
-	bd->bi_intfreq = 200000000;
-
-
-	cp = (u_char *)def_enet_addr;
-	for (i=0; i<6; i++) {
-		bd->bi_enetaddr[i] = *cp++;
-	}
-}
-#endif /* ADS8260 */
+	switch	(brg_df) {
+	case 0 : 
+		bd->bi_brgfreq = main_clk / 4;
+		break;
+	default:
+	case 1 : 
+		bd->bi_brgfreq = main_clk / 16;
+		break;
+	case 2 : 
+		bd->bi_brgfreq = main_clk / 64;
+		break;
+	case 3 : 
+		bd->bi_brgfreq = main_clk / 256;
+		break;
+	}
+	MAGIC_CAST( bd->bi_brgfreq);
+
+	switch(core_cnf) {
+	default :
+	case 0x01 :	
+	case 0x02 :
+		bd->bi_intfreq = bd->bi_busfreq;
+		break;
+	case 0x00 :
+	case 0x0C :
+		bd->bi_intfreq = (((main_clk / (bus_df + 1)) * 3) / 2);
+		break;
+	case 0x05 :	
+	case 0x15 :	
+	case 0x04 :	
+		bd->bi_intfreq = ((main_clk / (bus_df + 1)) * 2);
+		break;
+	case 0x11 :	
+	case 0x06 :	
+		bd->bi_intfreq = (((main_clk / (bus_df + 1)) * 5) / 2);
+		break;
+	case 0x10 :	
+	case 0x08 :	
+		bd->bi_intfreq = ((main_clk / (bus_df + 1)) * 3);
+		break;
+	case 0x0E :	
+	case 0x1E :	
+		bd->bi_intfreq = (((main_clk / (bus_df + 1)) * 7) / 2);
+		break;
+	case 0x0A :	
+	case 0x1A :	
+		bd->bi_intfreq = ((main_clk / (bus_df + 1)) * 4);
+		break;
+	case 0x07 :	
+	case 0x17 :	
+		bd->bi_intfreq = (((main_clk / (bus_df + 1)) * 9) / 2);
+		break;
+	case 0x0B :	
+	case 0x1B :	
+		bd->bi_intfreq = ((main_clk / (bus_df + 1)) * 5);
+		break;
+	case 0x09 :	
+	case 0x19 :	
+		bd->bi_intfreq = (((main_clk / (bus_df + 1)) * 11) / 2);
+		break;
+	case 0x0D :	
+	case 0x1D :	
+		bd->bi_intfreq = ((main_clk / (bus_df + 1)) * 6);
+		break;
+	case 0x12 :	
+		bd->bi_intfreq = (((main_clk / (bus_df + 1)) * 13) / 2);
+		break;
+	case 0x14 :	
+		bd->bi_intfreq = ((main_clk / (bus_df + 1)) * 7);
+		break;
+	case 0x16 :	
+		bd->bi_intfreq = (((main_clk / (bus_df + 1)) * 15) / 2);
+		break;
+	case 0x1C :	
+		bd->bi_intfreq = ((main_clk / (bus_df + 1)) * 8);
+		break;
+	}
+	MAGIC_CAST( bd->bi_intfreq);
+ 
+	/* unused */
+	bd->bi_sccfreq	= 0;
+	bd->bi_vco 		= 0;
 
-#ifdef CONFIG_WILLOW
-void
-embed_config(bd_t **bdp)
-{
-	u_char	*cp;
-	int	i;
-	bd_t	*bd;
-
-	/* Willow has Open Firmware....I should learn how to get this
-	 * information from it.
-	 */
-	bd = &bdinfo;
-	*bdp = bd;
+	/* console baud rate */
 	bd->bi_baudrate = 9600;
-	bd->bi_memsize = 32 * 1024 * 1024;
-
-	/* Set all of the clocks.  We have to know the speed of the
-	 * external clock.  The development board had 66 MHz.
-	 */
-	bd->bi_busfreq = 66666666;
-	clk_8260(bd);
-
-	/* I don't know how to compute this yet.
-	*/
-	bd->bi_intfreq = 200000000;
-
-
-	cp = (u_char *)def_enet_addr;
-	for (i=0; i<6; i++) {
-		bd->bi_enetaddr[i] = *cp++;
-	}
 }
-#endif /* WILLOW */
-
-#ifdef CONFIG_XILINX_ML300
-void
-embed_config(bd_t ** bdp)
-{
-	static const unsigned long line_size = 32;
-	static const unsigned long congruence_classes = 256;
-	unsigned long addr;
-	u_char *cp;
-	int i;
-	bd_t *bd;
-
-	/*
-	 * At one point, we were getting machine checks.  Linux was not
-	 * invalidating the data cache before it was enabled.  The
-	 * following code was added to do that.  Soon after we had done
-	 * that, we found the real reasons for the machine checks.  I've
-	 * run the kernel a few times with the following code
-	 * temporarily removed without any apparent problems.  However,
-	 * I objdump'ed the kernel and boot code and found out that
-	 * there were no other dccci's anywhere, so I put the code back
-	 * in and have been reluctant to remove it.  It seems safer to
-	 * just leave it here.
-	 */
-	for (addr = 0;
-	     addr < (congruence_classes * line_size); addr += line_size) {
-	      __asm__("dccci 0,%0": :"b"(addr));
-	}
-
-	bd = &bdinfo;
-	*bdp = bd;
-	bd->bi_memsize = XPAR_DDR_0_SIZE;
-	bd->bi_intfreq = XPAR_CORE_CLOCK_FREQ_HZ;
-	bd->bi_busfreq = XPAR_PLB_CLOCK_FREQ_HZ;
-}
-#endif /* CONFIG_XILINX_ML300 */
-
-#ifdef CONFIG_IBM_OPENBIOS
-/* This could possibly work for all treeboot roms.
-*/
-#if defined(CONFIG_ASH) || defined(CONFIG_BEECH) || defined(CONFIG_BUBINGA)
-#define BOARD_INFO_VECTOR       0xFFF80B50 /* openbios 1.19 moved this vector down  - armin */
-#else
-#define BOARD_INFO_VECTOR	0xFFFE0B50
-#endif
-
-#ifdef CONFIG_BEECH
-static void
-get_board_info(bd_t **bdp)
-{
-	typedef void (*PFV)(bd_t *bd);
-	((PFV)(*(unsigned long *)BOARD_INFO_VECTOR))(*bdp);
-	return;
-}
-
-void
-embed_config(bd_t **bdp)
-{
-        *bdp = &bdinfo;
-	get_board_info(bdp);
-}
-#else /* !CONFIG_BEECH */
-void
-embed_config(bd_t **bdp)
-{
-	u_char	*cp;
-	int	i;
-	bd_t	*bd, *treeboot_bd;
-	bd_t *(*get_board_info)(void) =
-	    (bd_t *(*)(void))(*(unsigned long *)BOARD_INFO_VECTOR);
-#if !defined(CONFIG_STB03xxx)
-
-	/* shut down the Ethernet controller that the boot rom
-	 * sometimes leaves running.
-	 */
-	mtdcr(DCRN_MALCR(DCRN_MAL_BASE), MALCR_MMSR);     /* 1st reset MAL */
-	while (mfdcr(DCRN_MALCR(DCRN_MAL_BASE)) & MALCR_MMSR) {}; /* wait for the reset */	
-	out_be32((volatile u32*)EMAC0_BASE,0x20000000);        /* then reset EMAC */
-#endif
-
-	bd = &bdinfo;
-	*bdp = bd;
-	if ((treeboot_bd = get_board_info()) != NULL) {
-		memcpy(bd, treeboot_bd, sizeof(bd_t));
-	}
-	else {
-		/* Hmmm...better try to stuff some defaults.
-		*/
-		bd->bi_memsize = 16 * 1024 * 1024;
-		cp = (u_char *)def_enet_addr;
-		for (i=0; i<6; i++) {
-			/* I should probably put different ones here,
-			 * hopefully only one is used.
-			 */
-			bd->BD_EMAC_ADDR(0,i) = *cp;
-
-#ifdef CONFIG_PCI
-			bd->bi_pci_enetaddr[i] = *cp++;
-#endif
-		}
-		bd->bi_tbfreq = 200 * 1000 * 1000;
-		bd->bi_intfreq = 200000000;
-		bd->bi_busfreq = 100000000;
-#ifdef CONFIG_PCI
-		bd->bi_pci_busfreq = 66666666;
-#endif
-	}
-	/* Yeah, this look weird, but on Redwood 4 they are
-	 * different object in the structure.  Sincr Redwwood 5
-	 * and Redwood 6 use OpenBIOS, it requires a special value.
-	 */
-#if defined(CONFIG_REDWOOD_5) || defined (CONFIG_REDWOOD_6)
-	bd->bi_tbfreq = 27 * 1000 * 1000;
-#endif
-	timebase_period_ns = 1000000000 / bd->bi_tbfreq;
-}
-#endif /* CONFIG_BEECH */
-#endif /* CONFIG_IBM_OPENBIOS */
-
-#ifdef CONFIG_EP405
-#include <linux/serial_reg.h>
-
-void
-embed_config(bd_t **bdp)
-{
-	u32 chcr0;
-	u_char *cp;
-	bd_t	*bd;
-
-	/* Different versions of the PlanetCore firmware vary in how
-	   they set up the serial port - in particular whether they
-	   use the internal or external serial clock for UART0.  Make
-	   sure the UART is in a known state. */
-	/* FIXME: We should use the board's 11.0592MHz external serial
-	   clock - it will be more accurate for serial rates.  For
-	   now, however the baud rates in ep405.h are for the internal
-	   clock. */
-	chcr0 = mfdcr(DCRN_CHCR0);
-	if ( (chcr0 & 0x1fff) != 0x103e ) {
-		mtdcr(DCRN_CHCR0, (chcr0 & 0xffffe000) | 0x103e);
-		/* The following tricks serial_init() into resetting the baud rate */
-		writeb(0, UART0_IO_BASE + UART_LCR);
-	}
-
-	/* We haven't seen actual problems with the EP405 leaving the
-	 * EMAC running (as we have on Walnut).  But the registers
-	 * suggest it may not be left completely quiescent.  Reset it
-	 * just to be sure. */
-	mtdcr(DCRN_MALCR(DCRN_MAL_BASE), MALCR_MMSR);     /* 1st reset MAL */
-	while (mfdcr(DCRN_MALCR(DCRN_MAL_BASE)) & MALCR_MMSR) {}; /* wait for the reset */	
-	out_be32((unsigned *)EMAC0_BASE,0x20000000);        /* then reset EMAC */
-
-	bd = &bdinfo;
-	*bdp = bd;
-#if 1
-	        cp = (u_char *)0xF0000EE0;
-	        for (;;) {
-	                if (*cp == 'E') {
-	                        cp++;
-	                        if (*cp == 'A') {
-                                  cp += 2;
-                                  rpx_eth(bd, cp);
-	                        }
-		         }
-
-	         	if (*cp == 'D') {
-	                        	cp++;
-	                        	if (*cp == '1') {
-		                                cp += 2;
-		                                rpx_memsize(bd, cp);
-	        	                }
-                	}
-
-			if (*cp == 'N') {
-				cp++;
-				if (*cp == 'V') {
-					cp += 2;
-					rpx_nvramsize(bd, cp);
-				}
-			}
-			while ((*cp != '\n') && (*cp != 0xff))
-			      cp++;
-
-	                cp++;
-	                if ((*cp == 0) || (*cp == 0xff))
-	                   break;
-	       }
-	bd->bi_intfreq   = 200000000;
-	bd->bi_busfreq   = 100000000;
-	bd->bi_pci_busfreq= 33000000 ;
-#else
-
-	bd->bi_memsize   = 64000000;
-	bd->bi_intfreq   = 200000000;
-	bd->bi_busfreq   = 100000000;
-	bd->bi_pci_busfreq= 33000000 ;
-#endif
-}
-#endif
-
-#ifdef CONFIG_RAINIER
-/* Rainier uses vxworks bootrom */
-void
-embed_config(bd_t **bdp)
-{
-	u_char	*cp;
-	int	i;
-	bd_t	*bd;
-	
-	bd = &bdinfo;
-	*bdp = bd;
-	
-	for(i=0;i<8192;i+=32) {
-		__asm__("dccci 0,%0" :: "r" (i));
-	}
-	__asm__("iccci 0,0");
-	__asm__("sync;isync");
-
-	/* init ram for parity */
-	memset(0, 0,0x400000);  /* Lo memory */
-
-
-	bd->bi_memsize   = (32 * 1024 * 1024) ;
-	bd->bi_intfreq = 133000000; //the internal clock is 133 MHz
-	bd->bi_busfreq   = 100000000;
-	bd->bi_pci_busfreq= 33000000;
-
-	cp = (u_char *)def_enet_addr;
-	for (i=0; i<6; i++) {
-		bd->bi_enetaddr[i] = *cp++;
-	}
-
-}
-#endif
-
+#endif /* CONFIG_RGWYPQ2 */
diff -Nurp linux-2.6.9.orig/arch/ppc/boot/simple/m8260_tty.c linux-2.6.9/arch/ppc/boot/simple/m8260_tty.c
--- linux-2.6.9.orig/arch/ppc/boot/simple/m8260_tty.c	2004-10-18 23:53:46.000000000 +0200
+++ linux-2.6.9/arch/ppc/boot/simple/m8260_tty.c	2006-09-07 18:57:01.000000000 +0200
@@ -72,20 +72,36 @@ serial_init(int ignored, bd_t *bd)
 	io->iop_pdird |= 0x00000002;	/* Tx */
 
 #else
+#ifdef CONFIG_SERIAL_CPM_SMC1
 	sp = (smc_t*)&(ip->im_smc[0]);
 	*(ushort *)(&ip->im_dprambase[PROFF_SMC1_BASE]) = PROFF_SMC1;
 	up = (smc_uart_t *)&ip->im_dprambase[PROFF_SMC1];
+#else
+	sp = (smc_t*)&(ip->im_smc[1]);
+	*(ushort *)(&ip->im_dprambase[PROFF_SMC2_BASE]) = PROFF_SMC2;
+	up = (smc_uart_t *)&ip->im_dprambase[PROFF_SMC2];
+#endif
 
 	/* Disable transmitter/receiver.
 	*/
 	sp->smc_smcmr &= ~(SMCMR_REN | SMCMR_TEN);
 
+#ifdef CONFIG_SERIAL_CPM_SMC1
 	/* Use Port D for SMC1 instead of other functions.
 	*/
 	io->iop_ppard |= 0x00c00000;
 	io->iop_pdird |= 0x00400000;
 	io->iop_pdird &= ~0x00800000;
 	io->iop_psord &= ~0x00c00000;
+#else
+	/* Use Port A for SMC2 instead of other functions.
+	*/
+	io->iop_ppara |= 0x00c00000;
+	io->iop_pdira |= 0x00400000;
+	io->iop_pdira &= ~0x00800000;
+	io->iop_psora &= ~0x00c00000;
+#endif
+
 #endif
 
 	/* Allocate space for two buffer descriptors in the DP ram.
@@ -159,7 +175,7 @@ serial_init(int ignored, bd_t *bd)
 	sccp->scc_sccm = 0;
 	sccp->scc_scce = 0xffff;
 	sccp->scc_dsr = 0x7e7e;
-	sccp->scc_pmsr = 0x3000;
+	sccp->scc_psmr = 0x3000;
 
 	/* Wire BRG1 to SCC1.  The console driver will take care of
 	 * others.
@@ -193,9 +209,15 @@ serial_init(int ignored, bd_t *bd)
 
 	/* The baud rate divisor needs to be coordinated with clk_8260().
 	*/
+#ifdef CONFIG_SERIAL_CPM_SMC1
 	ip->im_brgc1 =
 		(((bd->bi_brgfreq/16) / bd->bi_baudrate) << 1) |
 								CPM_BRG_EN;
+#else
+	ip->im_brgc2 =
+		(((bd->bi_brgfreq/16) / bd->bi_baudrate) << 1) |
+								CPM_BRG_EN;
+#endif
 
 	/* Make the first buffer the only buffer.
 	*/
@@ -207,9 +229,13 @@ serial_init(int ignored, bd_t *bd)
 #ifdef SCC_CONSOLE
 	sccp->scc_gsmrl |= (SCC_GSMRL_ENR | SCC_GSMRL_ENT);
 #else
+#ifdef CONFIG_SERIAL_CPM_SMC1
 	cp->cp_cpcr = mk_cr_cmd(CPM_CR_SMC1_PAGE, CPM_CR_SMC1_SBLOCK, 0, CPM_CR_INIT_TRX) | CPM_CR_FLG;
 	while (cp->cp_cpcr & CPM_CR_FLG);
-
+#else
+	cp->cp_cpcr = mk_cr_cmd(CPM_CR_SMC2_PAGE, CPM_CR_SMC2_SBLOCK, 0, CPM_CR_INIT_TRX) | CPM_CR_FLG;
+	while (cp->cp_cpcr & CPM_CR_FLG);
+#endif
 	/* Enable transmitter/receiver.
 	*/
 	sp->smc_smcmr |= SMCMR_REN | SMCMR_TEN;
@@ -239,8 +265,13 @@ serial_readbuf(u_char *cbuf)
 	sup = (scc_uart_t *)&ip->im_dprambase[PROFF_SCC1 + ((SCC_CONSOLE-1) << 8)];
 	rbdf = (cbd_t *)&ip->im_dprambase[sup->scc_genscc.scc_rbase];
 #else
+#ifdef CONFIG_SERIAL_CPM_SMC1
 	up = (smc_uart_t *)&(ip->im_dprambase[PROFF_SMC1]);
 	rbdf = (cbd_t *)&ip->im_dprambase[up->smc_rbase];
+#else
+	up = (smc_uart_t *)&(ip->im_dprambase[PROFF_SMC2]);
+	rbdf = (cbd_t *)&ip->im_dprambase[up->smc_rbase];
+#endif
 #endif
 
 	/* Wait for character to show up.
@@ -272,8 +303,13 @@ serial_putc(void *ignored, const char c)
 	sup = (scc_uart_t *)&ip->im_dprambase[PROFF_SCC1 + ((SCC_CONSOLE-1) << 8)];
 	tbdf = (cbd_t *)&ip->im_dprambase[sup->scc_genscc.scc_tbase];
 #else
+#ifdef CONFIG_SERIAL_CPM_SMC1
 	up = (smc_uart_t *)&(ip->im_dprambase[PROFF_SMC1]);
 	tbdf = (cbd_t *)&ip->im_dprambase[up->smc_tbase];
+#else
+	up = (smc_uart_t *)&(ip->im_dprambase[PROFF_SMC2]);
+	tbdf = (cbd_t *)&ip->im_dprambase[up->smc_tbase];
+#endif
 #endif
 
 	/* Wait for last character to go.
@@ -317,8 +353,13 @@ serial_tstc(void *ignored)
 	sup = (scc_uart_t *)&ip->im_dprambase[PROFF_SCC1 + ((SCC_CONSOLE-1) << 8)];
 	rbdf = (cbd_t *)&ip->im_dprambase[sup->scc_genscc.scc_rbase];
 #else
+#ifdef CONFIG_SERIAL_CPM_SMC1
 	up = (smc_uart_t *)&(ip->im_dprambase[PROFF_SMC1]);
 	rbdf = (cbd_t *)&ip->im_dprambase[up->smc_rbase];
+#else
+	up = (smc_uart_t *)&(ip->im_dprambase[PROFF_SMC2]);
+	rbdf = (cbd_t *)&ip->im_dprambase[up->smc_rbase];
+#endif
 #endif
 
 	return(!(rbdf->cbd_sc & BD_SC_EMPTY));
diff -Nurp linux-2.6.9.orig/arch/ppc/boot/simple/Makefile linux-2.6.9/arch/ppc/boot/simple/Makefile
--- linux-2.6.9.orig/arch/ppc/boot/simple/Makefile	2004-10-18 23:53:06.000000000 +0200
+++ linux-2.6.9/arch/ppc/boot/simple/Makefile	2006-09-07 18:59:56.000000000 +0200
@@ -52,6 +52,11 @@ zimageinitrd-$(CONFIG_IBM_OPENBIOS)	:= z
          end-$(CONFIG_IBM_OPENBIOS)	:= treeboot
         misc-$(CONFIG_IBM_OPENBIOS)	:= misc-embedded.o
 
+      zimage-$(CONFIG_IBM_PIBS)		:= zImage-TREE
+zimageinitrd-$(CONFIG_IBM_PIBS)		:= zImage.initrd-TREE
+         end-$(CONFIG_IBM_PIBS)		:= treeboot
+        misc-$(CONFIG_IBM_PIBS)		:= misc-embedded.o
+
          end-$(CONFIG_EMBEDDEDBOOT)	:= embedded
         misc-$(CONFIG_EMBEDDEDBOOT)	:= misc-embedded.o
 
@@ -66,7 +71,7 @@ zimageinitrd-$(CONFIG_OCOTEA)		:= zImage
   entrypoint-$(CONFIG_OCOTEA)		:= 0x01000000
      extra.o-$(CONFIG_OCOTEA)		:= pibs.o
 
-     extra.o-$(CONFIG_EV64260)		:= direct.o misc-ev64260.o
+     extra.o-$(CONFIG_EV64260)		:= misc-ev64260.o
          end-$(CONFIG_EV64260)		:= ev64260
    cacheflag-$(CONFIG_EV64260)		:= -include $(clear_L2_L3)
 
@@ -192,10 +197,13 @@ $(obj)/zvmlinux.initrd: $(OBJS) $(LIBS) 
 # Sort-of dummy rules, that let us format the image we want.
 zImage: $(images)/$(zimage-y) $(obj)/zvmlinux
 	cp -f $(obj)/zvmlinux $(images)/zImage.elf
+	$(OBJCOPY) -I elf32-powerpc -O binary $(images)/zImage.elf $(images)/zImage
 	rm -f $(obj)/zvmlinux
 
 zImage.initrd: $(images)/$(zimageinitrd-y) $(obj)/zvmlinux.initrd
 	cp -f $(obj)/zvmlinux.initrd $(images)/zImage.initrd.elf
+	$(OBJCOPY) -I elf32-powerpc -O binary $(images)/zImage.initrd.elf $(images)/zImage.initrd
+	cp -f $(obj)/zvmlinux.initrd $(images)/zImage.initrd
 	rm -f $(obj)/zvmlinux.initrd
 
 znetboot: zImage
diff -Nurp linux-2.6.9.orig/arch/ppc/boot/simple/misc-embedded.c linux-2.6.9/arch/ppc/boot/simple/misc-embedded.c
--- linux-2.6.9.orig/arch/ppc/boot/simple/misc-embedded.c	2004-10-18 23:53:23.000000000 +0200
+++ linux-2.6.9/arch/ppc/boot/simple/misc-embedded.c	2006-09-07 18:57:01.000000000 +0200
@@ -70,7 +70,7 @@ extern unsigned long start;
 extern void flush_instruction_cache(void);
 extern void gunzip(void *, int, unsigned char *, int *);
 extern void embed_config(bd_t **bp);
-
+extern void putdec(unsigned long val);
 /* Weak function for boards which don't need to build the
  * board info struct because they are using PPCBoot/U-Boot.
  */
@@ -82,8 +82,13 @@ embed_config(bd_t **bdp)
 unsigned long
 load_kernel(unsigned long load_addr, int num_words, unsigned long cksum, bd_t *bp)
 {
+#ifdef CONFIG_RGWYPQ2
+	char *cp;
+	int zimage_size;
+#else
 	char *cp, ch;
 	int timer = 0, zimage_size;
+#endif
 	unsigned long initrd_size;
 
 	/* First, capture the embedded board information.  Then
@@ -94,6 +99,17 @@ load_kernel(unsigned long load_addr, int
 	com_port = serial_init(0, bp);
 #endif
 
+#ifdef CONFIG_RGWYPQ2
+puts("\n********************************\n");
+puts("SDRAM SIZE : ");putdec(bp->bi_memsize / (1024 * 1024));puts(" Mo\n");
+puts("CORE FREQ  : ");putdec(bp->bi_intfreq / 1000000);puts(" MHz\n");
+puts("CPM  FREQ  : ");putdec(bp->bi_cpmfreq / 1000000);puts(" MHz\n");
+puts("BUS  FREQ  : ");putdec(bp->bi_busfreq / 1000000);puts(" MHz\n");
+puts("BRG  FREQ  : ");putdec(bp->bi_brgfreq / 1000000);puts(" MHz\n");
+puts("IMMR       : ");puthex(bp->bi_immr_base);puts("\n");
+puts("*********************************\n");
+#endif /* CONFIG_RGWYPQ2 */
+
 	/* Grab some space for the command line and board info.  Since
 	 * we no longer use the ELF header, but it was loaded, grab
 	 * that space.
@@ -170,6 +186,8 @@ load_kernel(unsigned long load_addr, int
 
 	puts("avail ram:     "); puthex((unsigned long)avail_ram); puts(" ");
 	puthex((unsigned long)end_avail); puts("\n");
+
+#ifdef CONFIG_RGWYPQ2
 	puts("\nLinux/PPC load: ");
 	cp = cmd_line;
 	/* This is where we try and pick the right command line for booting.
@@ -187,6 +205,26 @@ load_kernel(unsigned long load_addr, int
 #endif
 	while ( *cp )
 		putc(*cp++);
+
+#else /* CONFIG_RGWYPQ2 */
+	puts("\nLinux/PPC load: ");
+	cp = cmd_line;
+	/* This is where we try and pick the right command line for booting.
+	 * If we were given one at compile time, use it.  It Is Right.
+	 * If we weren't, see if we have a ramdisk.  If so, thats root.
+	 * When in doubt, give them the netroot (root=/dev/nfs rw) -- Tom
+	 */
+#ifdef CONFIG_CMDLINE_BOOL
+	memcpy (cmd_line, compiled_string, sizeof(compiled_string));
+#else
+	if ( initrd_size )
+		memcpy (cmd_line, ramroot_string, sizeof(ramroot_string));
+	else
+		memcpy (cmd_line, netroot_string, sizeof(netroot_string));
+#endif
+	while ( *cp )
+		putc(*cp++);
+
 	while (timer++ < 5*1000) {
 		if (tstc()) {
 			while ((ch = getc()) != '\n' && ch != '\r') {
@@ -211,6 +249,8 @@ load_kernel(unsigned long load_addr, int
 		udelay(1000);  /* 1 msec */
 	}
 	*cp = 0;
+#endif /* CONFIG_RGWYPQ2 */
+
 	puts("\nUncompressing Linux...");
 
 	gunzip(0, 0x400000, zimage_start, &zimage_size);
diff -Nurp linux-2.6.9.orig/arch/ppc/Kconfig linux-2.6.9/arch/ppc/Kconfig
--- linux-2.6.9.orig/arch/ppc/Kconfig	2004-10-18 23:55:29.000000000 +0200
+++ linux-2.6.9/arch/ppc/Kconfig	2006-09-07 18:57:01.000000000 +0200
@@ -571,6 +571,11 @@ config EST8260
 	  <http://www.windriver.com/>, but the EST8260 cannot be found on it
 	  and has probably been discontinued or rebadged.
 
+config RGWYPQ2
+	bool "RADIOGATEWAY-PQ2PMCb"
+	---help---
+	  Support for the Radiogateway with IC-PQ2PMCb board from Interface Concept.
+
 config SBC82xx
 	bool "SBC82xx"
 	---help---
@@ -633,7 +638,7 @@ config PPC_MPC52xx
 config 8260
 	bool "CPM2 Support" if WILLOW
 	depends on 6xx
-	default y if TQM8260 || RPX8260 || EST8260 || SBS8260 || SBC82xx
+	default y if TQM8260 || RPX8260 || EST8260 || SBS8260 || SBC82xx || RGWYPQ2
 	help
 	  The MPC8260 is a typical embedded CPU made by Motorola.  Selecting
 	  this option means that you wish to build a kernel for a machine with
@@ -835,6 +840,12 @@ config PREP_RESIDUAL
 
 	  If you are running a PReP system, say Y here, otherwise say N.
 
+config PPCBOOT
+	bool "Support/Use U-Boot/PPCboot firmware"
+	help
+	  Some systems boot via U-Boot/PPCboot.
+	  Say Y to support this.
+
 config PROC_PREPRESIDUAL
 	bool "Support for reading of PReP Residual Data in /proc"
 	depends on PREP_RESIDUAL && PROC_FS
@@ -845,12 +856,14 @@ config PROC_PREPRESIDUAL
 	  want this.
 
 config CMDLINE_BOOL
+	depends on !PPCBOOT
+	default y
 	bool "Default bootloader kernel arguments"
 
 config CMDLINE
 	string "Initial kernel command string"
 	depends on CMDLINE_BOOL
-	default "console=ttyS0,9600 console=tty0 root=/dev/sda2"
+	default $ELINOS_CMDLINE
 	help
 	  On some platforms, there is currently no way for the boot loader to
 	  pass arguments to the kernel. For these platforms, you can supply
diff -Nurp linux-2.6.9.orig/arch/ppc/kernel/head.S linux-2.6.9/arch/ppc/kernel/head.S
--- linux-2.6.9.orig/arch/ppc/kernel/head.S	2004-10-18 23:54:31.000000000 +0200
+++ linux-2.6.9/arch/ppc/kernel/head.S	2006-09-07 18:57:01.000000000 +0200
@@ -1642,6 +1642,7 @@ initial_mm_power4:
  * I use this for building a small kernel that can load other kernels,
  * rather than trying to write or rely on a rom monitor that can tftp load.
  */
+#if 0
        .globl  m8260_gorom
 m8260_gorom:
 	mfmsr	r0
@@ -1669,6 +1670,36 @@ m8260_gorom:
 	blr
 #endif
 
+	.globl  m8260_gorom
+m8260_gorom:
+	mfmsr	r0
+	rlwinm	r0,r0,0,17,15   /* clear MSR_EE in r0 */
+	sync    
+	mtmsr	r0
+	sync
+	mfspr	r11, HID0
+	lis		r10, 0
+	ori		r10,r10,HID0_ICE|HID0_DCE
+	andc	r11, r11, r10
+	mtspr	HID0, r11
+	isync   
+	li		r5, MSR_RI
+	lis		r6,3f@h
+	addis	r6,r6,-0@h
+	ori		r6,r6,3f@l
+	mtspr	SRR0,r6
+	mtspr	SRR1,r5
+	isync
+	sync
+	rfi
+3:
+	lis     r4, 0x7fff
+	lwz     r3, 0(r4)
+4: 
+	b       4b
+
+#endif
+
 
 /*
  * We put a few things here that have to be page-aligned.
diff -Nurp linux-2.6.9.orig/arch/ppc/kernel/irq.c linux-2.6.9/arch/ppc/kernel/irq.c
--- linux-2.6.9.orig/arch/ppc/kernel/irq.c	2004-10-18 23:54:55.000000000 +0200
+++ linux-2.6.9/arch/ppc/kernel/irq.c	2006-09-07 18:57:01.000000000 +0200
@@ -214,7 +214,7 @@ void free_irq(unsigned int irq, void* de
 			irq_kfree(action);
 			return;
 		}
-		printk("Trying to free free IRQ%d\n",irq);
+		/* GG printk("Trying to free free IRQ%d\n",irq); */
 		spin_unlock_irqrestore(&desc->lock,flags);
 		break;
 	}
diff -Nurp linux-2.6.9.orig/arch/ppc/platforms/rgwypq2.h linux-2.6.9/arch/ppc/platforms/rgwypq2.h
--- linux-2.6.9.orig/arch/ppc/platforms/rgwypq2.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.9/arch/ppc/platforms/rgwypq2.h	2006-09-07 18:57:01.000000000 +0200
@@ -0,0 +1,79 @@
+#ifdef __KERNEL__
+#ifndef __ASM_PLATFORMS_RGWYPQ2_H__
+#define __ASM_PLATFORMS_RGWYPQ2_H__
+#include <asm/ppcboot.h>
+
+#define CPUINFO_VENDOR               "Interface Concept"
+#define CPUINFO_MACHINE              "rgwy-pq2"
+
+/* board map */
+#define BD_60X_SDRAM_BASE_ADDR		0x00000000	/* SDRAM address */
+#define BD_PCI_MEM_PREF_BASE_ADDR	0x80000000	/* PCI Prefetch memory address */
+#define BD_PCI_MEM_PREF_SPACE_SIZE	0x20000000	/* PCI Prefetch memory size */
+#define BD_PCI_MEM_BASE_ADDR		0xA0000000	/* PCI non Prefetch memory address */
+#define BD_PCI_MEM_SPACE_SIZE		0x20000000	/* PCI non Prefetch memory size */
+#define BD_PLD_SYS_BASE_ADDR		0xF4000000	/* PLD System address */
+#define BD_RTC_BASE_ADDR			0xF9000000	/* Real Time Clock */
+#define BD_SRAM_BASE_ADDR			0xF5000000	/* SRAM address */
+#define BD_SRAM_USER_SIZE			128*KBYTE	/* SRAM size */
+#define BD_BFLASH_BASE_ADDR			0xF0000000	/* Boot Flash address */
+#define BD_MFLASH_BASE_ADDR			0xFA000000	/* Mass Flash address */
+#define BD_PCI_IO_BASE_ADDR			0xFA000000	/* PCI IO space address */
+#define BD_PCI_IO_SPACE_SIZE		0x01000000	/* PCI IO space size */
+#define BD_IOMEM_BASE_ADDR			0xFF000000	/* IMMR address */
+
+/* flash map */
+#define BD_ICDATA_OFFSET			0x00008000
+#define BD_ICBOOT_OFFSET			0x00010000
+#define BD_ICBIOS_OFFSET			0x00030000 
+#define BD_ICTOOLS_OFFSET			0x00050000
+#define BD_ICNVRAM_OFFSET			0x000D0000
+#define BD_PCIENUM_OFFSET			0x000E0000
+#define BD_PBIT_OFFSET				0x000F0000
+
+#define BD_BFLASH_BOOT_OFFSET		0x00000000
+#define BD_BFLASH_BOOT_CHK_OFFSET	0x000DFFFC
+#define BD_BFLASH_USER_OFFSET		0x00100000
+
+#define BD_ICDATA_IN_FLASH			(BD_BFLASH_BASE_ADDR + BD_ICDATA_OFFSET)
+#define BD_ICBOOT_IN_FLASH			(BD_BFLASH_BASE_ADDR + BD_ICBOOT_OFFSET)
+#define BD_ICBIOS_IN_FLASH			(BD_BFLASH_BASE_ADDR + BD_ICBIOS_OFFSET) 
+#define BD_ICTOOLS_IN_FLASH			(BD_BFLASH_BASE_ADDR + BD_ICTOOLS_OFFSET)
+#define BD_ICNVRAM_IN_FLASH			(BD_BFLASH_BASE_ADDR + BD_ICNVRAM_OFFSET)
+#define BD_PCIENUM_IN_FLASH			(BD_BFLASH_BASE_ADDR + BD_PCIENUM_OFFSET)
+#define BD_PBIT_IN_FLASH			(BD_BFLASH_BASE_ADDR + BD_PBIT_OFFSET)
+
+#define BD_ICDATA_IN_SDRAM			(BD_60X_SDRAM_BASE_ADDR + BD_ICDATA_OFFSET)
+#define BD_ICBOOT_IN_SDRAM			(BD_60X_SDRAM_BASE_ADDR + BD_ICBOOT_OFFSET)
+#define BD_ICBIOS_IN_SDRAM			(BD_60X_SDRAM_BASE_ADDR + BD_ICBIOS_OFFSET)
+#define BD_ICTOOLS_IN_SDRAM			(BD_60X_SDRAM_BASE_ADDR + BD_ICTOOLS_OFFSET)
+
+#define IMAP_ADDR					((uint)BD_IOMEM_BASE_ADDR)
+#define IMAP_SIZE					((uint)(128 * 1024))
+#define CPM_MAP_ADDR 				IMAP_ADDR
+
+/* global pci mapping */
+#define MPC826x_PCI_BASE    		BD_PCI_MEM_BASE_ADDR
+
+/* prefetchable memory */
+#define MPC826x_PCI_LOWER_MEM		BD_PCI_MEM_PREF_BASE_ADDR
+#define MPC826x_PCI_UPPER_MEM		(BD_PCI_MEM_PREF_BASE_ADDR + \
+									BD_PCI_MEM_PREF_SPACE_SIZE - 1)
+#define MPC826x_PCI_MEM_OFFSET		0x00000000
+
+/* non prefetchable memory  */
+#define MPC826x_PCI_LOWER_MMIO		BD_PCI_MEM_BASE_ADDR
+#define MPC826x_PCI_UPPER_MMIO		(BD_PCI_MEM_BASE_ADDR +  \
+									BD_PCI_MEM_SPACE_SIZE -1)
+#define MPC826x_PCI_MMIO_OFFSET		0x00000000
+
+/* IO space */
+#define MPC826x_PCI_LOWER_IO		BD_PCI_IO_BASE_ADDR
+#define MPC826x_PCI_UPPER_IO		(BD_PCI_IO_BASE_ADDR + BD_PCI_IO_SPACE_SIZE - 1)
+#define MPC826x_PCI_IO_BASE			BD_PCI_IO_BASE_ADDR
+#define MPC826x_PCI_IO_SIZE			BD_PCI_IO_SPACE_SIZE
+		
+#define PCI_INTERRUPT				SIU_INT_IRQ1
+
+#endif /* __ASM_PLATFORMS_RGWYPQ2_H__ */
+#endif /* __KERNEL__ */
diff -Nurp linux-2.6.9.orig/arch/ppc/syslib/cpm2_pic.c linux-2.6.9/arch/ppc/syslib/cpm2_pic.c
--- linux-2.6.9.orig/arch/ppc/syslib/cpm2_pic.c	2004-10-18 23:54:31.000000000 +0200
+++ linux-2.6.9/arch/ppc/syslib/cpm2_pic.c	2006-09-07 18:57:01.000000000 +0200
@@ -29,7 +29,8 @@ static	u_char	irq_to_siureg[] = {
 	1, 1, 1, 1, 1, 1, 1, 1,
 	1, 1, 1, 1, 1, 1, 1, 1,
 	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0
+	0, 0, 0, 0, 0, 0, 0, 0,
+	2, 2, 2, 2
 };
 
 static	u_char	irq_to_siubit[] = {
@@ -40,7 +41,8 @@ static	u_char	irq_to_siubit[] = {
 	 0,  1,  2,  3,  4,  5,  6,  7,
 	 8,  9, 10, 11, 12, 13, 14, 15,
 	15, 14, 13, 12, 11, 10,  9,  8,
-	 7,  6,  5,  4,  3,  2,  1,  0
+	 7,  6,  5,  4,  3,  2,  1,  0,
+	 0,  1,  2,  3					/* CPLD status bit */
 };
 
 static void cpm2_mask_irq(unsigned int irq_nr)
@@ -51,8 +53,21 @@ static void cpm2_mask_irq(unsigned int i
 	bit = irq_to_siubit[irq_nr];
 	word = irq_to_siureg[irq_nr];
 
-	simr = &(cpm2_immr->im_intctl.ic_simrh);
+	/* set new interrupt mask */
 	ppc_cached_irq_mask[word] &= ~(1 << (31 - bit));
+	if (word == 2) {
+		/* PCI interrupt */
+		if (ppc_cached_irq_mask[word] == 0)	{
+			/* mask PCI_INTERRUPT */
+			bit = irq_to_siubit[PCI_INTERRUPT];
+			word = irq_to_siureg[PCI_INTERRUPT];
+			ppc_cached_irq_mask[word] &= ~(1 << (31 - bit));
+		} else {
+			/* no interrupt to mask */
+			return;
+		}
+	}
+	simr = &(cpm2_immr->im_intctl.ic_simrh);
 	simr[word] = ppc_cached_irq_mask[word];
 }
 
@@ -64,8 +79,15 @@ static void cpm2_unmask_irq(unsigned int
 	bit = irq_to_siubit[irq_nr];
 	word = irq_to_siureg[irq_nr];
 
-	simr = &(cpm2_immr->im_intctl.ic_simrh);
+	/* set new interrupt mask */
 	ppc_cached_irq_mask[word] |= (1 << (31 - bit));
+	if (word == 2) {
+		/* unmask PCI_INTERRUPT */
+		bit = irq_to_siubit[PCI_INTERRUPT];
+		word = irq_to_siureg[PCI_INTERRUPT];
+		ppc_cached_irq_mask[word] |= (1 << (31 - bit));
+	}
+	simr = &(cpm2_immr->im_intctl.ic_simrh);
 	simr[word] = ppc_cached_irq_mask[word];
 }
 
@@ -74,12 +96,20 @@ static void cpm2_mask_and_ack(unsigned i
 	int	bit, word;
 	volatile uint	*simr, *sipnr;
 
+	simr = &(cpm2_immr->im_intctl.ic_simrh);
+	sipnr = &(cpm2_immr->im_intctl.ic_sipnrh);
+	
 	bit = irq_to_siubit[irq_nr];
 	word = irq_to_siureg[irq_nr];
 
-	simr = &(cpm2_immr->im_intctl.ic_simrh);
-	sipnr = &(cpm2_immr->im_intctl.ic_sipnrh);
+	/* set new interrupt mask */
 	ppc_cached_irq_mask[word] &= ~(1 << (31 - bit));
+	if (word == 2) {
+		/* PCI interrupt */
+		bit = irq_to_siubit[PCI_INTERRUPT];
+		word = irq_to_siureg[PCI_INTERRUPT];
+		ppc_cached_irq_mask[word] &= ~(1 << (31 - bit));
+	}
 	simr[word] = ppc_cached_irq_mask[word];
 	sipnr[word] = 1 << (31 - bit);
 }
@@ -94,9 +124,17 @@ static void cpm2_end_irq(unsigned int ir
 
 		bit = irq_to_siubit[irq_nr];
 		word = irq_to_siureg[irq_nr];
+	
+		/* set new interrupt mask */
+		ppc_cached_irq_mask[word] |= (1 << (31 - bit));
+		if (word == 2) {
+			/* PCI interrupt */
+			bit = irq_to_siubit[PCI_INTERRUPT];
+			word = irq_to_siureg[PCI_INTERRUPT];
+			ppc_cached_irq_mask[word] |= (1 << (31 - bit));
+		}
 
 		simr = &(cpm2_immr->im_intctl.ic_simrh);
-		ppc_cached_irq_mask[word] |= (1 << (31 - bit));
 		simr[word] = ppc_cached_irq_mask[word];
 	}
 }
@@ -116,15 +154,25 @@ struct hw_interrupt_type cpm2_pic = {
 int
 cpm2_get_irq(struct pt_regs *regs)
 {
-	int irq;
-        unsigned long bits;
+	int 			irq;
+	unsigned char*	cpld_sts = (unsigned char*)(BD_PLD_SYS_BASE_ADDR + 0x10);
+
+	unsigned long bits;
 
-        /* For CPM2, read the SIVEC register and shift the bits down
-         * to get the irq number.         */
-        bits = cpm2_immr->im_intctl.ic_sivec;
-        irq = bits >> 26;
+   	/* For CPM2, read the SIVEC register and shift the bits down
+	* to get the irq number.         */
+	bits = cpm2_immr->im_intctl.ic_sivec;
+	irq = bits >> 26;
 
-	if (irq == 0)
+	if (irq == 0) {
 		return(-1);
+	}
+	else if (irq == PCI_INTERRUPT) {
+		if ((*cpld_sts & 0x1) == 0)			irq = SIU_INT_PCIA;
+		else if ((*cpld_sts & 0x2) == 0)	irq = SIU_INT_PCIB;
+		else if ((*cpld_sts & 0x4) == 0)	irq = SIU_INT_PCIC;
+		else if ((*cpld_sts & 0x8) == 0)	irq = SIU_INT_PCID;
+		else						return(-1);
+	}
 	return irq;
 }
diff -Nurp linux-2.6.9.orig/arch/ppc/syslib/m8260_pci.c linux-2.6.9/arch/ppc/syslib/m8260_pci.c
--- linux-2.6.9.orig/arch/ppc/syslib/m8260_pci.c	2004-10-18 23:53:05.000000000 +0200
+++ linux-2.6.9/arch/ppc/syslib/m8260_pci.c	2006-09-07 18:57:01.000000000 +0200
@@ -40,6 +40,16 @@
 
 #include "m8260_pci.h"
 
+int m8260_pci_map_irq(struct pci_dev *dev, unsigned char idsel, unsigned char pin)
+{ 
+	/* in this project the PQ2Pmca board only support pci interrupt on PCIA line */
+    return SIU_INT_PCIA;
+}
+
+int m8260_exclude_device(u8 bus, u8 devfn)
+{
+	return (bus == 0 && devfn == 0);
+}
 
 /* PCI bus configuration registers.
  */
@@ -47,18 +57,8 @@
 static void __init m8260_setup_pci(struct pci_controller *hose)
 {
 	volatile cpm2_map_t *immap = cpm2_immr;
-	unsigned long pocmr;
-	u16 tempShort;
-
-#ifndef CONFIG_ATC 	/* already done in U-Boot */
-	/* 
-	 * Setting required to enable IRQ1-IRQ7 (SIUMCR [DPPC]), 
-	 * and local bus for PCI (SIUMCR [LBPC]).
-	 */
-	immap->im_siu_conf.siu_82xx.sc_siumcr = 0x00640000;
-#endif
-
-	/* Make PCI lowest priority */
+/*	unsigned long pocmr;*/
+	
 	/* Each 4 bits is a device bus request  and the MS 4bits 
 	   is highest priority */
 	/* Bus               4bit value 
@@ -74,76 +74,21 @@ static void __init m8260_setup_pci(struc
 	   External Master 2 0b1000
 	   External Master 3 0b1001
 	   The rest are reserved */
-	immap->im_siu_conf.siu_82xx.sc_ppc_alrh = 0x61207893;
-
-	/* Park bus on core while modifying PCI Bus accesses */
-	immap->im_siu_conf.siu_82xx.sc_ppc_acr = 0x6;
-
-	/* 
-	 * Set up master window that allows the CPU to access PCI space. This 
-	 * window is set up using the first SIU PCIBR registers.
-	 */
-	immap->im_memctl.memc_pcimsk0 = MPC826x_PCI_MASK;
-	immap->im_memctl.memc_pcibr0 =	MPC826x_PCI_BASE | PCIBR_ENABLE;
-
-	/* Disable machine check on no response or target abort */
-	immap->im_pci.pci_emr = cpu_to_le32(0x1fe7);
-	/* Release PCI RST (by default the PCI RST signal is held low)  */
-	immap->im_pci.pci_gcr = cpu_to_le32(PCIGCR_PCI_BUS_EN);
-
-	/* give it some time */
-	mdelay(1);
-
-	/* 
-	 * Set up master window that allows the CPU to access PCI Memory (prefetch) 
-	 * space. This window is set up using the first set of Outbound ATU registers.
-	 */
-	immap->im_pci.pci_potar0 = cpu_to_le32(MPC826x_PCI_LOWER_MEM >> 12);
-	immap->im_pci.pci_pobar0 = cpu_to_le32((MPC826x_PCI_LOWER_MEM - MPC826x_PCI_MEM_OFFSET) >> 12);
-	pocmr = ((MPC826x_PCI_UPPER_MEM - MPC826x_PCI_LOWER_MEM) >> 12) ^ 0xfffff;
-	immap->im_pci.pci_pocmr0 = cpu_to_le32(pocmr | POCMR_ENABLE | POCMR_PREFETCH_EN);
-
-	/* 
-	 * Set up master window that allows the CPU to access PCI Memory (non-prefetch) 
-	 * space. This window is set up using the second set of Outbound ATU registers.
-	 */
-	immap->im_pci.pci_potar1 = cpu_to_le32(MPC826x_PCI_LOWER_MMIO >> 12);
-	immap->im_pci.pci_pobar1 = cpu_to_le32((MPC826x_PCI_LOWER_MMIO - MPC826x_PCI_MMIO_OFFSET) >> 12);
-	pocmr = ((MPC826x_PCI_UPPER_MMIO - MPC826x_PCI_LOWER_MMIO) >> 12) ^ 0xfffff;
-	immap->im_pci.pci_pocmr1 = cpu_to_le32(pocmr | POCMR_ENABLE);
-
-	/* 
-	 * Set up master window that allows the CPU to access PCI IO space. This window
-	 * is set up using the third set of Outbound ATU registers.
-	 */
-	immap->im_pci.pci_potar2 = cpu_to_le32(MPC826x_PCI_IO_BASE >> 12);
-	immap->im_pci.pci_pobar2 = cpu_to_le32(MPC826x_PCI_LOWER_IO >> 12);
-	pocmr = ((MPC826x_PCI_UPPER_IO - MPC826x_PCI_LOWER_IO) >> 12) ^ 0xfffff;
-	immap->im_pci.pci_pocmr2 = cpu_to_le32(pocmr | POCMR_ENABLE | POCMR_PCI_IO);
-
-	/* 
-	 * Set up slave window that allows PCI masters to access MPC826x local memory. 
-	 * This window is set up using the first set of Inbound ATU registers
-	 */
-
-	immap->im_pci.pci_pitar0 = cpu_to_le32(MPC826x_PCI_SLAVE_MEM_LOCAL >> 12);
-	immap->im_pci.pci_pibar0 = cpu_to_le32(MPC826x_PCI_SLAVE_MEM_BUS >> 12);
-	pocmr = ((MPC826x_PCI_SLAVE_MEM_SIZE-1) >> 12) ^ 0xfffff;
-	immap->im_pci.pci_picmr0 = cpu_to_le32(pocmr | PICMR_ENABLE | PICMR_PREFETCH_EN);
 
 	/* See above for description - puts PCI request as highest priority */
-	immap->im_siu_conf.siu_82xx.sc_ppc_alrh = 0x03124567;
+/*	immap->im_siu_conf.siu_82xx.sc_ppc_alrh = 0x61207893;*/
 
 	/* Park the bus on the PCI */
-	immap->im_siu_conf.siu_82xx.sc_ppc_acr = PPC_ACR_BUS_PARK_PCI;
+/*	immap->im_siu_conf.siu_82xx.sc_ppc_acr = PPC_ACR_BUS_PARK_PCI;*/
 
-	/* Host mode - specify the bridge as a host-PCI bridge */
-	early_write_config_word(hose, 0, 0, PCI_CLASS_DEVICE, PCI_CLASS_BRIDGE_HOST);
+	/* set IRQ1(PCI) as  a low level interrupt */
+	immap->im_intctl.ic_siexr &= ~0x00004000;
 
-	/* Enable the host bridge to be a master on the PCI bus, and to act as a PCI memory target */
-	early_read_config_word(hose, 0, 0, PCI_COMMAND, &tempShort);
-	early_write_config_word(hose, 0, 0, PCI_COMMAND,
-				tempShort | PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY);
+	/* set pci inbound windows */
+/*	immap->im_pci.pci_pitar1 = cpu_to_le32(MPC826x_PCI_MEM_OFFSET >> 12);
+	immap->im_pci.pci_pibar1 = cpu_to_le32(MPC826x_PCI_MEM_OFFSET >> 12);
+	pocmr = ((BD_PCI_MEM_SPACE_SIZE-1) >> 12) ^ 0xfffff;
+	immap->im_pci.pci_picmr1 = cpu_to_le32(pocmr | PICMR_ENABLE | PICMR_PREFETCH_EN);*/
 }
 
 void __init m8260_find_bridges(void)
@@ -164,31 +109,41 @@ void __init m8260_find_bridges(void)
 	hose->bus_offset = 0;
 	hose->last_busno = 0xff;
 
-	setup_m8260_indirect_pci(hose, 
-				 (unsigned long)&cpm2_immr->im_pci.pci_cfg_addr,
-				 (unsigned long)&cpm2_immr->im_pci.pci_cfg_data);
+	setup_m8260_indirect_pci(hose, (unsigned long)&cpm2_immr->im_pci.pci_cfg_addr, (unsigned long)&cpm2_immr->im_pci.pci_cfg_data);
 
 	m8260_setup_pci(hose);
-        hose->pci_mem_offset = MPC826x_PCI_MEM_OFFSET;
-
-        isa_io_base =
-                (unsigned long) ioremap(MPC826x_PCI_IO_BASE,
-                                        MPC826x_PCI_IO_SIZE);
-        hose->io_base_virt = (void *) isa_io_base;
- 
-        /* setup resources */
-        pci_init_resource(&hose->mem_resources[0],
-			  MPC826x_PCI_LOWER_MEM,
-			  MPC826x_PCI_UPPER_MEM,
-			  IORESOURCE_MEM|IORESOURCE_PREFETCH, "PCI prefetchable memory");
-
-        pci_init_resource(&hose->mem_resources[1],
-			  MPC826x_PCI_LOWER_MMIO,
-			  MPC826x_PCI_UPPER_MMIO,
-			  IORESOURCE_MEM, "PCI memory");
-
-        pci_init_resource(&hose->io_resource,
-			  MPC826x_PCI_LOWER_IO,
-			  MPC826x_PCI_UPPER_IO,
-			  IORESOURCE_IO, "PCI I/O");
+   
+	hose->pci_mem_offset	= MPC826x_PCI_MEM_OFFSET;
+	isa_io_base				= (unsigned long) ioremap(MPC826x_PCI_IO_BASE, MPC826x_PCI_IO_SIZE);
+	hose->io_base_virt		= (void *)isa_io_base;
+
+	/* setup resources */
+	pci_init_resource(&hose->mem_resources[0],
+		MPC826x_PCI_LOWER_MEM,
+		MPC826x_PCI_UPPER_MEM,
+		IORESOURCE_MEM|IORESOURCE_PREFETCH, "PCI prefetchable memory");
+		
+	pci_init_resource(&hose->mem_resources[1],
+		MPC826x_PCI_LOWER_MMIO,
+		MPC826x_PCI_UPPER_MMIO,
+		IORESOURCE_MEM, "PCI memory");
+		
+	pci_init_resource(&hose->io_resource,
+		MPC826x_PCI_LOWER_IO,
+		MPC826x_PCI_UPPER_IO,
+		IORESOURCE_IO, "PCI I/O");
+
+#if 0	
+	hose->io_space.start	= MPC826x_PCI_LOWER_IO;
+	hose->io_space.end		= MPC826x_PCI_UPPER_IO;
+	hose->io_base_phys		= MPC826x_PCI_LOWER_IO;
+	
+	/* setup resources */
+	pci_init_resource(&hose->mem_resources[0],
+		MPC826x_PCI_LOWER_MEM,
+		MPC826x_PCI_UPPER_MEM,
+		IORESOURCE_MEM, "PCI memory");
+	hose->mem_space.start	= MPC826x_PCI_LOWER_MEM;
+	hose->mem_space.end		= MPC826x_PCI_LOWER_MEM;
+#endif
 }
diff -Nurp linux-2.6.9.orig/arch/ppc/syslib/m8260_setup.c linux-2.6.9/arch/ppc/syslib/m8260_setup.c
--- linux-2.6.9.orig/arch/ppc/syslib/m8260_setup.c	2004-10-18 23:54:08.000000000 +0200
+++ linux-2.6.9/arch/ppc/syslib/m8260_setup.c	2006-09-07 18:57:01.000000000 +0200
@@ -18,8 +18,13 @@
 #include <linux/initrd.h>
 #include <linux/seq_file.h>
 #include <linux/irq.h>
+#include <linux/root_dev.h>
+#include <linux/pci.h>
 
 #include <asm/mmu.h>
+#ifdef CONFIG_RGWYPQ2
+#include <asm/dma.h>
+#endif /* RGWYPQ2 */
 #include <asm/io.h>
 #include <asm/pgtable.h>
 #include <asm/mpc8260.h>
@@ -35,6 +40,8 @@ unsigned char __res[sizeof(bd_t)];
 extern void cpm2_reset(void);
 extern void m8260_find_bridges(void);
 extern void idma_pci9_init(void);
+extern int  m8260_pci_map_irq (struct pci_dev *dev, unsigned char idsel, unsigned char pin);
+extern int	m8260_exclude_device (u8 bus, u8 devfn);
 
 static void __init
 m8260_setup_arch(void)
@@ -51,7 +58,7 @@ m8260_setup_arch(void)
 #ifdef CONFIG_PCI_8260
 	m8260_find_bridges();
 #endif
-#ifdef CONFIG_BLK_DEV_INITRD
+#if defined(CONFIG_BLK_DEV_INITRD) || defined(CONFIG_EXTRACT_ROOTFS)
 	if (initrd_start)
 		ROOT_DEV = Root_RAM0;
 #endif
@@ -93,27 +100,19 @@ m8260_get_rtc_time(void)
 	return((unsigned long)rtc_time);
 }
 
-#ifndef BOOTROM_RESTART_ADDR
-#warning "Using default BOOTROM_RESTART_ADDR!"
-#define BOOTROM_RESTART_ADDR	0xff000104
-#endif
-
 static void
 m8260_restart(char *cmd)
 {
-	extern void m8260_gorom(bd_t *bi, uint addr);
-	uint	startaddr;
+	extern void	m8260_gorom(bd_t *bi, uint addr);
+	uint					startaddr;
+	volatile cpm2_map_t*	im = (volatile cpm2_map_t *)IMAP_ADDR;
 
 	/* Most boot roms have a warmstart as the second instruction
 	 * of the reset vector.  If that doesn't work for you, change this
 	 * or the reboot program to send a proper address.
 	 */
-	startaddr = BOOTROM_RESTART_ADDR;
-	if (cmd != NULL) {
-		if (!strncmp(cmd, "startaddr=", 10))
-			startaddr = simple_strtoul(&cmd[10], NULL, 0);
-	}
-
+	startaddr = 0x7fff0000;
+	im->im_clkrst.car_rmr |= 0x00000001;
 	m8260_gorom((void*)__pa(__res), startaddr);
 }
 
@@ -161,8 +160,11 @@ m8260_init_IRQ(void)
 {
 	int i;
 
-        for ( i = 0 ; i < NR_SIU_INTS ; i++ )
-                irq_desc[i].handler = &cpm2_pic;
+        for ( i = 0 ; i < NR_SIU_INTS ; i++ ) {
+			/* make interrupt type */
+			irq_desc[i].status |= IRQ_LEVEL;
+			irq_desc[i].handler = &cpm2_pic;
+		}
 
 	/* Initialize the default interrupt mapping priorities,
 	 * in case the boot rom changed something on us.
@@ -192,6 +194,9 @@ m8260_find_end_of_memory(void)
 static void __init
 m8260_map_io(void)
 {
+#ifdef CONFIG_RGWYPQ2
+	io_block_mapping(0xf0000000, 0xf0000000, 0x10000000, _PAGE_IO);
+#else
 	uint addr;
 
 	/* Map IMMR region to a 256MB BAT */
@@ -200,12 +205,19 @@ m8260_map_io(void)
 
 	/* Map I/O region to a 256MB BAT */
 	io_block_mapping(IO_VIRT_ADDR, IO_PHYS_ADDR, 0x10000000, _PAGE_IO);
+#endif /* CONFIG_RGWYPQ2 */
 }
 
 /* Place-holder for board-specific init */
 void __attribute__ ((weak)) __init
 m82xx_board_init(void)
 {
+/*	isa_io_base         = _IO_BASE;
+	isa_mem_base        = _ISA_MEM_BASE;
+	ISA_DMA_THRESHOLD   = 0x00ffffff;
+	DMA_MODE_READ       = 0x44;
+	DMA_MODE_WRITE      = 0x48;*/
+
 }
 
 /* Inputs:
@@ -228,7 +240,7 @@ platform_init(unsigned long r3, unsigned
 	if ( r3 )
 		memcpy( (void *)__res,(void *)(r3+KERNELBASE), sizeof(bd_t) );
 
-#ifdef CONFIG_BLK_DEV_INITRD
+#if defined(CONFIG_BLK_DEV_INITRD) || defined(CONFIG_EXTRACT_ROOTFS)
 	/* take care of initrd if we have one */
 	if ( r4 ) {
 		initrd_start = r4 + KERNELBASE;
@@ -259,4 +271,11 @@ platform_init(unsigned long r3, unsigned
 
 	ppc_md.find_end_of_memory	= m8260_find_end_of_memory;
 	ppc_md.setup_io_mappings	= m8260_map_io;
+#ifdef CONFIG_PCI
+	ppc_md.pci_map_irq			= m8260_pci_map_irq;	// GG
+	ppc_md.pci_exclude_device	= m8260_exclude_device; // GG
+#else 
+	ppc_md.pci_map_irq			= NULL;	// GG
+	ppc_md.pci_exclude_device	= NULL; // GG
+#endif
 }
diff -Nurp linux-2.6.9.orig/drivers/mtd/chips/cfi_cmdset_0002.c linux-2.6.9/drivers/mtd/chips/cfi_cmdset_0002.c
--- linux-2.6.9.orig/drivers/mtd/chips/cfi_cmdset_0002.c	2004-10-18 23:53:51.000000000 +0200
+++ linux-2.6.9/drivers/mtd/chips/cfi_cmdset_0002.c	2006-09-07 18:57:01.000000000 +0200
@@ -45,8 +45,6 @@ static int cfi_amdstd_write_words(struct
 static int cfi_amdstd_write_buffers(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
 static int cfi_amdstd_erase_chip(struct mtd_info *, struct erase_info *);
 static int cfi_amdstd_erase_varsize(struct mtd_info *, struct erase_info *);
-static int cfi_amdstd_lock_varsize(struct mtd_info *, loff_t, size_t);
-static int cfi_amdstd_unlock_varsize(struct mtd_info *, loff_t, size_t);
 static void cfi_amdstd_sync (struct mtd_info *);
 static int cfi_amdstd_suspend (struct mtd_info *);
 static void cfi_amdstd_resume (struct mtd_info *);
@@ -317,8 +315,6 @@ static struct mtd_info *cfi_amdstd_setup
 		mtd->erase = cfi_amdstd_erase_chip;
 	} else {
 		mtd->erase = cfi_amdstd_erase_varsize;
-		mtd->lock = cfi_amdstd_lock_varsize;
-		mtd->unlock = cfi_amdstd_unlock_varsize;
 	}
 
 	if ( cfi->cfiq->BufWriteTimeoutTyp && !FORCE_WORD_WRITE) {
@@ -1081,8 +1077,13 @@ static int cfi_amdstd_write_buffers(stru
 		size_t local_len = (-ofs)&(map_bankwidth(map)-1);
 		if (local_len > len)
 			local_len = len;
+#if 0
 		ret = cfi_amdstd_write_words(mtd, to, local_len,
 					       retlen, buf);
+#else
+		ret = cfi_amdstd_write_words(mtd, ofs + (chipnum<<cfi->chipshift),
+									local_len, retlen, buf);
+#endif /* GG */
 		if (ret)
 			return ret;
 		ofs += local_len;
@@ -1128,7 +1129,12 @@ static int cfi_amdstd_write_buffers(stru
 	if (len) {
 		size_t retlen_dregs = 0;
 
+#if 0
 		ret = cfi_amdstd_write_words(mtd, to, len, &retlen_dregs, buf);
+#else
+		ret = cfi_amdstd_write_words(mtd, ofs + (chipnum<<cfi->chipshift),
+									len, &retlen_dregs, buf);
+#endif /* GG */
 
 		*retlen += retlen_dregs;
 		return ret;
@@ -1623,102 +1629,6 @@ struct xxlock_thunk {
 	flstate_t state;
 };
 
-
-#define DO_XXLOCK_ONEBLOCK_LOCK   ((struct xxlock_thunk){0x01, FL_LOCKING})
-#define DO_XXLOCK_ONEBLOCK_UNLOCK ((struct xxlock_thunk){0x00, FL_UNLOCKING})
-
-
-/*
- * FIXME - this is *very* specific to a particular chip.  It likely won't
- * work for all chips that require unlock.  It also hasn't been tested
- * with interleaved chips.
- */
-static int do_xxlock_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr, void *thunk)
-{
-	struct cfi_private *cfi = map->fldrv_priv;
-	struct xxlock_thunk *xxlt = (struct xxlock_thunk *)thunk;
-	int ret;
-
-	/*
-	 * This is easy because these are writes to registers and not writes
-	 * to flash memory - that means that we don't have to check status
-	 * and timeout.
-	 */
-
-	adr += chip->start;
-	/*
-	 * lock block registers:
-	 * - on 64k boundariesand
-	 * - bit 1 set high
-	 * - block lock registers are 4MiB lower - overflow subtract (danger)
-	 */
-	adr = ((adr & ~0xffff) | 0x2) + ~0x3fffff;
-
-	cfi_spin_lock(chip->mutex);
-	ret = get_chip(map, chip, adr, FL_LOCKING);
-	if (ret) {
-		cfi_spin_unlock(chip->mutex);
-		return ret;
-	}
-
-	chip->state = xxlt->state;
-	map_write(map, CMD(xxlt->val), adr);
-	
-	/* Done and happy. */
-	chip->state = FL_READY;
-	put_chip(map, chip, adr);
-	cfi_spin_unlock(chip->mutex);
-	return 0;
-}
-
-
-static int cfi_amdstd_lock_varsize(struct mtd_info *mtd,
-				   loff_t ofs,
-				   size_t len)
-{
-	int ret;
-
-	DEBUG(MTD_DEBUG_LEVEL3,
-	      "%s: lock status before, ofs=0x%08llx, len=0x%08zX\n",
-	      __func__, ofs, len);
-	debug_dump_locks(mtd, do_printlockstatus_oneblock, ofs, len, 0);
-
-	ret = cfi_amdstd_varsize_frob(mtd, do_xxlock_oneblock, ofs, len,
-				      (void *)&DO_XXLOCK_ONEBLOCK_LOCK);
-	
-	DEBUG(MTD_DEBUG_LEVEL3,
-	      "%s: lock status after, ret=%d\n",
-	      __func__, ret);
-
-	debug_dump_locks(mtd, do_printlockstatus_oneblock, ofs, len, 0);
-
-	return ret;
-}
-
-
-static int cfi_amdstd_unlock_varsize(struct mtd_info *mtd,
-				     loff_t ofs,
-				     size_t len)
-{
-	int ret;
-
-	DEBUG(MTD_DEBUG_LEVEL3,
-	      "%s: lock status before, ofs=0x%08llx, len=0x%08zX\n",
-	      __func__, ofs, len);
-	debug_dump_locks(mtd, do_printlockstatus_oneblock, ofs, len, 0);
-
-	ret = cfi_amdstd_varsize_frob(mtd, do_xxlock_oneblock, ofs, len,
-				      (void *)&DO_XXLOCK_ONEBLOCK_UNLOCK);
-	
-	DEBUG(MTD_DEBUG_LEVEL3,
-	      "%s: lock status after, ret=%d\n",
-	      __func__, ret);
-	debug_dump_locks(mtd, do_printlockstatus_oneblock, ofs, len, 0);
-	
-	return ret;
-}
-
-
 static void cfi_amdstd_destroy(struct mtd_info *mtd)
 {
 	struct map_info *map = mtd->priv;
diff -Nurp linux-2.6.9.orig/drivers/net/fec_mpc52xx/fec.c linux-2.6.9/drivers/net/fec_mpc52xx/fec.c
--- linux-2.6.9.orig/drivers/net/fec_mpc52xx/fec.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.9/drivers/net/fec_mpc52xx/fec.c	2006-09-07 18:57:01.000000000 +0200
@@ -0,0 +1,791 @@
+/*
+ * drivers/net/fec_mpc52xx/fec.c
+ *
+ * Driver for the MPC5200 Fast Ethernet Controller
+ *
+ * Author: Dale Farnsworth <dfarnsworth@mvista.com>
+ *
+ * 2003-2004 (c) MontaVista, Software, Inc.  This file is licensed under
+ * the terms of the GNU General Public License version 2.  This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#include <linux/module.h>
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/crc32.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/skbuff.h>
+
+#include <asm/io.h>
+#include <asm/delay.h>
+#include <asm/ppcboot.h>
+#include <asm/mpc52xx.h>
+#include <asm/ocp.h>
+
+#include <syslib/bestcomm/bestcomm.h>
+#include <syslib/bestcomm/fec.h>
+
+#include "fec_phy.h"
+#include "fec.h"
+
+static irqreturn_t fec_interrupt(int, void *, struct pt_regs *);
+static irqreturn_t fec_rx_interrupt(int, void *, struct pt_regs *);
+static irqreturn_t fec_tx_interrupt(int, void *, struct pt_regs *);
+static struct net_device_stats *fec_get_stats(struct net_device *);
+static void fec_set_multicast_list(struct net_device *dev);
+static void fec_reinit(struct net_device *dev);
+
+static u8 mpc52xx_fec_mac_addr[6];
+static u8 null_mac[6];
+
+static void fec_tx_timeout(struct net_device *dev)
+{
+	struct fec_priv *priv = (struct fec_priv *)dev->priv;
+
+	priv->stats.tx_errors++;
+
+	if (!priv->tx_full)
+		netif_wake_queue(dev);
+}
+
+static void fec_set_paddr(struct net_device *dev, u8 *mac)
+{
+	struct fec_priv *priv = (struct fec_priv *)dev->priv;
+	struct mpc52xx_fec *fec = priv->fec;
+
+	out_be32(&fec->paddr1, *(u32*)(&mac[0]));
+	out_be32(&fec->paddr2, (*(u16*)(&mac[4]) << 16) | 0x8808);
+}
+
+static void fec_get_paddr(struct net_device *dev, u8 *mac)
+{
+	struct fec_priv *priv = (struct fec_priv *)dev->priv;
+	struct mpc52xx_fec *fec = priv->fec;
+
+	*(u32*)(&mac[0]) = in_be32(&fec->paddr1);
+	*(u16*)(&mac[4]) = in_be32(&fec->paddr2) >> 16;
+}
+
+static int fec_set_mac_address(struct net_device *dev, void *addr)
+{
+	struct sockaddr *sock = (struct sockaddr *)addr;
+
+	memcpy(dev->dev_addr, sock->sa_data, dev->addr_len);
+
+	fec_set_paddr(dev, sock->sa_data);
+	return 0;
+}
+
+/* This function is called to start or restart the FEC during a link
+ * change.  This happens on fifo errors or when switching between half
+ * and full duplex.
+ */
+static void fec_restart(struct net_device *dev, int duplex)
+{
+	struct fec_priv *priv = (struct fec_priv *)dev->priv;
+	struct mpc52xx_fec *fec = priv->fec;
+	u32 rcntrl;
+	u32 tcntrl;
+	int i;
+
+	out_be32(&fec->rfifo_status, in_be32(&fec->rfifo_status) & 0x700000);
+	out_be32(&fec->tfifo_status, in_be32(&fec->tfifo_status) & 0x700000);
+	out_be32(&fec->reset_cntrl, 0x1000000);
+
+	/* Whack a reset.  We should wait for this. */
+	out_be32(&fec->ecntrl, FEC_ECNTRL_RESET);
+	for (i = 0; i < FEC_RESET_DELAY; ++i) {
+		if ((in_be32(&fec->ecntrl) & FEC_ECNTRL_RESET) == 0)
+			break;
+		udelay(1);
+	}
+	if (i == FEC_RESET_DELAY)
+		printk (KERN_ERR "FEC Reset timeout!\n");
+
+	/* Set station address. */
+	fec_set_paddr(dev, dev->dev_addr);
+
+	fec_set_multicast_list(dev);
+
+	rcntrl = FEC_RX_BUFFER_SIZE << 16;	/* max frame length */
+	rcntrl |= FEC_RCNTRL_FCE;
+	rcntrl |= MII_RCNTL_MODE;
+	if (duplex)
+		tcntrl = FEC_TCNTRL_FDEN;		/* FD enable */
+	else {
+		rcntrl |= FEC_RCNTRL_DRT;
+		tcntrl = 0;
+	}
+	out_be32(&fec->r_cntrl, rcntrl);
+	out_be32(&fec->x_cntrl, tcntrl);
+
+	set_phy_speed(fec, priv->phy_speed);
+
+	priv->full_duplex = duplex;
+
+	/* Clear any outstanding interrupt. */
+	out_be32(&fec->ievent, 0xffffffff);	/* clear intr events */
+
+	/* Enable interrupts we wish to service.
+	*/
+	out_be32(&fec->imask, FEC_IMASK_ENABLE);
+
+	/* And last, enable the transmit and receive processing.
+	*/
+	out_be32(&fec->ecntrl, FEC_ECNTRL_ETHER_EN);
+	out_be32(&fec->r_des_active, 0x01000000);
+
+	/* The tx ring is no longer full. */
+	if (priv->tx_full)
+	{
+		priv->tx_full = 0;
+		netif_wake_queue(dev);
+	}
+}
+
+static void fec_free_rx_buffers(struct sdma *s)
+{
+	struct sk_buff *skb;
+
+	while (!sdma_queue_empty(s)) {
+		skb = sdma_retrieve_buffer(s, NULL);
+		kfree_skb(skb);
+	}
+}
+
+static int fec_open(struct net_device *dev)
+{
+	struct fec_priv *priv = (struct fec_priv *)dev->priv;
+	struct sk_buff *skb;
+	void *data;
+
+	sdma_fec_rx_init(priv->rx_sdma, priv->rx_fifo, FEC_RX_BUFFER_SIZE);
+	sdma_fec_tx_init(priv->tx_sdma, priv->tx_fifo);
+
+	while (!sdma_queue_full(priv->rx_sdma)) {
+		skb = dev_alloc_skb(FEC_RX_BUFFER_SIZE);
+		if (skb == 0)
+			goto eagain;
+		skb->dev = dev;
+		skb_put(skb, FEC_RX_BUFFER_SIZE);
+
+		/* zero out the initial receive buffers to aid debugging */
+		memset(skb->data, 0, FEC_RX_BUFFER_SIZE);
+		data = (void *)virt_to_phys(skb->data);
+		sdma_submit_buffer(priv->rx_sdma, skb, data, skb->len);
+	}
+
+	fec_set_paddr(dev, dev->dev_addr);
+
+	if (fec_mii_wait(dev) != 0)
+		return -ENODEV;
+
+	sdma_enable(priv->rx_sdma);
+	sdma_enable(priv->tx_sdma);
+
+	netif_start_queue(dev);
+
+	return 0;
+
+eagain:
+	printk(KERN_ERR "fec_open: failed\n");
+
+	fec_free_rx_buffers(priv->rx_sdma);
+
+	return -EAGAIN;
+}
+
+/* The BestComm hardware requires data to be 32-bit aligned.
+ * We also pad to minimum ethernet packet length, ETH_ZLEN.
+ */
+static inline struct sk_buff *fec_skb_align_and_pad(struct sk_buff *skb)
+{
+	void *data = skb->data;
+	int len = skb->len;
+	int pad = (int)data & 0x3;
+	struct sk_buff *nskb;
+	int nlen;
+
+	if (pad == 0)
+		return skb;
+
+	if (!skb_cloned(skb)) {
+		skb_push(skb, pad);
+		memmove(skb->data, data, len);
+		skb_trim(skb, len);
+		skb = skb_padto(skb, ETH_ZLEN);
+		return skb;
+	}
+
+	/* ensure skb_padto doesn't have to reallocate */
+	nlen = (len >= ETH_ZLEN) ? len : ETH_ZLEN;
+
+	nskb = alloc_skb(nlen, GFP_ATOMIC);
+	if (nskb) {
+		skb_put(nskb, len);
+		memcpy(nskb->data, data, len);
+		nskb = skb_padto(nskb, ETH_ZLEN);
+	}
+	kfree_skb(skb);
+	return nskb;
+}
+
+/* This will only be invoked if your driver is _not_ in XOFF state.
+ * What this means is that you need not check it, and that this
+ * invariant will hold if you make sure that the netif_*_queue()
+ * calls are done at the proper times.
+ */
+static int fec_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct fec_priv *priv = (struct fec_priv *)dev->priv;
+	void *data;
+
+	if (sdma_queue_full(priv->tx_sdma))
+		panic("MPC52xx transmit queue overrun\n");
+
+	skb = fec_skb_align_and_pad(skb);
+	if (!skb) {
+		priv->stats.tx_dropped++;
+		return 0;
+	}
+
+	spin_lock_irq(&priv->lock);
+	dev->trans_start = jiffies;
+
+	data = (void *)virt_to_phys(skb->data);
+	sdma_fec_tfd_submit_buffer(priv->tx_sdma, skb, data, skb->len);
+
+	if (sdma_queue_full(priv->tx_sdma)) {
+		priv->tx_full = 1;
+		netif_stop_queue(dev);
+	}
+	spin_unlock_irq(&priv->lock);
+
+	return 0;
+}
+
+/* This handles BestComm transmit task interrupts
+ */
+static irqreturn_t fec_tx_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct net_device *dev = dev_id;
+	struct fec_priv *priv = (struct fec_priv *)dev->priv;
+	struct sk_buff *skb;
+
+	for (;;) {
+		sdma_clear_irq(priv->tx_sdma);
+		spin_lock(&priv->lock);
+		if (!sdma_buffer_done(priv->tx_sdma)) {
+			spin_unlock(&priv->lock);
+			break;
+		}
+		skb = sdma_retrieve_buffer(priv->tx_sdma, NULL);
+
+		if (priv->tx_full) {
+			priv->tx_full = 0;
+			netif_wake_queue(dev);
+		}
+		spin_unlock(&priv->lock);
+		dev_kfree_skb_irq(skb);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t fec_rx_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct net_device *dev = dev_id;
+	struct fec_priv *priv = (struct fec_priv *)dev->priv;
+	struct sk_buff *skb;
+	struct sk_buff *rskb;
+	void *data;
+	int length;
+
+	for (;;) {
+		sdma_clear_irq(priv->rx_sdma);
+
+		if (!sdma_buffer_done(priv->rx_sdma))
+			break;
+
+		rskb = sdma_retrieve_buffer(priv->rx_sdma, &length);
+		/* length included sizeof CRC32 */
+		skb_trim(rskb, length - sizeof(u32));
+
+		/* allocate replacement skb */
+		skb = dev_alloc_skb(FEC_RX_BUFFER_SIZE);
+		if (skb) {
+			rskb->protocol = eth_type_trans(rskb, dev);
+			netif_rx(rskb);
+			dev->last_rx = jiffies;
+		} else {
+			printk(KERN_NOTICE
+				"%s: Memory squeeze, dropping packet.\n",
+				dev->name);
+			priv->stats.rx_dropped++;
+
+			skb_trim(rskb, 0);
+			skb = rskb;
+		}
+
+		skb->dev = dev;
+		skb_put(skb, FEC_RX_BUFFER_SIZE);
+		data = (void *)virt_to_phys(skb->data);
+		sdma_submit_buffer(priv->rx_sdma, skb, data, skb->len);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t fec_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct net_device *dev = (struct net_device *)dev_id;
+	struct fec_priv *priv = (struct fec_priv *)dev->priv;
+	struct mpc52xx_fec *fec = priv->fec;
+	int ievent;
+
+	ievent = in_be32(&fec->ievent);
+	out_be32(&fec->ievent, ievent);		/* clear pending events */
+
+	if (ievent & (FEC_IEVENT_RFIFO_ERROR | FEC_IEVENT_XFIFO_ERROR)) {
+		if (ievent & FEC_IEVENT_RFIFO_ERROR)
+			printk(KERN_WARNING "FEC_IEVENT_RFIFO_ERROR\n");
+		if (ievent & FEC_IEVENT_XFIFO_ERROR)
+			printk(KERN_WARNING "FEC_IEVENT_XFIFO_ERROR\n");
+		fec_reinit(dev);
+	}
+	else if (ievent & FEC_IEVENT_MII)
+		fec_mii(dev);
+	return IRQ_HANDLED;
+}
+
+static int fec_close(struct net_device *dev)
+{
+	struct fec_priv *priv = (struct fec_priv *)dev->priv;
+	unsigned long timeout;
+
+	priv->open_time = 0;
+	priv->sequence_done = 0;
+
+	netif_stop_queue(dev);
+
+	sdma_disable(priv->rx_sdma);		/* disable receive task */
+
+	/* Wait for queues to drain */
+	timeout = jiffies + 2*HZ;
+	while (time_before(jiffies, timeout) &&
+					(!sdma_queue_empty(priv->tx_sdma) ||
+					!sdma_queue_empty(priv->rx_sdma))) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ/10);
+	}
+	if (time_after_eq(jiffies, timeout))
+		printk(KERN_ERR "fec_close: queues didn't drain\n");
+
+	sdma_disable(priv->tx_sdma);
+
+	fec_free_rx_buffers(priv->rx_sdma);
+
+	fec_get_stats(dev);
+
+	return 0;
+}
+
+/*
+ * Get the current statistics.
+ * This may be called with the card open or closed.
+ */
+static struct net_device_stats *fec_get_stats(struct net_device *dev)
+{
+	struct fec_priv *priv = (struct fec_priv *)dev->priv;
+	struct net_device_stats *stats = &priv->stats;
+	struct mpc52xx_fec *fec = priv->fec;
+
+	stats->rx_bytes = in_be32(&fec->rmon_r_octets);
+	stats->rx_packets = in_be32(&fec->rmon_r_packets);
+	stats->rx_errors = stats->rx_packets - in_be32(&fec->ieee_r_frame_ok);
+	stats->tx_bytes = in_be32(&fec->rmon_t_octets);
+	stats->tx_packets = in_be32(&fec->rmon_t_packets);
+	stats->tx_errors = stats->tx_packets - (
+					in_be32(&fec->ieee_t_frame_ok) +
+					in_be32(&fec->rmon_t_col) +
+					in_be32(&fec->ieee_t_1col) +
+					in_be32(&fec->ieee_t_mcol) +
+					in_be32(&fec->ieee_t_def));
+	stats->multicast = in_be32(&fec->rmon_r_mc_pkt);
+	stats->collisions = in_be32(&fec->rmon_t_col);
+
+	/* detailed rx_errors: */
+	stats->rx_length_errors = in_be32(&fec->rmon_r_undersize)
+					+ in_be32(&fec->rmon_r_oversize)
+					+ in_be32(&fec->rmon_r_frag)
+					+ in_be32(&fec->rmon_r_jab);
+	stats->rx_over_errors = in_be32(&fec->r_macerr);
+	stats->rx_crc_errors = in_be32(&fec->ieee_r_crc);
+	stats->rx_frame_errors = in_be32(&fec->ieee_r_align);
+	stats->rx_fifo_errors = in_be32(&fec->rmon_r_drop);
+	stats->rx_missed_errors = in_be32(&fec->rmon_r_drop);
+
+	/* detailed tx_errors: */
+	stats->tx_aborted_errors = 0;
+	stats->tx_carrier_errors = in_be32(&fec->ieee_t_cserr);
+	stats->tx_fifo_errors = in_be32(&fec->rmon_t_drop);
+	stats->tx_heartbeat_errors = in_be32(&fec->ieee_t_sqe);
+	stats->tx_window_errors = in_be32(&fec->ieee_t_lcol);
+
+	return stats;
+}
+
+static void fec_update_stat(struct net_device *dev)
+{
+	struct fec_priv *priv = (struct fec_priv *)dev->priv;
+	struct net_device_stats *stats = &priv->stats;
+	struct mpc52xx_fec *fec = priv->fec;
+
+	out_be32(&fec->mib_control, FEC_MIB_DISABLE);
+	memset_io(&fec->rmon_t_drop, 0,
+			(u32)&fec->reserved10 - (u32)&fec->rmon_t_drop);
+	out_be32(&fec->mib_control, 0);
+	memset(stats, 0, sizeof *stats);
+	fec_get_stats(dev);
+}
+
+/*
+ * Set or clear the multicast filter for this adaptor.
+ */
+static void fec_set_multicast_list(struct net_device *dev)
+{
+	struct fec_priv *priv = (struct fec_priv *)dev->priv;
+	struct mpc52xx_fec *fec = priv->fec;
+	u32 rx_control;
+
+	rx_control = in_be32(&fec->r_cntrl);
+
+	if (dev->flags & IFF_PROMISC) {
+		rx_control |= FEC_RCNTRL_PROM;
+		out_be32(&fec->r_cntrl, rx_control);
+	} else {
+		rx_control &= ~FEC_RCNTRL_PROM;
+		out_be32(&fec->r_cntrl, rx_control);
+
+		if (dev->flags & IFF_ALLMULTI) {
+			out_be32(&fec->gaddr1, 0xffffffff);
+			out_be32(&fec->gaddr2, 0xffffffff);
+		} else {
+			u32 crc;
+			int i;
+			struct dev_mc_list *dmi;
+			u32 gaddr1 = 0x00000000;
+			u32 gaddr2 = 0x00000000;
+
+			dmi = dev->mc_list;
+			for (i=0; i<dev->mc_count; i++) {
+				crc = ether_crc_le(6, dmi->dmi_addr) >> 26;
+				if (crc >= 32)
+					gaddr1 |= 1 << (crc-32);
+				else
+					gaddr2 |= 1 << crc;
+				dmi = dmi->next;
+			}
+			out_be32(&fec->gaddr1, gaddr1);
+			out_be32(&fec->gaddr2, gaddr2);
+		}
+	}
+}
+
+static void __init fec_str2mac(char *str, unsigned char *mac)
+{
+	int i;
+	u64 val64;
+
+	val64 = simple_strtoull(str, NULL, 16);
+
+	for (i = 0; i < 6; i++)
+		mac[5-i] = val64 >> (i*8);
+}
+
+int __init mpc52xx_fec_mac_setup(char *mac_address)
+{
+	fec_str2mac(mac_address, mpc52xx_fec_mac_addr);
+	return 0;
+}
+
+__setup("mpc52xx_mac=", mpc52xx_fec_mac_setup);
+
+static void fec_hw_init(struct net_device *dev)
+{
+	struct fec_priv *priv = (struct fec_priv *)dev->priv;
+	struct mpc52xx_fec *fec = priv->fec;
+	bd_t *bd = (bd_t *) &__res;
+
+	out_be32(&fec->op_pause, 0x00010020);
+	out_be32(&fec->rfifo_cntrl, 0x0f000000);
+	out_be32(&fec->rfifo_alarm, 0x0000030c);
+	out_be32(&fec->tfifo_cntrl, 0x0f000000);
+	out_be32(&fec->tfifo_alarm, 0x00000100);
+	out_be32(&fec->x_wmrk, 0x3);		/* xmit fifo watermark = 256 */
+	out_be32(&fec->xmit_fsm, 0x03000000);	/* enable crc generation */
+	out_be32(&fec->iaddr1, 0x00000000);	/* No individual filter */
+	out_be32(&fec->iaddr2, 0x00000000);	/* No individual filter */
+
+	priv->phy_speed = ((bd->bi_ipbfreq >> 20) / 5) << 1;
+
+	fec_restart(dev, 0);	/* always use half duplex mode only */
+	/*
+	 * Read MIB counters in order to reset them,
+	 * then zero all the stats fields in memory
+	 */
+	fec_update_stat(dev);
+}
+
+
+static void fec_reinit(struct net_device *dev)
+{
+	struct fec_priv *priv = (struct fec_priv *)dev->priv;
+	struct mpc52xx_fec *fec = priv->fec;
+	static void fec_update_stat(struct net_device *);
+
+	netif_stop_queue(dev);
+	out_be32(&fec->imask, 0x0);
+
+	/* Disable the rx and tx tasks. */
+	sdma_disable(priv->rx_sdma);
+	sdma_disable(priv->tx_sdma);
+
+	/* Stop FEC */
+	out_be32(&fec->ecntrl, in_be32(&fec->ecntrl) & ~0x2);
+
+	/* Restart the DMA tasks */
+	sdma_fec_rx_init(priv->rx_sdma, priv->rx_fifo, FEC_RX_BUFFER_SIZE);
+	sdma_fec_tx_init(priv->tx_sdma, priv->tx_fifo);
+	fec_hw_init(dev);
+
+	if (priv->sequence_done) {		 /* redo the fec_open() */
+		fec_free_rx_buffers(priv->rx_sdma);
+		fec_open(dev);
+	}
+	return;
+}
+
+
+/* ======================================================================== */
+/* OCP Driver                                                               */
+/* ======================================================================== */
+
+static int __devinit
+mpc52xx_fec_probe(struct ocp_device *ocp)
+{
+	int ret;
+	struct net_device *dev;
+	struct fec_priv *priv = NULL;
+
+	/* Reserve FEC control zone */
+	if (!request_mem_region(ocp->def->paddr, sizeof(struct mpc52xx_fec),
+	                        "mpc52xx_fec"))
+		return -EBUSY;
+
+	/* Get the ether dev & it's private zone */
+	dev = alloc_etherdev(sizeof(struct fec_priv));
+	if (!dev) {
+		ret = -ENOMEM;
+		goto probe_error;
+	}
+	
+	priv = (struct fec_priv *)dev->priv;
+	
+	/* Init ether dev with what we have */
+	dev->open		= fec_open;
+	dev->stop		= fec_close;
+	dev->hard_start_xmit	= fec_hard_start_xmit;
+	dev->do_ioctl		= fec_ioctl;
+	dev->get_stats		= fec_get_stats;
+	dev->set_mac_address	= fec_set_mac_address;
+	dev->set_multicast_list = fec_set_multicast_list;
+	dev->tx_timeout		= fec_tx_timeout;
+	dev->watchdog_timeo	= FEC_WATCHDOG_TIMEOUT;
+	dev->flags &= ~IFF_RUNNING;
+	dev->base_addr		= ocp->def->paddr;
+
+	priv->rx_fifo = dev->base_addr + FIELD_OFFSET(mpc52xx_fec,rfifo_data);
+	priv->tx_fifo = dev->base_addr + FIELD_OFFSET(mpc52xx_fec,tfifo_data);
+	priv->t_irq = priv->r_irq = dev->irq = -1; /* IRQ are free for now */
+	
+	spin_lock_init(&priv->lock);
+
+	/* ioremap the zones */
+	priv->fec = (struct mpc52xx_fec *)
+		ioremap(ocp->def->paddr, sizeof(struct mpc52xx_fec));
+	
+	if (!priv->fec) {
+		ret = -ENOMEM;
+		goto probe_error;
+	}
+	
+	/* SDMA init */
+	priv->rx_sdma = sdma_alloc(FEC_RX_NUM_BD);
+	priv->tx_sdma = sdma_alloc(FEC_TX_NUM_BD);
+	
+	if (!priv->rx_sdma || !priv->tx_sdma) {
+		ret = -ENOMEM;
+		goto probe_error;
+	}
+
+	ret = sdma_fec_rx_init(priv->rx_sdma, priv->rx_fifo,FEC_RX_BUFFER_SIZE);
+	if (ret < 0)
+		goto probe_error;
+
+	ret = sdma_fec_tx_init(priv->tx_sdma, priv->tx_fifo);
+	if (ret < 0)
+		goto probe_error;
+
+	/* Get the IRQ we need one by one */
+		/* Control */
+	dev->irq = ocp->def->irq;
+	if (request_irq(dev->irq, &fec_interrupt, SA_INTERRUPT,
+	                "mpc52xx_fec_ctrl", dev)) {
+		printk(KERN_ERR "mpc52xx_fec: ctrl interrupt request failed\n");
+		ret = -EBUSY;
+		dev->irq = -1;	/* Don't try to free it */
+		goto probe_error;
+	}
+
+		/* RX */
+	priv->r_irq = sdma_irq(priv->rx_sdma);
+	if (request_irq(priv->r_irq, &fec_rx_interrupt, SA_INTERRUPT,
+	                "mpc52xx_fec_rx", dev)) {
+		printk(KERN_ERR "mpc52xx_fec: rx interrupt request failed\n");
+		ret = -EBUSY;
+		priv->r_irq = -1;	/* Don't try to free it */
+		goto probe_error;
+	}
+
+		/* TX */
+	priv->t_irq = sdma_irq(priv->tx_sdma);
+	if (request_irq(priv->t_irq, &fec_tx_interrupt, SA_INTERRUPT,
+	                "mpc52xx_fec_tx", dev)) {
+		printk(KERN_ERR "mpc52xx_fec: tx interrupt request failed\n");
+		ret = -EBUSY;
+		priv->t_irq = -1;	/* Don't try to free it */
+		goto probe_error;
+	}
+
+	/* MAC address init */
+	if (memcmp(mpc52xx_fec_mac_addr, null_mac, 6) != 0)
+		memcpy(dev->dev_addr, mpc52xx_fec_mac_addr, 6);
+	else
+		fec_get_paddr(dev, dev->dev_addr);
+
+	/* Hardware init */
+	fec_hw_init(dev);
+
+	/* Register the new network device */
+	ret = register_netdev(dev);
+	if(ret < 0)
+		goto probe_error;
+
+	/* MII init : After register ???? */
+	fec_mii_init(dev);
+	
+	/* We're done ! */
+	ocp_set_drvdata(ocp, dev);
+
+	return 0;
+
+
+	/* Error handling - free everything that might be allocated */
+probe_error:
+
+	if (dev) {
+		if (priv->rx_sdma)	sdma_free(priv->rx_sdma);
+		if (priv->tx_sdma)	sdma_free(priv->tx_sdma);
+		
+		if (dev->irq >= 0)	free_irq(dev->irq, dev);
+		if (priv->r_irq >= 0)	free_irq(priv->r_irq, dev);
+		if (priv->t_irq >= 0)	free_irq(priv->t_irq, dev);
+
+		if (priv->fec)		iounmap(priv->fec);
+	
+		free_netdev(dev);
+	}
+	
+	release_mem_region(ocp->def->paddr, sizeof(struct mpc52xx_fec));
+
+	return ret;
+}
+
+static void
+mpc52xx_fec_remove(struct ocp_device *ocp)
+{
+	struct net_device *dev;
+	struct fec_priv *priv;
+	
+	dev = (struct net_device *) ocp_get_drvdata(ocp);
+	if (!dev)
+		return;
+	priv = (struct fec_priv *) dev->priv;
+
+	unregister_netdev(dev);
+	
+	free_irq(dev->irq, dev);
+	free_irq(priv->r_irq, dev);
+	free_irq(priv->t_irq, dev);
+
+	iounmap(priv->fec);
+	
+	release_mem_region(dev->base_addr, sizeof(struct mpc52xx_fec));
+
+	free_netdev(dev);
+	
+	ocp_set_drvdata(ocp, NULL);
+}
+
+static struct ocp_device_id mpc52xx_fec_ids[] __devinitdata = {
+	{ .vendor = OCP_VENDOR_FREESCALE, .function = OCP_FUNC_FEC_MPC52xx },
+	{ .vendor = OCP_VENDOR_INVALID /* Terminating entry */ }
+};
+
+MODULE_DEVICE_TABLE(ocp, mpc52xx_fec_ids);
+
+static struct ocp_driver mpc52xx_fec_ocp_driver = {
+	.name		= "mpc52xx_fec",
+	.id_table	= mpc52xx_fec_ids,
+	.probe		= mpc52xx_fec_probe,
+	.remove		= mpc52xx_fec_remove,
+#ifdef CONFIG_PM
+/*	.suspend	= mpc52xx_fec_suspend,	TODO */
+/*	.resume		= mpc52xx_fec_resume,	TODO */
+#endif
+};
+
+
+/* ======================================================================== */
+/* Module                                                                   */
+/* ======================================================================== */
+
+static int __init
+mpc52xx_fec_init(void)
+{
+	return ocp_register_driver(&mpc52xx_fec_ocp_driver);
+}
+
+static void __exit
+mpc52xx_fec_exit(void)
+{
+	ocp_unregister_driver(&mpc52xx_fec_ocp_driver);
+}
+
+
+module_init(mpc52xx_fec_init);
+module_exit(mpc52xx_fec_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Dale Farnsworth");
+MODULE_DESCRIPTION("Ethernet driver for the Freescale MPC52xx FEC");
diff -Nurp linux-2.6.9.orig/drivers/net/fec_mpc52xx/fec.h linux-2.6.9/drivers/net/fec_mpc52xx/fec.h
--- linux-2.6.9.orig/drivers/net/fec_mpc52xx/fec.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.9/drivers/net/fec_mpc52xx/fec.h	2006-09-07 18:57:01.000000000 +0200
@@ -0,0 +1,308 @@
+/*
+ * drivers/net/fec_mpc52xx/fec.h
+ *
+ * Driver for the MPC5200 Fast Ethernet Controller
+ *
+ * Author: Dale Farnsworth <dfarnsworth@mvista.com>
+ *
+ * 2003-2004 (c) MontaVista, Software, Inc.  This file is licensed under
+ * the terms of the GNU General Public License version 2.  This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#ifndef __DRIVERS_NET_MPC52XX_FEC_H__
+#define __DRIVERS_NET_MPC52XX_FEC_H__
+
+/* Tunable constant */
+/* FEC_RX_BUFFER_SIZE includes 4 bytes for CRC32 */
+#define FEC_RX_BUFFER_SIZE	1522	/* max receive packet size */
+#define FEC_RX_NUM_BD		64
+#define FEC_TX_NUM_BD		64
+
+#define FEC_RESET_DELAY		50 	/* uS */
+
+#define FEC_WATCHDOG_TIMEOUT	((400*HZ)/1000)
+
+struct fec_priv {
+	int full_duplex;
+	int tx_full;
+	int r_irq;
+	int t_irq;
+	u32 last_transmit_time;
+	struct mpc52xx_fec *fec;
+	struct sdma *rx_sdma;
+	struct sdma *tx_sdma;
+	spinlock_t lock;
+	unsigned long open_time;
+	struct net_device_stats stats;
+#ifdef CONFIG_USE_MDIO
+	uint phy_id;
+	uint phy_id_done;
+	uint phy_status;
+	uint phy_speed;
+	phy_info_t *phy;
+	struct tasklet_struct phy_task;
+	uint sequence_done;
+	uint phy_addr;
+	struct timer_list phy_timer_list;
+	u16 old_status;
+	phys_addr_t rx_fifo;
+	phys_addr_t tx_fifo;
+#endif	/* CONFIG_USE_MDIO */
+};
+
+
+/* ======================================================================== */
+/* Hardware register sets & bits                                            */
+/* ======================================================================== */
+
+struct mpc52xx_fec {
+	u32 fec_id;			/* FEC + 0x000 */
+	u32 ievent;			/* FEC + 0x004 */
+	u32 imask;			/* FEC + 0x008 */
+
+	u32 reserved0[1];		/* FEC + 0x00C */
+	u32 r_des_active;		/* FEC + 0x010 */
+	u32 x_des_active;		/* FEC + 0x014 */
+	u32 r_des_active_cl;		/* FEC + 0x018 */
+	u32 x_des_active_cl;		/* FEC + 0x01C */
+	u32 ivent_set;			/* FEC + 0x020 */
+	u32 ecntrl;			/* FEC + 0x024 */
+
+	u32 reserved1[6];		/* FEC + 0x028-03C */
+	u32 mii_data;			/* FEC + 0x040 */
+	u32 mii_speed;			/* FEC + 0x044 */
+	u32 mii_status;			/* FEC + 0x048 */
+
+	u32 reserved2[5];		/* FEC + 0x04C-05C */
+	u32 mib_data;			/* FEC + 0x060 */
+	u32 mib_control;		/* FEC + 0x064 */
+
+	u32 reserved3[6];		/* FEC + 0x068-7C */
+	u32 r_activate;			/* FEC + 0x080 */
+	u32 r_cntrl;			/* FEC + 0x084 */
+	u32 r_hash;			/* FEC + 0x088 */
+	u32 r_data;			/* FEC + 0x08C */
+	u32 ar_done;			/* FEC + 0x090 */
+	u32 r_test;			/* FEC + 0x094 */
+	u32 r_mib;			/* FEC + 0x098 */
+	u32 r_da_low;			/* FEC + 0x09C */
+	u32 r_da_high;			/* FEC + 0x0A0 */
+
+	u32 reserved4[7];		/* FEC + 0x0A4-0BC */
+	u32 x_activate;			/* FEC + 0x0C0 */
+	u32 x_cntrl;			/* FEC + 0x0C4 */
+	u32 backoff;			/* FEC + 0x0C8 */
+	u32 x_data;			/* FEC + 0x0CC */
+	u32 x_status;			/* FEC + 0x0D0 */
+	u32 x_mib;			/* FEC + 0x0D4 */
+	u32 x_test;			/* FEC + 0x0D8 */
+	u32 fdxfc_da1;			/* FEC + 0x0DC */
+	u32 fdxfc_da2;			/* FEC + 0x0E0 */
+	u32 paddr1;			/* FEC + 0x0E4 */
+	u32 paddr2;			/* FEC + 0x0E8 */
+	u32 op_pause;			/* FEC + 0x0EC */
+
+	u32 reserved5[4];		/* FEC + 0x0F0-0FC */
+	u32 instr_reg;			/* FEC + 0x100 */
+	u32 context_reg;		/* FEC + 0x104 */
+	u32 test_cntrl;			/* FEC + 0x108 */
+	u32 acc_reg;			/* FEC + 0x10C */
+	u32 ones;			/* FEC + 0x110 */
+	u32 zeros;			/* FEC + 0x114 */
+	u32 iaddr1;			/* FEC + 0x118 */
+	u32 iaddr2;			/* FEC + 0x11C */
+	u32 gaddr1;			/* FEC + 0x120 */
+	u32 gaddr2;			/* FEC + 0x124 */
+	u32 random;			/* FEC + 0x128 */
+	u32 rand1;			/* FEC + 0x12C */
+	u32 tmp;			/* FEC + 0x130 */
+
+	u32 reserved6[3];		/* FEC + 0x134-13C */
+	u32 fifo_id;			/* FEC + 0x140 */
+	u32 x_wmrk;			/* FEC + 0x144 */
+	u32 fcntrl;			/* FEC + 0x148 */
+	u32 r_bound;			/* FEC + 0x14C */
+	u32 r_fstart;			/* FEC + 0x150 */
+	u32 r_count;			/* FEC + 0x154 */
+	u32 r_lag;			/* FEC + 0x158 */
+	u32 r_read;			/* FEC + 0x15C */
+	u32 r_write;			/* FEC + 0x160 */
+	u32 x_count;			/* FEC + 0x164 */
+	u32 x_lag;			/* FEC + 0x168 */
+	u32 x_retry;			/* FEC + 0x16C */
+	u32 x_write;			/* FEC + 0x170 */
+	u32 x_read;			/* FEC + 0x174 */
+
+	u32 reserved7[2];		/* FEC + 0x178-17C */
+	u32 fm_cntrl;			/* FEC + 0x180 */
+	u32 rfifo_data;			/* FEC + 0x184 */
+	u32 rfifo_status;		/* FEC + 0x188 */
+	u32 rfifo_cntrl;		/* FEC + 0x18C */
+	u32 rfifo_lrf_ptr;		/* FEC + 0x190 */
+	u32 rfifo_lwf_ptr;		/* FEC + 0x194 */
+	u32 rfifo_alarm;		/* FEC + 0x198 */
+	u32 rfifo_rdptr;		/* FEC + 0x19C */
+	u32 rfifo_wrptr;		/* FEC + 0x1A0 */
+	u32 tfifo_data;			/* FEC + 0x1A4 */
+	u32 tfifo_status;		/* FEC + 0x1A8 */
+	u32 tfifo_cntrl;		/* FEC + 0x1AC */
+	u32 tfifo_lrf_ptr;		/* FEC + 0x1B0 */
+	u32 tfifo_lwf_ptr;		/* FEC + 0x1B4 */
+	u32 tfifo_alarm;		/* FEC + 0x1B8 */
+	u32 tfifo_rdptr;		/* FEC + 0x1BC */
+	u32 tfifo_wrptr;		/* FEC + 0x1C0 */
+
+	u32 reset_cntrl;		/* FEC + 0x1C4 */
+	u32 xmit_fsm;			/* FEC + 0x1C8 */
+
+	u32 reserved8[3];		/* FEC + 0x1CC-1D4 */
+	u32 rdes_data0;			/* FEC + 0x1D8 */
+	u32 rdes_data1;			/* FEC + 0x1DC */
+	u32 r_length;			/* FEC + 0x1E0 */
+	u32 x_length;			/* FEC + 0x1E4 */
+	u32 x_addr;			/* FEC + 0x1E8 */
+	u32 cdes_data;			/* FEC + 0x1EC */
+	u32 status;			/* FEC + 0x1F0 */
+	u32 dma_control;		/* FEC + 0x1F4 */
+	u32 des_cmnd;			/* FEC + 0x1F8 */
+	u32 data;			/* FEC + 0x1FC */
+
+	u32 rmon_t_drop;		/* FEC + 0x200 */
+	u32 rmon_t_packets;		/* FEC + 0x204 */
+	u32 rmon_t_bc_pkt;		/* FEC + 0x208 */
+	u32 rmon_t_mc_pkt;		/* FEC + 0x20C */
+	u32 rmon_t_crc_align;		/* FEC + 0x210 */
+	u32 rmon_t_undersize;		/* FEC + 0x214 */
+	u32 rmon_t_oversize;		/* FEC + 0x218 */
+	u32 rmon_t_frag;		/* FEC + 0x21C */
+	u32 rmon_t_jab;			/* FEC + 0x220 */
+	u32 rmon_t_col;			/* FEC + 0x224 */
+	u32 rmon_t_p64;			/* FEC + 0x228 */
+	u32 rmon_t_p65to127;		/* FEC + 0x22C */
+	u32 rmon_t_p128to255;		/* FEC + 0x230 */
+	u32 rmon_t_p256to511;		/* FEC + 0x234 */
+	u32 rmon_t_p512to1023;		/* FEC + 0x238 */
+	u32 rmon_t_p1024to2047;		/* FEC + 0x23C */
+	u32 rmon_t_p_gte2048;		/* FEC + 0x240 */
+	u32 rmon_t_octets;		/* FEC + 0x244 */
+	u32 ieee_t_drop;		/* FEC + 0x248 */
+	u32 ieee_t_frame_ok;		/* FEC + 0x24C */
+	u32 ieee_t_1col;		/* FEC + 0x250 */
+	u32 ieee_t_mcol;		/* FEC + 0x254 */
+	u32 ieee_t_def;			/* FEC + 0x258 */
+	u32 ieee_t_lcol;		/* FEC + 0x25C */
+	u32 ieee_t_excol;		/* FEC + 0x260 */
+	u32 ieee_t_macerr;		/* FEC + 0x264 */
+	u32 ieee_t_cserr;		/* FEC + 0x268 */
+	u32 ieee_t_sqe;			/* FEC + 0x26C */
+	u32 t_fdxfc;			/* FEC + 0x270 */
+	u32 ieee_t_octets_ok;		/* FEC + 0x274 */
+
+	u32 reserved9[2];		/* FEC + 0x278-27C */
+	u32 rmon_r_drop;		/* FEC + 0x280 */
+	u32 rmon_r_packets;		/* FEC + 0x284 */
+	u32 rmon_r_bc_pkt;		/* FEC + 0x288 */
+	u32 rmon_r_mc_pkt;		/* FEC + 0x28C */
+	u32 rmon_r_crc_align;		/* FEC + 0x290 */
+	u32 rmon_r_undersize;		/* FEC + 0x294 */
+	u32 rmon_r_oversize;		/* FEC + 0x298 */
+	u32 rmon_r_frag;		/* FEC + 0x29C */
+	u32 rmon_r_jab;			/* FEC + 0x2A0 */
+
+	u32 rmon_r_resvd_0;		/* FEC + 0x2A4 */
+
+	u32 rmon_r_p64;			/* FEC + 0x2A8 */
+	u32 rmon_r_p65to127;		/* FEC + 0x2AC */
+	u32 rmon_r_p128to255;		/* FEC + 0x2B0 */
+	u32 rmon_r_p256to511;		/* FEC + 0x2B4 */
+	u32 rmon_r_p512to1023;		/* FEC + 0x2B8 */
+	u32 rmon_r_p1024to2047;		/* FEC + 0x2BC */
+	u32 rmon_r_p_gte2048;		/* FEC + 0x2C0 */
+	u32 rmon_r_octets;		/* FEC + 0x2C4 */
+	u32 ieee_r_drop;		/* FEC + 0x2C8 */
+	u32 ieee_r_frame_ok;		/* FEC + 0x2CC */
+	u32 ieee_r_crc;			/* FEC + 0x2D0 */
+	u32 ieee_r_align;		/* FEC + 0x2D4 */
+	u32 r_macerr;			/* FEC + 0x2D8 */
+	u32 r_fdxfc;			/* FEC + 0x2DC */
+	u32 ieee_r_octets_ok;		/* FEC + 0x2E0 */
+
+	u32 reserved10[6];		/* FEC + 0x2E4-2FC */
+
+	u32 reserved11[64];		/* FEC + 0x300-3FF */
+};
+
+#define	FEC_MIB_DISABLE			0x80000000
+
+#define	FEC_IEVENT_HBERR		0x80000000
+#define	FEC_IEVENT_BABR			0x40000000
+#define	FEC_IEVENT_BABT			0x20000000
+#define	FEC_IEVENT_GRA			0x10000000
+#define	FEC_IEVENT_TFINT		0x08000000
+#define	FEC_IEVENT_MII			0x00800000
+#define	FEC_IEVENT_LATE_COL		0x00200000
+#define	FEC_IEVENT_COL_RETRY_LIM	0x00100000
+#define	FEC_IEVENT_XFIFO_UN		0x00080000
+#define	FEC_IEVENT_XFIFO_ERROR		0x00040000
+#define	FEC_IEVENT_RFIFO_ERROR		0x00020000
+
+#define	FEC_IMASK_HBERR			0x80000000
+#define	FEC_IMASK_BABR			0x40000000
+#define	FEC_IMASK_BABT			0x20000000
+#define	FEC_IMASK_GRA			0x10000000
+#define	FEC_IMASK_MII			0x00800000
+#define	FEC_IMASK_LATE_COL		0x00200000
+#define	FEC_IMASK_COL_RETRY_LIM		0x00100000
+#define	FEC_IMASK_XFIFO_UN		0x00080000
+#define	FEC_IMASK_XFIFO_ERROR		0x00040000
+#define	FEC_IMASK_RFIFO_ERROR		0x00020000
+
+#define	FEC_RCNTRL_MAX_FL_SHIFT		16
+#define	FEC_RCNTRL_LOOP			0x01
+#define	FEC_RCNTRL_DRT			0x02
+#define	FEC_RCNTRL_MII_MODE		0x04
+#define	FEC_RCNTRL_PROM			0x08
+#define	FEC_RCNTRL_BC_REJ		0x10
+#define	FEC_RCNTRL_FCE			0x20
+
+#define	FEC_TCNTRL_GTS			0x00000001
+#define	FEC_TCNTRL_HBC			0x00000002
+#define	FEC_TCNTRL_FDEN			0x00000004
+#define	FEC_TCNTRL_TFC_PAUSE		0x00000008
+#define	FEC_TCNTRL_RFC_PAUSE		0x00000010
+
+#define	FEC_ECNTRL_RESET		0x00000001
+#define	FEC_ECNTRL_ETHER_EN		0x00000002
+
+struct mibCounters {
+	unsigned int byteReceived;
+	unsigned int byteSent;
+	unsigned int framesReceived;
+	unsigned int framesSent;
+	unsigned int totalByteReceived;
+	unsigned int totalFramesReceived;
+	unsigned int broadcastFramesReceived;
+	unsigned int multicastFramesReceived;
+	unsigned int cRCError;
+	unsigned int oversizeFrames;
+	unsigned int fragments;
+	unsigned int jabber;
+	unsigned int collision;
+	unsigned int lateCollision;
+	unsigned int frames64;
+	unsigned int frames65_127;
+	unsigned int frames128_255;
+	unsigned int frames256_511;
+	unsigned int frames512_1023;
+	unsigned int frames1024_MaxSize;
+	unsigned int macRxError;
+	unsigned int droppedFrames;
+	unsigned int outMulticastFrames;
+	unsigned int outBroadcastFrames;
+	unsigned int undersizeFrames;
+};
+
+
+#endif	/* __DRIVERS_NET_MPC52XX_FEC_H__ */
diff -Nurp linux-2.6.9.orig/drivers/net/fec_mpc52xx/fec_phy.c linux-2.6.9/drivers/net/fec_mpc52xx/fec_phy.c
--- linux-2.6.9.orig/drivers/net/fec_mpc52xx/fec_phy.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.9/drivers/net/fec_mpc52xx/fec_phy.c	2006-09-07 18:57:01.000000000 +0200
@@ -0,0 +1,526 @@
+/*
+ * arch/ppc/52xx_io/fec_phy.c
+ *
+ * Driver for the MPC5200 Fast Ethernet Controller
+ * Based heavily on the MII support for the MPC8xx by Dan Malek
+ *
+ * Author: Dale Farnsworth <dfarnsworth@mvista.com>
+ *
+ * 2003-2004 (c) MontaVista, Software, Inc.  This file is licensed under
+ * the terms of the GNU General Public License version 2.  This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/netdevice.h>
+#include <linux/mii.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <asm/io.h>
+#include <asm/mpc52xx.h>
+#include <syslib/bestcomm/bestcomm.h>
+#include <syslib/bestcomm/fec.h>
+#include "fec_phy.h"
+#include "fec.h"
+
+static int mpc52xx_netdev_ethtool_ioctl(struct net_device *dev, void *useraddr);
+
+/* MII processing.  We keep this as simple as possible.  Requests are
+ * placed on the list (if there is room).  When the request is finished
+ * by the MII, an optional function may be called.
+ */
+typedef struct mii_list {
+	uint	mii_regval;
+	void	(*mii_func)(uint val, struct net_device *dev, uint data);
+	struct	mii_list *mii_next;
+	uint	mii_data;
+} mii_list_t;
+
+#define		NMII	20
+mii_list_t	mii_cmds[NMII];
+mii_list_t	*mii_free;
+mii_list_t	*mii_head;
+mii_list_t	*mii_tail;
+
+typedef struct mdio_read_data {
+	__u16 regval;
+	struct task_struct *sleeping_task;
+} mdio_read_data_t;
+
+static int mii_queue(struct net_device *dev, int request,
+		void (*func)(uint, struct net_device *, uint), uint data);
+
+/* Make MII read/write commands for the FEC.
+ * */
+#define mk_mii_read(REG)	(0x60020000 | ((REG & 0x1f) << 18))
+#define mk_mii_write(REG, VAL)	(0x50020000 | ((REG & 0x1f) << 18) | \
+							(VAL & 0xffff))
+#define mk_mii_end	0
+
+/* Register definitions for the PHY.
+*/
+
+#define MII_REG_CR	 0	/* Control Register */
+#define MII_REG_SR	 1	/* Status Register */
+#define MII_REG_PHYIR1	 2	/* PHY Identification Register 1 */
+#define MII_REG_PHYIR2	 3	/* PHY Identification Register 2 */
+#define MII_REG_ANAR	 4	/* A-N Advertisement Register */
+#define MII_REG_ANLPAR	 5	/* A-N Link Partner Ability Register */
+#define MII_REG_ANER	 6	/* A-N Expansion Register */
+#define MII_REG_ANNPTR	 7	/* A-N Next Page Transmit Register */
+#define MII_REG_ANLPRNPR 8	/* A-N Link Partner Received Next Page Reg. */
+
+/* values for phy_status */
+
+#define PHY_CONF_ANE	0x0001	/* 1 auto-negotiation enabled */
+#define PHY_CONF_LOOP	0x0002	/* 1 loopback mode enabled */
+#define PHY_CONF_SPMASK	0x00f0	/* mask for speed */
+#define PHY_CONF_10HDX	0x0010	/* 10 Mbit half duplex supported */
+#define PHY_CONF_10FDX	0x0020	/* 10 Mbit full duplex supported */
+#define PHY_CONF_100HDX	0x0040	/* 100 Mbit half duplex supported */
+#define PHY_CONF_100FDX	0x0080	/* 100 Mbit full duplex supported */
+
+#define PHY_STAT_LINK	0x0100	/* 1 up - 0 down */
+#define PHY_STAT_FAULT	0x0200	/* 1 remote fault */
+#define PHY_STAT_ANC	0x0400	/* 1 auto-negotiation complete	*/
+#define PHY_STAT_SPMASK	0xf000	/* mask for speed */
+#define PHY_STAT_10HDX	0x1000	/* 10 Mbit half duplex selected	*/
+#define PHY_STAT_10FDX	0x2000	/* 10 Mbit full duplex selected	*/
+#define PHY_STAT_100HDX	0x4000	/* 100 Mbit half duplex selected */
+#define PHY_STAT_100FDX	0x8000	/* 100 Mbit full duplex selected */
+
+void fec_mii(struct net_device *dev)
+{
+	struct fec_priv *priv = (struct fec_priv *)dev->priv;
+	struct mpc52xx_fec *fec = priv->fec;
+	mii_list_t	*mip;
+	uint		mii_reg;
+
+	mii_reg = in_be32(&fec->mii_data);
+
+	if ((mip = mii_head) == NULL) {
+		printk(KERN_ERR "MII and no head!\n");
+		return;
+	}
+
+	if (mip->mii_func != NULL)
+		(*(mip->mii_func))(mii_reg, dev, mip->mii_data);
+
+	mii_head = mip->mii_next;
+	mip->mii_next = mii_free;
+	mii_free = mip;
+
+	if ((mip = mii_head) != NULL)
+		out_be32(&fec->mii_data, mip->mii_regval);
+}
+
+static int mii_queue(struct net_device *dev, int regval,
+				void (*func)(uint, struct net_device *, uint),
+				uint data)
+{
+	struct fec_priv *priv = (struct fec_priv *)dev->priv;
+	struct mpc52xx_fec *fec = priv->fec;
+	mii_list_t	*mip;
+	int		retval;
+
+	/* Add PHY address to register command.
+	*/
+	regval |= priv->phy_addr << 23;
+
+	retval = 0;
+
+	if ((mip = mii_free) != NULL) {
+		mii_free = mip->mii_next;
+		mip->mii_regval = regval;
+		mip->mii_func = func;
+		mip->mii_next = NULL;
+		mip->mii_data = data;
+		if (mii_head) {
+			mii_tail->mii_next = mip;
+			mii_tail = mip;
+		} else {
+			mii_head = mii_tail = mip;
+			out_be32(&fec->mii_data, regval);
+		}
+	} else
+		retval = 1;
+
+	return retval;
+}
+
+static void mii_do_cmd(struct net_device *dev, const phy_cmd_t *c)
+{
+	int k;
+
+	if (!c)
+		return;
+
+	for (k = 0; (c+k)->mii_data != mk_mii_end; k++)
+		mii_queue(dev, (c+k)->mii_data, (c+k)->funct, 0);
+}
+
+static void mii_parse_sr(uint mii_reg, struct net_device *dev, uint data)
+{
+	struct fec_priv *priv = (struct fec_priv *)dev->priv;
+	uint s = priv->phy_status;
+
+	s &= ~(PHY_STAT_LINK | PHY_STAT_FAULT | PHY_STAT_ANC);
+
+	if (mii_reg & 0x0004)
+		s |= PHY_STAT_LINK;
+	if (mii_reg & 0x0010)
+		s |= PHY_STAT_FAULT;
+	if (mii_reg & 0x0020)
+		s |= PHY_STAT_ANC;
+
+	priv->phy_status = s;
+}
+
+static void mii_parse_cr(uint mii_reg, struct net_device *dev, uint data)
+{
+	struct fec_priv *priv = (struct fec_priv *)dev->priv;
+	uint s = priv->phy_status;
+
+	s &= ~(PHY_CONF_ANE | PHY_CONF_LOOP);
+
+	if (mii_reg & 0x1000)
+		s |= PHY_CONF_ANE;
+	if (mii_reg & 0x4000)
+		s |= PHY_CONF_LOOP;
+
+	priv->phy_status = s;
+}
+
+static void mii_parse_anar(uint mii_reg, struct net_device *dev, uint data)
+{
+	struct fec_priv *priv = (struct fec_priv *)dev->priv;
+	uint s = priv->phy_status;
+
+	s &= ~(PHY_CONF_SPMASK);
+
+	if (mii_reg & 0x0020)
+		s |= PHY_CONF_10HDX;
+	if (mii_reg & 0x0040)
+		s |= PHY_CONF_10FDX;
+	if (mii_reg & 0x0080)
+		s |= PHY_CONF_100HDX;
+	if (mii_reg & 0x0100)
+		s |= PHY_CONF_100FDX;
+
+	priv->phy_status = s;
+}
+
+/* ------------------------------------------------------------------------- */
+/* Generic PHY support.  Should work for all PHYs, but does not support link
+ * change interrupts.
+ */
+static phy_info_t phy_info_generic = {
+	0x00000000, /* 0-->match any PHY */
+	"GENERIC",
+
+	(const phy_cmd_t []) {	/* config */
+		/* advertise only half-duplex capabilities */
+		{ mk_mii_write(MII_ADVERTISE, MII_ADVERTISE_HALF),
+			mii_parse_anar },
+
+		/* enable auto-negotiation */
+		{ mk_mii_write(MII_BMCR, BMCR_ANENABLE), mii_parse_cr },
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) {	/* startup */
+		/* restart auto-negotiation */
+		{ mk_mii_write(MII_BMCR, (BMCR_ANENABLE | BMCR_ANRESTART)),
+			NULL },
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) { /* ack_int */
+		/* We don't actually use the ack_int table with a generic
+		 * PHY, but putting a reference to mii_parse_sr here keeps
+		 * us from getting a compiler warning about unused static
+		 * functions in the case where we only compile in generic
+		 * PHY support.
+		 */
+		{ mk_mii_read(MII_BMSR), mii_parse_sr },
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) {	/* shutdown */
+		{ mk_mii_end, }
+	},
+};
+/* -------------------------------------------------------------------- */
+
+/* register definitions for the 971 */
+
+#define MII_LXT971_PCR	16	/* Port Control Register	*/
+#define MII_LXT971_SR2	17	/* Status Register 2		*/
+#define MII_LXT971_IER	18	/* Interrupt Enable Register	*/
+#define MII_LXT971_ISR	19	/* Interrupt Status Register	*/
+#define MII_LXT971_LCR	20	/* LED Control Register		*/
+#define MII_LXT971_TCR	30	/* Transmit Control Register	*/
+
+static void mii_parse_lxt971_sr2(uint mii_reg, struct net_device *dev, uint data)
+{
+	struct fec_priv *priv = (struct fec_priv *)dev->priv;
+	uint s = priv->phy_status;
+
+	s &= ~(PHY_STAT_SPMASK);
+
+	if (mii_reg & 0x4000) {
+		if (mii_reg & 0x0200)
+			s |= PHY_STAT_100FDX;
+		else
+			s |= PHY_STAT_100HDX;
+	} else {
+		if (mii_reg & 0x0200)
+			s |= PHY_STAT_10FDX;
+		else
+			s |= PHY_STAT_10HDX;
+	}
+	if (mii_reg & 0x0008)
+		s |= PHY_STAT_FAULT;
+
+	priv->phy_status = s;
+}
+
+static phy_info_t phy_info_lxt971 = {
+	0x0001378e,
+	"LXT971",
+
+	(const phy_cmd_t []) {	/* config */
+		{ mk_mii_write(MII_REG_ANAR, 0x0A1), NULL }, /* 10/100, HD */
+		{ mk_mii_read(MII_REG_CR), mii_parse_cr },
+		{ mk_mii_read(MII_REG_ANAR), mii_parse_anar },
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) {	/* startup - enable interrupts */
+		{ mk_mii_write(MII_LXT971_IER, 0x00f2), NULL },
+		{ mk_mii_write(MII_REG_CR, 0x1200), NULL }, /* autonegotiate */
+
+		/* Somehow does the 971 tell me that the link is down
+		 * the first read after power-up.
+		 * read here to get a valid value in ack_int */
+
+		{ mk_mii_read(MII_REG_SR), mii_parse_sr },
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) { /* ack_int */
+		/* find out the current status */
+
+		{ mk_mii_read(MII_REG_SR), mii_parse_sr },
+		{ mk_mii_read(MII_LXT971_SR2), mii_parse_lxt971_sr2 },
+
+		/* we only need to read ISR to acknowledge */
+
+		{ mk_mii_read(MII_LXT971_ISR), NULL },
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) {	/* shutdown - disable interrupts */
+		{ mk_mii_write(MII_LXT971_IER, 0x0000), NULL },
+		{ mk_mii_end, }
+	},
+};
+
+static phy_info_t *phy_info[] = {
+	&phy_info_lxt971,
+	/* Generic PHY support.  This must be the last PHY in the table.
+	 * It will be used to support any PHY that doesn't match a previous
+	 * entry in the table.
+	 */
+	&phy_info_generic,
+	NULL
+};
+
+static void mii_display_config(struct net_device *dev)
+{
+	struct fec_priv *priv = (struct fec_priv *)dev->priv;
+	uint s = priv->phy_status;
+
+	printk(KERN_INFO "%s: config: auto-negotiation ", dev->name);
+
+	if (s & PHY_CONF_ANE)
+		printk("on");
+	else
+		printk("off");
+
+	if (s & PHY_CONF_100FDX)
+		printk(", 100FDX");
+	if (s & PHY_CONF_100HDX)
+		printk(", 100HDX");
+	if (s & PHY_CONF_10FDX)
+		printk(", 10FDX");
+	if (s & PHY_CONF_10HDX)
+		printk(", 10HDX");
+	if (!(s & PHY_CONF_SPMASK))
+		printk(", No speed/duplex selected?");
+
+	if (s & PHY_CONF_LOOP)
+		printk(", loopback enabled");
+
+	printk(".\n");
+
+	priv->sequence_done = 1;
+}
+
+static void mii_queue_config(uint mii_reg, struct net_device *dev, uint data)
+{
+	struct fec_priv *priv = (struct fec_priv *)dev->priv;
+
+	priv->phy_task.func = (void *)mii_display_config;
+	priv->phy_task.data = (unsigned long)dev;
+	tasklet_schedule(&priv->phy_task);
+}
+
+
+phy_cmd_t phy_cmd_config[] =  { { mk_mii_read(MII_REG_CR), mii_queue_config },
+				{ mk_mii_end, } };
+
+
+/* Read remainder of PHY ID.
+*/
+static void mii_discover_phy3(uint mii_reg, struct net_device *dev, uint data)
+{
+	struct fec_priv *priv = (struct fec_priv *)dev->priv;
+	int	i;
+
+	priv->phy_id |= (mii_reg & 0xffff);
+
+	for (i = 0; phy_info[i]; i++) {
+		if (phy_info[i]->id == (priv->phy_id >> 4) || !phy_info[i]->id)
+			break;
+		if (phy_info[i]->id == 0)	/* check generic entry */
+			break;
+	}
+
+	if (!phy_info[i])
+		panic("%s: PHY id 0x%08x is not supported!\n",
+			dev->name, priv->phy_id);
+
+	priv->phy = phy_info[i];
+	priv->phy_id_done = 1;
+
+	printk(KERN_INFO "%s: Phy @ 0x%x, type %s (0x%08x)\n",
+		dev->name, priv->phy_addr, priv->phy->name, priv->phy_id);
+}
+
+/* Scan all of the MII PHY addresses looking for someone to respond
+ * with a valid ID.  This usually happens quickly.
+ */
+static void mii_discover_phy(uint mii_reg, struct net_device *dev, uint data)
+{
+	struct fec_priv *priv = (struct fec_priv *)dev->priv;
+	uint	phytype;
+
+	if ((phytype = (mii_reg & 0xffff)) != 0xffff) {
+		/* Got first part of ID, now get remainder.
+		*/
+		priv->phy_id = phytype << 16;
+		mii_queue(dev, mk_mii_read(MII_REG_PHYIR2), mii_discover_phy3,
+									0);
+	} else {
+		priv->phy_addr++;
+		if (priv->phy_addr < 32)
+			mii_queue(dev, mk_mii_read(MII_REG_PHYIR1),
+							mii_discover_phy, 0);
+		else
+			printk(KERN_ERR "fec: No PHY device found.\n");
+	}
+}
+
+static int mpc52xx_netdev_ethtool_ioctl(struct net_device *dev, void *useraddr)
+{
+	__u32 ethcmd;
+
+	if (copy_from_user(&ethcmd, useraddr, sizeof ethcmd))
+		return -EFAULT;
+
+	switch (ethcmd) {
+
+		/* Get driver info */
+	case ETHTOOL_GDRVINFO:{
+			struct ethtool_drvinfo info = { ETHTOOL_GDRVINFO };
+			strncpy(info.driver, "MPC5200 FEC",
+				sizeof info.driver - 1);
+			if (copy_to_user(useraddr, &info, sizeof info))
+				return -EFAULT;
+			return 0;
+		}
+		/* get message-level */
+	case ETHTOOL_GMSGLVL:{
+			struct ethtool_value edata = { ETHTOOL_GMSGLVL };
+			edata.data = 0;	/* XXX */
+			if (copy_to_user(useraddr, &edata, sizeof edata))
+				return -EFAULT;
+			return 0;
+		}
+		/* set message-level */
+	case ETHTOOL_SMSGLVL:{
+			struct ethtool_value edata;
+			if (copy_from_user(&edata, useraddr, sizeof edata))
+				return -EFAULT;
+			return 0;
+		}
+	}
+	return -EOPNOTSUPP;
+}
+
+int fec_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	int retval;
+
+	switch (cmd) {
+	case SIOCETHTOOL:
+		retval = mpc52xx_netdev_ethtool_ioctl(
+					dev, (void *) rq->ifr_data);
+		break;
+
+	default:
+		retval = -EOPNOTSUPP;
+		break;
+	}
+	return retval;
+}
+
+void fec_mii_init(struct net_device *dev)
+{
+	struct fec_priv *priv = (struct fec_priv *)dev->priv;
+	int i;
+
+	for (i=0; i<NMII-1; i++)
+		mii_cmds[i].mii_next = &mii_cmds[i+1];
+	mii_free = mii_cmds;
+
+	/* Queue up command to detect the PHY and initialize the
+	 * remainder of the interface.
+	 */
+	priv->phy_id_done = 0;
+	priv->phy_addr = 0;
+	mii_queue(dev, mk_mii_read(MII_REG_PHYIR1), mii_discover_phy, 0);
+
+	priv->old_status = 0;
+}
+
+int fec_mii_wait(struct net_device *dev)
+{
+	struct fec_priv *priv = (struct fec_priv *)dev->priv;
+
+	if (!priv->sequence_done) {
+		if (!priv->phy) {
+			printk("KERN_ERR fec_open: PHY not configured\n");
+			return -ENODEV;		/* No PHY we understand */
+		}
+
+		mii_do_cmd(dev, priv->phy->config);
+		mii_do_cmd(dev, phy_cmd_config); /* display configuration */
+		while(!priv->sequence_done)
+			schedule();
+
+		mii_do_cmd(dev, priv->phy->startup);
+	}
+	return 0;
+}
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Dale Farnsworth");
+MODULE_DESCRIPTION("PHY driver for Motorola MPC52xx FEC");
diff -Nurp linux-2.6.9.orig/drivers/net/fec_mpc52xx/fec_phy.h linux-2.6.9/drivers/net/fec_mpc52xx/fec_phy.h
--- linux-2.6.9.orig/drivers/net/fec_mpc52xx/fec_phy.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.9/drivers/net/fec_mpc52xx/fec_phy.h	2006-09-07 18:57:01.000000000 +0200
@@ -0,0 +1,73 @@
+/*
+ * arch/ppc/52xx_io/fec_phy.h
+ *
+ * Driver for the MPC5200 Fast Ethernet Controller
+ * Based heavily on the MII support for the MPC8xx by Dan Malek
+ *
+ * Author: Dale Farnsworth <dfarnsworth@mvista.com>
+ *
+ * 2003-2004 (c) MontaVista, Software, Inc.  This file is licensed under
+ * the terms of the GNU General Public License version 2.  This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#ifdef CONFIG_USE_MDIO
+#define MII_ADVERTISE_HALF	(ADVERTISE_100HALF | ADVERTISE_10HALF | \
+				 ADVERTISE_CSMA)
+
+#define MII_ADVERTISE_ALL	(ADVERTISE_100FULL | ADVERTISE_10FULL | \
+				 MII_ADVERTISE_HALF)
+#ifdef PHY_INTERRUPT
+#define MII_ADVERTISE_DEFAULT	MII_ADVERTISE_ALL
+#else
+#define MII_ADVERTISE_DEFAULT	MII_ADVERTISE_HALF
+#endif
+
+#define MII_RCNTL_MODE		FEC_RCNTRL_MII_MODE
+#define set_phy_speed(fec, s)	out_be32(&fec->mii_speed, s)
+#define FEC_IMASK_ENABLE	0xf0fe0000
+
+typedef struct {
+	uint mii_data;
+	void (*funct)(uint mii_reg, struct net_device *dev, uint data);
+} phy_cmd_t;
+
+typedef struct {
+	uint id;
+	char *name;
+
+	const phy_cmd_t *config;
+	const phy_cmd_t *startup;
+	const phy_cmd_t *ack_int;
+	const phy_cmd_t *shutdown;
+} phy_info_t;
+
+#else
+#define MII_RCNTL_MODE		0
+#define set_phy_speed(fec, s)
+#define FEC_IMASK_ENABLE	0xf07e0000
+#define fec_mii_wait(dev)	0
+#define fec_mii(dev)	printk(KERN_WARNING "unexpected FEC_IEVENT_MII\n")
+#define fec_mii_init(dev)
+#endif	/* CONFIG_USE_MDIO */
+
+/* MII-related definitions */
+#define FEC_MII_DATA_ST		0x40000000	/* Start frame */
+#define FEC_MII_DATA_OP_RD	0x20000000	/* Perform read */
+#define FEC_MII_DATA_OP_WR	0x10000000	/* Perform write */
+#define FEC_MII_DATA_PA_MSK	0x0f800000	/* PHY Address mask */
+#define FEC_MII_DATA_RA_MSK	0x007c0000	/* PHY Register mask */
+#define FEC_MII_DATA_TA		0x00020000	/* Turnaround */
+#define FEC_MII_DATA_DATAMSK	0x00000fff	/* PHY data mask */
+
+#define FEC_MII_DATA_RA_SHIFT	0x12		/* MII reg addr bits */
+#define FEC_MII_DATA_PA_SHIFT	0x17		/* MII PHY addr bits */
+
+#define FEC_MII_SPEED		(5 * 2)
+
+extern void fec_mii_init(struct net_device *dev);
+extern int fec_mii_wait(struct net_device *dev);
+extern void fec_mii(struct net_device *dev);
+
+extern int fec_ioctl(struct net_device *, struct ifreq *rq, int cmd);
diff -Nurp linux-2.6.9.orig/drivers/net/fec_mpc52xx/Kconfig linux-2.6.9/drivers/net/fec_mpc52xx/Kconfig
--- linux-2.6.9.orig/drivers/net/fec_mpc52xx/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.9/drivers/net/fec_mpc52xx/Kconfig	2006-09-07 18:57:01.000000000 +0200
@@ -0,0 +1,23 @@
+menu "MPC5200 Networking Options"
+	depends PPC_MPC52xx && NET_ETHERNET
+
+config FEC_MPC52xx
+	bool "FEC Ethernet"
+	depends on NET_ETHERNET
+	select PPC_BESTCOMM
+	select CRC32
+	---help---
+	  This option enables support for the MPC5200's on-chip
+	  Fast Ethernet Controller
+
+config USE_MDIO
+	bool "  Use external Ethernet MII PHY"
+	select MII
+	depends FEC_MPC52xx
+	---help---
+	  The MPC5200's FEC can connect to the Ethernet either with
+	  an external MII PHY chip or 10 Mbps 7-wire interface 
+	  (Motorola? industry standard).
+	  If your board uses an external PHY, say y, else n.
+
+endmenu
diff -Nurp linux-2.6.9.orig/drivers/net/fec_mpc52xx/Makefile linux-2.6.9/drivers/net/fec_mpc52xx/Makefile
--- linux-2.6.9.orig/drivers/net/fec_mpc52xx/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.9/drivers/net/fec_mpc52xx/Makefile	2006-09-07 18:57:01.000000000 +0200
@@ -0,0 +1,2 @@
+obj-$(CONFIG_FEC_MPC52xx) 	+= fec.o
+obj-$(CONFIG_USE_MDIO)		+= fec_phy.o
diff -Nurp linux-2.6.9.orig/include/asm-ppc/cpm2.h linux-2.6.9/include/asm-ppc/cpm2.h
--- linux-2.6.9.orig/include/asm-ppc/cpm2.h	2004-10-18 23:54:07.000000000 +0200
+++ linux-2.6.9/include/asm-ppc/cpm2.h	2006-09-07 18:57:01.000000000 +0200
@@ -69,6 +69,7 @@
 #define CPM_CR_INIT_TX		((ushort)0x0002)
 #define CPM_CR_HUNT_MODE	((ushort)0x0003)
 #define CPM_CR_STOP_TX		((ushort)0x0004)
+#define CPM_CR_GRA_STOP_TX      ((ushort)0x0005)
 #define CPM_CR_RESTART_TX	((ushort)0x0006)
 #define CPM_CR_SET_GADDR	((ushort)0x0008)
 #define CPM_CR_START_IDMA	((ushort)0x0009)
@@ -132,6 +133,7 @@ typedef struct cpm_buf_desc {
 #define BD_SC_CM	((ushort)0x0200)	/* Continous mode */
 #define BD_SC_ID	((ushort)0x0100)	/* Rec'd too many idles */
 #define BD_SC_P		((ushort)0x0100)	/* xmt preamble */
+#define BD_SC_NS    ((ushort)0x0080)    /* No stop bit or shaved stop bit */
 #define BD_SC_BR	((ushort)0x0020)	/* Break received */
 #define BD_SC_FR	((ushort)0x0010)	/* Framing error */
 #define BD_SC_PR	((ushort)0x0008)	/* Parity error */
@@ -146,6 +148,35 @@ typedef struct cpm_buf_desc {
 #define CPMFCR_DTB	((u_char)0x02)	/* Use local bus for data when set */
 #define CPMFCR_BDB	((u_char)0x01)	/* Use local bus for BD when set */
 
+/* HDLC definition for bd status */
+#define BD_HDLC_RX_EMPTY    ((ushort)0x8000)    /* Receive is empty */
+#define BD_HDLC_RX_WRAP     ((ushort)0x2000)    /* Last buffer descriptor */
+#define BD_HDLC_RX_INTRPT   ((ushort)0x1000)    /* Interrupt on change */
+#define BD_HDLC_RX_LAST     ((ushort)0x0800)    /* Last buffer in frame */
+#define BD_HDLC_RX_FIRST    ((ushort)0x0400)    /* First buffer in frame */
+#define BD_HDLC_RX_CM       ((ushort)0x0200)    /* Continous mode */
+#define BD_HDLC_RX_DE       ((ushort)0x0080)    /* DPLL error */
+#define BD_HDLC_RX_LG       ((ushort)0x0020)    /* Frame length violation */
+#define BD_HDLC_RX_NO       ((ushort)0x0010)    /* No aligned frame */
+#define BD_HDLC_RX_AB       ((ushort)0x0008)    /* Abort received */
+#define BD_HDLC_RX_CR       ((ushort)0x0004)    /* CRC error */
+#define BD_HDLC_RX_OV       ((ushort)0x0002)    /* Overrun */
+#define BD_HDLC_RX_CD       ((ushort)0x0001)    /* Carrier detect error */
+
+#define BD_HDLC_RX_STATS    BD_HDLC_RX_EMPTY|BD_HDLC_RX_INTRPT|BD_HDLC_RX_LAST|BD_HDLC_RX_FIRST|BD_HDLC_RX_CM|BD_HDLC_RX_DE|BD_HDLC_RX_LG|BD_HDLC_RX_NO|BD_HDLC_RX_AB|BD_HDLC_RX_CR|BD_HDLC_RX_OV|BD_HDLC_RX_CD
+
+#define BD_HDLC_TX_READY    ((ushort)0x8000)    /* Transmit is ready */
+#define BD_HDLC_TX_WRAP     ((ushort)0x2000)    /* Last buffer descriptor */
+#define BD_HDLC_TX_INTRPT   ((ushort)0x1000)    /* Interrupt on change */
+#define BD_HDLC_TX_LAST     ((ushort)0x0800)    /* Last buffer in frame */
+#define BD_HDLC_TX_TC       ((ushort)0x0400)    /* Transmit CRC */
+#define BD_HDLC_TX_CM       ((ushort)0x0200)    /* Continous mode */
+#define BD_HDLC_TX_UN       ((ushort)0x0002)    /* Underrun */
+#define BD_HDLC_TX_CT       ((ushort)0x0001)    /* CTS lost */
+
+#define BD_HDLC_TX_STATS    BD_HDLC_TX_READY|BD_HDLC_TX_INTRPT|BD_HDLC_TX_LAST|BD_HDLC_TX_TC|BD_HDLC_TX_CM|BD_HDLC_TX_UN|BD_HDLC_TX_CT
+
+
 /* Parameter RAM offsets from the base.
 */
 #define PROFF_SCC1		((uint)0x8000)
@@ -330,6 +361,7 @@ typedef struct smc_uart {
 /* SCC Event and Mask register.
 */
 #define SCCM_TXE	((unsigned char)0x10)
+#define SCCM_RXF    ((unsigned char)0x08)
 #define SCCM_BSY	((unsigned char)0x04)
 #define SCCM_TX		((unsigned char)0x02)
 #define SCCM_RX		((unsigned char)0x01)
@@ -354,6 +386,32 @@ typedef struct scc_param {
 	uint	scc_tcrc;	/* Internal */
 } sccp_t;
 
+/* SCC as HDLC
+ *  */
+typedef struct scc_hdlc {
+	sccp_t  genscc;
+	uint    res1;       /* Reserved */
+	uint    c_mask;     /* CRC mask */
+	uint    c_pres;     /* CRC preset */
+	ushort  disfc;      /* Discarded Frame Counter */
+	ushort  crcec;      /* CRC Error Counter */
+	ushort  abtsc;      /* Abort Sequence Counter */
+	ushort  nmarc;      /* NonMatching Address Rcvd Counter */
+	ushort  retrc;      /* Retransmitted Frame Counter */
+	ushort  mflr;       /* Max frame length */
+	ushort  max_cnt;    /* Maximum length counter (reserved) */
+	ushort  rfthr;      /* Receved Frame Threshold */
+	ushort  rfcnt;      /* Received Frames Count */
+	ushort  hmask;      /* Address Mask */
+	ushort  haddr1;     /* Address #1 */
+	ushort  haddr2;     /* Address #2 */
+	ushort  haddr3;     /* Address #3 */
+	ushort  haddr4;     /* Address #4 */
+	ushort  tmp1;       /* Temp storage (reserved) */
+	ushort  tmp_mb;     /* Temp storage (reserved) */
+} scc_hdlc_t;
+
+
 /* CPM Ethernet through SCC1.
  */
 typedef struct scc_enet {
diff -Nurp linux-2.6.9.orig/include/asm-ppc/irq.h linux-2.6.9/include/asm-ppc/irq.h
--- linux-2.6.9.orig/include/asm-ppc/irq.h	2004-10-18 23:53:21.000000000 +0200
+++ linux-2.6.9/include/asm-ppc/irq.h	2006-09-07 18:57:01.000000000 +0200
@@ -85,6 +85,10 @@ irq_canonicalize(int irq)
 
 #elif defined(CONFIG_8xx)
 
+/* Now include the board configuration specific associations.
+*/
+#include <asm/mpc8xx.h>
+
 /* The MPC8xx cores have 16 possible interrupts.  There are eight
  * possible level sensitive interrupts assigned and generated internally
  * from such devices as CPM, PCMCIA, RTC, PIT, TimeBase and Decrementer.
@@ -93,10 +97,22 @@ irq_canonicalize(int irq)
  *
  * On some implementations, there is also the possibility of an 8259
  * through the PCI and PCI-ISA bridges.
+ *
+ * We are "flattening" the interrupt vectors of the cascaded CPM
+ * and 8259 interrupt controllers so that we can uniquely identify
+ * any interrupt source with a single integer.
  */
 #define NR_SIU_INTS	16
+#define NR_CPM_INTS	32
+#ifndef NR_8259_INTS
+#define NR_8259_INTS 0
+#endif
 
-#define NR_IRQS	(NR_SIU_INTS + NR_8259_INTS)
+#define SIU_IRQ_OFFSET		0
+#define CPM_IRQ_OFFSET		(SIU_IRQ_OFFSET + NR_SIU_INTS)
+#define I8259_IRQ_OFFSET	(CPM_IRQ_OFFSET + NR_CPM_INTS)
+
+#define NR_IRQS	(NR_SIU_INTS + NR_CPM_INTS + NR_8259_INTS)
 
 /* These values must be zero-based and map 1:1 with the SIU configuration.
  * They are used throughout the 8xx I/O subsystem to generate
@@ -121,10 +137,6 @@ irq_canonicalize(int irq)
 #define	SIU_IRQ7	(14)
 #define	SIU_LEVEL7	(15)
 
-/* Now include the board configuration specific associations.
-*/
-#include <asm/mpc8xx.h>
-
 /* The internal interrupts we can configure as we see fit.
  * My personal preference is CPM at level 2, which puts it above the
  * MBX PCI/ISA/IDE interrupts.
@@ -248,7 +260,7 @@ static __inline__ int irq_canonicalize(i
  * (Document errata updates have fixed this...make sure you have up to
  * date processor documentation -- Dan).
  */
-#define NR_SIU_INTS	64
+#define NR_SIU_INTS	68
 
 #define	SIU_INT_ERROR		((uint)0x00)
 #define	SIU_INT_I2C		((uint)0x01)
@@ -299,6 +311,10 @@ static __inline__ int irq_canonicalize(i
 #define	SIU_INT_PC2		((uint)0x3d)
 #define	SIU_INT_PC1		((uint)0x3e)
 #define	SIU_INT_PC0		((uint)0x3f)
+#define	SIU_INT_PCIA		((uint)0x40)
+#define	SIU_INT_PCIB		((uint)0x41)
+#define	SIU_INT_PCIC		((uint)0x42)
+#define	SIU_INT_PCID		((uint)0x43)
 
 #endif /* CONFIG_8260 */
 
diff -Nurp linux-2.6.9.orig/include/asm-ppc/mpc8260.h linux-2.6.9/include/asm-ppc/mpc8260.h
--- linux-2.6.9.orig/include/asm-ppc/mpc8260.h	2004-10-18 23:53:06.000000000 +0200
+++ linux-2.6.9/include/asm-ppc/mpc8260.h	2006-09-07 18:57:01.000000000 +0200
@@ -12,6 +12,10 @@
 
 #ifdef CONFIG_8260
 
+#ifdef CONFIG_RGWYPQ2
+#include <platforms/rgwypq2.h>
+#endif
+
 #ifdef CONFIG_EST8260
 #include <platforms/est8260.h>
 #endif
diff -Nurp linux-2.6.9.orig/include/linux/autoconf.h linux-2.6.9/include/linux/autoconf.h
--- linux-2.6.9.orig/include/linux/autoconf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.9/include/linux/autoconf.h	2006-09-07 18:57:01.000000000 +0200
@@ -0,0 +1,587 @@
+/*
+ * Automatically generated C config: don't edit
+ * Linux kernel version: 2.6.9-elinos-149
+ * Wed Mar  8 11:57:11 2006
+ */
+#define AUTOCONF_INCLUDED
+#define CONFIG_MMU 1
+#define CONFIG_RWSEM_XCHGADD_ALGORITHM 1
+#define CONFIG_HAVE_DEC_LOCK 1
+#define CONFIG_PPC 1
+#define CONFIG_PPC32 1
+#define CONFIG_GENERIC_NVRAM 1
+
+/*
+ * Code maturity level options
+ */
+#define CONFIG_EXPERIMENTAL 1
+#define CONFIG_CLEAN_COMPILE 1
+#define CONFIG_BROKEN_ON_SMP 1
+
+/*
+ * General setup
+ */
+#define CONFIG_LOCALVERSION ""
+#define CONFIG_SWAP 1
+#undef CONFIG_SYSVIPC
+#undef CONFIG_POSIX_MQUEUE
+#undef CONFIG_BSD_PROCESS_ACCT
+#undef CONFIG_SYSCTL
+#undef CONFIG_AUDIT
+#define CONFIG_LOG_BUF_SHIFT 14
+#undef CONFIG_HOTPLUG
+#undef CONFIG_IKCONFIG
+#define CONFIG_EMBEDDED 1
+#define CONFIG_KALLSYMS 1
+#undef CONFIG_KALLSYMS_EXTRA_PASS
+#undef CONFIG_FUTEX
+#undef CONFIG_EPOLL
+#undef CONFIG_IOSCHED_NOOP
+#undef CONFIG_IOSCHED_AS
+#define CONFIG_IOSCHED_DEADLINE 1
+#undef CONFIG_IOSCHED_CFQ
+#undef CONFIG_CC_OPTIMIZE_FOR_SIZE
+#undef CONFIG_SHMEM
+#define CONFIG_ELINOS_CMDLINE "console=ttyS0,9600 devfs=mount rootfstype=tmpfs root=/dev/ram rw "
+#define CONFIG_EXTRACT_ROOTFS 1
+#define CONFIG_TINY_SHMEM 1
+
+/*
+ * Loadable module support
+ */
+#define CONFIG_MODULES 1
+#define CONFIG_MODULE_UNLOAD 1
+#undef CONFIG_MODULE_FORCE_UNLOAD
+#define CONFIG_OBSOLETE_MODPARM 1
+#undef CONFIG_MODVERSIONS
+#undef CONFIG_KMOD
+
+/*
+ * Processor
+ */
+#define CONFIG_6xx 1
+#undef CONFIG_40x
+#undef CONFIG_44x
+#undef CONFIG_POWER3
+#undef CONFIG_POWER4
+#undef CONFIG_8xx
+#undef CONFIG_E500
+#undef CONFIG_CPU_FREQ
+#define CONFIG_EMBEDDEDBOOT 1
+#define CONFIG_PPC_STD_MMU 1
+
+/*
+ * Platform options
+ */
+#undef CONFIG_PPC_MULTIPLATFORM
+#undef CONFIG_APUS
+#undef CONFIG_WILLOW
+#undef CONFIG_PCORE
+#undef CONFIG_POWERPMC250
+#undef CONFIG_EV64260
+#undef CONFIG_SPRUCE
+#undef CONFIG_LOPEC
+#undef CONFIG_MCPN765
+#undef CONFIG_MVME5100
+#undef CONFIG_PPLUS
+#undef CONFIG_PRPMC750
+#undef CONFIG_PRPMC800
+#undef CONFIG_SANDPOINT
+#undef CONFIG_ADIR
+#undef CONFIG_K2
+#undef CONFIG_PAL4
+#undef CONFIG_GEMINI
+#undef CONFIG_EST8260
+#define CONFIG_RGWYPQ2 1
+#undef CONFIG_SBC82xx
+#undef CONFIG_SBS8260
+#undef CONFIG_RPX8260
+#undef CONFIG_TQM8260
+#undef CONFIG_ADS8272
+#undef CONFIG_LITE5200
+#define CONFIG_8260 1
+#define CONFIG_CPM2 1
+#undef CONFIG_PC_KEYBOARD
+#undef CONFIG_SMP
+#undef CONFIG_PREEMPT
+#undef CONFIG_HIGHMEM
+#define CONFIG_BINFMT_ELF 1
+#undef CONFIG_BINFMT_MISC
+#undef CONFIG_PPCBOOT
+#define CONFIG_CMDLINE_BOOL 1
+#define CONFIG_CMDLINE "devfs=mount rootfstype=tmpfs root=/dev/ram rw "
+
+/*
+ * Bus options
+ */
+#define CONFIG_PCI 1
+#define CONFIG_PCI_DOMAINS 1
+#define CONFIG_PCI_8260 1
+#undef CONFIG_8260_PCI9
+#undef CONFIG_PCI_LEGACY_PROC
+#undef CONFIG_PCI_NAMES
+
+/*
+ * Advanced setup
+ */
+#undef CONFIG_ADVANCED_OPTIONS
+
+/*
+ * Default settings for advanced configuration options are used
+ */
+#define CONFIG_HIGHMEM_START 0xfe000000
+#define CONFIG_LOWMEM_SIZE 0x30000000
+#define CONFIG_KERNEL_START 0xc0000000
+#define CONFIG_TASK_SIZE 0x80000000
+#define CONFIG_BOOT_LOAD 0x00400000
+
+/*
+ * Device Drivers
+ */
+
+/*
+ * Generic Driver Options
+ */
+#define CONFIG_STANDALONE 1
+#define CONFIG_PREVENT_FIRMWARE_BUILD 1
+
+/*
+ * Memory Technology Devices (MTD)
+ */
+#undef CONFIG_MTD
+
+/*
+ * Parallel port support
+ */
+#undef CONFIG_PARPORT
+
+/*
+ * Plug and Play support
+ */
+
+/*
+ * Block devices
+ */
+#undef CONFIG_BLK_DEV_FD
+#undef CONFIG_BLK_CPQ_DA
+#undef CONFIG_BLK_CPQ_CISS_DA
+#undef CONFIG_BLK_DEV_DAC960
+#undef CONFIG_BLK_DEV_UMEM
+#define CONFIG_BLK_DEV_LOOP 1
+#undef CONFIG_BLK_DEV_CRYPTOLOOP
+#undef CONFIG_BLK_DEV_NBD
+#undef CONFIG_BLK_DEV_SX8
+#undef CONFIG_BLK_DEV_RAM
+#undef CONFIG_LBD
+
+/*
+ * ATA/ATAPI/MFM/RLL support
+ */
+#undef CONFIG_IDE
+
+/*
+ * SCSI device support
+ */
+#undef CONFIG_SCSI
+
+/*
+ * Multi-device support (RAID and LVM)
+ */
+#undef CONFIG_MD
+
+/*
+ * Fusion MPT device support
+ */
+
+/*
+ * IEEE 1394 (FireWire) support
+ */
+#undef CONFIG_IEEE1394
+
+/*
+ * I2O device support
+ */
+#undef CONFIG_I2O
+
+/*
+ * Macintosh device drivers
+ */
+
+/*
+ * Networking support
+ */
+#define CONFIG_NET 1
+
+/*
+ * Networking options
+ */
+#undef CONFIG_PACKET
+#undef CONFIG_NETLINK_DEV
+#define CONFIG_UNIX 1
+#undef CONFIG_NET_KEY
+#define CONFIG_INET 1
+#undef CONFIG_IP_MULTICAST
+#undef CONFIG_IP_ADVANCED_ROUTER
+#undef CONFIG_IP_PNP
+#undef CONFIG_NET_IPIP
+#undef CONFIG_NET_IPGRE
+#undef CONFIG_ARPD
+#undef CONFIG_SYN_COOKIES
+#undef CONFIG_INET_AH
+#undef CONFIG_INET_ESP
+#undef CONFIG_INET_IPCOMP
+#undef CONFIG_INET_TUNNEL
+#undef CONFIG_IPV6
+#undef CONFIG_NETFILTER
+
+/*
+ * SCTP Configuration (EXPERIMENTAL)
+ */
+#undef CONFIG_IP_SCTP
+#undef CONFIG_ATM
+#undef CONFIG_BRIDGE
+#undef CONFIG_VLAN_8021Q
+#undef CONFIG_DECNET
+#undef CONFIG_LLC2
+#undef CONFIG_IPX
+#undef CONFIG_ATALK
+#undef CONFIG_X25
+#undef CONFIG_LAPB
+#undef CONFIG_NET_DIVERT
+#undef CONFIG_ECONET
+#undef CONFIG_WAN_ROUTER
+#undef CONFIG_NET_HW_FLOWCONTROL
+
+/*
+ * QoS and/or fair queueing
+ */
+#undef CONFIG_NET_SCHED
+#undef CONFIG_NET_CLS_ROUTE
+
+/*
+ * Network testing
+ */
+#undef CONFIG_NET_PKTGEN
+#undef CONFIG_NETPOLL
+#undef CONFIG_NET_POLL_CONTROLLER
+#undef CONFIG_HAMRADIO
+#undef CONFIG_IRDA
+#undef CONFIG_BT
+#define CONFIG_NETDEVICES 1
+#undef CONFIG_DUMMY
+#undef CONFIG_BONDING
+#undef CONFIG_EQUALIZER
+#undef CONFIG_TUN
+
+/*
+ * ARCnet devices
+ */
+#undef CONFIG_ARCNET
+
+/*
+ * Ethernet (10 or 100Mbit)
+ */
+#define CONFIG_NET_ETHERNET 1
+#define CONFIG_MII 1
+#undef CONFIG_HAPPYMEAL
+#undef CONFIG_SUNGEM
+#undef CONFIG_NET_VENDOR_3COM
+
+/*
+ * Tulip family network device support
+ */
+#undef CONFIG_NET_TULIP
+#undef CONFIG_HP100
+#undef CONFIG_NET_PCI
+#undef CONFIG_USE_MDIO
+
+/*
+ * Ethernet (1000 Mbit)
+ */
+#undef CONFIG_ACENIC
+#undef CONFIG_DL2K
+#undef CONFIG_E1000
+#undef CONFIG_NS83820
+#undef CONFIG_HAMACHI
+#undef CONFIG_YELLOWFIN
+#undef CONFIG_R8169
+#undef CONFIG_SK98LIN
+#undef CONFIG_TIGON3
+
+/*
+ * Ethernet (10000 Mbit)
+ */
+#undef CONFIG_IXGB
+#undef CONFIG_S2IO
+
+/*
+ * Token Ring devices
+ */
+#undef CONFIG_TR
+
+/*
+ * Wireless LAN (non-hamradio)
+ */
+#undef CONFIG_NET_RADIO
+
+/*
+ * Wan interfaces
+ */
+#undef CONFIG_WAN
+#undef CONFIG_FDDI
+#undef CONFIG_HIPPI
+#undef CONFIG_PPP
+#undef CONFIG_SLIP
+#undef CONFIG_SHAPER
+#undef CONFIG_NETCONSOLE
+
+/*
+ * ISDN subsystem
+ */
+#undef CONFIG_ISDN
+
+/*
+ * Telephony Support
+ */
+#undef CONFIG_PHONE
+
+/*
+ * Input device support
+ */
+#undef CONFIG_INPUT
+
+/*
+ * Userland interfaces
+ */
+
+/*
+ * Input I/O drivers
+ */
+#undef CONFIG_GAMEPORT
+#define CONFIG_SOUND_GAMEPORT 1
+#undef CONFIG_SERIO
+#undef CONFIG_SERIO_I8042
+
+/*
+ * Input Device Drivers
+ */
+
+/*
+ * Character devices
+ */
+#undef CONFIG_VT
+#define CONFIG_DEF_KEYMAP "defkeymap"
+#undef CONFIG_SERIAL_NONSTANDARD
+
+/*
+ * Serial drivers
+ */
+#undef CONFIG_SERIAL_8250
+
+/*
+ * Non-8250 serial port support
+ */
+#define CONFIG_SERIAL_CORE 1
+#define CONFIG_SERIAL_CORE_CONSOLE 1
+#define CONFIG_SERIAL_CPM 1
+#define CONFIG_SERIAL_CPM_CONSOLE 1
+#undef CONFIG_SERIAL_CPM_SCC1
+#undef CONFIG_SERIAL_CPM_SCC2
+#undef CONFIG_SERIAL_CPM_SCC3
+#undef CONFIG_SERIAL_CPM_SCC4
+#undef CONFIG_SERIAL_CPM_SMC1
+#define CONFIG_SERIAL_CPM_SMC2 1
+#define CONFIG_UNIX98_PTYS 1
+#define CONFIG_LEGACY_PTYS 1
+#define CONFIG_LEGACY_PTY_COUNT 256
+
+/*
+ * IPMI
+ */
+#undef CONFIG_IPMI_HANDLER
+
+/*
+ * Watchdog Cards
+ */
+#undef CONFIG_WATCHDOG
+#undef CONFIG_NVRAM
+#undef CONFIG_GEN_RTC
+#undef CONFIG_DTLK
+#undef CONFIG_R3964
+#undef CONFIG_APPLICOM
+
+/*
+ * Ftape, the floppy tape device driver
+ */
+#undef CONFIG_AGP
+#undef CONFIG_DRM
+#undef CONFIG_RAW_DRIVER
+
+/*
+ * I2C support
+ */
+#undef CONFIG_I2C
+
+/*
+ * Dallas's 1-wire bus
+ */
+#undef CONFIG_W1
+
+/*
+ * Misc devices
+ */
+
+/*
+ * Multimedia devices
+ */
+#undef CONFIG_VIDEO_DEV
+
+/*
+ * Digital Video Broadcasting Devices
+ */
+#undef CONFIG_DVB
+
+/*
+ * Graphics support
+ */
+#undef CONFIG_FB
+
+/*
+ * Sound
+ */
+#undef CONFIG_SOUND
+
+/*
+ * USB support
+ */
+#undef CONFIG_USB
+
+/*
+ * USB Gadget Support
+ */
+#undef CONFIG_USB_GADGET
+
+/*
+ * File systems
+ */
+#undef CONFIG_EXT2_FS
+#undef CONFIG_EXT3_FS
+#undef CONFIG_JBD
+#undef CONFIG_REISERFS_FS
+#undef CONFIG_JFS_FS
+#undef CONFIG_XFS_FS
+#undef CONFIG_MINIX_FS
+#undef CONFIG_ROMFS_FS
+#undef CONFIG_QUOTA
+#undef CONFIG_AUTOFS_FS
+#undef CONFIG_AUTOFS4_FS
+
+/*
+ * CD-ROM/DVD Filesystems
+ */
+#undef CONFIG_ISO9660_FS
+#undef CONFIG_UDF_FS
+
+/*
+ * DOS/FAT/NT Filesystems
+ */
+#undef CONFIG_MSDOS_FS
+#undef CONFIG_VFAT_FS
+#undef CONFIG_NTFS_FS
+
+/*
+ * Pseudo filesystems
+ */
+#define CONFIG_PROC_FS 1
+#define CONFIG_PROC_KCORE 1
+#define CONFIG_SYSFS 1
+#define CONFIG_DEVFS_FS 1
+#define CONFIG_DEVFS_MOUNT 1
+#undef CONFIG_DEVFS_DEBUG
+#undef CONFIG_DEVPTS_FS_XATTR
+#define CONFIG_TMPFS 1
+#undef CONFIG_HUGETLB_PAGE
+#define CONFIG_RAMFS 1
+
+/*
+ * Miscellaneous filesystems
+ */
+#undef CONFIG_ADFS_FS
+#undef CONFIG_AFFS_FS
+#undef CONFIG_HFS_FS
+#undef CONFIG_HFSPLUS_FS
+#undef CONFIG_BEFS_FS
+#undef CONFIG_BFS_FS
+#undef CONFIG_EFS_FS
+#undef CONFIG_CRAMFS
+#undef CONFIG_VXFS_FS
+#undef CONFIG_HPFS_FS
+#undef CONFIG_QNX4FS_FS
+#undef CONFIG_SYSV_FS
+#undef CONFIG_UFS_FS
+
+/*
+ * Network File Systems
+ */
+#undef CONFIG_NFS_FS
+#undef CONFIG_NFSD
+#undef CONFIG_EXPORTFS
+#undef CONFIG_SMB_FS
+#undef CONFIG_CIFS
+#undef CONFIG_NCP_FS
+#undef CONFIG_CODA_FS
+#undef CONFIG_AFS_FS
+
+/*
+ * Partition Types
+ */
+#undef CONFIG_PARTITION_ADVANCED
+#define CONFIG_MSDOS_PARTITION 1
+
+/*
+ * Native Language Support
+ */
+#undef CONFIG_NLS
+#undef CONFIG_SCC_ENET
+#define CONFIG_FEC_ENET 1
+
+/*
+ * CPM2 Options
+ */
+#define CONFIG_FCC1_ENET 1
+#define CONFIG_FCC2_ENET 1
+#undef CONFIG_FCC3_ENET
+
+/*
+ * Library routines
+ */
+#undef CONFIG_CRC_CCITT
+#define CONFIG_CRC32 1
+#undef CONFIG_LIBCRC32C
+
+/*
+ * Profiling support
+ */
+#undef CONFIG_PROFILING
+
+/*
+ * Kernel Tracing
+ */
+#undef CONFIG_TRACE
+#undef CONFIG_LATENCY_PROFILE
+
+/*
+ * Kernel hacking
+ */
+#undef CONFIG_DEBUG_KERNEL
+#undef CONFIG_KGDB_CONSOLE
+
+/*
+ * Security options
+ */
+#undef CONFIG_SECURITY
+
+/*
+ * Cryptographic options
+ */
+#undef CONFIG_CRYPTO
diff -Nurp linux-2.6.9.orig/init/main.c linux-2.6.9/init/main.c
--- linux-2.6.9.orig/init/main.c	2004-10-18 23:53:23.000000000 +0200
+++ linux-2.6.9/init/main.c	2006-09-07 18:57:01.000000000 +0200
@@ -220,7 +220,8 @@ void __devinit calibrate_delay(void)
 	} else {
 		loops_per_jiffy = (1<<12);
 
-		printk(KERN_DEBUG "Calibrating delay loop... ");
+		/* printk(KERN_DEBUG "Calibrating delay loop... "); GEG */
+		printk("Calibrating delay loop... ");
 		while ((loops_per_jiffy <<= 1) != 0) {
 			/* wait for "start of" clock tick */
 			ticks = jiffies;
@@ -528,7 +529,7 @@ asmlinkage void __init start_kernel(void
 		panic(panic_later, panic_param);
 	profile_init();
 	local_irq_enable();
-#ifdef CONFIG_BLK_DEV_INITRD
+#if CONFIG_BLK_DEV_INITRD || CONFIG_EXTRACT_ROOTFS
 	if (initrd_start && !initrd_below_start_ok &&
 			initrd_start < min_low_pfn << PAGE_SHIFT) {
 		printk(KERN_CRIT "initrd overwritten (0x%08lx < 0x%08lx) - "
diff -Nurp linux-2.6.9.orig/net/ipv4/af_inet.c linux-2.6.9/net/ipv4/af_inet.c
--- linux-2.6.9.orig/net/ipv4/af_inet.c	2004-10-18 23:53:21.000000000 +0200
+++ linux-2.6.9/net/ipv4/af_inet.c	2006-09-07 18:57:01.000000000 +0200
@@ -1055,13 +1055,14 @@ static int __init inet_init(void)
   	 *	Set the IP module up
   	 */
 
-	ip_init();
 
 	tcp_v4_init(&inet_family_ops);
 
 	/* Setup TCP slab cache for open requests. */
 	tcp_init();
 
+	ip_init(); // GG
+
 
 	/*
 	 *	Set the ICMP layer up
diff -Nurp linux-2.6.9.orig/net/ipv4/ip_output.c linux-2.6.9/net/ipv4/ip_output.c
--- linux-2.6.9.orig/net/ipv4/ip_output.c	2004-10-18 23:55:29.000000000 +0200
+++ linux-2.6.9/net/ipv4/ip_output.c	2006-09-07 18:57:01.000000000 +0200
@@ -1339,11 +1339,13 @@ static struct packet_type ip_packet_type
 
 void __init ip_init(void)
 {
-	dev_add_pack(&ip_packet_type);
 
 	ip_rt_init();
 	inet_initpeers();
 
+	/* DOL */
+	dev_add_pack(&ip_packet_type);
+
 #if defined(CONFIG_IP_MULTICAST) && defined(CONFIG_PROC_FS)
 	igmp_mc_proc_init();
 #endif
