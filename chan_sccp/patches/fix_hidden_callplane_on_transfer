diff --git a/src/sccp_channel.c b/src/sccp_channel.c
index e42c017..778f5ab 100644
--- a/src/sccp_channel.c
+++ b/src/sccp_channel.c
@@ -1556,19 +1556,6 @@ void sccp_channel_endcall_locked(sccp_channel_t * c)
    }
    SCCP_LIST_UNLOCK(&c->line->channels);
 
-   /**
-   workaround to fix issue with 7960 and protocol version != 6
-   7960 loses callplane when cancel transfer (end call on other channel).
-   This script set the hold state for transfer_channel explicitly -MC
-   */
-   if (c->device && c->device->transfer_channel && c->device->transfer_channel != c) {
-       uint8_t instance = sccp_device_find_index_for_line(c->device, c->device->transfer_channel->line->name);
-       sccp_dev_set_lamp(c->device, SKINNY_STIMULUS_LINE, instance, SKINNY_LAMP_WINK);
-       sccp_device_sendcallstate(c->device, instance, c->device->transfer_channel->callid, SKINNY_CALLSTATE_HOLD, SKINNY_CALLPRIORITY_LOW, SKINNY_CALLINFO_VISIBILITY_DEFAULT);
-       sccp_dev_set_keyset(c->device, instance, c->device->transfer_channel->callid, KEYMODE_ONHOLD);
-       c->device->transfer_channel = NULL;
-   }
-
    if (c->owner) {
        /* Is there a blocker ? */
        res = (c->owner->pbx || ast_test_flag(c->owner, AST_FLAG_BLOCKING));
diff --git a/src/sccp_indicate.c b/src/sccp_indicate.c
index c69cea2..b51ab21 100644
--- a/src/sccp_indicate.c
+++ b/src/sccp_indicate.c
@@ -146,6 +146,19 @@ void __sccp_indicate_locked(sccp_device_t * device, sccp_channel_t * c, uint8_t
        /* for earlyrtp take a look at sccp_channel_newcall because we have no c->owner here */
        break;
    case SCCP_CHANNELSTATE_ONHOOK:
+       /**
+       workaround to fix issue with 7960 and protocol version != 6
+       7960 loses callplane when cancel transfer (end call on other channel).
+       This script set the hold state for transfer_channel explicitly -MC
+       */
+       if (d->transfer_channel && d->transfer_channel != c) {
+           uint8_t xfer_instance = sccp_device_find_index_for_line(d, d->transfer_channel->line->name);
+           sccp_dev_set_lamp(d, SKINNY_STIMULUS_LINE, xfer_instance, SKINNY_LAMP_WINK);
+           sccp_device_sendcallstate(d, xfer_instance, d->transfer_channel->callid, SKINNY_CALLSTATE_HOLD, SKINNY_CALLPRIORITY_LOW, SKINNY_CALLINFO_VISIBILITY_DEFAULT);
+           sccp_dev_set_keyset(d, xfer_instance, d->transfer_channel->callid, KEYMODE_ONHOLD);
+           c->device->transfer_channel = NULL;
+       }
+
        c->state = SCCP_CHANNELSTATE_DOWN;
        sccp_ast_setstate(c, AST_STATE_DOWN);
        if (c == d->active_channel)
