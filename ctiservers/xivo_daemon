#!/usr/bin/python

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Alternatively, XIVO Daemon is available under other licenses directly
# contracted with Pro-formatique SARL. See the LICENSE file at top of the
# source tree or delivered in the installable package in which XIVO Daemon
# is distributed for more details.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, you will find one at
# <http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>.

__version__   = '$Revision$'
__date__      = '$Date$'
__copyright__ = 'Copyright (C) 2007, 2008, Proformatique'
__author__    = 'Corentin Le Gall'

"""
# 1) General description of XIVO CTI Daemon
# The XIVO CTI Daemon is a general-purpose daemon, whose basic features are :
#  - the monitoring of one or more Asterisk, through AMI
#  - taking care of Asteriks AGI requests
#  - the ability to receive incoming "CTI clients" connections
#  - the ability to relay commands (between a Web interface and Asterisk)
#  - the connection to one or more databases (cdr, directory, ...)
#  - the connection to a given server
# 
# 2) Primary data structures
# 
#  - users list
#  - contexts/companies list
# 
#  - asterisk / configurations
#  - phonelist
#
# 3) Main loop
# The main loop is triggered by a select() on the file descriptors for :
# - the AMI Event sockets (AMIsocks)
# - the incoming TCP sockets (CTI, WEBI, INFO, (F)AGI)
#
# 4) Custom-defined Plugins
#
"""

__revision__ = __version__.split()[1]

# debian.org modules
import getopt
import os
import select
import signal
import socket
import string
import sys
import threading
import time
import logging
from logging.handlers import SysLogHandler

__alphanums__ = string.uppercase + string.lowercase + string.digits
waiting_actionid = {}

try:
        DAEMONNAME = os.path.basename(sys.argv[0])
except:
        DAEMONNAME = 'xivo_daemon'

# XIVO lib-python modules initialization
XIVOCONFFILE            = '/etc/asterisk/%s.conf' % DAEMONNAME
GETOPT_SHORTOPTS        = 'dc:'
GETOPT_LONGOPTS         = ["debug", "config="]
debug_mode = False
def config_path():
        global XIVOCONFFILE, debug_mode
        for opt, arg in getopt.getopt(
                sys.argv[1:],
                GETOPT_SHORTOPTS,
                GETOPT_LONGOPTS
                )[0]:
                if opt == "-c":
                        XIVOCONFFILE = arg
                elif opt == "-d":
                        debug_mode = True
config_path()

# XIVO lib-python modules imports
from xivo import agitb
from xivo import anysql
from xivo.BackSQL import backmysql
from xivo.BackSQL import backsqlite

# XIVO CTI modules
from xivo_agid import fastagi
from xivo_ctiservers import xivo_ami
from xivo_ctiservers import xivo_contexts
from xivo_ctiservers import xivo_astcfg
from xivo_ctiservers import cti_config
from xivo_ctiservers import xivo_commandsets
from xivo_ctiservers.CommandSets import *
from xivo_ctiservers.xivo_commandsets import ctidaemonize as daemonize

PIDFILE = '/var/run/%s.pid' % DAEMONNAME
# TODO: command line parameter

BUFSIZE_LARGE = 8192
BUFSIZE_ANY = 512

socket.setdefaulttimeout(2)
XIVO_CLI_WEBI_HEADER = 'XIVO-CLI-WEBI'
XIVOVERSION = '0.4'

## \brief Deals with requests from the UI clients.
# \param connid connection identifier
# \param msg message to process
# \param sep separator to split the message
# \return none
def manage_cti_connections(connid, msg, sep):
        """
        Handles CTI connections.
        """
        requester = '%s:%d' % connid.getpeername()
        if requester in commandclass.transfers_ref:
                commandclass.transfer_addbuf(requester, msg)
                return

        multimsg = msg.split(sep)
        for usefulmsgpart in multimsg:
                usefulmsg = usefulmsgpart.split('\r')[0]
                if len(usefulmsg) == 0:
                        break
                command = commandclass.parsecommand(usefulmsg)
                if command.name in commandclass.get_list_commands():
                        try:
                                if command.type in [xivo_commandsets.CMD_LOGIN_ID,
                                                    xivo_commandsets.CMD_LOGIN_PASS,
                                                    xivo_commandsets.CMD_LOGIN_CAPAS]:
                                        # log.info('LOGIN(%s) %s : args   %s' % (command.type, requester, command.args))
                                        loginparams = commandclass.get_login_params(command, asterisklist[0], connid)
                                        # log.info('LOGIN(%s) %s : params %s' % (command.type, requester, loginparams))
                                        uinfo = commandclass.manage_login(loginparams, command.type, userinfo_current.get(connid))
                                        # log.info('LOGIN(%s) %s : uinfo  %s' % (command.type, requester, uinfo))
                                        
                                        if uinfo.__class__.__name__ == 'str':
                                                commandclass.loginko(loginparams, uinfo, connid)
                                                fdlist_full.remove(connid)
                                                del fdlist_established[connid]
                                                connid.close()
                                        else:
                                                if command.type == xivo_commandsets.CMD_LOGIN_CAPAS:
                                                        uinfo['login']['connection'] = connid
                                                        userinfo_by_requester[connid] = uinfo
                                                        if connid in userinfo_current:
                                                                del userinfo_current[connid]
                                                else:
                                                        userinfo_current[connid] = uinfo
                                                commandclass.loginok(loginparams, uinfo, connid, command.type)
                                elif command.type == xivo_commandsets.CMD_TRANSFER:
                                        log.info('TRANSFER on %s : %s' % (requester, command.struct))
                                        commandclass.transfer_addref(connid, command.struct)
                                else:
                                        if connid in userinfo_by_requester:
                                                commandclass.manage_cticommand(userinfo_by_requester[connid],
                                                                               command)
                                        else:
                                                log.warning('unlogged %s is attempting a %s (TCP) : %s'
                                                            % (requester, command.name, command.args))
                        except Exception:
                                log.exception('--- exception --- CTI connection when managing [%s] for %s'
                                              % (command.name, requester))
                else:
                        connid.sendall('Unknown Command <%s>\n' % command.name)


## \brief Deals with requests from the UI clients.
# \param connid connection identifier
# \return none
def manage_webi_connections(connid, msg, sep):
        """
        Handles WEBI connections.
        """
        global askedtoquit
        requester = '%s:%d' % connid.getpeername()
        requester_ip = connid.getpeername()[0]
        closemenow = True
        
        if requester_ip not in ip_reverse_webi:
                connid.sendall('%s:KO <NOT ALLOWED>\n' % XIVO_CLI_WEBI_HEADER)
                return closemenow
        astid = ip_reverse_webi[requester_ip]
        
        multimsg = msg.split(sep)
        for usefulmsgpart in multimsg:
                usefulmsg = usefulmsgpart.split('\r')[0]
                if len(usefulmsg) == 0:
                        break
                try:
                        if usefulmsg in ['xivo[userlist,update]',
                                         'xivo[agentlist,update]',
                                         'xivo[queuelist,update]',
                                         'xivo[grouplist,update]']:
                                update_userlist[astid] = True
                                log.info('%s : WEBI requested %s (%s)' % (astid, usefulmsg, requester))
                        elif usefulmsg == 'xivo[daemon,reload]':
                                askedtoquit = True
                                log.info('%s : WEBI requested %s (%s)' % (astid, usefulmsg, requester))
                        elif usefulmsg == 'xivo[ctiprofilelist,get]':
                                log.info('%s : WEBI requested %s (%s)' % (astid, usefulmsg, requester))
                                connid.sendall('%s:ID <%s>\n' % (XIVO_CLI_WEBI_HEADER, astid))
                                connid.sendall('%s\n' % commandclass.getprofilelist())
                                connid.sendall('%s:OK\n' % XIVO_CLI_WEBI_HEADER)
                        elif astid in amilist.ami and amilist.ami[astid]:
                                stripped_usefulmsg = usefulmsg.strip()
                                try:
                                        if stripped_usefulmsg == 'moh reload':
                                                commandclass.pre_moh_reload()
                                        elif stripped_usefulmsg == 'reload':
                                                commandclass.pre_reload()
                                except Exception:
                                        log.exception('--- exception --- (pre reloads (%s))' % stripped_usefulmsg)
                                        
                                closemenow = False
                                try:
                                        actionid = amilist.execute(astid, 'sendcommand', 'Command', [('Command', stripped_usefulmsg)])
                                        log.info('%s : WEBI requested a <%s> with actionid %s (%s)' % (astid, stripped_usefulmsg,
                                                                                                       actionid, connid))
                                        waiting_actionid[actionid] = connid
                                except Exception, exc:
                                        log.error('--- exception --- (%s) WEBI command exec <%s> : (client %s) : %s'
                                                  % (astid, stripped_usefulmsg, requester, exc))
                except Exception, exc:
                        log.error('--- exception --- (%s) WEBI <%s> : (client %s) : %s'
                                  % (astid, usefulmsg.strip(), requester, exc))
                        connid.sendall('%s:KO <Exception : %s>\n' % (XIVO_CLI_WEBI_HEADER, exc))
        return closemenow


## \brief Deals with requests from the UI clients.
# \param connid connection identifier
# \return none
def manage_info_connections(connid, msg, sep):
        """
        Handles INFO connections (basic administration console,
        primarily aimed at displaying informations first).
        """
        requester = '%s:%d' % connid.getpeername()
        multimsg = msg.replace('\r', '').split(sep)
        for usefulmsg in multimsg:
                if len(usefulmsg) == 0:
                        break
                try:
                        if usefulmsg == 'show_infos':
                                time_uptime = int(time.time() - time_start)
                                reply = 'infos=' \
                                        'xivo_version=%s;' \
                                        'server_version=%s;' \
                                        'commandset=%s;' \
                                        'commandset_version=%s;' \
                                        'uptime=%d s' \
                                        % (XIVOVERSION, __revision__,
                                           commandclass.xdname,
                                           commandclass.version(),
                                           time_uptime)
                                connid.sendall(reply + '\n')
                                # connid.sendall('server capabilities = %s\n' % (','.join()))
                        elif usefulmsg == 'show_users':
                                for user, info in commandclass.users().iteritems():
                                        try:
                                                connid.sendall('%s %s\n' % (user.encode('latin1'), info))
                                        except Exception:
                                                log.exception('--- exception --- INFO %s' % usefulmsg)
                        elif usefulmsg == 'show_agents':
                                for astid, agents in commandclass.agents().iteritems():
                                        try:
                                                connid.sendall('agents for %s\n' % astid)
                                                for ag, agp in agents.keeplist.iteritems():
                                                        connid.sendall('%s %s\n' % (ag, agp))
                                        except Exception:
                                                log.exception('--- exception --- INFO %s' % usefulmsg)
                        elif usefulmsg == 'show_queues':
                                for astid, queues in commandclass.queues().iteritems():
                                        try:
                                                connid.sendall('queues for %s\n' % astid)
                                                for ag, agp in queues.keeplist.iteritems():
                                                        connid.sendall('%s %s\n' % (ag, agp))
                                        except Exception:
                                                log.exception('--- exception --- INFO %s' % usefulmsg)
                        elif usefulmsg == 'show_meetme':
                                for astid, meetme in commandclass.meetme().iteritems():
                                        try:
                                                connid.sendall('meetme for %s\n' % astid)
                                                for ag, agp in meetme.keeplist.iteritems():
                                                        connid.sendall('%s %s\n' % (ag, agp))
                                        except Exception:
                                                log.exception('--- exception --- INFO %s' % usefulmsg)
                        elif usefulmsg == 'show_phones':
                                for astid, phones in commandclass.phones().iteritems():
                                        try:
                                                connid.sendall('phones for %s\n' % astid)
                                                for ag, agp in phones.keeplist.iteritems():
                                                        connid.sendall('%s %s\n' % (ag, agp))
                                        except Exception:
                                                log.exception('--- exception --- INFO %s' % usefulmsg)
                        elif usefulmsg == 'show_uniqueids':
                                for astid, uids in commandclass.uniqueids.iteritems():
                                        try:
                                                connid.sendall('uniqueids for %s\n' % astid)
                                                for ag, agp in uids.iteritems():
                                                        connid.sendall('%s %s\n' % (ag, agp))
                                        except Exception:
                                                log.exception('--- exception --- INFO %s' % usefulmsg)
                        elif usefulmsg == 'show_logged_ip':
                                for user, info in commandclass.connected_users().iteritems():
                                        if 'connection' in info['login']:
                                                try:
                                                        [ipaddr, ipport] = info['login']['connection'].getpeername()
                                                except Exception:
                                                        log.exception('--- exception --- INFO %s' % usefulmsg)
                                                        [ipaddr, ipport] = ['err_addr', 'err_port']
                                                connid.sendall('user %s : ip:port = %s:%s\n' % (user.encode('latin1'), ipaddr, ipport))
                        elif usefulmsg == 'show_logged':
                                for user, info in commandclass.connected_users().iteritems():
                                        try:
                                                connid.sendall('%s %s\n' % (user.encode('latin1'), info))
                                        except Exception:
                                                log.exception('--- exception --- INFO %s' % usefulmsg)
                        elif usefulmsg == 'show_ami':
                                for astid, ami in amilist.ami.iteritems():
                                        connid.sendall('commands : %s : %s\n' % (astid, ami))
                        elif usefulmsg.startswith('%s:' % commandset):
                                commandclass.cliaction(connid, usefulmsg)
                        else:
                                pass
                        connid.sendall('XIVO-INFO:OK\n')
                except Exception:
                        log.exception('--- exception --- INFO connection [%s] : KO when sending to %s'
                                      % (usefulmsg, requester))

def manage_tcp_connections(sel_i, msg, kind):
        """
        Dispatches the message's handling according to the connection's kind.
        """
        closemenow = True
        if kind == 'CTI':
                manage_cti_connections(sel_i, msg, commandclass.separator)
        elif kind == 'WEBI':
                closemenow = manage_webi_connections(sel_i, msg, '\n')
        elif kind == 'INFO':
                manage_info_connections(sel_i, msg, '\n')
        elif kind == 'AGI':
                agireply = commandclass.handle_agi(asterisklist[0], msg)
                if agireply is not None:
                        sel_i.sendall(agireply)
        else:
                log.warning('unknown connection kind %s' % kind)
        return closemenow


"""
Management of events that are spied on the AMI
"""
## \brief Handling of AMI events occuring in Events=on mode.
# \param astid the asterisk Id
# \param idata the data read from the AMI we want to parse
# \return none
def handle_ami_event(astid, idata):
        """
        Handles the AMI events occuring on Asterisk.
        If the Event field is there, calls the handle_ami_function() function.
        """
        global save_for_next_packet_events
        if astid not in configs:
                log.info('%s : no such asterisk Id' % astid)
                return

        full_idata = save_for_next_packet_events[astid] + idata
        evlist = full_idata.split('\r\n\r\n')
        save_for_next_packet_events[astid] = evlist.pop()
        
        for evt in evlist:
                this_event = {}
                nocolon = []
                for myline in evt.split('\r\n'):
                        myfieldvalue = myline.split(': ', 1)
                        if len(myfieldvalue) == 2:
                                this_event[myfieldvalue[0]] = myfieldvalue[1]
                        else:
                                nocolon.append(myline)
                evfunction = this_event.get('Event')
                # log.info('AMI(all)  %s  : %s' % (evfunction, this_event))
                if evfunction is not None:
                        handle_ami_function(astid, evfunction, this_event)
                        if evfunction not in ['Newexten', 'Newchannel', 'Newstate', 'Newcallerid']:
                                pass
                                # verboselog('%s %s' % (astid, this_event), True, False)
                else:
                        response = this_event.get('Response')
                        if response is not None:
                                if response == 'Follows' and this_event.get('Privilege') == 'Command':
                                        if 'ActionID' in this_event:
                                                actionid = this_event.get('ActionID')
                                                connreply = waiting_actionid.get(actionid)
                                                try:
                                                        if connreply is not None:
                                                                connreply.sendall('%s:ID <%s>\n' % (XIVO_CLI_WEBI_HEADER, astid))
                                                        for noc in nocolon:
                                                                arggs = noc.split('\n')
                                                                for toremove in ['', '--END COMMAND--']:
                                                                        while toremove in arggs:
                                                                                arggs.remove(toremove)
                                                                if arggs:
                                                                        log.info('AMI Response %s : %s : %s' % (astid, actionid, arggs))
                                                                        if connreply is not None:
                                                                                for argg in arggs:
                                                                                        connreply.sendall(argg + '\n')
                                                        if connreply is not None:
                                                                connreply.sendall('%s:OK\n' % XIVO_CLI_WEBI_HEADER)
                                                                fdlist_full.remove(connreply)
                                                                del fdlist_established[connreply]
                                                                log.info('TCP socket closed on %s (%s)' % ('%s:%d' % connreply.getpeername(), 'WEBI'))
                                                                connreply.close()
                                                                del waiting_actionid[actionid]
                                                except Exception:
                                                        log.exception('--- exception --- %s (command reply to %s, %s)' % (astid, connreply, actionid))
                                elif response == 'Success':
                                        try:
                                                commandclass.amiresponse_success(astid, this_event)
                                        except Exception:
                                                log.exception('--- exception --- %s amiresponse_success (%s)' % (astid, this_event))
                                elif response == 'Error':
                                        try:
                                                commandclass.amiresponse_error(astid, this_event)
                                        except Exception:
                                                log.exception('--- exception --- %s amiresponse_error (%s)' % (astid, this_event))
                                else:
                                        log.warning('AMI %s Response=%s (untracked) : %s' % (astid, response, this_event))
                        elif len(this_event) > 0:
                                log.warning('AMI:XXX: <%s> : %s' % (astid, this_event))
                        else:
                                log.warning('AMI %s Other : %s' % (astid, this_event))


evfunction_to_method_name = {
        'Registry':             'ami_registry',
        'Dial':                 'ami_dial',
        'Link':                 'ami_link',
        'Unlink':               'ami_unlink',
        'Hangup':               'ami_hangup',
        'Join':                 'ami_join',
        'Leave':                'ami_leave',
        'DTMF':                 'ami_dtmf',
        'PeerStatus':           'ami_peerstatus',
        'Agentlogin':           'ami_agentlogin',
        'Agentlogoff':          'ami_agentlogoff',
        'Agentcallbacklogin':   'ami_agentcallbacklogin',
        'Agentcallbacklogoff':  'ami_agentcallbacklogoff',
        'AgentCalled':          'ami_agentcalled',
        'AgentComplete':        'ami_agentcomplete',
        'AgentsComplete':       'ami_agentscomplete',
        'AgentConnect':         'ami_agentconnect',
        'AgentDump':            'ami_agentdump',
        'Agents':               'ami_agents',
        'ChannelReload':        'ami_channelreload',            # (1.4)
        'ParkedCall':           'ami_parkedcall',               # when the requested parking is acked
        'UnParkedCall':         'ami_unparkedcall',
        'ParkedCallTimeOut':    'ami_parkedcalltimeout',
        'ParkedCallGiveUp':     'ami_parkedcallgiveup',
        'ParkedCallsComplete':  'ami_parkedcallscomplete',
        'Cdr':                  'ami_cdr',
        'Hold':                 'ami_hold',
        'Unhold':               'ami_unhold',
        'Alarm':                'ami_alarm',
        'AlarmClear':           'ami_alarmclear',
        'FaxSent':              'ami_faxsent',
        'FaxReceived':          'ami_faxreceived',
        'MeetmeJoin':           'ami_meetmejoin',               # when a member joins a conference
        'MeetmeLeave':          'ami_meetmeleave',              # when a member leaves a conference
        'MeetmeMute':           'ami_meetmemute',               # when a member is (un)muted
        'MeetmeTalking':        'ami_meetmetalking',
        'MeetmeList':           'ami_meetmelist',
        'MeetmeListComplete':   'ami_meetmelistcomplete',
        'Transfer':             'ami_transfer',
        'ExtensionStatus':      'ami_extensionstatus',
        'OriginateSuccess':     'ami_originatesuccess',
        'AOriginateSuccess':    'ami_aoriginatesuccess',
        'OriginateFailure':     'ami_originatefailure',
        'AOriginateFailure':    'ami_aoriginatefailure',
        'OriginateResponse':    'ami_originateresponse',
        'Rename':               'ami_rename',                   # appears when there is a transfer
        'Newstate':             'ami_newstate',
        'Newcallerid':          'ami_newcallerid',              # useful for tricky managements
        'Newchannel':           'ami_newchannel',
        'Newexten':             'ami_newexten',                 # in order to handle outgoing calls ?
        'MessageWaiting':       'ami_messagewaiting',
        'QueueParams':          'ami_queueparams',
        'QueueMemberAdded':     'ami_queuememberadded',
        'QueueMemberPaused':    'ami_queuememberpaused',
        'QueueMemberRemoved':   'ami_queuememberremoved',
        'QueueMember':          'ami_queuemember',
        'QueueMemberStatus':    'ami_queuememberstatus',
        'QueueStatusComplete':  'ami_queuestatuscomplete',
        'QueueEntry':           'ami_queueentry',
        'QueueCallerAbandon':   'ami_queuecallerabandon',       # (1.4)
        'Status':               'ami_status',
        'StatusComplete':       'ami_statuscomplete',
}


def handle_ami_function(astid, evfunction, this_event):
        """
        Handles the AMI events related to a given function (i.e. containing the Event field).
        It roughly only dispatches them to the relevant commandset's methods.
        """
        try:
                if evfunction == 'Reload':
                        log.warning('AMI:Reload: %s : %s' % (astid, this_event))
                        commandclass.ami_reload(astid, this_event)
                elif evfunction == 'Shutdown':
                        shutdown = this_event.get('Shutdown')
                        restart  = this_event.get('Restart')
                        log.warning('AMI:Shutdown: %s (how=%s restart=%s)' % (astid, shutdown, restart))
                        commandclass.ami_shutdown(astid, this_event)
                elif evfunction.startswith('UserEvent'):
                        commandclass.ami_userevent(astid, this_event)
                elif (evfunction in evfunction_to_method_name):
                        getattr(commandclass, evfunction_to_method_name[evfunction])(astid, this_event)
                else:
                        log.warning('AMI %s ... this event (%s) is not tracked' % (astid, evfunction))
        except Exception:
                log.exception('--- exception --- AMI %s / %s : event %s' % (astid, evfunction, this_event))


def update_readconf():
        log.info('reparsing config file(s)')
        lconf = cti_config.Config(XIVOCONFFILE)

        commandclass.set_cticonfig(lconf)
        commandclass.set_options(cconf.read_section('commandset', commandset), cconf)
        return


def update_amisocks(astid):
        """
        Connects to the Asterisk's AMI (defined by astid) if not yet done.
        Requests a Status when it (re)connects.
        """
        try:
                amilist.setconfig(astid,
                                  (configs[astid].remoteaddr,
                                   configs[astid].ami_port),
                                  configs[astid].ami_login,
                                  configs[astid].ami_pass)
                amilist.connect(astid)
                amilist.set_aoriginate(astid, configs[astid].aoriginate)
                for fd in amilist.fdlist():
                        if fd not in fdlist_full:
                                fdlist_full.append(fd)
        except Exception:
                log.exception('--- exception --- %s (update_amisocks)' % astid)


## \brief Handler for catching signals (in the main thread)
# \param signum signal number
# \param frame frame
# \return none
def sighandler(signum, frame):
        global askedtoquit
        print
        print '--- signal %s (atq = %s) received : quits' % (signum, askedtoquit)
        for t in filter(lambda x: x.getName() != 'MainThread', threading.enumerate()):
                print '--- living thread <%s>' % (t.getName())
                t._Thread__stop()
        askedtoquit = True


## \brief Handler for catching signals (in the main thread)
# \param signum signal number
# \param frame frame
# \return none
def sighandler_reload(signum, frame):
        global askedtoquit
        print
        print '--- signal %s (atq = %s) received : reloads' % (signum, askedtoquit)
        askedtoquit = False

# ==============================================================================
# Main Code starts here
# ==============================================================================

logging.basicConfig(level=logging.INFO)
sysloghandler = SysLogHandler("/dev/log", SysLogHandler.LOG_DAEMON)
sysloghandler.setFormatter(logging.Formatter("%s[%%(process)d] (%%(name)s): %%(message)s" % DAEMONNAME))
logging.getLogger('').addHandler(sysloghandler)
log = logging.getLogger('main')

if not debug_mode:
        daemonize.daemonize()

daemonize.lock_pidfile_or_die(PIDFILE)

signal.signal(signal.SIGINT, sighandler)
signal.signal(signal.SIGTERM, sighandler)
signal.signal(signal.SIGHUP, sighandler_reload)

nreload = 0
directorylist = xivo_contexts.Contexts()
configs = {}
xdname = None

while True: # loops over the reloads
        askedtoquit = False

        time_start = time.time()
        if nreload == 0:
                log.info('# STARTING XIVO Daemon %s (pid %d) / svn:%s # (0/3) Starting'
                          % (XIVOVERSION, os.getpid(), __revision__))
        else:
                log.info('# STARTING XIVO Daemon %s (pid %d) / svn:%s # (0/3) Reloading (%d)'
                          % (XIVOVERSION, os.getpid(), __revision__, nreload))
        nreload += 1
        
        # global default definitions
        commandset = 'xivocti'
        incoming_tcp_ports = []
        extraconn = ''
        updates_period = 60
        asterisklist = []
        contextlist = []
        userlists = []
        ctilog = None
        
        userinfo_by_requester = {}
        userinfo_current = {}

        cconf = cti_config.Config(XIVOCONFFILE)
        xivoconf_general = cconf.read_section('general', 'general')

        # loads the general configuration
        if 'commandset' in xivoconf_general:
                commandset = xivoconf_general['commandset']
        if 'incoming_tcp_ports' in xivoconf_general:
                incoming_tcp_ports = xivoconf_general['incoming_tcp_ports'].split(',')
        for func in ['CTI', 'WEBI', 'FAGI', 'INFO']:
                fieldname = 'incoming_tcp_%s' % func.lower()
                if fieldname in xivoconf_general:
                        bind_and_port = xivoconf_general[fieldname].split(':')
                        if len(bind_and_port) > 1:
                                try:
                                        incoming_tcp_ports.append('%d:%s:%s' % (int(bind_and_port[1]), func, bind_and_port[0]))
                                except Exception:
                                        log.exception('--- exception --- %s definition' % fieldname)
        if 'extraconn' in xivoconf_general:
                extraconn = xivoconf_general['extraconn']
        if 'updates_period' in xivoconf_general:
                updates_period = int(xivoconf_general['updates_period'])
        if 'asterisklist' in xivoconf_general:
                asterisklist = xivoconf_general['asterisklist'].split(',')
        if 'contextlist' in xivoconf_general:
                contextlist = xivoconf_general['contextlist'].split(',')
        if 'userlists' in xivoconf_general:
                userlists = xivoconf_general['userlists'].split(',')
        if 'ctilog' in xivoconf_general:
                ctilog = xivoconf_general['ctilog']
        
        queued_threads_pipe = os.pipe()
        amilist = xivo_ami.AMIList()
        if commandset in xivo_commandsets.CommandClasses:
                commandclass = xivo_commandsets.CommandClasses[commandset](amilist,
                                                                           incoming_tcp_ports,
                                                                           queued_threads_pipe)
                xdname = commandclass.xdname
        else:
                commandclass = xivo_commandsets.BaseCommand()
                xdname = commandclass.xdname
                log.warning('# STARTING %s : no such commandset <%s>' % (xdname, commandset))
                
        log.info('# STARTING %s / svn:%s / %d' % (xdname, commandclass.version(), nreload))
        
        update_readconf()
        commandclass.set_userlist_urls(userlists)
        commandclass.set_contextlist(directorylist)
        commandclass.set_configs(configs)
        commandclass.set_ctilog(ctilog)
        
        for ctx in contextlist:
                xivoconf_context = cconf.read_section('context', ctx)
                if len(xivoconf_context) > 0:
                        if 'contextname' in xivoconf_context:
                                contextname = xivoconf_context['contextname']
                        if 'display' in xivoconf_context:
                                displaysection = xivoconf_context['display']
                                directorylist.setdisplay(contextname, cconf.read_section('displayitem', displaysection))
                        if 'directories' in xivoconf_context:
                                directories = xivoconf_context['directories'].split(',')
                                for dr in directories:
                                        xivoconf_dir = cconf.read_section('directory', dr)
                                        directorylist.update(contextname, dr, xivoconf_dir)

        save_for_next_packet_events = {}
        ip_reverse_webi = {}
        ip_reverse_sht = {}

        # loads the configuration for each asterisk
        for astid in asterisklist:
                xivoconf_asterisk = cconf.read_section('ipbx', astid)
                if len(xivoconf_asterisk) > 0:
                        localaddr = '127.0.0.1'
                        urllist = {}
                        ipaddress = '127.0.0.1'
                        ipaddress_webi = '127.0.0.1'
                        ami_port = 5038
                        ami_login = 'xivouser'
                        ami_pass = 'xivouser'
                        cdr_db_uri = userfeatures_db_uri = None
                        realm = 'asterisk'
                        parkingnumber = '700'
                        faxcallerid = 'faxcallerid'
                        linkestablished = ''
                        aoriginate = 'AOriginate'
                        url_queuelog = None
                        
                        if 'localaddr' in xivoconf_asterisk:
                                localaddr = xivoconf_asterisk['localaddr']
                        for listname in ['phones', 'queues', 'vqueues', 'agents', 'meetme', 'voicemail']:
                                fieldname = 'urllist_%s' % listname
                                if fieldname in xivoconf_asterisk:
                                        urllist[listname] = xivoconf_asterisk[fieldname].split(',')
                                else:
                                        urllist[listname] = []
                        if 'url_queuelog' in xivoconf_asterisk:
                                url_queuelog = xivoconf_asterisk['url_queuelog']
                        if 'ipaddress' in xivoconf_asterisk:
                                ipaddress = xivoconf_asterisk['ipaddress']
                        if 'ipaddress_webi' in xivoconf_asterisk:
                                ipaddress_webi = xivoconf_asterisk['ipaddress_webi']
                        if 'parkingnumber' in xivoconf_asterisk:
                                parkingnumber = int(xivoconf_asterisk['parkingnumber'])
                        if 'faxcallerid' in xivoconf_asterisk:
                                faxcallerid = int(xivoconf_asterisk['faxcallerid'])
                        if 'linkestablished' in xivoconf_asterisk:
                                linkestablished = xivoconf_asterisk['linkestablished']
                        if 'ami_port' in xivoconf_asterisk:
                                ami_port = int(xivoconf_asterisk['ami_port'])
                        if 'ami_login' in xivoconf_asterisk:
                                ami_login = xivoconf_asterisk['ami_login']
                        if 'ami_pass' in xivoconf_asterisk:
                                ami_pass = xivoconf_asterisk['ami_pass']
                        if 'userfeatures_db_uri' in xivoconf_asterisk:
                                userfeatures_db_uri = xivoconf_asterisk['userfeatures_db_uri']
                        if 'cdr_db_uri' in xivoconf_asterisk:
                                cdr_db_uri = xivoconf_asterisk['cdr_db_uri']
                        if 'realm' in xivoconf_asterisk:
                                realm = xivoconf_asterisk['realm']
                        if 'aoriginate' in xivoconf_asterisk:
                                aoriginate = xivoconf_asterisk['aoriginate']

                        capafeatures = []

                        configs[astid] = xivo_astcfg.AsteriskConfig(astid,
                                                                    localaddr,
                                                                    ipaddress,
                                                                    ipaddress_webi,
                                                                    ami_port,
                                                                    ami_login,
                                                                    ami_pass,
                                                                    userfeatures_db_uri,
                                                                    capafeatures,
                                                                    cdr_db_uri,
                                                                    realm,
                                                                    parkingnumber,
                                                                    faxcallerid,
                                                                    linkestablished,
                                                                    aoriginate)
                        
                        commandclass.set_phonelist(astid, urllist['phones'])
                        commandclass.set_agentlist(astid, urllist['agents'])
                        commandclass.set_queuelist(astid, urllist['queues'])
                        commandclass.set_vqueuelist(astid, urllist['vqueues'])
                        commandclass.set_meetmelist(astid, urllist['meetme'])
                        commandclass.set_voicemaillist(astid, urllist['voicemail'])
                        commandclass.read_queuelog(astid, url_queuelog)
                        
                        if ipaddress not in ip_reverse_sht:
                                ip_reverse_sht[ipaddress] = astid
                        else:
                                log.warning('WARNING - IP address already exists for asterisk <%s> - can not set it for <%s>'
                                          % (ip_reverse_sht[ipaddress], astid))
                        if ipaddress_webi not in ip_reverse_webi:
                                ip_reverse_webi[ipaddress_webi] = astid
                        else:
                                log.warning('WARNING - IP address (WEBI) already exists for asterisk <%s> - can not set it for <%s>'
                                          % (ip_reverse_webi[ipaddress_webi], astid))
                        save_for_next_packet_events[astid] = ''

        outsock = commandclass.extrasock(extraconn)

        fdlist_full = []
        fdlist_established = {}
        fdlist_listen_cti = {}
        update_userlist = {}
        lastrequest_time = {}
        xivodaemonreload = False
        
        log.info("the monitored asterisk's is/are : %s" % asterisklist)
        log.info('# STARTING %s # (1/2) AMI socket connections + fetch Web Services' % xdname)
        
        for astid in configs:
                try:
                        update_userlist[astid] = False
                        lastrequest_time[astid] = time.time()
                        update_amisocks(astid)
                except Exception:
                        log.exception('--- exception --- %s : failed while setting lists and sockets' % astid)
        try:
                commandclass.updates() # users' update, ...
        except Exception:
                log.exception('--- exception --- commandclass.updates()')
                
        log.info('# STARTING %s # (2/2) listening sockets (CTI, WEBI, (F)AGI, INFO)' % xdname)
        # opens the listening socket for incoming (CTI, WEBI, (F)AGI, INFO) connections
        for portkind in incoming_tcp_ports:
                pk = portkind.split(':')
                port = pk[0]
                kind = 'INFO'
                bind = '127.0.0.1'
                nmax = '1'
                if len(pk) > 1:
                        kind = pk[1].strip()
                        if len(pk) > 2:
                                bind = pk[2].strip()
                                if len(pk) > 3:
                                        nmax = pk[3].strip()
                UIsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                UIsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                UIsock.bind((bind, int(port)))
                UIsock.listen(10)
                fdlist_listen_cti[UIsock] = '%s:%s' % (kind, nmax)
                fdlist_full.append(UIsock)

        if outsock is not None:
                fdlist_full.append(outsock)
        fdlist_full.append(queued_threads_pipe[0])




        # Main select() loop - Receive messages
        while not askedtoquit:
                try:
                        [sels_i, sels_o, sels_e] = select.select(fdlist_full, [], [], updates_period)
                except Exception, exc:
                        print '--- exception --- after select (%s, %s) : %s' % (askedtoquit, fdlist_full, exc)
                        print ' current open TCP connections : (CTI, WEBI, (F)AGI, INFO) ', fdlist_established
                        print ' current open TCP connections : (AMI) ', amilist.fdlist()
                        print ' current open TCP connections : (OUT) ', outsock
                        print
                        
                        for s in fdlist_full:
                                if s in fdlist_established and fdlist_established[s] == 'CTI':
                                        if askedtoquit:
                                                commandclass.reset('stop', s)
                                        else:
                                                commandclass.reset('reload', s)
                                if s.__class__.__name__ == 'int':
                                        os.close(s)
                                else:
                                        s.close()
                        if askedtoquit:
                                commandclass.reset('stop')
                                for t in filter(lambda x: x.getName() != 'MainThread', threading.enumerate()):
                                        print '--- (stop) killing thread <%s>' % t.getName()
                                        t._Thread__stop()
                                daemonize.unlock_pidfile(PIDFILE)
                                sys.exit(5)
                        else:
                                commandclass.reset('reload')
                                askedtoquit = True
                                for t in filter(lambda x: x.getName() != 'MainThread', threading.enumerate()):
                                        print '--- (reload) the thread <%s> remains' % t.getName()
                                        # t._Thread__stop() # does not work in reload case (vs. stop case)
                                continue
                if sels_i:
                        for sel_i in sels_i:
                                # these AMI connections are used in order to manage AMI commands and events
                                if sel_i in amilist.fdlist():
                                        try:
                                                buf = sel_i.readline()
                                                astid = amilist.astid(sel_i)
                                                if len(buf) == 0:
                                                        log.warning('%s AMI : CLOSING' % astid)
                                                        amilist.remove(astid)
                                                        sel_i.close()
                                                        fdlist_full.remove(sel_i)
                                                else:
                                                        if astid is not None:
                                                                try:
                                                                        handle_ami_event(astid, buf)
                                                                except Exception:
                                                                        log.exception('--- exception --- (handle_ami_event) %s' % astid)
                                        except Exception:
                                                log.exception('--- exception --- (amilist)')

                                # other 'outgoing' connections
                                elif sel_i == outsock:
                                        try:
                                                msg = sel_i.recv(BUFSIZE_LARGE, socket.MSG_DONTWAIT)
                                        except Exception:
                                                log.exception('--- exception --- outsock')
                                                msg = ''
                                        if len(msg) == 0:
                                                sel_i.close()
                                                fdlist_full.remove(sel_i)
                                                outsock = None
                                                log.warning('WARNING - outsock has closed the connection')
                                        else:
                                                commandclass.handle_outsock(asterisklist[0], msg)

                                # the new TCP connections (CTI, WEBI, (F)AGI, INFO) are catched here
                                elif sel_i in fdlist_listen_cti:
                                        [kind, nmax] = fdlist_listen_cti[sel_i].split(':')
                                        [conn, sockparams] = sel_i.accept()
                                        if kind == 'FAGI':
                                                if sockparams[0] in ip_reverse_sht:
                                                        astid = ip_reverse_sht.get(sockparams[0])
                                                else:
                                                        astid = 'xivo'
                                                log.info('TCP FAGI socket opened on %s:%d => %s' % (sockparams[0], sockparams[1], astid))
                                                mfr = conn.makefile('rb', -1)
                                                mfw = conn.makefile('wb', 0)
                                                try:
                                                        fagi = fastagi.FastAGI(mfr, mfw)
                                                        commandclass.handle_fagi(astid, fagi)
                                                except Exception:
                                                        log.exception('--- exception --- (fastagi) %s' % astid)
                                                mfr.close()
                                                mfw.close()
                                                conn.close()
                                                log.info('TCP FAGI socket closed on %s:%d' % (sockparams[0], sockparams[1]))
                                        else:
                                                log.info('TCP socket opened on %s:%d (%s)' % (sockparams[0], sockparams[1], kind))
                                                if kind == 'CTI':
                                                        commandclass.connected(conn)
                                                # appending the opened socket to the ones watched
                                                # conn.setblocking(0)
                                                # conn.settimeout(2)
                                                fdlist_full.append(conn)
                                                fdlist_established[conn] = kind

                                # incoming TCP connections (CTI, WEBI, AGI, INFO)
                                elif sel_i in fdlist_established:
                                        try:
                                                kind = fdlist_established[sel_i]
                                                requester = '%s:%d' % sel_i.getpeername()
                                                closemenow = False
                                                try:
                                                        msg = sel_i.recv(BUFSIZE_LARGE, socket.MSG_DONTWAIT)
                                                        lmsg = len(msg)
                                                except Exception:
                                                        log.exception('--- exception --- connection to %s (%s)' % (requester, kind))
                                                        lmsg = 0
                                                if lmsg > 0:
                                                        try:
                                                                closemenow = manage_tcp_connections(sel_i, msg, kind)
                                                        except Exception:
                                                                log.exception('--- exception --- handling %s (%s)' % (requester, kind))
                                                else:
                                                        if kind == 'CTI':
                                                                if sel_i in userinfo_by_requester:
                                                                        userinfo = userinfo_by_requester.get(sel_i)
                                                                        commandclass.manage_logout(userinfo, 'end')
                                                                        del userinfo_by_requester[sel_i]
                                                doclose = False
                                                if kind == 'WEBI':
                                                        doclose = closemenow
                                                elif kind not in ['CTI', 'INFO'] or lmsg == 0:
                                                        doclose = True
                                                if doclose:
                                                        sel_i.close()
                                                        fdlist_full.remove(sel_i)
                                                        del fdlist_established[sel_i]
                                                        if requester in commandclass.transfers_ref:
                                                                commandclass.transfer_endbuf(requester)
                                                        log.info('TCP socket closed on %s (%s)' % (requester, kind))
                                        except Exception:
                                                log.exception('--- exception --- [%s] %s' % (kind, sel_i))
                                                try:
                                                        fdlist_full.remove(sel_i)
                                                        del fdlist_established[sel_i]
                                                        sel_i.close()
                                                        if sel_i in userinfo_by_requester:
                                                                userinfo = userinfo_by_requester.get(sel_i)
                                                                log.warning('logging off %s following unexpected socket breakup' % userinfo)
                                                                commandclass.manage_logout(userinfo, 'exc')
                                                                del userinfo_by_requester[sel_i]
                                                        else:
                                                                log.warning('could not find a match for socket %s' % sel_i)
                                                except Exception:
                                                        log.exception('--- exception (2) [CTI, WEBI, AGI, INFO]')

                                # local pipe fd
                                elif queued_threads_pipe[0] == sel_i:
                                        try:
                                                actionqueue = commandclass.checkqueue()
                                                for actionname, actionarg in actionqueue.iteritems():
                                                        if actionname == 'disconnlist-user':
                                                                disconnlist = actionarg
                                                                for userinfo in disconnlist:
                                                                        log.error('checkqueue return : will disconnect %s' % userinfo)
                                                                        if 'login' in userinfo and 'connection' in userinfo.get('login'):
                                                                                connid = userinfo.get('login')['connection']
                                                                                if connid in fdlist_full and connid in fdlist_established:
                                                                                        fdlist_full.remove(connid)
                                                                                        del fdlist_established[connid]
                                                                                else:
                                                                                        log.warning('connid %s no more in fdlists' % connid)
                                                                                connid.close()
                                                                                commandclass.manage_logout(userinfo, 'pipe')
                                                                                del userinfo_by_requester[connid]
                                                                        else:
                                                                                log.warning('WARNING - no login/connection field present in userinfo')
                                                                commandclass.clear_disconnlist()
                                                        elif actionname == 'disconnlist-tcp':
                                                                disconnlist = actionarg
                                                                for connid in disconnlist:
                                                                        commandclass.telldisconn(connid)
                                                                        fdlist_full.remove(connid)
                                                                        del fdlist_established[connid]
                                                                        connid.close()
                                        except Exception:
                                                log.exception('--- exception --- [queued threads]')


                                for astid in configs:
                                        if (time.time() - lastrequest_time[astid]) > updates_period or update_userlist[astid]:
                                                lastrequest_time[astid] = time.time()
                                                log.info('[%s] %s : updates (computed timeout) %s'
                                                          % (xdname, astid, time.asctime()))
                                                try:
                                                        if outsock is None:
                                                                outsock = commandclass.extrasock(extraconn)
                                                                if outsock is not None:
                                                                        fdlist_full.append(outsock)
                                                        update_amisocks(astid)
                                                        update_readconf()
                                                        commandclass.regular_update()
                                                        update_userlist[astid] = False
                                                except Exception:
                                                        log.exception('--- exception --- %s : failed while updating lists and sockets (computed timeout)' % astid)
                                                try:
                                                        commandclass.updates() # users' update, ...
                                                except Exception:
                                                        log.exception('--- exception --- commandclass.updates() (computed timeout)')

                else: # when nothing happens on the sockets, we fall here sooner or later
                        log.info('[%s] updates (select timeout) %s'
                                  % (xdname, time.asctime()))
                        try:
                                commandclass.updates() # users' update, ...
                        except Exception:
                                log.exception('--- exception --- commandclass.updates() (select timeout)')
                        for astid in configs:
                                lastrequest_time[astid] = time.time()
                                try:
                                        if outsock is None:
                                                outsock = commandclass.extrasock(extraconn)
                                                if outsock is not None:
                                                        fdlist_full.append(outsock)
                                        update_amisocks(astid)
                                        update_readconf()
                                        commandclass.regular_update()
                                except Exception:
                                        log.exception('--- exception --- %s : failed while updating lists and sockets (select timeout)' % astid)
                                        
        log.info('after askedtoquit loop (%s)' % askedtoquit)
