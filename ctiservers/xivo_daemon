#!/usr/bin/python
# vim: set fileencoding=utf-8 :

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# Alternatively, XIVO Daemon is available under other licenses directly
# contracted with Pro-formatique SARL. See the LICENSE file at top of the
# source tree or delivered in the installable package in which XIVO Daemon
# is distributed for more details.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

__version__   = '$Revision$'
__date__      = '$Date$'
__copyright__ = 'Copyright (C) 2007-2009 Proformatique'
__author__    = 'Corentin Le Gall'

"""
# 1) General description of XIVO CTI Daemon
# The XIVO CTI Daemon is a general-purpose daemon, whose basic features are :
#  - the monitoring of one or more Asterisk, through AMI
#  - taking care of Asteriks AGI requests
#  - the ability to receive incoming "CTI clients" connections
#  - the ability to relay commands (between a Web interface and Asterisk)
#  - the connection to one or more databases (cdr, directory, ...)
#  - the connection to a given server
# 
# 2) Primary data structures
# 
#  - users list
#  - contexts/companies list
# 
#  - asterisk / configurations
#  - phonelist
#
# 3) Main loop
# The main loop is triggered by a select() on the file descriptors for :
# - the AMI Event sockets (AMIsocks)
# - the incoming TCP sockets (CTI, WEBI, INFO, (F)AGI)
#
# 4) Custom-defined Plugins
#
"""

__revision__ = __version__.split()[1]

# debian.org modules
import getopt
import os
import pickle
import select
import signal
import socket
import string
import sys
import threading
import time
import logging
from logging.handlers import SysLogHandler
import Queue
from xivo_ctiservers.client_connection import ClientConnection

__alphanums__ = string.uppercase + string.lowercase + string.digits
waiting_actionid = {}
waiting_actionid_timer = {}
dumpami = False

try:
        DAEMONNAME = os.path.basename(sys.argv[0])
except:
        DAEMONNAME = 'xivo_daemon'

# XIVO lib-python modules initialization
XIVOCONFFILE            = '/etc/asterisk/%s.conf' % DAEMONNAME
PIDFILE                 = '/var/run/%s.pid' % DAEMONNAME
GETOPT_SHORTOPTS        = 'dc:p:'
GETOPT_LONGOPTS         = ["debug", "config=", "pidfile="]
debug_mode = False
def config_path():
        global XIVOCONFFILE, PIDFILE, debug_mode
        for opt, arg in getopt.getopt(
                sys.argv[1:],
                GETOPT_SHORTOPTS,
                GETOPT_LONGOPTS
                )[0]:
                if opt == "-c":
                        XIVOCONFFILE = arg
                elif opt == "-d":
                        debug_mode = True
                elif opt=="-p":
                        PIDFILE = arg
config_path()

# XIVO lib-python modules imports
from xivo import anysql
from xivo.BackSQL import backmysql
from xivo.BackSQL import backsqlite

# XIVO CTI modules
from xivo_agid import fastagi
from xivo_ctiservers import xivo_ami
from xivo_ctiservers import xivo_contexts
from xivo_ctiservers import xivo_astcfg
from xivo_ctiservers import cti_config
from xivo_ctiservers import xivo_commandsets
from xivo_ctiservers.CommandSets import *
from xivo_ctiservers.xivo_commandsets import ctidaemonize as daemonize

BUFSIZE_LARGE = 8192
BUFSIZE_ANY = 512

XIVO_CLI_WEBI_HEADER = 'XIVO-CLI-WEBI'
XIVOVERSION = '1.0'

## \brief Deals with requests from the UI clients.
# \param connid connection identifier
# \param msg message to process
# \param sep separator to split the message
# \return none
def manage_cti_connections(connid, msg, sep):
        """
        Handles CTI connections.
        """
        requester = '%s:%d' % connid.getpeername()
        if requester in commandclass.transfers_ref:
                commandclass.transfer_addbuf(requester, msg)
                return
        
        multimsg = msg.split(sep)
        for usefulmsgpart in multimsg:
                # remove tailing \r
                usefulmsg = usefulmsgpart.split('\r')[0]
                if len(usefulmsg) == 0:
                        break
                command = commandclass.parsecommand(usefulmsg)
                if command.name in commandclass.get_list_commands():
                        try:
                                if command.type in [xivo_commandsets.CMD_LOGIN_ID,
                                                    xivo_commandsets.CMD_LOGIN_PASS,
                                                    xivo_commandsets.CMD_LOGIN_CAPAS]:
                                        # log.info('LOGIN(%s) %s : args   %s' % (command.type, requester, command.args))
                                        loginparams = commandclass.get_login_params(command, asterisklist[0], connid)
                                        # log.info('LOGIN(%s) %s : params %s' % (command.type, requester, loginparams))
                                        uinfo = commandclass.manage_login(loginparams, command.type, userinfo_current.get(connid))
                                        # log.info('LOGIN(%s) %s : uinfo  %s' % (command.type, requester, uinfo))
                                        
                                        if isinstance(uinfo, str):
                                                commandclass.loginko(loginparams, uinfo, connid)
                                                log.info('TCP socket %s closed(loginko) on %s' % (fdlist_established[connid],
                                                                                                  '%s:%d' % connid.getpeername()))
                                                del fdlist_established[connid]
                                                connid.close()
                                        else:
                                                if command.type == xivo_commandsets.CMD_LOGIN_CAPAS:
                                                        uinfo['login']['connection'] = connid
                                                        userinfo_by_requester[connid] = uinfo
                                                        if connid in userinfo_current:
                                                                del userinfo_current[connid]
                                                else:
                                                        userinfo_current[connid] = uinfo
                                                commandclass.loginok(loginparams, uinfo, connid, command.type)
                                elif command.type == xivo_commandsets.CMD_TRANSFER:
                                        log.info('TRANSFER on %s : %s' % (requester, command.struct))
                                        commandclass.transfer_addref(connid, command.struct)
                                else:
                                        if connid in userinfo_by_requester:
                                                commandclass.manage_cticommand(userinfo_by_requester[connid],
                                                                               command)
                                        else:
                                                log.warning('unlogged %s is attempting a %s (TCP) : %s'
                                                            % (requester, command.name, command.args))
                        except Exception:
                                log.exception('CTI connection when managing [%s, %s] for %s'
                                              % (command.name, command.type, requester))
                else:
                        connid.sendall('Unknown Command <%s>\n' % command.name)


## \brief Deals with requests from the UI clients.
# \param connid connection identifier
# \return none
def manage_webi_connections(connid, msg, sep):
        """
        Handles WEBI connections.
        """
        global askedtoquit
        requester = '%s:%d' % connid.getpeername()
        requester_ip = connid.getpeername()[0]
        closemenow = True
        
        if requester_ip not in ip_reverse_webi:
                connid.sendall('%s:KO <NOT ALLOWED>\n' % XIVO_CLI_WEBI_HEADER)
                return closemenow
        astid = ip_reverse_webi[requester_ip]
        
        multimsg = msg.split(sep)
        for usefulmsgpart in multimsg:
                usefulmsg = usefulmsgpart.split('\r')[0]
                if len(usefulmsg) == 0:
                        break
                try:
                        if usefulmsg in ['xivo[userlist,update]',
                                         'xivo[agentlist,update]',
                                         'xivo[queuelist,update]',
                                         'xivo[grouplist,update]']:
                                update_userlist[astid] = True
                                log.info('%s : WEBI requested %s (%s)' % (astid, usefulmsg, requester))
                        elif usefulmsg == 'xivo[daemon,reload]':
                                askedtoquit = True
                                log.info('%s : WEBI requested %s (%s)' % (astid, usefulmsg, requester))
                        elif usefulmsg == 'xivo[ctiprofilelist,get]':
                                log.info('%s : WEBI requested %s (%s)' % (astid, usefulmsg, requester))
                                connid.sendall('%s:ID <%s>\n' % (XIVO_CLI_WEBI_HEADER, astid))
                                connid.sendall('%s\n' % commandclass.getprofilelist())
                                connid.sendall('%s:OK\n' % XIVO_CLI_WEBI_HEADER)
                        elif astid in amilist.ami and amilist.ami[astid]:
                                stripped_usefulmsg = usefulmsg.strip()
                                try:
                                        if stripped_usefulmsg == 'moh reload':
                                                commandclass.pre_moh_reload()
                                        elif stripped_usefulmsg == 'reload':
                                                commandclass.pre_reload()
                                except Exception:
                                        log.exception('(pre reloads (%s))' % stripped_usefulmsg)
                                        
                                closemenow = False
                                try:
                                        actionid = amilist.execute(astid, 'sendcommand', 'Command', [('Command', stripped_usefulmsg)])
                                        log.info('%s : WEBI requested a <%s> with actionid %s (%s)' % (astid, stripped_usefulmsg,
                                                                                                       actionid, connid))
                                        waiting_actionid[actionid] = connid
                                        waiting_actionid_timer[actionid] = threading.Timer(5, callback_timer_main, ('webirequest', actionid))
                                        waiting_actionid_timer[actionid].start()
                                except Exception, exc:
                                        log.error('(%s) WEBI command exec <%s> : (client %s) : %s'
                                                  % (astid, stripped_usefulmsg, requester, exc))
                except Exception, exc:
                        log.error('(%s) WEBI <%s> : (client %s) : %s'
                                  % (astid, usefulmsg.strip(), requester, exc))
                        connid.sendall('%s:KO <Exception : %s>\n' % (XIVO_CLI_WEBI_HEADER, exc))
        return closemenow


## \brief Deals with requests from the UI clients.
# \param connid connection identifier
# \return none
def manage_info_connections(connid, msg, sep):
        """
        Handles INFO connections (basic administration console,
        primarily aimed at displaying informations first).
        """
        global dumpami
        global log
        requester = '%s:%d' % connid.getpeername()
        multimsg = msg.replace('\r', '').split(sep)
        for usefulmsg in multimsg:
                if len(usefulmsg) == 0:
                        break
                try:
                        retstr = 'OK'
                        if usefulmsg == 'help':
                                helptxt = ['show_infos',
                                           'show_users',
                                           'show_varsizes',
                                           'dumpami enable',
                                           'dumpami disable']
                                for helpline in helptxt:
                                        connid.sendall('%s\n' % helpline)
                        elif usefulmsg == 'show_infos':
                                time_uptime = int(time.time() - time.mktime(time_start))
                                reply = 'infos=' \
                                        'xivo_version=%s;' \
                                        'server_version=%s;' \
                                        'commandset=%s;' \
                                        'commandset_version=%s;' \
                                        'uptime=%d s' \
                                        % (XIVOVERSION, __revision__,
                                           commandclass.xdname,
                                           commandclass.version(),
                                           time_uptime)
                                connid.sendall(reply + '\n')
                                # connid.sendall('server capabilities = %s\n' % (','.join()))
                        elif usefulmsg == 'dumpami enable':
                                dumpami = True
                        elif usefulmsg == 'dumpami disable':
                                dumpami = False
                        elif usefulmsg.startswith('loglevel '):
                                command_args = usefulmsg.split()
                                if len(command_args) > 2:
                                        action = command_args[1]
                                        levelname = command_args[2]
                                        levels = {'debug' : logging.DEBUG,
                                                  'info' : logging.INFO,
                                                  'warning' : logging.WARNING,
                                                  'error' : logging.ERROR}
                                        if action == 'set':
                                                if levelname in levels:
                                                        newlevel = levels[levelname]
                                                        log.setLevel(logging.INFO)
                                                        log.info('=== setting loglevel to %s (%s) ===' % (levelname, newlevel))
                                                        log.setLevel(newlevel)
                                                        logging.getLogger('xivocti').setLevel(newlevel)
                                                        logging.getLogger('xivo_ami').setLevel(newlevel)
                                                        logging.getLogger('urllist').setLevel(newlevel)
                                                        connid.sendall('loglevel set to %s (%s)\n' % (levelname, newlevel))
                                                else:
                                                        connid.sendall('unknown level name <%s> to set\n' % levelname)
                                        elif action == 'get':
                                                pass
                                        else:
                                                connid.sendall('unknown action <%s> for loglevel : try set or get\n' % action)
                        elif usefulmsg == 'show_users':
                                for user, info in commandclass.users().iteritems():
                                        try:
                                                connid.sendall('%s %s\n' % (user.encode('latin1'), info))
                                        except Exception:
                                                log.exception('INFO %s' % usefulmsg)
                        elif usefulmsg in ['show_phones', 'show_trunks',
                                           'show_queues', 'show_groups', 'show_agents',
                                           'show_meetme', 'show_voicemail']:
                                itemname = usefulmsg[5:]
                                for astid, itm in commandclass.getdetails(itemname).iteritems():
                                        try:
                                                connid.sendall('%s for %s\n' % (itemname, astid))
                                                for id, idv in itm.keeplist.iteritems():
                                                        connid.sendall('%s %s\n' % (id, idv))
                                        except Exception:
                                                log.exception('INFO %s' % usefulmsg)
                        elif usefulmsg.startswith('show_var '):
                                command_args = usefulmsg.split()
                                if len(command_args) > 2:
                                        astid = command_args[1]
                                        varname = command_args[2]
                                        if hasattr(commandclass, varname):
                                                tvar = getattr(commandclass, varname)
                                                if astid in tvar:
                                                        connid.sendall('%s on %s\n' % (varname, astid))
                                                        for ag, agp in tvar[astid].iteritems():
                                                                connid.sendall('%s %s\n' % (ag, agp))
                                                else:
                                                        connid.sendall('no such astid %s\n' % astid)
                                        else:
                                                connid.sendall('no such variable %s\n' % varname)
                                else:
                                        connid.sendall('first argument : astid value\n')
                                        connid.sendall('second argument : one of %s\n' % commandclass.astid_vars)
                        elif usefulmsg.startswith('show_varsizes '):
                                command_args = usefulmsg.split()
                                if len(command_args) > 1:
                                        astid = command_args[1]
                                        for varname in commandclass.astid_vars:
                                                if hasattr(commandclass, varname):
                                                        tvar = getattr(commandclass, varname)
                                                        if astid in tvar:
                                                                connid.sendall('%s on %s: %d\n' % (varname, astid, len(tvar[astid])))
                                                        else:
                                                                connid.sendall('no such astid %s\n' % astid)
                                                else:
                                                        connid.sendall('no such variable %s\n' % varname)
                                else:
                                        connid.sendall('argument : astid value\n')
                        elif usefulmsg == 'show_logged_ip':
                                for user, info in commandclass.connected_users().iteritems():
                                        if 'connection' in info['login']:
                                                try:
                                                        [ipaddr, ipport] = info['login']['connection'].getpeername()
                                                except Exception:
                                                        log.exception('INFO %s' % usefulmsg)
                                                        [ipaddr, ipport] = ['err_addr', 'err_port']
                                                connid.sendall('user %s : ip:port = %s:%s\n' % (user.encode('latin1'), ipaddr, ipport))
                        elif usefulmsg == 'show_logged':
                                for user, info in commandclass.connected_users().iteritems():
                                        try:
                                                connid.sendall('%s %s\n' % (user.encode('latin1'), info))
                                        except Exception:
                                                log.exception('INFO %s' % usefulmsg)
                        elif usefulmsg.startswith('reverse '):
                                command_args = usefulmsg.split()
                                if len(command_args) > 2:
                                        dirnames = command_args[1]
                                        numbers = command_args[2:]
                                        for number in numbers:
                                                reverses = commandclass.findreverse(dirnames, number)
                                                for number, rep in reverses.iteritems():
                                                        connid.sendall('%s %s\n' % (number, rep))
                        elif usefulmsg.startswith('disc '):
                                command_args = usefulmsg.split()
                                if len(command_args) > 2:
                                        ipdef = tuple([command_args[1], int(command_args[2])])
                                        socktoremove = None
                                        for sockid in fdlist_established.keys():
                                                if ipdef == sockid.getpeername():
                                                        socktoremove = sockid
                                        if socktoremove:
                                                connid.sendall('disconnecting %s (%s)\n'
                                                               % (socktoremove.getpeername(), fdlist_established[socktoremove]))
                                                socktoremove.close()
                                                del fdlist_established[socktoremove]
                                        else:
                                                connid.sendall('nobody disconnected\n')
                        elif usefulmsg == 'show_ami':
                                for astid, ami in amilist.ami.iteritems():
                                        connid.sendall('commands : %s : %s\n' % (astid, ami))
                        elif usefulmsg.startswith('ami '):
                                amicmd = usefulmsg.split()[1:]
                                if amicmd:
                                        connid.sendall('ami request %s\n' % amicmd)
                                        if len(amicmd) > 1:
                                                astid = amicmd[0]
                                                cmd = amicmd[1]
                                                cmdargs = amicmd[2:]
                                                amilist.execute(astid, cmd, *cmdargs)
                        elif usefulmsg.startswith('kick '):
                                command_args = usefulmsg.split()
                                try:
                                        if len(command_args) > 1:
                                                kickuser = command_args[1]
                                                if kickuser in commandclass.connected_users():
                                                        uinfo = commandclass.connected_users()[kickuser]
                                                        if 'login' in uinfo and 'connection' in uinfo.get('login'):
                                                                cid = uinfo.get('login')['connection']
                                                                if cid in fdlist_established:
                                                                        del fdlist_established[cid]
                                                                        cid.close()
                                                                        commandclass.manage_logout(uinfo, 'admin')
                                                                        del userinfo_by_requester[cid]
                                                                        connid.sendall('kicked %s\n' % kickuser)
                                                                else:
                                                                        connid.sendall('did not kick %s (socket id not in daemon refs)\n' % kickuser)
                                                        else:
                                                                connid.sendall('did not kick %s (no connection attributes for the user)\n' % kickuser)
                                                else:
                                                        connid.sendall('did not kick %s (user not found)\n' % kickuser)
                                        else:
                                                connid.sendall('nobody to kick\n')
                                except Exception:
                                        log.exception('INFO %s' % usefulmsg)
                                        connid.sendall('(exception when trying to kick - see server log)\n')
                        elif usefulmsg.startswith('%s:' % commandset):
                                commandclass.cliaction(connid, usefulmsg)
                        else:
                                retstr = 'KO'
                        connid.sendall('XIVO-INFO:%s\n' % retstr)
                except Exception:
                        log.exception('INFO connection [%s] : KO when sending to %s'
                                      % (usefulmsg, requester))

def manage_tcp_connections(sel_i, msg, kind):
        """
        Dispatches the message's handling according to the connection's kind.
        """
        closemenow = True
        if kind == 'CTI':
                manage_cti_connections(sel_i, msg, commandclass.ctiseparator)
        elif kind == 'WEBI':
                closemenow = manage_webi_connections(sel_i, msg, '\n')
        elif kind == 'INFO':
                manage_info_connections(sel_i, msg, '\n')
        elif kind == 'AGI':
                agireply = commandclass.handle_agi(asterisklist[0], msg)
                if agireply is not None:
                        sel_i.sendall(agireply)
        else:
                log.warning('unknown connection kind %s' % kind)
        return closemenow


"""
Management of events that are spied on the AMI
"""
## \brief Handling of AMI events occuring in Events=on mode.
# \param astid the asterisk Id
# \param idata the data read from the AMI we want to parse
# \return none
def handle_ami_event(astid, idata):
        """
        Handles the AMI events occuring on Asterisk.
        If the Event field is there, calls the handle_ami_function() function.
        """
        global save_for_next_packet_events
        if astid not in configs:
                log.info('%s : no such asterisk Id' % astid)
                return
        
        full_idata = save_for_next_packet_events[astid] + idata
        evlist = full_idata.split('\r\n\r\n')
        save_for_next_packet_events[astid] = evlist.pop()
        
        for evt in evlist:
                evt = evt.decode('utf8')
                this_event = {}
                nocolon = []
                for myline in evt.split('\r\n'):
                        if myline.find('\n') < 0:
                                myfieldvalue = myline.split(': ', 1)
                                if len(myfieldvalue) == 2:
                                        this_event[myfieldvalue[0]] = myfieldvalue[1]
                                else:
                                        if myline.startswith('Asterisk Call Manager'):
                                                log.info('%s : %s' % (astid, myline))
                                        else:
                                                log.warning('%s unable to parse %s' % (astid, myline))
                        else:
                                nocolon.append(myline)
                if len(nocolon) > 1:
                        log.warning('%s nocolon is %s' % (astid, nocolon))
                evfunction = this_event.get('Event')
                # log.info('%s AMI(all)  %s  : %s' % (astid, evfunction, this_event))
                if evfunction is not None:
                        handle_ami_function(astid, evfunction, this_event)
                        if evfunction not in ['Newexten', 'Newchannel', 'Newstate', 'Newcallerid']:
                                pass
                                # verboselog('%s %s' % (astid, this_event), True, False)
                else:
                        response = this_event.get('Response')
                        if response is not None:
                                if response == 'Follows' and this_event.get('Privilege') == 'Command':
                                        if 'ActionID' in this_event:
                                                actionid = this_event.get('ActionID')
                                                connreply = waiting_actionid.get(actionid)
                                                try:
                                                        if connreply is not None:
                                                                connreply.sendall('%s:ID <%s>\n' % (XIVO_CLI_WEBI_HEADER, astid))
                                                        for noc in nocolon:
                                                                arggs = noc.split('\n')
                                                                for toremove in ['', '--END COMMAND--']:
                                                                        while toremove in arggs:
                                                                                arggs.remove(toremove)
                                                                if arggs:
                                                                        if connreply is not None:
                                                                                log.info('%s AMI Response : %s : %s' % (astid, actionid, arggs))
                                                                                for argg in arggs:
                                                                                        connreply.sendall(argg + '\n')
                                                        if connreply is not None:
                                                                connreply.sendall('%s:OK\n' % XIVO_CLI_WEBI_HEADER)
                                                                log.info('TCP socket %s closed(actionid-ok) on %s' % (fdlist_established[connreply],
                                                                                                                      '%s:%d' % connreply.getpeername()))
                                                                del fdlist_established[connreply]
                                                                connreply.close()
                                                                del waiting_actionid[actionid]
                                                                waiting_actionid_timer[actionid].cancel()
                                                                del waiting_actionid_timer[actionid]
                                                except Exception:
                                                        log.exception('%s (command reply to %s, %s)' % (astid, connreply, actionid))
                                        try:
                                                commandclass.amiresponse_follows(astid, this_event, nocolon)
                                        except Exception:
                                                log.exception('%s amiresponse_follows (%s) (%s)' % (astid, this_event, nocolon))
                                elif response == 'Success':
                                        try:
                                                commandclass.amiresponse_success(astid, this_event, nocolon)
                                        except Exception:
                                                log.exception('%s amiresponse_success (%s) (%s)' % (astid, this_event, nocolon))
                                elif response == 'Error':
                                        if 'ActionID' in this_event:
                                                actionid = this_event.get('ActionID')
                                                connreply = waiting_actionid.get(actionid)
                                                try:
                                                        if connreply is not None:
                                                                connreply.sendall('%s:ID <%s>\n' % (XIVO_CLI_WEBI_HEADER, astid))
                                                                connreply.sendall('%s:KO\n' % XIVO_CLI_WEBI_HEADER)
                                                                log.info('TCP socket %s closed(actionid-ko) on %s' % (fdlist_established[connreply],
                                                                                                                      '%s:%d' % connreply.getpeername()))
                                                                del fdlist_established[connreply]
                                                                connreply.close()
                                                                del waiting_actionid[actionid]
                                                                waiting_actionid_timer[actionid].cancel()
                                                                del waiting_actionid_timer[actionid]
                                                except Exception:
                                                        log.exception('%s (command reply to %s, %s)' % (astid, connreply, actionid))
                                        try:
                                                commandclass.amiresponse_error(astid, this_event, nocolon)
                                        except Exception:
                                                log.exception('%s amiresponse_error (%s) (%s)' % (astid, this_event, nocolon))
                                else:
                                        log.warning('AMI %s Response=%s (untracked) : %s' % (astid, response, this_event))
                        elif len(this_event) > 0:
                                log.warning('AMI:XXX: <%s> : %s' % (astid, this_event))
                        else:
                                log.warning('AMI %s Other : %s' % (astid, this_event))


evfunction_to_method_name = {
        'Registry':             'ami_registry',
        'Dial':                 'ami_dial',
        'Link':                 'ami_link',
        'Unlink':               'ami_unlink',
        'Bridge':               'ami_bridge',                   # (1.6) Seems to replace partly Link/Unlink events
        'Masquerade':           'ami_masquerade',               # (1.6 backported) for indirect transfers & intercepts
        'Hangup':               'ami_hangup',
        'HangupRequest':        'ami_hanguprequest',            # (xivo) to know who 'ordered' the hangup
        'Join':                 'ami_join',
        'Leave':                'ami_leave',
        'DTMF':                 'ami_dtmf',                     # (1.6 backported)
        'PeerStatus':           'ami_peerstatus',
        'Agentlogin':           'ami_agentlogin',
        'Agentlogoff':          'ami_agentlogoff',
        'Agentcallbacklogin':   'ami_agentcallbacklogin',
        'Agentcallbacklogoff':  'ami_agentcallbacklogoff',
        'AgentCalled':          'ami_agentcalled',
        'AgentComplete':        'ami_agentcomplete',
        'AgentsComplete':       'ami_agentscomplete',
        'AgentConnect':         'ami_agentconnect',
        'AgentDump':            'ami_agentdump',
        'Agents':               'ami_agents',
        'ChannelReload':        'ami_channelreload',            # (1.4)
        'ParkedCall':           'ami_parkedcall',               # when the requested parking is acked
        'UnParkedCall':         'ami_unparkedcall',
        'ParkedCallTimeOut':    'ami_parkedcalltimeout',
        'ParkedCallGiveUp':     'ami_parkedcallgiveup',
        'ParkedCallsComplete':  'ami_parkedcallscomplete',
        'DNDState':             'ami_dndstate',
        'Cdr':                  'ami_cdr',
        'Hold':                 'ami_hold',
        'Unhold':               'ami_unhold',
        'Alarm':                'ami_alarm',
        'AlarmClear':           'ami_alarmclear',
        'FaxSent':              'ami_faxsent',
        'FaxReceived':          'ami_faxreceived',
        'MeetmeJoin':           'ami_meetmejoin',               # when a member joins a conference
        'MeetmeLeave':          'ami_meetmeleave',              # when a member leaves a conference
        'MeetmeMute':           'ami_meetmemute',               # when a member is (un)muted
        'MeetmeTalking':        'ami_meetmetalking',
        'MeetmeList':           'ami_meetmelist',
        'MeetmeListComplete':   'ami_meetmelistcomplete',
        'Transfer':             'ami_transfer',                 # (1.6 backported)
        'ExtensionStatus':      'ami_extensionstatus',
        'OriginateSuccess':     'ami_originatesuccess',
        'AOriginateSuccess':    'ami_aoriginatesuccess',
        'OriginateFailure':     'ami_originatefailure',
        'AOriginateFailure':    'ami_aoriginatefailure',
        'OriginateResponse':    'ami_originateresponse',
        'Rename':               'ami_rename',                   # appears when there is a transfer
        'Newstate':             'ami_newstate',
        'Newcallerid':          'ami_newcallerid',              # useful for tricky managements
        'Newchannel':           'ami_newchannel',
        'Newexten':             'ami_newexten',                 # in order to handle outgoing calls ?
        'MessageWaiting':       'ami_messagewaiting',
        'QueueParams':          'ami_queueparams',
        'QueueMemberAdded':     'ami_queuememberadded',
        'QueueMemberPaused':    'ami_queuememberpaused',
        'QueueMemberRemoved':   'ami_queuememberremoved',
        'QueueMember':          'ami_queuemember',
        'QueueMemberStatus':    'ami_queuememberstatus',
        'QueueStatusComplete':  'ami_queuestatuscomplete',
        'QueueEntry':           'ami_queueentry',
        'QueueCallerAbandon':   'ami_queuecallerabandon',       # (1.4)
        'Status':               'ami_status',
        'StatusComplete':       'ami_statuscomplete',
        'Atxfer':               'ami_atxfer',                   #
}


def handle_ami_function(astid, evfunction, this_event):
        """
        Handles the AMI events related to a given function (i.e. containing the Event field).
        It roughly only dispatches them to the relevant commandset's methods.
        """
        try:
                if 'Privilege' in this_event:
                        this_event.pop('Privilege')
                if dumpami:
                        todisp = this_event
                        if 'Event' in todisp:
                                efn = todisp.pop('Event')
                                for ik, iv in fdlist_established.iteritems():
                                        if iv == 'INFO':
                                                ik.sendall('%s %s %s\n' % (astid, efn, todisp))
                if evfunction == 'Reload':
                        log.warning('%s AMI:Reload %s' % (astid, this_event))
                        commandclass.ami_reload(astid, this_event)
                elif evfunction == 'Shutdown':
                        shutdown = this_event.get('Shutdown')
                        restart  = this_event.get('Restart')
                        log.warning('%s AMI:Shutdown (how=%s restart=%s)' % (astid, shutdown, restart))
                        commandclass.ami_shutdown(astid, this_event)
                elif evfunction.startswith('UserEvent'):
                        commandclass.ami_userevent(astid, this_event)
                elif (evfunction in evfunction_to_method_name):
                        getattr(commandclass, evfunction_to_method_name[evfunction])(astid, this_event)
                else:
                        log.warning('%s AMI ... this event (%s) is not tracked : %s' % (astid, evfunction, this_event))
        except Exception:
                log.exception('%s AMI / %s : event %s' % (astid, evfunction, this_event))


def update_readconf():
        log.info('reparsing config file(s)')
        lconf = cti_config.Config(XIVOCONFFILE)
        commandclass.set_cticonfig(lconf)
        commandclass.set_options(cconf.read_section('commandset', commandset), cconf)
        return


def update_amisocks(astid):
        """
        Connects to the Asterisk's AMI (defined by astid) if not yet done.
        Requests a Status when it (re)connects.
        """
        try:
                amilist.setconfig(astid,
                                  (configs[astid].remoteaddr,
                                   configs[astid].ami_port),
                                  configs[astid].ami_login,
                                  configs[astid].ami_pass)
                amilist.connect(astid)
                amilist.set_aoriginate(astid, configs[astid].aoriginate)
        except Exception:
                log.exception('%s (update_amisocks) %s:%d' % (astid, configs[astid].remoteaddr, configs[astid].ami_port))
        return

tqueue = Queue.Queue()

def callback_timer_main(*args):
        global tqueue
        thisthread = threading.currentThread()
        tname = thisthread.getName()
        log.info('callback_timer_main (timer finished at %s) %s %s' % (time.asctime(), tname, args))
        thisthread.setName(tname + '-' + '-'.join(args))
        tqueue.put(thisthread)
        os.write(pipe_queued_threads_main[1], thisthread.getName())
        return

def checkqueue_main():
        buf = os.read(pipe_queued_threads_main[0], 1024)
        log.info('checkqueue_main : read buf = %s, tqueue size = %d' % (buf, tqueue.qsize()))
        while tqueue.qsize() > 0:
                thisthread = tqueue.get()
                action = thisthread.args[0]
                if action == 'ipbxup':
                        # check whether the AMI is already connected,
                        # and connects if needed
                        astid = thisthread.args[1]
                        update_amisocks(astid)
                elif action == 'webirequest':
                        # checks whether the given actionid is still ongoing and closes
                        # the related WEBI request then
                        actionid = thisthread.args[1]
                        if actionid in waiting_actionid and actionid in waiting_actionid_timer:
                                conn_to_close = waiting_actionid[actionid]
                                del fdlist_established[conn_to_close]
                                conn_to_close.close()
                                del waiting_actionid[actionid]
                                del waiting_actionid_timer[actionid]
                                log.info('closing the WEBI connection %s for the request %s' % (conn_to_close, actionid))
                        else:
                                log.warning('the actionid %s has gone' % actionid)
        return

## \brief Handler for catching signals (in the main thread)
# \param signum signal number
# \param frame frame
# \return none
def sighandler(signum, frame):
        global askedtoquit
        log.warning('(sighandler) signal %s (atq = %s) received : quits' % (signum, askedtoquit))
        for t in filter(lambda x: x.getName() != 'MainThread', threading.enumerate()):
                print '--- living thread <%s>' % (t.getName())
                t._Thread__stop()
        askedtoquit = True


## \brief Handler for catching signals (in the main thread)
# \param signum signal number
# \param frame frame
# \return none
def sighandler_reload(signum, frame):
        global askedtoquit
        log.warning('(sighandler_reload) signal %s (atq = %s) received : reloads' % (signum, askedtoquit))
        askedtoquit = False

# ==============================================================================
# Main Code starts here
# ==============================================================================

print sys.getdefaultencoding()
logging.basicConfig(level=logging.INFO)
#logging.basicConfig(level=logging.DEBUG)
sysloghandler = SysLogHandler('/dev/log', SysLogHandler.LOG_DAEMON)
formatter = logging.Formatter('%s[%%(process)d] (%%(levelname)s) (%%(name)s): %%(message)s' % DAEMONNAME)

sysloghandler.setFormatter(formatter)
logging.getLogger('').addHandler(sysloghandler)
log = logging.getLogger('main')

if not debug_mode:
        daemonize.daemonize()

daemonize.lock_pidfile_or_die(PIDFILE)

signal.signal(signal.SIGINT, sighandler)
signal.signal(signal.SIGTERM, sighandler)
signal.signal(signal.SIGHUP, sighandler_reload)

nreload = 0
directorylist = xivo_contexts.Contexts()
configs = {}
xdname = None

while True: # loops over the reloads
        askedtoquit = False
        
        time_start = time.localtime()
        if nreload == 0:
                log.info('# STARTING XIVO Daemon %s (pid %d) / svn:%s # (0/3) Starting'
                          % (XIVOVERSION, os.getpid(), __revision__))
        else:
                log.info('# STARTING XIVO Daemon %s (pid %d) / svn:%s # (0/3) Reloading (%d)'
                          % (XIVOVERSION, os.getpid(), __revision__, nreload))
        nreload += 1
        
        # global default definitions
        incoming_tcp_ports = []
        incoming_udp_ports = []
        asterisklist = []
        contextlist = []
        userlists = []
        ctilog = None
        
        userinfo_by_requester = {}
        userinfo_current = {}
        
        cconf = cti_config.Config(XIVOCONFFILE)
        xivoconf_general = cconf.read_section('general', 'general')
        
        # loads the general configuration
        commandset = xivoconf_general.get('commandset', 'xivocti')
        if 'incoming_tcp_ports' in xivoconf_general:
                incoming_tcp_ports = xivoconf_general['incoming_tcp_ports'].split(',')
        if 'incoming_udp_ports' in xivoconf_general:
                incoming_udp_ports = xivoconf_general['incoming_udp_ports'].split(',')
        for func in ['CTI', 'WEBI', 'FAGI', 'INFO']:
                fieldname = 'incoming_tcp_%s' % func.lower()
                if fieldname in xivoconf_general:
                        bind_and_port = xivoconf_general[fieldname].split(':')
                        if len(bind_and_port) > 1:
                                try:
                                        incoming_tcp_ports.append('%d:%s:%s' % (int(bind_and_port[1]), func, bind_and_port[0]))
                                except Exception:
                                        log.exception('%s definition' % fieldname)
        for func in ['ANNOUNCE']:
                fieldname = 'incoming_udp_%s' % func.lower()
                if fieldname in xivoconf_general:
                        bind_and_port = xivoconf_general[fieldname].split(':')
                        if len(bind_and_port) > 1:
                                try:
                                        incoming_udp_ports.append('%d:%s:%s' % (int(bind_and_port[1]), func, bind_and_port[0]))
                                except Exception:
                                        log.exception('%s definition' % fieldname)
        extraconn = xivoconf_general.get('extraconn', '')
        updates_period = int(xivoconf_general.get('updates_period', '60'))
        ctilog = xivoconf_general.get('ctilog')
        socktimeout = xivoconf_general.get('sockettimeout', '2')
        logintimeout = int(xivoconf_general.get('logintimeout', '5'))
        apnoeafile = xivoconf_general.get('apnoeafile')
        prefixfile = xivoconf_general.get('prefixfile')
        parting_astid_context = xivoconf_general.get('parting_astid_context')
        if 'asterisklist' in xivoconf_general:
                asterisklist = xivoconf_general['asterisklist'].split(',')
        if 'contextlist' in xivoconf_general:
                contextlist = xivoconf_general['contextlist'].split(',')
        if 'userlists' in xivoconf_general:
                userlists = xivoconf_general['userlists'].split(',')
                
        socket.setdefaulttimeout(float(socktimeout))
        
        pipe_queued_threads_commandclass = os.pipe()
        pipe_queued_threads_main = os.pipe()
        amilist = xivo_ami.AMIList()
        if commandset in xivo_commandsets.CommandClasses:
                commandclass = xivo_commandsets.CommandClasses[commandset](amilist,
                                                                           incoming_tcp_ports,
                                                                           pipe_queued_threads_commandclass)
                xdname = commandclass.xdname
        else:
                commandclass = xivo_commandsets.BaseCommand()
                xdname = commandclass.xdname
                log.warning('# STARTING %s : no such commandset <%s>' % (xdname, commandset))
                
        log.info('# STARTING %s / svn:%s / %d' % (xdname, commandclass.version(), nreload))
        
        update_readconf()
        commandclass.set_userlist_urls(userlists)
        commandclass.set_contextlist(directorylist)
        commandclass.set_configs(configs)
        commandclass.set_ctilog(ctilog)
        commandclass.set_logintimeout(logintimeout)
        
        if apnoeafile:
                try:
                        e = open(apnoeafile, 'r')
                        torescue = pickle.loads(e.read())
                        e.close()
                        commandclass.apnoea_rescue(torescue)
                except:
                        log.exception('read apnoea file %s' % apnoeafile)
        if prefixfile:
                commandclass.read_internatprefixes(prefixfile)
        if parting_astid_context:
                commandclass.set_partings(parting_astid_context)
                
        for ctx in contextlist:
                xivoconf_context = cconf.read_section('context', ctx)
                if len(xivoconf_context) > 0:
                        if 'contextname' in xivoconf_context:
                                contextname = xivoconf_context['contextname']
                        if 'display' in xivoconf_context:
                                displaysection = xivoconf_context['display']
                                directorylist.setdisplay(contextname, cconf.read_section('displayitem', displaysection))
                        if 'directories' in xivoconf_context:
                                directories = xivoconf_context['directories'].split(',')
                                for dr in directories:
                                        xivoconf_dir = cconf.read_section('directory', dr)
                                        directorylist.update(contextname, dr, xivoconf_dir)
                                        
        save_for_next_packet_events = {}
        ip_reverse_webi = {}
        ip_reverse_sht = {}
        
        # loads the configuration for each asterisk
        for astid in asterisklist:
                xivoconf_asterisk = cconf.read_section('ipbx', astid)
                if len(xivoconf_asterisk) > 0:
                        localaddr = '127.0.0.1'
                        urllist = {}
                        ipaddress = '127.0.0.1'
                        ipaddress_webi = '127.0.0.1'
                        ami_port = 5038
                        ami_login = 'xivouser'
                        ami_pass = 'xivouser'
                        cdr_db_uri = userfeatures_db_uri = None
                        realm = 'asterisk'
                        parkingnumber = '700'
                        faxcallerid = 'faxcallerid'
                        linkestablished = ''
                        aoriginate = 'AOriginate'
                        url_queuelog = None
                        
                        if 'localaddr' in xivoconf_asterisk:
                                localaddr = xivoconf_asterisk['localaddr']
                        for listname in commandclass.weblist.keys():
                                fieldname = 'urllist_%s' % listname
                                if fieldname in xivoconf_asterisk:
                                        urllist[listname] = xivoconf_asterisk[fieldname].split(',')
                                else:
                                        urllist[listname] = []
                        if 'url_queuelog' in xivoconf_asterisk:
                                url_queuelog = xivoconf_asterisk['url_queuelog']
                        if 'ipaddress' in xivoconf_asterisk:
                                ipaddress = xivoconf_asterisk['ipaddress']
                        if 'ipaddress_webi' in xivoconf_asterisk:
                                ipaddress_webi = xivoconf_asterisk['ipaddress_webi']
                        if 'parkingnumber' in xivoconf_asterisk:
                                parkingnumber = int(xivoconf_asterisk['parkingnumber'])
                        if 'faxcallerid' in xivoconf_asterisk:
                                faxcallerid = int(xivoconf_asterisk['faxcallerid'])
                        if 'linkestablished' in xivoconf_asterisk:
                                linkestablished = xivoconf_asterisk['linkestablished']
                        if 'ami_port' in xivoconf_asterisk:
                                ami_port = int(xivoconf_asterisk['ami_port'])
                        if 'ami_login' in xivoconf_asterisk:
                                ami_login = xivoconf_asterisk['ami_login']
                        if 'ami_pass' in xivoconf_asterisk:
                                ami_pass = xivoconf_asterisk['ami_pass']
                        if 'userfeatures_db_uri' in xivoconf_asterisk:
                                userfeatures_db_uri = xivoconf_asterisk['userfeatures_db_uri']
                        if 'cdr_db_uri' in xivoconf_asterisk:
                                cdr_db_uri = xivoconf_asterisk['cdr_db_uri']
                        if 'realm' in xivoconf_asterisk:
                                realm = xivoconf_asterisk['realm']
                        if 'aoriginate' in xivoconf_asterisk:
                                aoriginate = xivoconf_asterisk['aoriginate']
                                
                        capafeatures = []
                        
                        configs[astid] = xivo_astcfg.AsteriskConfig(astid,
                                                                    localaddr,
                                                                    ipaddress,
                                                                    ipaddress_webi,
                                                                    ami_port,
                                                                    ami_login,
                                                                    ami_pass,
                                                                    userfeatures_db_uri,
                                                                    capafeatures,
                                                                    cdr_db_uri,
                                                                    realm,
                                                                    parkingnumber,
                                                                    faxcallerid,
                                                                    linkestablished,
                                                                    aoriginate)
                        
                        for ilist in commandclass.weblist.keys():
                                commandclass.set_urllist(astid, ilist, urllist[ilist])
                        t1 = time.time()
                        commandclass.read_queuelog(astid, url_queuelog)
                        t2 = time.time()
                        log.info('%s spent %f seconds to read queuelog file' % (astid, t2 - t1))
                        
                        if ipaddress not in ip_reverse_sht:
                                ip_reverse_sht[ipaddress] = astid
                        else:
                                log.warning('WARNING - IP address already exists for asterisk <%s> - can not set it for <%s>'
                                          % (ip_reverse_sht[ipaddress], astid))
                        if ipaddress_webi not in ip_reverse_webi:
                                ip_reverse_webi[ipaddress_webi] = astid
                        else:
                                log.warning('WARNING - IP address (WEBI) already exists for asterisk <%s> - can not set it for <%s>'
                                          % (ip_reverse_webi[ipaddress_webi], astid))
                        save_for_next_packet_events[astid] = ''
                        
        outsock = commandclass.extrasock(extraconn)
        
        fdlist_established = {}
        fdlist_listen_cti = {}
        fdlist_udp_cti = {}
        update_userlist = {}
        lastrequest_time = {}
        xivodaemonreload = False
        
        log.info("the monitored asterisk's is/are : %s" % asterisklist)
        log.info('# STARTING %s # (1/2) AMI socket connections + fetch Web Services' % xdname)
        
        for astid in configs:
                try:
                        update_userlist[astid] = False
                        lastrequest_time[astid] = time.time()
                        update_amisocks(astid)
                except Exception:
                        log.exception('%s : failed while setting lists and sockets' % astid)
        try:
                commandclass.updates() # users' update, ...
        except Exception:
                log.exception('commandclass.updates()')
                
        log.info('# STARTING %s # (2/2) listening sockets (CTI, WEBI, (F)AGI, INFO)' % xdname)
        # opens the listening socket for incoming (CTI, WEBI, (F)AGI, INFO) connections
        for portkind in incoming_tcp_ports:
                pk = portkind.split(':')
                port = pk[0]
                kind = 'INFO'
                bind = '127.0.0.1'
                nmax = '1'
                if len(pk) > 1:
                        kind = pk[1].strip()
                        if len(pk) > 2:
                                bind = pk[2].strip()
                                if len(pk) > 3:
                                        nmax = pk[3].strip()
                UIsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                UIsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                UIsock.bind((bind, int(port)))
                UIsock.listen(10)
                fdlist_listen_cti[UIsock] = '%s:%s' % (kind, nmax)
                
        for portkind in incoming_udp_ports:
                pk = portkind.split(':')
                port = pk[0]
                kind = 'INFO'
                bind = '127.0.0.1'
                nmax = '1'
                if len(pk) > 1:
                        kind = pk[1].strip()
                        if len(pk) > 2:
                                bind = pk[2].strip()
                                if len(pk) > 3:
                                        nmax = pk[3].strip()
                UIsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                UIsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                UIsock.bind((bind, int(port)))
                fdlist_udp_cti[UIsock] = '%s:%s' % (kind, nmax)
                
        # Main select() loop - Receive messages
        while not askedtoquit:
                try:
			fdtodel = []
			for cn in fdlist_established.keys():
				if isinstance(cn, ClientConnection):
                                        if cn.isClosed:
                                                fdtodel.append(cn)
                                        if cn.toClose and not cn.need_sending():
                                                cn.close()
                                                fdtodel.append(cn)
			if fdtodel:
				log.warning('there are fd to delete : %s' % fdtodel)
				for cn in fdtodel:
					del fdlist_established[cn]
                                        if cn in userinfo_by_requester:
                                                del userinfo_by_requester[cn]
                        fdlist_full = fdlist_listen_cti.keys() + fdlist_udp_cti.keys() + fdlist_established.keys()
                        fdlist_full.extend(amilist.fdlist())
                        fdlist_full.append(pipe_queued_threads_commandclass[0])
                        fdlist_full.append(pipe_queued_threads_main[0])
                        if outsock is not None:
                                fdlist_full.append(outsock)
                        writefds = []
                        for iconn, kind in fdlist_established.iteritems():
                                if kind == 'CTI' and iconn.need_sending():
                                        writefds.append(iconn)
                        [sels_i, sels_o, sels_e] = select.select(fdlist_full, writefds, [], updates_period)
                except Exception, exc:
                        log.exception('(select) probably Ctrl-C or daemon stop or daemon restart ...')
                        log.warning('(select) askedtoquit=%s fdlist_full=%s' % (askedtoquit, fdlist_full))
                        log.warning('(select) current open TCP connections : (CTI, WEBI, (F)AGI, INFO) %s' % fdlist_established)
                        log.warning('(select) current open TCP connections : (AMI) %s' % amilist.fdlist())
                        log.warning('(select) current open TCP connections : (OUT) %s' % outsock)
                        
                        if askedtoquit and apnoeafile:
                                try:
                                        tosave = commandclass.apnoea_tosave()
                                        e = open(apnoeafile, 'w')
                                        e.write(pickle.dumps(tosave))
                                        e.close()
                                except:
                                        log.exception('write apnoea file %s' % apnoeafile)
                                        
                        for s in fdlist_full:
                                if s in fdlist_established and fdlist_established[s] == 'CTI':
                                        if askedtoquit:
                                                commandclass.reset('stop', s)
                                        else:
                                                commandclass.reset('reload', s)
                                if isinstance(s, int):
                                        os.close(s)
                                else:
                                        s.close()
                                        
                        if askedtoquit:
                                commandclass.reset('stop')
                                time_uptime = int(time.time() - time.mktime(time_start))
                                log.info('# STOPPING XIVO Daemon %s (pid %d) / svn:%s # uptime %d s (since %s)'
                                         % (XIVOVERSION, os.getpid(), __revision__,
                                            time_uptime, time.asctime(time_start)))
                                for t in filter(lambda x: x.getName() != 'MainThread', threading.enumerate()):
                                        print '--- (stop) killing thread <%s>' % t.getName()
                                        t._Thread__stop()
                                daemonize.unlock_pidfile(PIDFILE)
                                sys.exit(5)
                        else:
                                commandclass.reset('reload')
                                askedtoquit = True
                                for t in filter(lambda x: x.getName() != 'MainThread', threading.enumerate()):
                                        print '--- (reload) the thread <%s> remains' % t.getName()
                                        # t._Thread__stop() # does not work in reload case (vs. stop case)
                                continue
                try:
                    # connexions ready for sending(writing)
                    for sel_o in sels_o:
                        try:
                            sel_o.process_sending()
                        except ClientConnection.CloseException, cexc:
                            if sel_o in userinfo_by_requester:
                                    userinfo = userinfo_by_requester.get(sel_o)
                                    commandclass.manage_logout(userinfo, 'end_sending')
                                    del userinfo_by_requester[sel_o]
                            log.info('TCP socket %s closed(sending %s) on %s' % (fdlist_established[sel_o],
                                                                                 cexc,
                                                                                 sel_o.getpeername()))
                            if sel_o in fdlist_established:
                                    del fdlist_established[sel_o]
                            commandclass.disconnected(sel_o)
                    if sels_i:
                        for sel_i in sels_i:
                                # these AMI connections are used in order to manage AMI commands and events
                                if sel_i in amilist.fdlist():
                                        try:
                                                buf = sel_i.readline()
                                                astid = amilist.astid(sel_i)
                                                if len(buf) == 0:
                                                        log.warning('%s AMI : CLOSING' % astid)
                                                        amilist.remove(astid)
                                                        sel_i.close()
                                                else:
                                                        if astid is not None:
                                                                try:
                                                                        handle_ami_event(astid, buf)
                                                                except Exception:
                                                                        log.exception('(handle_ami_event) %s' % astid)
                                        except Exception:
                                                log.exception('(amilist)')
                                                
                                # other 'outgoing' connections
                                elif sel_i == outsock:
                                        try:
                                                msg = sel_i.recv(BUFSIZE_LARGE, socket.MSG_DONTWAIT)
                                        except Exception:
                                                log.exception('outsock')
                                                msg = ''
                                        if len(msg) == 0:
                                                sel_i.close()
                                                outsock = None
                                                log.warning('WARNING - outsock has closed the connection')
                                        else:
                                                commandclass.handle_outsock(asterisklist[0], msg)
                                                
                                # the UDP messages (ANNOUNCE) are catched here
                                elif sel_i in fdlist_udp_cti:
                                        [kind, nmax] = fdlist_udp_cti[sel_i].split(':')
                                        if kind == 'ANNOUNCE':
                                                [data, sockparams] = sel_i.recvfrom(32768)
                                                if sockparams[0] in ip_reverse_sht:
                                                        astid = ip_reverse_sht.get(sockparams[0])
                                                else:
                                                        astid = 'xivo'
                                                log.info('UDP %s <%s> %s => %s' % (kind, data.strip(), sockparams, astid))
                                                if astid in configs:
                                                        # scheduling astid's AMI reconnection
                                                        k = threading.Timer(2, callback_timer_main, ('ipbxup', astid))
                                                        k.start()
                                        else:
                                                log.warning('unknown kind %s received' % kind)
                                                
                                # the new TCP connections (CTI, WEBI, (F)AGI, INFO) are catched here
                                elif sel_i in fdlist_listen_cti:
                                        [kind, nmax] = fdlist_listen_cti[sel_i].split(':')
                                        [connc, sockparams] = sel_i.accept()
                                        if kind == 'FAGI':
                                                if sockparams[0] in ip_reverse_sht:
                                                        astid = ip_reverse_sht.get(sockparams[0])
                                                else:
                                                        astid = 'xivo'
                                                log.info('TCP socket FAGI opened on %s:%d => %s' % (sockparams[0], sockparams[1], astid))
                                                mfr = connc.makefile('rb', -1)
                                                mfw = connc.makefile('wb', 0)
                                                try:
                                                        fagi = fastagi.FastAGI(mfr, mfw)
                                                        commandclass.handle_fagi(astid, fagi)
                                                except Exception:
                                                        log.exception('(fastagi) %s' % astid)
                                                mfr.close()
                                                mfw.close()
                                                connc.close()
                                                log.info('TCP socket FAGI closed on %s:%d' % (sockparams[0], sockparams[1]))
                                        else:
                                                log.info('TCP socket %s opened on %s:%d' % (kind,
                                                                                            sockparams[0], sockparams[1]))
                                                if kind == 'CTI':
                                                        connc = ClientConnection(connc, sockparams, commandclass.ctiseparator)
                                                        commandclass.connected(connc)
                                                # appending the opened socket to the ones watched
                                                # connc.setblocking(0)
                                                # connc.settimeout(2)
                                                fdlist_established[connc] = kind
                                                
                                # incoming TCP connections (CTI, WEBI, AGI, INFO)
                                elif sel_i in fdlist_established:
                                        try:
                                                kind = fdlist_established[sel_i]
                                                requester = '%s:%d' % sel_i.getpeername()
                                                if isinstance(sel_i, ClientConnection):
                                                    try:
                                                        while True:
                                                            line = sel_i.readline()
                                                            if line is None:
                                                                break
                                                            manage_tcp_connections(sel_i, line, kind)
                                                    except ClientConnection.CloseException, cexc:
                                                        if kind == 'CTI':
                                                            if sel_i in userinfo_by_requester:
                                                                userinfo = userinfo_by_requester.get(sel_i)
                                                                commandclass.manage_logout(userinfo, 'end_receiving')
                                                                del userinfo_by_requester[sel_i]
                                                        if sel_i in fdlist_established:
                                                                del fdlist_established[sel_i]
                                                        if requester in commandclass.transfers_ref:
                                                                commandclass.transfer_endbuf(requester)
                                                        log.info('TCP socket %s closed(A %s) on %s' % (kind, cexc, requester))
                                                        if kind == 'CTI':
                                                                commandclass.disconnected(sel_i)
                                                else:
                                                    closemenow = False
                                                    try:
                                                        msg = sel_i.recv(BUFSIZE_LARGE, socket.MSG_DONTWAIT)
                                                        lmsg = len(msg)
                                                    except Exception:
                                                        log.exception('connection to %s (%s)' % (requester, kind))
                                                        lmsg = 0
                                                    if lmsg > 0:
                                                        try:
                                                                closemenow = manage_tcp_connections(sel_i, msg, kind)
                                                        except Exception:
                                                                log.exception('handling %s (%s)' % (requester, kind))
                                                    else:
                                                        if kind == 'CTI':
                                                                if sel_i in userinfo_by_requester:
                                                                        userinfo = userinfo_by_requester.get(sel_i)
                                                                        commandclass.manage_logout(userinfo, 'end_receiving')
                                                                        del userinfo_by_requester[sel_i]
                                                    doclose = False
                                                    if kind == 'WEBI':
                                                        doclose = closemenow
                                                    elif kind not in ['CTI', 'INFO'] or lmsg == 0:
                                                        doclose = True
                                                    if doclose:
                                                        sel_i.close()
                                                        if sel_i in fdlist_established:
                                                                del fdlist_established[sel_i]
                                                        if requester in commandclass.transfers_ref:
                                                                commandclass.transfer_endbuf(requester)
                                                        log.info('TCP socket %s closed(B) on %s' % (kind, requester))
                                                        if kind == 'CTI':
                                                                 commandclass.disconnected(sel_i)
                                        except Exception:
                                                # socket.error : exc.args[0]
                                                log.exception('[%s] %s' % (kind, sel_i))
                                                try:
                                                        del fdlist_established[sel_i]
                                                        sel_i.close()
                                                        if sel_i in userinfo_by_requester:
                                                                userinfo = userinfo_by_requester.get(sel_i)
                                                                log.warning('logging off %s following unexpected socket breakup' % userinfo)
                                                                commandclass.manage_logout(userinfo, 'exc')
                                                                del userinfo_by_requester[sel_i]
                                                        else:
                                                                log.warning('could not find a match for socket %s' % sel_i)
                                                except Exception:
                                                        log.exception('[%s] (2nd exception)' % kind)
                                                        
                                # local pipe fd
                                elif pipe_queued_threads_commandclass[0] == sel_i:
                                        try:
                                                actionqueue = commandclass.checkqueue()
                                                for actionname, actionarg in actionqueue.iteritems():
                                                        if actionname == 'disconnlist-tcp':
                                                                # disconnect when timeout after first connection
                                                                disconnlist = actionarg
                                                                if disconnlist:
                                                                        log.warning('checkqueue return : should disconnect %d connections' % len(disconnlist))
                                                                        for connid in disconnlist:
                                                                                try:
                                                                                        commandclass.telldisconn(connid)
                                                                                except Exception:
                                                                                        log.exception('disconnlist-tcp')
                                                                                log.info('TCP socket %s closed(disconnlist) on %s'
                                                                                         % (fdlist_established[connid],
                                                                                            '%s:%d' % connid.getpeername()))
                                                                                del fdlist_established[connid]
                                                                                connid.close()
                                        except Exception:
                                                log.exception('[pipe_queued_threads_commandclass]')
                                                
                                elif pipe_queued_threads_main[0] == sel_i:
                                        try:
                                                checkqueue_main()
                                        except Exception:
                                                log.exception('[pipe_queued_threads_main]')
                                                
                                for astid in configs:
                                        if (time.time() - lastrequest_time[astid]) > updates_period or update_userlist[astid]:
                                                lastrequest_time[astid] = time.time()
                                                log.info('[%s] %s : updates (computed timeout) %s'
                                                          % (xdname, astid, time.asctime()))
                                                try:
                                                        if outsock is None:
                                                                outsock = commandclass.extrasock(extraconn)
                                                        update_amisocks(astid)
                                                        update_readconf()
                                                        commandclass.regular_update()
                                                        update_userlist[astid] = False
                                                except Exception:
                                                        log.exception('%s : failed while updating lists and sockets (computed timeout)' % astid)
                                                try:
                                                        commandclass.updates() # users' update, ...
                                                except Exception:
                                                        log.exception('commandclass.updates() (computed timeout)')
                                                        
                    else: # when nothing happens on the sockets, we fall here sooner or later
                        log.info('[%s] updates (select timeout) %s'
                                  % (xdname, time.asctime()))
                        try:
                                commandclass.updates() # users' update, ...
                        except Exception:
                                log.exception('commandclass.updates() (select timeout)')
                        for astid in configs:
                                lastrequest_time[astid] = time.time()
                                try:
                                        if outsock is None:
                                                outsock = commandclass.extrasock(extraconn)
                                        update_amisocks(astid)
                                        update_readconf()
                                        commandclass.regular_update()
                                except Exception:
                                        log.exception('%s : failed while updating lists and sockets (select timeout)' % astid)
                except Exception:
                        log.exception('main loop')
        log.info('after askedtoquit loop (%s)' % askedtoquit)

