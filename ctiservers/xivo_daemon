#!/usr/bin/python
# vim: set fileencoding=utf-8 :

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# Alternatively, XIVO Daemon is available under other licenses directly
# contracted with Pro-formatique SARL. See the LICENSE file at top of the
# source tree or delivered in the installable package in which XIVO Daemon
# is distributed for more details.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

__version__   = '$Revision$'
__date__      = '$Date$'
__copyright__ = 'Copyright (C) 2007-2010 Proformatique'
__author__    = 'Corentin Le Gall'

"""
# 1) General description of XIVO CTI Daemon
# The XIVO CTI Daemon is a general-purpose daemon, whose basic features are :
#  - the monitoring of one or more Asterisk, through AMI
#  - taking care of Asteriks AGI requests
#  - the ability to receive incoming "CTI clients" connections
#  - the ability to relay commands (between a Web interface and Asterisk)
#  - the connection to one or more databases (cdr, directory, ...)
#  - the connection to a given server
# 
# 2) Primary data structures
# 
#  - users list
#  - contexts/companies list
# 
#  - asterisk / configurations
#  - phonelist
#
# 3) Main loop
# The main loop is triggered by a select() on the file descriptors for :
# - the AMI Event sockets (AMIsocks)
# - the incoming TCP sockets (CTI, WEBI, INFO, (F)AGI)
#
# 4) Custom-defined Plugins
#
"""

__revision__ = __version__.split()[1]

# debian.org modules
import getopt
from optparse import OptionParser
import os
import pickle
import select
import signal
import socket
import string
import sys
import threading
import time
import logging
from logging.handlers import RotatingFileHandler
import Queue
from xivo_ctiservers.client_connection import ClientConnection

__alphanums__ = string.uppercase + string.lowercase + string.digits
waiting_actionid = {}
waiting_actionid_timer = {}
dumpami = False

LOGDAEMONNAME = 'cti-server'
try:
    DAEMONNAME = os.path.basename(sys.argv[0])
except:
    DAEMONNAME = 'xivo_daemon'

# XIVO lib-python modules initialization
#XIVO_CONF_FILE   = '/etc/pf-xivo/ctiservers/xivo_daemon.conf'
XIVO_CONF_FILE   = "https://localhost/service/ipbx/json.php/private/ctiserver/configuration"
PIDFILE          = '/var/run/%s.pid' % DAEMONNAME
LOGFILENAME      = '/var/log/pf-xivo-cti-server/daemon.log'
GETOPT_SHORTOPTS = 'dc:p:l:'
GETOPT_LONGOPTS  = ['debug', 'config=', 'pidfile=', 'logfile=']
debug_mode = False

def parse_command_line():
    global XIVO_CONF_FILE, PIDFILE, debug_mode
    for opt, arg in getopt.getopt( sys.argv[1:], GETOPT_SHORTOPTS, GETOPT_LONGOPTS)[0]:
        if opt == '-c':
            XIVO_CONF_FILE = arg
        elif opt == '-d':
            debug_mode = True
        elif opt == '-p':
            PIDFILE = arg
        elif opt == '-l':
            LOGFILENAME = arg

parse_command_line()

# XIVO lib-python modules imports
from xivo import anysql
from xivo.BackSQL import backmysql
from xivo.BackSQL import backsqlite

# XIVO CTI modules
from xivo_agid import fastagi
from xivo_ctiservers import xivo_ami
from xivo_ctiservers import xivo_contexts
from xivo_ctiservers import xivo_astcfg
from xivo_ctiservers import cti_config
from xivo_ctiservers import xivo_commandsets
from xivo_ctiservers.CommandSets import *
from xivo_ctiservers.xivo_commandsets import ctidaemonize as daemonize

BUFSIZE_LARGE = 8192
BUFSIZE_ANY = 512

XIVO_CLI_WEBI_HEADER = 'XIVO-CLI-WEBI'
XIVOVERSION = '1.1'

class manage_connection:
    ## \brief Deals with requests from the UI clients.
    # \param connid connection identifier
    # \param msg message to process
    # \param sep separator to split the message
    # \return none
    @staticmethod
    def manage_cti_connections(daemon, connid, msg, sep):
        """
        Handles CTI connections.
        """
        requester = '%s:%d' % connid.getpeername()
        if requester in daemon.commandclass.transfers_ref:
            daemon.commandclass.transfer_addbuf(requester, msg)
            return
        
        multimsg = msg.split(sep)
        for usefulmsgpart in multimsg:
            # remove tailing \r
            usefulmsg = usefulmsgpart.split('\r')[0]
            if len(usefulmsg) == 0:
                break
            command = daemon.commandclass.parsecommand(usefulmsg)
            if command.name in daemon.commandclass.get_list_commands():
                try:
                    commandtype_list = [xivo_commandsets.CMD_LOGIN_ID,
                                        xivo_commandsets.CMD_LOGIN_PASS,
                                        xivo_commandsets.CMD_LOGIN_CAPAS]
                    if command.type in commandtype_list:
                        # log.info('LOGIN(%s) %s : args   %s' % (command.type, requester, command.args))
                        loginparams = daemon.commandclass.get_login_params(command, daemon.asterisklist[0], connid)
                        # log.info('LOGIN(%s) %s : params %s' % (command.type, requester, loginparams))
                        uinfo = daemon.commandclass.manage_login(loginparams, command.type, daemon.userinfo_current.get(connid))
                        # log.info('LOGIN(%s) %s : uinfo  %s' % (command.type, requester, uinfo))
                        
                        if isinstance(uinfo, str):
                            daemon.commandclass.loginko(loginparams, uinfo, connid)
                            log.info('TCP socket %s closed(loginko) on %s' % (daemon.fdlist_established[connid],
                                                                              '%s:%d' % connid.getpeername()))
                            del daemon.fdlist_established[connid]
                            connid.close()
                        else:
                            if command.type == xivo_commandsets.CMD_LOGIN_CAPAS:
                                uinfo['login']['connection'] = connid
                                daemon.userinfo_by_requester[connid] = uinfo
                                if connid in daemon.userinfo_current:
                                    del daemon.userinfo_current[connid]
                            else:
                                daemon.userinfo_current[connid] = uinfo
                            daemon.commandclass.loginok(loginparams, uinfo, connid, command.type)
                    elif command.type == xivo_commandsets.CMD_TRANSFER:
                        log.info('TRANSFER on %s : %s' % (requester, command.struct))
                        daemon.commandclass.transfer_addref(connid, command.struct)
                    else:
                        if connid in daemon.userinfo_by_requester:
                            daemon.commandclass.manage_cticommand(daemon.userinfo_by_requester[connid], command)
                        else:
                            log.warning('unlogged %s is attempting a %s (TCP) : %s'
                                        % (requester, command.name, command.args))
                except Exception:
                    log.exception('CTI connection when managing [%s, %s] for %s'
                                  % (command.name, command.type, requester))
            else:
                connid.sendall('Unknown Command <%s>\n' % command.name)
    
    
    ## \brief Deals with requests from the UI clients.
    # \param connid connection identifier
    # \return none
    @staticmethod
    def manage_webi_connections(daemon, connid, msg, sep):
        """
        Handles WEBI connections.
        """
        requester = '%s:%d' % connid.getpeername()
        requester_ip = connid.getpeername()[0]
        closemenow = True
        
        if requester_ip not in daemon.ip_reverse_webi:
            connid.sendall('%s:KO <NOT ALLOWED>\n' % XIVO_CLI_WEBI_HEADER)
            return closemenow
        astid = daemon.ip_reverse_webi[requester_ip]
        
        multimsg = msg.split(sep)
        for usefulmsgpart in multimsg:
            usefulmsg = usefulmsgpart.split('\r')[0]
            if len(usefulmsg) == 0:
                break
            try:
                xivocmd_update_list = ['xivo[userlist,update]',
                                       'xivo[meetmelist,update]',
                                       'xivo[agentlist,update]',
                                       'xivo[queuelist,update]',
                                       'xivo[grouplist,update]']
                if usefulmsg in xivocmd_update_list:
                    if usefulmsg not in daemon.update_userlist[astid]:
                        daemon.update_userlist[astid].append(usefulmsg)
                        log.info('%s : WEBI requested %s (%s)' % (astid, usefulmsg, requester))
                    else:
                        log.info('%s : WEBI re-requested %s (%s)' % (astid, usefulmsg, requester))
                elif usefulmsg == 'xivo[daemon,reload]':
                    daemon.askedtoquit = True
                    log.info('%s : WEBI requested %s (%s)' % (astid, usefulmsg, requester))
                elif usefulmsg == 'xivo[ctiprofilelist,get]':
                    log.info('%s : WEBI requested %s (%s)' % (astid, usefulmsg, requester))
                    connid.sendall('%s:ID <%s>\n' % (XIVO_CLI_WEBI_HEADER, astid))
                    connid.sendall('%s\n' % daemon.commandclass.getprofilelist())
                    connid.sendall('%s:OK\n' % XIVO_CLI_WEBI_HEADER)
                elif astid in daemon.amilist.ami and daemon.amilist.ami[astid]:
                    stripped_usefulmsg = usefulmsg.strip()
                    try:
                        if stripped_usefulmsg == 'moh reload':
                            daemon.commandclass.pre_moh_reload()
                        elif stripped_usefulmsg == 'reload':
                            daemon.commandclass.pre_reload()
                    except Exception:
                        log.exception('(pre reloads (%s))' % stripped_usefulmsg)

                    closemenow = False

                    try:
                        actionid = daemon.amilist.execute(astid, 'sendcommand', 'Command', [('Command', stripped_usefulmsg)])
                        log.info('%s : WEBI requested a <%s> with actionid %s (%s)' % (astid, stripped_usefulmsg, actionid, connid))

                        waiting_actionid[actionid] = connid
                        waiting_actionid_timer[actionid] = threading.Timer(5, manage_connection.callback_timer_main, (daemon,('webirequest', actionid)))
                        waiting_actionid_timer[actionid].start()
                    except Exception, exc:
                        log.error('(%s) WEBI command exec <%s> : (client %s) : %s'
                                  % (astid, stripped_usefulmsg, requester, exc))
            except Exception, exc:
                log.error('(%s) WEBI <%s> : (client %s) : %s'
                          % (astid, usefulmsg.strip(), requester, exc))
                connid.sendall('%s:KO <Exception : %s>\n' % (XIVO_CLI_WEBI_HEADER, exc))
        return closemenow
    
    
    ## \brief Deals with requests from the UI clients.
    # \param connid connection identifier
    # \return none
    @staticmethod
    def manage_info_connections(daemon, connid, msg, sep):
        """
        Handles INFO connections (basic administration console,
        primarily aimed at displaying informations first).
        """
        global dumpami
        global log
        requester = '%s:%d' % connid.getpeername()
        multimsg = msg.replace('\r', '').split(sep)
        for usefulmsg in multimsg:
            if len(usefulmsg) == 0:
                break
            try:
                retstr = 'OK'
                show_command_list = ['show_phones', 'show_trunks',
                                     'show_queues', 'show_groups', 'show_agents',
                                     'show_incomingcalls', 'show_phonebook',
                                     'show_meetme', 'show_voicemail']
                if usefulmsg == 'help':
                    helptxt = ['',
                               'help                     : this help',
                               '-- general purpose commands --',
                               'show_infos               : gives a few informations about the daemon (version, uptime)',
                               '-- informations about misc lists --',
                               'show_users               : the users list',
                               'show_phones, show_trunks : phones and trunks lists',
                               'show_queues, show_groups,',
                               'show_agents              : call-center related lists',
                               'show_incomingcalls       : did lists',
                               'show_meetme              : conference rooms',
                               'show_voicemail           : voicemails',
                               'show_phonebook           : phonebook contents',
                               '-- selective lists --',
                               'show_logged              : only the logged users',
                               'show_logged_ip           : the human-readable IPs of logged users',
                               '-- for debugging purposes --',
                               'loglevel set <level>         : changes the syslog output level',
                               'show_varsizes <astid>        : gives the number of items of some variables',
                               'show_var <astid> <varname>   : outputs the contents of one such variable',
                               'dumpami enable               : enables the line-by-line display of AMI events',
                               'dumpami disable              : disables it',
                               '-- slightly advanced features --',
                               'kick <user>                  : disconnects the user <user>',
                               'disc <ip> <port>             : closes the socket linked to <ip>:<port> if present',
                               'ami <astid> <command> <args> : executes the CTI-defined AMI function on <astid>',
                               'reverse <dirname> <number>   : lookup the number in the given directory',
                               '']
                    for helpline in helptxt:
                        connid.sendall('%s\n' % helpline)
                elif usefulmsg == 'show_infos':
                    time_uptime = int(time.time() - time.mktime(daemon.time_start))
                    reply = 'infos=' \
                            'xivo_version=%s;' \
                            'server_version=%s;' \
                            'commandset=%s;' \
                            'commandset_version=%s;' \
                            'uptime=%d s' \
                            % (XIVOVERSION, __revision__,
                               daemon.xdname,
                               daemon.commandclass.version(),
                               time_uptime)
                    connid.sendall(reply + '\n')
                    # connid.sendall('server capabilities = %s\n' % (','.join()))
                elif usefulmsg == 'dumpami enable':
                    dumpami = True
                elif usefulmsg == 'dumpami disable':
                    dumpami = False
                elif usefulmsg.startswith('loglevel '):
                    command_args = usefulmsg.split()
                    if len(command_args) > 2:
                        action = command_args[1]
                        levelname = command_args[2]
                        levels = {'debug' : logging.DEBUG,
                                  'info' : logging.INFO,
                                  'warning' : logging.WARNING,
                                  'error' : logging.ERROR}
                        if action == 'set':
                            if levelname in levels:
                                newlevel = levels[levelname]
                                log.setLevel(logging.INFO)
                                log.info('=== setting loglevel to %s (%s) ===' % (levelname, newlevel))
                                log.setLevel(newlevel)
                                logging.getLogger('xivocti').setLevel(newlevel)
                                logging.getLogger('xivo_ami').setLevel(newlevel)
                                logging.getLogger('urllist').setLevel(newlevel)
                                connid.sendall('loglevel set to %s (%s)\n' % (levelname, newlevel))
                            else:
                                connid.sendall('unknown level name <%s> to set\n' % levelname)
                        elif action == 'get':
                            pass
                        else:
                            connid.sendall('unknown action <%s> for loglevel : try set or get\n' % action)
                elif usefulmsg == 'show_users':
                    for user, info in daemon.commandclass.users().iteritems():
                        try:
                            connid.sendall('%s %s\n' % (user.encode('latin1'), info))
                        except Exception:
                            log.exception('INFO %s' % usefulmsg)
                elif usefulmsg in show_command_list:
                    itemname = usefulmsg[5:]
                    for astid, itm in daemon.commandclass.getdetails(itemname).iteritems():
                        try:
                            connid.sendall('%s for %s\n' % (itemname, astid))
                            for id, idv in itm.keeplist.iteritems():
                                connid.sendall('%s %s\n' % (id, idv))
                        except Exception:
                            log.exception('INFO %s' % usefulmsg)
                elif usefulmsg.startswith('show_var '):
                    command_args = usefulmsg.split()
                    if len(command_args) > 2:
                        astid = command_args[1]
                        varname = command_args[2]
                        if hasattr(daemon.commandclass, varname):
                            tvar = getattr(daemon.commandclass, varname)
                            if astid in tvar:
                                connid.sendall('%s on %s\n' % (varname, astid))
                                for ag, agp in tvar[astid].iteritems():
                                    connid.sendall('%s %s\n' % (ag, agp))
                            else:
                                connid.sendall('no such astid %s\n' % astid)
                        else:
                            connid.sendall('no such variable %s\n' % varname)
                    else:
                        connid.sendall('first argument : astid value\n')
                        connid.sendall('second argument : one of %s\n' % daemon.commandclass.astid_vars)

                elif usefulmsg.startswith('show_varsizes '):
                    command_args = usefulmsg.split()
                    if len(command_args) > 1:
                        astid = command_args[1]
                        for varname in daemon.commandclass.astid_vars:
                            if hasattr(daemon.commandclass, varname):
                                tvar = getattr(daemon.commandclass, varname)
                                if astid in tvar:
                                    connid.sendall('%s on %s: %d\n' % (varname, astid, len(tvar[astid])))
                                else:
                                    connid.sendall('no such astid %s\n' % astid)
                            else:
                                connid.sendall('no such variable %s\n' % varname)
                    else:
                        connid.sendall('argument : astid value\n')

                elif usefulmsg == 'show_logged_ip':
                    for user, info in daemon.commandclass.connected_users().iteritems():
                        if 'connection' in info['login']:
                            try:
                                [ipaddr, ipport] = info['login']['connection'].getpeername()
                            except Exception:
                                log.exception('INFO %s' % usefulmsg)
                                [ipaddr, ipport] = ['err_addr', 'err_port']
                            connid.sendall('user %s : ip:port = %s:%s\n' % (user.encode('latin1'), ipaddr, ipport))
                elif usefulmsg == 'show_logged':
                    for user, info in daemon.commandclass.connected_users().iteritems():
                        try:
                            connid.sendall('%s %s\n' % (user.encode('latin1'), info))
                        except Exception:
                            log.exception('INFO %s' % usefulmsg)
                elif usefulmsg.startswith('reverse '):
                    command_args = usefulmsg.split()
                    if len(command_args) > 2:
                        dirnames = command_args[1]
                        numbers = command_args[2:]
                        for number in numbers:
                            reverses = daemon.commandclass.findreverse(dirnames, number)
                            for number, rep in reverses.iteritems():
                                connid.sendall('%s %s\n' % (number, rep))
                elif usefulmsg.startswith('disc '):
                    command_args = usefulmsg.split()
                    if len(command_args) > 2:
                        ipdef = tuple([command_args[1], int(command_args[2])])
                        socktoremove = None
                        for sockid in daemon.fdlist_established.keys():
                            if ipdef == sockid.getpeername():
                                socktoremove = sockid
                        if socktoremove:
                            connid.sendall('disconnecting %s (%s)\n'
                                           % (socktoremove.getpeername(), daemon.fdlist_established[socktoremove]))
                            socktoremove.close()
                            del daemon.fdlist_established[socktoremove]
                        else:
                            connid.sendall('nobody disconnected\n')
                elif usefulmsg == 'show_ami':
                    for astid, ami in daemon.amilist.ami.iteritems():
                        connid.sendall('commands : %s : %s\n' % (astid, ami))
                elif usefulmsg.startswith('ami '):
                    amicmd = usefulmsg.split()[1:]
                    if amicmd:
                        connid.sendall('ami request %s\n' % amicmd)
                        if len(amicmd) > 1:
                            astid = amicmd[0]
                            cmd = amicmd[1]
                            cmdargs = amicmd[2:]
                            daemon.amilist.execute(astid, cmd, *cmdargs)
                elif usefulmsg.startswith('kick '):
                    command_args = usefulmsg.split()
                    try:
                        if len(command_args) > 1:
                            kickuser = command_args[1]
                            if kickuser in daemon.commandclass.connected_users():
                                uinfo = daemon.commandclass.connected_users()[kickuser]
                                if 'login' in uinfo and 'connection' in uinfo.get('login'):
                                    cid = uinfo.get('login')['connection']
                                    if cid in daemon.fdlist_established:
                                        del daemon.fdlist_established[cid]
                                        cid.close()
                                        daemon.commandclass.manage_logout(uinfo, 'admin')
                                        del daemon.userinfo_by_requester[cid]
                                        connid.sendall('kicked %s\n' % kickuser)
                                    else:
                                        connid.sendall('did not kick %s (socket id not in daemon refs)\n' % kickuser)
                                else:
                                    connid.sendall('did not kick %s (no connection attributes for the user)\n' % kickuser)
                            else:
                                connid.sendall('did not kick %s (user not found)\n' % kickuser)
                        else:
                            connid.sendall('nobody to kick\n')
                    except Exception:
                        log.exception('INFO %s' % usefulmsg)
                        connid.sendall('(exception when trying to kick - see server log)\n')
                elif usefulmsg.startswith('%s:' % daemon.commandset):
                    daemon.commandclass.cliaction(connid, usefulmsg)
                else:
                    retstr = 'KO'

                connid.sendall('XIVO-INFO:%s\n' % retstr)
            except Exception:
                log.exception('INFO connection [%s] : KO when sending to %s'
                              % (usefulmsg, requester))
    
    @staticmethod
    def manage_tcp_connections(daemon, sel_i, msg, kind):
        """
        Dispatches the message's handling according to the connection's kind.
        """
        closemenow = True
        if kind == 'CTI':
            manage_connection.manage_cti_connections(daemon, sel_i, msg, daemon.commandclass.ctiseparator)
        elif kind == 'WEBI':
            closemenow = manage_connection.manage_webi_connections(daemon, sel_i, msg, '\n')
        elif kind == 'INFO':
            manage_connection.manage_info_connections(daemon, sel_i, msg, '\n')
        elif kind == 'AGI':
            agireply = daemon.commandclass.handle_agi(daemon.asterisklist[0], msg)
            if agireply is not None:
                sel_i.sendall(agireply)
        else:
            log.warning('unknown connection kind %s' % kind)
        return closemenow


    """
    Management of events that are spied on the AMI
    """
    ## \brief Handling of AMI events occuring in Events=on mode.
    # \param astid the asterisk Id
    # \param idata the data read from the AMI we want to parse
    # \return none
    @staticmethod
    def handle_ami_event(daemon, astid, idata):
        """
        Handles the AMI events occuring on Asterisk.
        If the Event field is there, calls the handle_ami_function() function.
        """
        if astid not in daemon.configs:
            log.info('%s : no such asterisk Id' % astid)
            return
        
        full_idata = daemon.save_for_next_packet_events[astid] + idata
        evlist = full_idata.split('\r\n\r\n')
        daemon.save_for_next_packet_events[astid] = evlist.pop()
        
        for evt in evlist:
            evt = evt.decode('utf8')
            this_event = {}
            nocolon = []
            for myline in evt.split('\r\n'):
                if myline.find('\n') < 0:
                    myfieldvalue = myline.split(': ', 1)
                    if len(myfieldvalue) == 2:
                        this_event[myfieldvalue[0]] = myfieldvalue[1]
                    else:
                        if myline.startswith('Asterisk Call Manager'):
                            log.info('%s : %s' % (astid, myline))
                        else:
                            log.warning('%s unable to parse %s' % (astid, myline))
                else:
                    nocolon.append(myline)

            if len(nocolon) > 1:
                log.warning('%s nocolon is %s' % (astid, nocolon))

            evfunction = this_event.get('Event')
            # log.info('%s AMI(all)  %s  : %s' % (astid, evfunction, this_event))
            if evfunction is not None:
                manage_connection.handle_ami_function(daemon, astid, evfunction, this_event)
                if evfunction not in ['Newexten', 'Newchannel', 'Newstate', 'Newcallerid']:
                    pass
                    # verboselog('%s %s' % (astid, this_event), True, False)
            else: # {
                response = this_event.get('Response')

                if response is not None:
                    if response == 'Follows' and this_event.get('Privilege') == 'Command':
                        if 'ActionID' in this_event:
                            actionid = this_event.get('ActionID')
                            connreply = waiting_actionid.get(actionid)
                            try:
                                if connreply is not None:
                                    connreply.sendall('%s:ID <%s>\n' % (XIVO_CLI_WEBI_HEADER, astid))
                                for noc in nocolon:
                                    arggs = noc.split('\n')
                                    for toremove in ['', '--END COMMAND--']:
                                        while toremove in arggs:
                                            arggs.remove(toremove)
                                    if arggs:
                                        if connreply is not None:
                                            log.info('%s AMI Response : %s : %s' % (astid, actionid, arggs))
                                            for argg in arggs:
                                                connreply.sendall(argg + '\n')
                                if connreply is not None:
                                    connreply.sendall('%s:OK\n' % XIVO_CLI_WEBI_HEADER)
                                    log.info('TCP socket %s closed(actionid-ok) on %s' % (daemon.fdlist_established[connreply],
                                                                                          '%s:%d' % connreply.getpeername()))
                                    del daemon.fdlist_established[connreply]
                                    connreply.close()
                                    del waiting_actionid[actionid]
                                    waiting_actionid_timer[actionid].cancel()
                                    del waiting_actionid_timer[actionid]
                            except Exception, e:
                                log.exception('%s (command reply to %s, %s)' % (astid, connreply, actionid))
                                print e
                        try:
                            daemon.commandclass.amiresponse_follows(astid, this_event, nocolon)
                        except Exception:
                            log.exception('%s amiresponse_follows (%s) (%s)' % (astid, this_event, nocolon))
                    elif response == 'Success':
                        try:
                            daemon.commandclass.amiresponse_success(astid, this_event, nocolon)
                        except Exception:
                            log.exception('%s amiresponse_success (%s) (%s)' % (astid, this_event, nocolon))
                    elif response == 'Error':
                        if 'ActionID' in this_event:
                            actionid = this_event.get('ActionID')
                            connreply = waiting_actionid.get(actionid)
                            try:
                                if connreply is not None:
                                    connreply.sendall('%s:ID <%s>\n' % (XIVO_CLI_WEBI_HEADER, astid))
                                    connreply.sendall('%s:KO\n' % XIVO_CLI_WEBI_HEADER)
                                    log.info('TCP socket %s closed(actionid-ko) on %s' % (daemon.fdlist_established[connreply],
                                                                                          '%s:%d' % connreply.getpeername()))
                                    del daemon.fdlist_established[connreply]
                                    connreply.close()
                                    del waiting_actionid[actionid]
                                    waiting_actionid_timer[actionid].cancel()
                                    del waiting_actionid_timer[actionid]
                            except Exception:
                                log.exception('%s (command reply to %s, %s)' % (astid, connreply, actionid))
                        try:
                            daemon.commandclass.amiresponse_error(astid, this_event, nocolon)
                        except Exception:
                            log.exception('%s amiresponse_error (%s) (%s)' % (astid, this_event, nocolon))
                    else:
                        log.warning('AMI %s Response=%s (untracked) : %s' % (astid, response, this_event))

                elif len(this_event) > 0:
                    log.warning('AMI:XXX: <%s> : %s' % (astid, this_event))
                else:
                    log.warning('AMI %s Other : %s' % (astid, this_event))
            # }
    
    
    evfunction_to_method_name = {
        'Registry':             'ami_registry',
        'Dial':                 'ami_dial',
        'Link':                 'ami_link',
        'Unlink':               'ami_unlink',
        'Bridge':               'ami_bridge',                   # (1.6) Seems to replace partly Link/Unlink events
        'Masquerade':           'ami_masquerade',               # (1.6 backported) for indirect transfers & intercepts
        'Hangup':               'ami_hangup',
        'HangupRequest':        'ami_hanguprequest',            # (xivo) to know who 'ordered' the hangup
        'Join':                 'ami_join',
        'Leave':                'ami_leave',
        'DTMF':                 'ami_dtmf',                     # (1.6 backported)
        'PeerStatus':           'ami_peerstatus',
        'Agentlogin':           'ami_agentlogin',
        'Agentlogoff':          'ami_agentlogoff',
        'Agentcallbacklogin':   'ami_agentcallbacklogin',
        'Agentcallbacklogoff':  'ami_agentcallbacklogoff',
        'AgentCalled':          'ami_agentcalled',
        'AgentComplete':        'ami_agentcomplete',
        'AgentsComplete':       'ami_agentscomplete',
        'AgentConnect':         'ami_agentconnect',
        'AgentDump':            'ami_agentdump',
        'Agents':               'ami_agents',
        'ChannelReload':        'ami_channelreload',            # (1.4)
        'ParkedCall':           'ami_parkedcall',               # when the requested parking is acked
        'UnParkedCall':         'ami_unparkedcall',
        'ParkedCallTimeOut':    'ami_parkedcalltimeout',
        'ParkedCallGiveUp':     'ami_parkedcallgiveup',
        'ParkedCallsComplete':  'ami_parkedcallscomplete',
        'DNDState':             'ami_dndstate',
        'Cdr':                  'ami_cdr',
        'Hold':                 'ami_hold',
        'Unhold':               'ami_unhold',
        'Alarm':                'ami_alarm',
        'AlarmClear':           'ami_alarmclear',
        'FaxSent':              'ami_faxsent',
        'FaxReceived':          'ami_faxreceived',
        'MeetmeJoin':           'ami_meetmejoin',               # when a member joins a conference
        'MeetmeNoAuthed':       'ami_meetmenoauthed',           # when a member was accepted or not by an admin
        'MeetmePause':          'ami_meetmepause',              # when a conf chamber is put in pause or activated
        'MeetmeLeave':          'ami_meetmeleave',              # when a member leaves a conference
        'MeetmeMute':           'ami_meetmemute',               # when a member is (un)muted
        'MeetmeTalking':        'ami_meetmetalking',
        'MeetmeList':           'ami_meetmelist',
        'MeetmeListComplete':   'ami_meetmelistcomplete',
        'Transfer':             'ami_transfer',                 # (1.6 backported)
        'ExtensionStatus':      'ami_extensionstatus',
        'OriginateSuccess':     'ami_originatesuccess',
        'AOriginateSuccess':    'ami_aoriginatesuccess',
        'OriginateFailure':     'ami_originatefailure',
        'AOriginateFailure':    'ami_aoriginatefailure',
        'OriginateResponse':    'ami_originateresponse',
        'Rename':               'ami_rename',                   # appears when there is a transfer
        'Newstate':             'ami_newstate',
        'Newcallerid':          'ami_newcallerid',              # useful for tricky managements
        'Newchannel':           'ami_newchannel',
        'Newexten':             'ami_newexten',                 # in order to handle outgoing calls ?
        'MessageWaiting':       'ami_messagewaiting',
        'QueueParams':          'ami_queueparams',
        'QueueMemberAdded':     'ami_queuememberadded',
        'QueueMemberPaused':    'ami_queuememberpaused',
        'QueueMemberRemoved':   'ami_queuememberremoved',
        'QueueMember':          'ami_queuemember',
        'QueueMemberStatus':    'ami_queuememberstatus',
        'QueueStatusComplete':  'ami_queuestatuscomplete',
        'QueueEntry':           'ami_queueentry',
        'QueueCallerAbandon':   'ami_queuecallerabandon',       # (1.4)
        'Status':               'ami_status',
        'StatusComplete':       'ami_statuscomplete',
        'Atxfer':               'ami_atxfer',                   #
    }
    
    
    @staticmethod
    def handle_ami_function(daemon, astid, evfunction, this_event):
        """
        Handles the AMI events related to a given function (i.e. containing the Event field).
        It roughly only dispatches them to the relevant commandset's methods.
        """
        try:
            if 'Privilege' in this_event:
                this_event.pop('Privilege')
            if dumpami:
                todisp = this_event
                if 'Event' in todisp:
                    efn = todisp.pop('Event')
                    for ik, iv in daemon.fdlist_established.iteritems():
                        if iv == 'INFO':
                            ik.sendall('%.3f %s %s %s\n' % (time.time(), astid, efn, todisp))
            if evfunction == 'Reload':
                log.warning('%s AMI:Reload %s' % (astid, this_event))
                daemon.commandclass.ami_reload(astid, this_event)
            elif evfunction == 'Shutdown':
                shutdown = this_event.get('Shutdown')
                restart  = this_event.get('Restart')
                log.warning('%s AMI:Shutdown (how=%s restart=%s)' % (astid, shutdown, restart))
                daemon.commandclass.ami_shutdown(astid, this_event)
            elif evfunction.startswith('UserEvent'):
                daemon.commandclass.ami_userevent(astid, this_event)
            elif (evfunction in manage_connection.evfunction_to_method_name):
                getattr(daemon.commandclass, manage_connection.evfunction_to_method_name[evfunction])(astid, this_event)
            else:
                log.warning('%s AMI ... this event (%s) is not tracked : %s' % (astid, evfunction, this_event))
    
        except Exception:
            log.exception('%s AMI / %s : event %s' % (astid, evfunction, this_event))
    
    
    
    
    @staticmethod
    def update_amisocks(astid, daemon):
        """
        Connects to the Asterisk's AMI (defined by astid) if not yet done.
        Requests a Status when it (re)connects.
        """
        try:
            daemon.amilist.setconfig(astid,
                              (daemon.configs[astid].remoteaddr,
                               daemon.configs[astid].ami_port),
                               daemon.configs[astid].ami_login,
                               daemon.configs[astid].ami_pass)
            daemon.amilist.connect(astid)
            daemon.amilist.set_aoriginate(astid, daemon.configs[astid].aoriginate)
    
        except Exception:
            log.exception('%s (update_amisocks) %s:%d' % (astid, daemon.configs[astid].remoteaddr, daemon.configs[astid].ami_port))
        return
    
    
    @staticmethod
    def callback_timer_main(*args):
        thisthread = threading.currentThread()
        daemon = args[0]
        tname = thisthread.getName()
        log.info('callback_timer_main (timer finished at %s) %s %s' % (time.asctime(), tname, args))
        thisthread.setName(tname + '-' + '-'.join(args[1]))
        daemon.tqueue.put(thisthread)
        os.write(pipe_queued_threads_main[1], thisthread.getName())
        return
    
    @staticmethod
    def checkqueue_main(daemon):
        buf = os.read(pipe_queued_threads_main[0], 1024)
        log.info('checkqueue_main : read buf = %s, tqueue size = %d' % (buf, daemon.tqueue.qsize()))
        while daemon.tqueue.qsize() > 0:
            thisthread = daemon.tqueue.get()
            action = thisthread.args[0]
            if action == 'ipbxup':
                # check whether the AMI is already connected,
                # and connects if needed
                astid = thisthread.args[1]
                manage_connection.update_amisocks(astid, daemon)
            elif action == 'webirequest':
                # checks whether the given actionid is still ongoing and closes
                # the related WEBI request then
                actionid = thisthread.args[1]
                if actionid in waiting_actionid and actionid in waiting_actionid_timer:
                    conn_to_close = waiting_actionid[actionid]
                    del daemon.fdlist_established[conn_to_close]
                    conn_to_close.close()
                    del waiting_actionid[actionid]
                    del waiting_actionid_timer[actionid]
                    log.info('closing the WEBI connection %s for the request %s' % (conn_to_close, actionid))
                else:
                    log.warning('the actionid %s has gone' % actionid)
        return




class xivo_daemon:
    # ==============================================================================
    # Main Code starts here
    # ==============================================================================
    def __init__(self):
        # print sys.getdefaultencoding()
        logging.basicConfig(level=logging.INFO)
        #logging.basicConfig(level=logging.DEBUG)
        
        global log

        log = logging.getLogger('main')
        
        try:
            logfilehandler = RotatingFileHandler(LOGFILENAME)
            formatter = logging.Formatter('%%(asctime)s %s[%%(process)d] (%%(levelname)s) (%%(name)s): %%(message)s'
                                          % LOGDAEMONNAME)
            logfilehandler.setFormatter(formatter)
            logging.getLogger('').addHandler(logfilehandler)
        
        except Exception:
            log.exception('logfilehandler')
        
        if not debug_mode:
            daemonize.daemonize()
        
        daemonize.lock_pidfile_or_die(PIDFILE)

        signal.signal(signal.SIGINT, self.sighandler)
        signal.signal(signal.SIGTERM, self.sighandler)
        signal.signal(signal.SIGHUP, self.sighandler_reload)
        
        self.nreload = 0
        self.directorylist = xivo_contexts.Contexts()
        self.configs = {}
        self.xdname = None
        self.tqueue = Queue.Queue()
        
        while True:
            try:
                self.main_loop()
            except Exception:
                # this will occur at server startup, when WEBI is not started yet
                # XXX this is a very naughty way, however, to handle that
                log.exception('main loop has crashed ... retrying in 5 seconds ...')
                time.sleep(5)
                
    ## \brief Handler for catching signals (in the main thread)
    # \param signum signal number
    # \param frame frame
    # \return none
    def sighandler(self, signum, frame):
        log.warning('(sighandler) signal %s (atq = %s) received : quits' % (signum, self.askedtoquit))
        for t in filter(lambda x: x.getName() != 'MainThread', threading.enumerate()):
            print '--- living thread <%s>' % (t.getName())
            t._Thread__stop()
        self.askedtoquit = True
    
    
    ## \brief Handler for catching signals (in the main thread)
    # \param signum signal number
    # \param frame frame
    # \return none
    def sighandler_reload(self, signum, frame):
        log.warning('(sighandler_reload) signal %s (atq = %s) received : reloads' % (signum, self.askedtoquit))
        self.askedtoquit = False

    
    def update_readconf(self):
        log.info('reparsing config file(s)')
        lconf = cti_config.Config(XIVO_CONF_FILE)
        self.commandclass.set_cticonfig(lconf)
        self.commandclass.set_options(self.cconf.read_section('commandset', self.commandset), self.cconf)

    # loads the configuration for each asterisk
    def load_asterisk_conf(self):   # {
        for astid in self.asterisklist:
            xivoconf_asterisk = self.cconf.read_section('ipbx', astid)
            if len(xivoconf_asterisk) > 0:
                localaddr = '127.0.0.1'
                urllist = {}
                ipaddress = '127.0.0.1'
                ipaddress_webi = '127.0.0.1'
                ami_port = 5038
                ami_login = 'xivouser'
                ami_pass = 'xivouser'
                cdr_db_uri = userfeatures_db_uri = None
                realm = 'asterisk'
                parkingnumber = '700'
                faxcallerid = 'faxcallerid'
                linkestablished = ''
                aoriginate = 'AOriginate'
                url_queuelog = None
                
                if 'localaddr' in xivoconf_asterisk:
                    localaddr = xivoconf_asterisk['localaddr']
                for listname in self.commandclass.weblist.keys():
                    fieldname = 'urllist_%s' % listname
                    if fieldname in xivoconf_asterisk:
                        urllist[listname] = xivoconf_asterisk[fieldname].split(',')
                    else:
                        urllist[listname] = []
                if 'url_queuelog' in xivoconf_asterisk:
                    url_queuelog = xivoconf_asterisk['url_queuelog']
                if 'ipaddress' in xivoconf_asterisk:
                    ipaddress = xivoconf_asterisk['ipaddress']
                if 'ipaddress_webi' in xivoconf_asterisk:
                    ipaddress_webi = xivoconf_asterisk['ipaddress_webi']
                if 'parkingnumber' in xivoconf_asterisk:
                    parkingnumber = int(xivoconf_asterisk['parkingnumber'])
                if 'faxcallerid' in xivoconf_asterisk:
                    faxcallerid = int(xivoconf_asterisk['faxcallerid'])
                if 'linkestablished' in xivoconf_asterisk:
                    linkestablished = xivoconf_asterisk['linkestablished']
                if 'ami_port' in xivoconf_asterisk:
                    ami_port = int(xivoconf_asterisk['ami_port'])
                if 'ami_login' in xivoconf_asterisk:
                    ami_login = xivoconf_asterisk['ami_login']
                if 'ami_pass' in xivoconf_asterisk:
                    ami_pass = xivoconf_asterisk['ami_pass']
                if 'userfeatures_db_uri' in xivoconf_asterisk:
                    userfeatures_db_uri = xivoconf_asterisk['userfeatures_db_uri']
                if 'cdr_db_uri' in xivoconf_asterisk:
                    cdr_db_uri = xivoconf_asterisk['cdr_db_uri']
                if 'realm' in xivoconf_asterisk:
                    realm = xivoconf_asterisk['realm']
                if 'aoriginate' in xivoconf_asterisk:
                    aoriginate = xivoconf_asterisk['aoriginate']
                        
                capafeatures = []
                
                self.configs[astid] = xivo_astcfg.AsteriskConfig(astid,
                                                                 localaddr,
                                                                 ipaddress,
                                                                 ipaddress_webi,
                                                                 ami_port,
                                                                 ami_login,
                                                                 ami_pass,
                                                                 userfeatures_db_uri,
                                                                 capafeatures,
                                                                 cdr_db_uri,
                                                                 realm,
                                                                 parkingnumber,
                                                                 faxcallerid,
                                                                 linkestablished,
                                                                 aoriginate)
                
                for ilist in self.commandclass.weblist.keys():
                    self.commandclass.set_urllist(astid, ilist, urllist[ilist])
    
                t1 = time.time()
                self.commandclass.read_queuelog(astid, url_queuelog)
                t2 = time.time()
    
                log.info('%s spent %f seconds to read queuelog file' % (astid, t2 - t1))
                
                if ipaddress not in self.ip_reverse_sht:
                    self.ip_reverse_sht[ipaddress] = astid
                else:
                    log.warning('WARNING - IP address already exists for asterisk <%s> - can not set it for <%s>' %
                                (self.ip_reverse_sht[ipaddress], astid))
                if ipaddress_webi not in self.ip_reverse_webi:
                    self.ip_reverse_webi[ipaddress_webi] = astid
                else:
                    log.warning('WARNING - IP address (WEBI) already exists for asterisk <%s> - can not set it for <%s>' %
                                (self.ip_reverse_webi[ipaddress_webi], astid))
    
                self.save_for_next_packet_events[astid] = ''
    # }
    
    def main_loop(self):    # {
        self.askedtoquit = False

        
        self.time_start = time.localtime()
        if self.nreload == 0:
            log.info('# STARTING XiVO Daemon %s (pid %d) / svn:%s # (0/3) Starting' %
                     (XIVOVERSION, os.getpid(), __revision__))
        else:
            log.info('# STARTING XiVO Daemon %s (pid %d) / svn:%s # (0/3) Reloading (%d)' %
                     (XIVOVERSION, os.getpid(), __revision__, self.nreload))
        self.nreload += 1
        
        # global default definitions
        incoming_tcp_ports = []
        incoming_udp_ports = []
        self.asterisklist = []
        contextlist = []
        userlists = []
        ctilog = None
        
        self.userinfo_by_requester = {}
        self.userinfo_current = {}
        
        self.cconf = cti_config.Config(XIVO_CONF_FILE)
        xivoconf_general = self.cconf.read_section('general', 'general')
        
        # loads the general configuration
        self.commandset = xivoconf_general.get('commandset', 'xivocti')
        if 'incoming_tcp_ports' in xivoconf_general:
            incoming_tcp_ports = xivoconf_general['incoming_tcp_ports'].split(',')
        if 'incoming_udp_ports' in xivoconf_general:
            incoming_udp_ports = xivoconf_general['incoming_udp_ports'].split(',')
        for func in ['CTI', 'WEBI', 'FAGI', 'INFO']:
            fieldname = 'incoming_tcp_%s' % func.lower()
            if fieldname in xivoconf_general:
                bind_and_port = xivoconf_general[fieldname].split(':')
                if len(bind_and_port) > 1:
                    try:
                        incoming_tcp_ports.append('%d:%s:%s' % (int(bind_and_port[1]), func, bind_and_port[0]))
                    except Exception:
                        log.exception('%s definition' % fieldname)
        for func in ['ANNOUNCE']:
            fieldname = 'incoming_udp_%s' % func.lower()
            if fieldname in xivoconf_general:
                bind_and_port = xivoconf_general[fieldname].split(':')
                if len(bind_and_port) > 1:
                    try:
                        incoming_udp_ports.append('%d:%s:%s' % (int(bind_and_port[1]), func, bind_and_port[0]))
                    except Exception:
                        log.exception('%s definition' % fieldname)
    
        self.extraconn = xivoconf_general.get('extraconn', '')
        self.updates_period = int(xivoconf_general.get('updates_period', '60'))
        ctilog = xivoconf_general.get('ctilog_db_uri')
        socktimeout = xivoconf_general.get('sockettimeout', '2')
        logintimeout = int(xivoconf_general.get('logintimeout', '5'))
        self.apnoeafile = xivoconf_general.get('apnoeafile')
        prefixfile = xivoconf_general.get('prefixfile')
        parting_astid_context = xivoconf_general.get('parting_astid_context')
        if 'asterisklist' in xivoconf_general:
            self.asterisklist = xivoconf_general['asterisklist'].split(',')
        if 'contextlist' in xivoconf_general:
            contextlist = xivoconf_general['contextlist'].split(',')
        if 'userlists' in xivoconf_general:
            userlists = xivoconf_general['userlists'].split(',')

        socket.setdefaulttimeout(float(socktimeout))
        
        self.pipe_queued_threads_commandclass = os.pipe()
        self.pipe_queued_threads_main = os.pipe()

        self.amilist = xivo_ami.AMIList()
        if self.commandset in xivo_commandsets.CommandClasses:
            self.commandclass = xivo_commandsets.CommandClasses[self.commandset](self.amilist,
                                                                                 incoming_tcp_ports,
                                                                                 self.pipe_queued_threads_commandclass)
        else:
            self.commandclass = xivo_commandsets.BaseCommand()
            log.warning('# STARTING %s : no such commandset <%s>' % (xdname, self.commandset))
            
        self.xdname = self.commandclass.xdname
        
        
        log.info('# STARTING %s / svn:%s / %d' % (self.xdname, self.commandclass.version(), self.nreload))
        
        self.update_readconf()
        self.commandclass.set_userlist_urls(userlists)
        self.commandclass.set_contextlist(self.directorylist)
        self.commandclass.set_configs(self.configs)
        self.commandclass.set_ctilog(ctilog)
        self.commandclass.set_logintimeout(logintimeout)
        
        if self.apnoeafile:
            try:
                e = open(self.apnoeafile, 'r')
                torescue = pickle.loads(e.read())
                e.close()
                self.commandclass.apnoea_rescue(torescue)
            except:
                log.exception('read apnoea file %s' % apnoeafile)
        if prefixfile:
            self.commandclass.read_internatprefixes(prefixfile)
        if parting_astid_context:
            self.commandclass.set_partings(parting_astid_context)
            
        for ctx in contextlist:
            xivoconf_context = self.cconf.read_section('context', ctx)
            if len(xivoconf_context) > 0:
                if 'contextname' in xivoconf_context:
                    contextname = xivoconf_context['contextname']
                if 'display' in xivoconf_context:
                    displaysection = xivoconf_context['display']
                    self.directorylist.setdisplay(contextname, self.cconf.read_section('displayitem', displaysection))
                if 'directories' in xivoconf_context:
                    directories = xivoconf_context['directories'].split(',')
                    for dr in directories:
                        try:
                            xivoconf_dir = self.cconf.read_section('directory', dr)
                            self.directorylist.update(contextname, dr, xivoconf_dir)
                        except Exception:
                            log.exception('unable to read directory config for %s' % dr)
        self.save_for_next_packet_events = {}
        self.ip_reverse_webi = {}
        self.ip_reverse_sht = {}
        
        
        self.load_asterisk_conf()
        
        
        self.outsock = self.commandclass.extrasock(self.extraconn)
        
        self.fdlist_established = {}
        self.fdlist_listen_cti = {}
        self.fdlist_udp_cti = {}
        self.update_userlist = {}
        self.lastrequest_time = {}
        xivodaemonreload = False
        
        log.info("the monitored asterisk's is/are : %s" % self.asterisklist)
        log.info('# STARTING %s # (1/2) AMI socket connections + fetch Web Services' % self.xdname)
        
        for astid in self.configs: # {
            try:
                self.update_userlist[astid] = []
                self.lastrequest_time[astid] = time.time()
                manage_connection.update_amisocks(astid, self)
            except Exception:
                log.exception('%s : failed while setting lists and sockets' % astid)        
                
            try:
                self.commandclass.updates(astid) # all updates ...
            except Exception:
                log.exception('%s : commandclass.updates()' % astid)
        # }
        
        log.info('# STARTING %s # (2/2) listening sockets (CTI, WEBI, (F)AGI, INFO)' % self.xdname)
        # opens the listening socket for incoming (CTI, WEBI, (F)AGI, INFO) connections
        for portkind in incoming_tcp_ports:
            pk = portkind.split(':')
            port = pk[0]
            kind = 'INFO'
            bind = '127.0.0.1'
            nmax = '1'
            if len(pk) > 1:
                kind = pk[1].strip()
                if len(pk) > 2:
                    bind = pk[2].strip()
                    if len(pk) > 3:
                        nmax = pk[3].strip()
            UIsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            UIsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            UIsock.bind((bind, int(port)))
            UIsock.listen(10)
            self.fdlist_listen_cti[UIsock] = '%s:%s' % (kind, nmax)
            
        for portkind in incoming_udp_ports:
            pk = portkind.split(':')
            port = pk[0]
            kind = 'INFO'
            bind = '127.0.0.1'
            nmax = '1'
            if len(pk) > 1:
                kind = pk[1].strip()
                if len(pk) > 2:
                    bind = pk[2].strip()
                    if len(pk) > 3:
                        nmax = pk[3].strip()
            UIsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            UIsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            UIsock.bind((bind, int(port)))
            self.fdlist_udp_cti[UIsock] = '%s:%s' % (kind, nmax)
            
        # Main select() loop - Receive messages
        while not self.askedtoquit:
            self.select_step()
    # }

    def select_step(self):  # {
        try:    # {
            fdtodel = []
            for cn in self.fdlist_established.keys():
                if isinstance(cn, ClientConnection):
                    if cn.isClosed:
                        fdtodel.append(cn)
                    if cn.toClose and not cn.need_sending():
                        cn.close()
                        fdtodel.append(cn)
            if fdtodel:
                log.warning('there are fd to delete : %s' % fdtodel)
                for cn in fdtodel:
                    del self.fdlist_established[cn]
                    if cn in self.userinfo_by_requester:
                        del self.userinfo_by_requester[cn]
            
            self.fdlist_full = self.fdlist_listen_cti.keys() + self.fdlist_udp_cti.keys() + self.fdlist_established.keys()
            self.fdlist_full.extend(self.amilist.fdlist())
            self.fdlist_full.append(self.pipe_queued_threads_commandclass[0])
            self.fdlist_full.append(self.pipe_queued_threads_main[0])
            if self.outsock is not None:
                self.fdlist_full.append(self.outsock)
            writefds = []
            for iconn, kind in self.fdlist_established.iteritems():
                if kind == 'CTI' and iconn.need_sending():
                    writefds.append(iconn)
            [sels_i, sels_o, sels_e] = select.select(self.fdlist_full, writefds, [], self.updates_period)
        # }
        except Exception, exc:  # {
            log.exception('(select) probably Ctrl-C or daemon stop or daemon restart ...')
            log.warning('(select) self.askedtoquit=%s fdlist_full=%s' % (self.askedtoquit, self.fdlist_full))
            log.warning('(select) current open TCP connections : (CTI, WEBI, (F)AGI, INFO) %s' % self.fdlist_established)
            log.warning('(select) current open TCP connections : (AMI) %s' % self.amilist.fdlist())
            log.warning('(select) current open TCP connections : (OUT) %s' % self.outsock)

            if self.askedtoquit and self.apnoeafile:
                try:
                    tosave = self.commandclass.apnoea_tosave()
                    e = open(self.apnoeafile, 'w')
                    e.write(pickle.dumps(tosave))
                    e.close()
                except:
                    log.exception('write apnoea file %s' % self.apnoeafile)

            for s in self.fdlist_full:
                if s in self.fdlist_established and self.fdlist_established[s] == 'CTI':
                    if self.askedtoquit:
                        self.commandclass.reset('stop', s)
                    else:
                        self.commandclass.reset('reload', s)
                if isinstance(s, int):
                    os.close(s)
                else:
                    s.close()
                    
            if self.askedtoquit:
                self.commandclass.reset('stop')
                time_uptime = int(time.time() - time.mktime(self.time_start))
                log.info('# STOPPING XiVO Daemon %s (pid %d) / svn:%s # uptime %d s (since %s)'
                         % (XIVOVERSION, os.getpid(), __revision__,
                            time_uptime, time.asctime(self.time_start)))
                for t in filter(lambda x: x.getName() != 'MainThread', threading.enumerate()):
                    print '--- (stop) killing thread <%s>' % t.getName()
                    t._Thread__stop()
                daemonize.unlock_pidfile(PIDFILE)
                sys.exit(5)
            else:
                self.commandclass.reset('reload')
                self.askedtoquit = True
                for t in filter(lambda x: x.getName() != 'MainThread', threading.enumerate()):
                    print '--- (reload) the thread <%s> remains' % t.getName()
                    # t._Thread__stop() # does not work in reload case (vs. stop case)
                return
        # }
        try:    # {
            # connexions ready for sending(writing)
            for sel_o in sels_o:
                try:
                    sel_o.process_sending()
                except ClientConnection.CloseException, cexc:
                    if sel_o in self.userinfo_by_requester:
                        userinfo = self.userinfo_by_requester.get(sel_o)
                        self.commandclass.manage_logout(userinfo, 'end_sending')
                        del self.userinfo_by_requester[sel_o]

                    log.info('TCP socket %s closed(sending %s) on %s' % (self.fdlist_established[sel_o], cexc, sel_o.getpeername()))

                    if sel_o in self.fdlist_established:
                        del self.fdlist_established[sel_o]

                    self.commandclass.disconnected(sel_o)

            if sels_i:  # {
                for sel_i in sels_i: # {
                    # these AMI connections are used in order to manage AMI commands and events
                    if sel_i in self.amilist.fdlist():
                        try:
                            buf = sel_i.readline()
                            astid = self.amilist.astid(sel_i)
                            if len(buf) == 0:
                                log.warning('%s AMI : CLOSING' % astid)
                                self.amilist.remove(astid)
                                sel_i.close()
                            else:
                                if astid is not None:
                                    try:
                                        manage_connection.handle_ami_event(self, astid, buf)
                                    except Exception:
                                        log.exception('(handle_ami_event) %s' % astid)
                        except Exception:
                            log.exception('(amilist)')

                    # other 'outgoing' connections
                    elif sel_i == self.outsock: # {
                        try:
                            msg = sel_i.recv(BUFSIZE_LARGE, socket.MSG_DONTWAIT)
                        except Exception:
                            log.exception('outsock')
                            msg = ''

                        if len(msg) == 0:
                            sel_i.close()
                            self.outsock = None
                            log.warning('WARNING - outsock has closed the connection')
                        else:
                            self.commandclass.handle_outsock(self.asterisklist[0], msg)

                    # } the UDP messages (ANNOUNCE) are catched here
                    elif sel_i in self.fdlist_udp_cti: # {
                        [kind, nmax] = self.fdlist_udp_cti[sel_i].split(':')
                        if kind == 'ANNOUNCE':
                            [data, sockparams] = sel_i.recvfrom(32768)
                            if sockparams[0] in self.ip_reverse_sht:
                                astid = self.ip_reverse_sht.get(sockparams[0])
                            else:
                                astid = 'xivo'
                            log.info('UDP %s <%s> %s => %s' % (kind, data.strip(), sockparams, astid))
                            if astid in self.configs:
                                # scheduling astid's AMI reconnection
                                k = threading.Timer(2, manage_connection.callback_timer_main, (daemon, ('ipbxup', astid)))
                                k.start()
                        else:
                            log.warning('unknown kind %s received' % kind)

                    # } the new TCP connections (CTI, WEBI, (F)AGI, INFO) are catched here
                    elif sel_i in self.fdlist_listen_cti: # {
                        [kind, nmax] = self.fdlist_listen_cti[sel_i].split(':')
                        [connc, sockparams] = sel_i.accept()
                        if kind == 'FAGI':
                            if sockparams[0] in self.ip_reverse_sht:
                                astid = self.ip_reverse_sht.get(sockparams[0])
                            else:
                                astid = 'xivo'
                            log.info('TCP socket FAGI opened on %s:%d => %s' % (sockparams[0], sockparams[1], astid))
                            mfr = connc.makefile('rb', -1)
                            mfw = connc.makefile('wb', 0)
                            try:
                                fagi = fastagi.FastAGI(mfr, mfw)
                                self.commandclass.handle_fagi(astid, fagi)
                            except Exception:
                                log.exception('(fastagi) %s' % astid)
                            mfr.close()
                            mfw.close()
                            connc.close()
                            log.info('TCP socket FAGI closed on %s:%d' % (sockparams[0], sockparams[1]))
                        else:
                            log.info('TCP socket %s opened on %s:%d' % (kind,
                                                                        sockparams[0], sockparams[1]))
                            if kind == 'CTI':
                                connc = ClientConnection(connc, sockparams, self.commandclass.ctiseparator)
                                self.commandclass.connected(connc)
                            # appending the opened socket to the ones watched
                            # connc.setblocking(0)
                            # connc.settimeout(2)
                            self.fdlist_established[connc] = kind

                    # } incoming TCP connections (CTI, WEBI, AGI, INFO)
                    elif sel_i in self.fdlist_established: # {
                        try: # {
                            kind = self.fdlist_established[sel_i]
                            requester = '%s:%d' % sel_i.getpeername()
                            if isinstance(sel_i, ClientConnection):
                                try:
                                    while True:
                                        line = sel_i.readline()
                                        if line is None:
                                            break
                                        manage_connection.manage_tcp_connections(self, sel_i, line, kind)
                                except ClientConnection.CloseException, cexc:
                                    if kind == 'CTI':
                                        if sel_i in self.userinfo_by_requester:
                                            userinfo = self.userinfo_by_requester.get(sel_i)
                                            self.commandclass.manage_logout(userinfo, 'end_receiving')
                                            del self.userinfo_by_requester[sel_i]
                                    if sel_i in self.fdlist_established:
                                        del self.fdlist_established[sel_i]
                                    if requester in self.commandclass.transfers_ref:
                                        self.commandclass.transfer_endbuf(requester)
                                    log.info('TCP socket %s closed(A %s) on %s' % (kind, cexc, requester))
                                    if kind == 'CTI':
                                        self.commandclass.disconnected(sel_i)
                            else: # {
                                closemenow = False

                                try:
                                    msg = sel_i.recv(BUFSIZE_LARGE, socket.MSG_DONTWAIT)
                                    lmsg = len(msg)
                                except Exception:
                                    log.exception('connection to %s (%s)' % (requester, kind))
                                    lmsg = 0

                                if lmsg > 0:
                                    try:
                                        closemenow = manage_connection.manage_tcp_connections(self, sel_i, msg, kind)
                                    except Exception:
                                        log.exception('handling %s (%s)' % (requester, kind))
                                        
                                else:
                                    if kind == 'CTI':
                                        if sel_i in self.userinfo_by_requester:
                                            userinfo = self.userinfo_by_requester.get(sel_i)
                                            self.commandclass.manage_logout(userinfo, 'end_receiving')
                                            del self.userinfo_by_requester[sel_i]
                                doclose = False
                                if kind == 'WEBI':
                                    doclose = closemenow
                                elif kind not in ['CTI', 'INFO'] or lmsg == 0:
                                    doclose = True
                                if doclose:
                                    sel_i.close()
                                    if sel_i in self.fdlist_established:
                                        del self.fdlist_established[sel_i]
                                    if requester in self.commandclass.transfers_ref:
                                        self.commandclass.transfer_endbuf(requester)
                                    log.info('TCP socket %s closed(B) on %s' % (kind, requester))
                                    if kind == 'CTI':
                                        self.commandclass.disconnected(sel_i)
                            # }
                        # }
                        except Exception:
                            # socket.error : exc.args[0]
                            log.exception('[%s] %s' % (kind, sel_i))
                            try:
                                del self.fdlist_established[sel_i]
                                sel_i.close()
                                if sel_i in self.userinfo_by_requester:
                                    userinfo = self.userinfo_by_requester.get(sel_i)
                                    log.warning('logging off %s following unexpected socket breakup' % userinfo)
                                    self.commandclass.manage_logout(userinfo, 'exc')
                                    del self.userinfo_by_requester[sel_i]
                                else:
                                    log.warning('could not find a match for socket %s' % sel_i)
                            except Exception:
                                log.exception('[%s] (2nd exception)' % kind)

                    # }
                    # local pipe fd
                    elif self.pipe_queued_threads_commandclass[0] == sel_i: # {
                        try:
                            actionqueue = self.commandclass.checkqueue()
                            for actionname, actionarg in actionqueue.iteritems():
                                if actionname == 'disconnlist-tcp':
                                    # disconnect when timeout after first connection
                                    disconnlist = actionarg
                                    if disconnlist:
                                        log.warning('checkqueue return : should disconnect %d connections' % len(disconnlist))
                                        for connid in disconnlist:
                                            try:
                                                self.commandclass.telldisconn(connid)
                                            except Exception:
                                                log.exception('disconnlist-tcp')

                                            log.info('TCP socket %s closed(disconnlist) on %s'
                                                     % (self.fdlist_established[connid],
                                                        '%s:%d' % connid.getpeername()))
                                            del self.fdlist_established[connid]
                                            connid.close()
                        except Exception:
                            log.exception('[pipe_queued_threads_commandclass]')

                    # }
                    elif pipe_queued_threads_main[0] == sel_i: # {
                        try:
                            checkqueue_main(self)
                        except Exception:
                            log.exception('[pipe_queued_threads_main]')

                    # }
                    try:
                        userdiscolist = self.commandclass.disconnlist
                        if userdiscolist:
                            log.warning('commandclass.disconnlist : should disconnect %d users' % len(userdiscolist))
                            for userinfo in userdiscolist:
                                log.warning('checkqueue return : will disconnect %s' % userinfo)
                                if 'login' in userinfo and 'connection' in userinfo.get('login'): 
                                    connid = userinfo.get('login')['connection']
                                    if connid in self.fdlist_established:
                                        del self.fdlist_established[connid]
                                    else:
                                        log.warning('connid %s no more in fdlists' % connid)

                                    self.commandclass.manage_logout(userinfo, 'pipe')
                                    del self.userinfo_by_requester[connid]

                                    if not connid.isClosed:
                                        connid.close()
                                else:
                                    log.warning('WARNING - no login/connection field present in userinfo')
                        self.commandclass.clear_disconnlist()
                    except Exception:
                        log.exception('userdiscolist')

                    for astid in self.configs: # {
                        if (time.time() - self.lastrequest_time[astid]) > self.updates_period or self.update_userlist[astid]:
                            self.lastrequest_time[astid] = time.time()
                            log.info('[%s] %s : updates (computed timeout) %s (%s)'
                                     % (self.xdname, astid, time.asctime(), self.update_userlist[astid]))
                            try:
                                if self.outsock is None:
                                    self.outsock = self.commandclass.extrasock(self.extraconn)
                                manage_connection.update_amisocks(astid, self)
                                self.update_readconf()
                                self.commandclass.regular_update()
                            except Exception:
                                log.exception('%s : failed while updating lists and sockets (computed timeout)' % astid)
                            try:
                                if self.update_userlist[astid]:
                                    while self.update_userlist[astid]:
                                        listtorequest = self.update_userlist[astid].pop()
                                        self.commandclass.updates(astid, listtorequest)
                                else:
                                    self.commandclass.updates(astid) # all updates ...
                            except Exception:
                                log.exception('%s : commandclass.updates() (computed timeout)' % astid)
                    # }
                # }
            # }
            else: # { when nothing happens on the sockets, we fall here sooner or later
                log.info('[%s] updates (select timeout) %s'
                          % (self.xdname, time.asctime()))
                for astid in self.configs:
                    try:
                        self.commandclass.updates(astid) # all updates ...
                    except Exception:
                        log.exception('%s : commandclass.updates() (select timeout)' % astid)
                        
                    self.lastrequest_time[astid] = time.time()
                    
                    try:
                        if self.outsock is None:
                            self.outsock = self.commandclass.extrasock(self.extraconn)
                        manage_connection.update_amisocks(astid, self)
                        self.update_readconf()
                        self.commandclass.regular_update()
                    except Exception:
                        log.exception('%s : failed while updating lists and sockets (select timeout)' % astid)
                # }
            # }
        # }
        except Exception:
            log.exception('select step')
    # }


main = xivo_daemon()
