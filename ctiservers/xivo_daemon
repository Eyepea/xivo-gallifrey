#!/usr/bin/python

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Alternatively, XIVO Daemon is available under other licenses directly
# contracted with Pro-formatique SARL. See the LICENSE file at top of the
# source tree or delivered in the installable package in which XIVO Daemon
# is distributed for more details.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, you will find one at
# <http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>.

__version__   = '$Revision$'
__date__      = '$Date$'
__copyright__ = 'Copyright (C) 2007, 2008, Proformatique'
__author__    = 'Corentin Le Gall'

"""
# 1) General description of XIVO CTI Daemon
# The XIVO CTI Daemon is a general-purpose daemon, whose basic features are :
#  - the monitoring of one or more Asterisk, through AMI
#  - taking care of Asteriks AGI requests
#  - the ability to receive incoming "CTI clients" connections
#  - the ability to relay commands (between a Web interface and Asterisk)
#  - the connection to one or more databases (cdr, directory, ...)
#  - the connection to a given server
# 
# 2) Primary data structures
# 
#  - users list
#  - contexts/companies list
# 
#  - asterisk / configurations
#  - phonelist
#
# 3) Main loop
# The main loop is triggered by a select() on the file descriptors for :
# - the AMI Event sockets (AMIsocks)
# - the incoming TCP sockets (CTI, WEBI, INFO, (F)AGI)
#
# 4) Custom-defined Plugins
#
"""

__revision__ = __version__.split()[1]

# debian.org modules
import getopt
import os
import select
import signal
import socket
import sys
import threading
import time

try:
        daemonname = os.path.basename(sys.argv[0])
except:
        daemonname = 'xivo_daemon'

# XIVO lib-python modules initialization
xivoconffile            = '/etc/asterisk/%s.conf' % daemonname
GETOPT_SHORTOPTS        = 'dc:'
GETOPT_LONGOPTS         = ["debug", "config="]
debug_mode = False
def config_path():
        global xivoconffile, debug_mode
        for opt, arg in getopt.getopt(
                sys.argv[1:],
                GETOPT_SHORTOPTS,
                GETOPT_LONGOPTS
                )[0]:
                if opt == "-c":
                        xivoconffile = arg
		elif opt == "-d":
			debug_mode = True
config_path()

# XIVO lib-python modules imports
from xivo import agitb
from xivo import daemonize
from xivo import except_tb
from xivo.easyslog import *
from xivo import anysql
from xivo.BackSQL import backmysql
from xivo.BackSQL import backsqlite

# XIVO CTI modules
## from xivo_agid import fastagi
from xivo_ctiservers import xivo_ami
from xivo_ctiservers import xivo_phones
from xivo_ctiservers import xivo_contexts
from xivo_ctiservers import xivo_commandsets
from xivo_ctiservers import xivo_astcfg
from xivo_ctiservers import cti_config
from xivo_ctiservers import cti_userlist
from xivo_ctiservers.xivo_log import *
from xivo_ctiservers.CommandSets import *

PIDFILE = '/var/run/%s.pid' % daemonname
# TODO: command line parameter

BUFSIZE_LARGE = 8192
BUFSIZE_ANY = 512

socket.setdefaulttimeout(2)
XIVO_CLI_WEBI_HEADER = 'XIVO-CLI-WEBI'
XIVOVERSION = '0.4'

def log_debug(a, b):
        log_debug_file(a, b, 'main')

## \brief Deals with requests from the UI clients.
# \param connid connection identifier
# \param msg message to process
# \param sep separator to split the message
# \return none
def manage_cti_connections(connid, msg, sep):
        """
        Handles CTI connections.
        """
        requester_ip = connid.getpeername()[0]
        requester_port = connid.getpeername()[1]
        requester = '%s:%d' % (requester_ip, requester_port)

        multimsg = msg.split(sep)
        for usefulmsgpart in multimsg:
                usefulmsg = usefulmsgpart.split('\r')[0]
                if len(usefulmsg) == 0:
                        break
                command = commandclass.parsecommand(usefulmsg)
                if command.name in commandclass.get_list_commands():
                        try:
                                if command.type == xivo_commandsets.CMD_LOGIN:
                                        loginparams = commandclass.get_login_params(asterisklist[0], command, connid)
                                        uinfo = commandclass.manage_login(loginparams)
                                        if uinfo.__class__.__name__ == 'str':
                                                commandclass.loginko(loginparams, uinfo, connid)
                                        else:
                                                uinfo['login']['connection'] = connid
                                                commandclass.loginok(loginparams, uinfo)
                                                userinfo_by_requester[connid] = uinfo
                                else:
                                        if connid in userinfo_by_requester:
                                                commandclass.manage_cticommand(userinfo_by_requester[connid],
                                                                               connid,
                                                                               command)
                                        else:
                                                log_debug(SYSLOG_WARNING, "unlogged %s is attempting a %s (TCP) : %s" %(requester, command.name, str(command.args)))
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- CTI connection when managing [%s] for %s : %s'
                                          %(command.name, requester, str(exc)))
                else:
                        connid.sendall('Unknown Command <%s>\n' % command.name)


## \brief Deals with requests from the UI clients.
# \param connid connection identifier
# \return none
def manage_webi_connections(connid, msg, sep):
        """
        Handles WEBI connections.
        """
        global askedtoquit
        requester_ip = connid.getpeername()[0]
        requester_port = connid.getpeername()[1]
        requester = '%s:%d' % (requester_ip, requester_port)

        multimsg = msg.split(sep)
        for usefulmsgpart in multimsg:
                usefulmsg = usefulmsgpart.split('\r')[0]
                if len(usefulmsg) == 0:
                        break
                if requester_ip in ip_reverse_webi:
                        try:
                                astid = ip_reverse_webi[requester_ip]
                                connid.sendall('%s:ID <%s>\n' %(XIVO_CLI_WEBI_HEADER, astid))
                                if usefulmsg == 'xivo[userlist,update]':
                                        update_userlist[astid] = True
                                        connid.sendall('%s:OK\n' %(XIVO_CLI_WEBI_HEADER))
                                        log_debug(SYSLOG_INFO, '%s : userlist update request received' % astid)
                                elif usefulmsg == 'xivo[daemon,reload]':
                                        askedtoquit = True
                                        connid.sendall('%s:OK\n' %(XIVO_CLI_WEBI_HEADER))
                                        log_debug(SYSLOG_INFO, '%s : daemon reload request received' % astid)
                                elif astid in AMI_array_user_commands and AMI_array_user_commands[astid]:
                                        stripped_usefulmsg = usefulmsg.strip()
                                        try:
                                                if stripped_usefulmsg == 'moh reload':
                                                        commandclass.pre_moh_reload()
                                                elif stripped_usefulmsg == 'reload':
                                                        commandclass.pre_reload()
                                        except Exception, exc:
                                                log_debug(SYSLOG_ERR, '--- exception --- (pre reloads) : %s' % str(exc))

                                        try:
                                                s = AMI_array_user_commands[astid].execclicommand(stripped_usefulmsg)
                                        except Exception, exc:
                                                log_debug(SYSLOG_ERR, '--- exception --- (%s) WEBI command exec <%s> : (client %s) : %s'
                                                          %(astid, str(stripped_usefulmsg), requester, str(exc)))
                                        try:
                                                for x in s:
                                                        connid.sendall(x)
                                                connid.sendall('%s:OK\n' %(XIVO_CLI_WEBI_HEADER))
                                        except Exception, exc:
                                                log_debug(SYSLOG_ERR, '--- exception --- (%s) WEBI command reply <%s> : (client %s) : %s'
                                                          %(astid, str(stripped_usefulmsg), requester, str(exc)))
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- (%s) WEBI <%s> : (client %s) : %s'
                                          %(astid, str(usefulmsg.strip()), requester, str(exc)))
                                connid.sendall('%s:KO <Exception : %s>\n' %(XIVO_CLI_WEBI_HEADER, str(exc)))
                else:
                        connid.sendall('%s:KO <NOT ALLOWED>\n' %(XIVO_CLI_WEBI_HEADER))


## \brief Deals with requests from the UI clients.
# \param connid connection identifier
# \return none
def manage_info_connections(connid, msg, sep):
        """
        Handles INFO connections (basic administration console,
        primarily aimed at displaying informations first).
        """
        requester = '%s:%d' % (connid.getpeername()[0], connid.getpeername()[1])
        multimsg = msg.replace('\r', '').split(sep)
        for usefulmsg in multimsg:
                if len(usefulmsg) == 0:
                        break
                try:
                        if usefulmsg == "show_infos":
                                time_uptime = int(time.time() - time_start)
                                reply = 'infos=' \
                                        'xivo_version=%s;' \
                                        'server_version=%s;' \
                                        'uptime=%d s' \
                                        %(XIVOVERSION,
                                          __revision__,
                                          time_uptime)
                                connid.sendall(reply + "\n")
                                # connid.sendall("server capabilities = %s\n" %(",".join()))
                        elif usefulmsg == 'show_users':
                                for user, info in commandclass.users().iteritems():
                                        connid.sendall('%s %s\n' %(user.encode('latin1'), info))
                        elif usefulmsg == 'show_logged_ip':
                                for user, info in commandclass.connected_users().iteritems():
                                        if 'connection' in info['login']:
                                                connid.sendall('user %s : ip/port = %s/%s\n' %(user.encode('latin1'),
                                                                                            info['login']['connection'].getpeername()[0],
                                                                                            info['login']['connection'].getpeername()[1]))
                        elif usefulmsg == 'show_logged':
                                for user, info in commandclass.connected_users().iteritems():
                                        connid.sendall('%s %s\n' %(user.encode('latin1'), info))
                        elif usefulmsg == 'show_ami':
                                for amis in AMI_array_events_fd:
                                        connid.sendall("events   : %s : %s\n" %(amis, str(AMI_array_events_fd[amis])))
                                for amis in AMI_array_user_commands:
                                        connid.sendall("commands : %s : %s\n" %(amis, str(AMI_array_user_commands[amis])))
                        elif usefulmsg.startswith('%s:' % commandset):
                                commandclass.cliaction(connid, usefulmsg)
                        else:
                                pass
                        connid.sendall("XIVO-INFO:OK\n")
                except Exception, exc:
                        log_debug(SYSLOG_ERR, '--- exception --- INFO connection [%s] : KO when sending to %s : %s'
                                  %(usefulmsg, requester, str(exc)))

def manage_tcp_connections(sel_i, msg, kind):
        """
        Dispatches the message's handling according to the connection's kind.
        """
        if kind == 'CTI':
                manage_cti_connections(sel_i, msg, commandclass.separator)
        elif kind == 'WEBI':
                manage_webi_connections(sel_i, msg, '\n')
        elif kind == 'INFO':
                manage_info_connections(sel_i, msg, '\n')
        elif kind == 'AGI':
                agireply = commandclass.handle_agi(asterisklist[0], msg)
                if agireply is not None:
                        sel_i.sendall(agireply)
        else:
                log_debug(SYSLOG_WARNING, 'unknown connection kind %s' % kind)


"""
Management of events that are spied on the AMI
"""
## \brief Handling of AMI events occuring in Events=on mode.
# \param astid the asterisk Id
# \param idata the data read from the AMI we want to parse
# \return none
def handle_ami_event(astid, idata):
        """
        Handles the AMI events occuring on Asterisk.
        If the Event field is there, calls the handle_ami_function() function.
        """
        global save_for_next_packet_events
        if astid not in configs:
                log_debug(SYSLOG_INFO, "%s : no such asterisk Id" % astid)
                return

        full_idata = save_for_next_packet_events[astid] + idata
        evlist = full_idata.split("\r\n\r\n")
        save_for_next_packet_events[astid] = evlist.pop()

        for evt in evlist:
                this_event = {}
                for myline in evt.split('\r\n'):
                        myfieldvalue = myline.split(': ', 1)
                        if len(myfieldvalue) == 2:
                                this_event[myfieldvalue[0]] = myfieldvalue[1]
                evfunction = this_event.get('Event')
                verboselog("/%s/ %s" %(astid, str(this_event)), True, False)
                # print '////////', evfunction, '   ------  ', this_event
                if evfunction is not None:
                        handle_ami_function(astid, evfunction, this_event)
                else:
                        response = this_event.get('Response')
                        if response is not None:
                                if response == 'Follows' and this_event.get('Privilege') == 'Command':
                                        log_debug(SYSLOG_INFO, 'AMI %s Response=Follows : %s' % (astid, str(this_event)))
                                elif response == 'Success':
                                        msg = this_event.get('Message')
                                        if msg == 'Extension Status':
                                                commandclass.ami_response_extensionstatus(astid, this_event)
                                else:
                                        log_debug(SYSLOG_WARNING, 'AMI %s Response=%s (untracked) : %s' % (astid, response, str(this_event)))
                        elif len(this_event) > 0:
                                log_debug(SYSLOG_WARNING, 'AMI:XXX: <%s> : %s' % (astid, str(this_event)))
                        else:
                                log_debug(SYSLOG_WARNING, 'AMI %s Other : %s' % (astid, str(this_event)))


evfunction_to_method_name = {
        'Registry':             'ami_registry',
        'Dial':                 'ami_dial',
        'Link':                 'ami_link',
        'Unlink':               'ami_unlink',
        'Hangup':               'ami_hangup',
        'Join':                 'ami_join',
        'Leave':                'ami_leave',
        'PeerStatus':           'ami_peerstatus',
        'Agentlogin':           'ami_agentlogin',
        'Agentlogoff':          'ami_agentlogoff',
        'Agentcallbacklogin':   'ami_agentcallbacklogin',
        'Agentcallbacklogoff':  'ami_agentcallbacklogoff',
        'AgentCalled':          'ami_agentcalled',
        'AgentComplete':        'ami_agentcomplete',
        'AgentConnect':         'ami_agentconnect',
        'AgentDump':            'ami_agentdump',
        'Agents':               'ami_agents',
        'ParkedCall':           'ami_parkedcall',               # when the requested parking is acked
        'UnParkedCall':         'ami_unparkedcall',
        'ParkedCallTimeOut':    'ami_parkedcalltimeout',
        'ParkedCallGiveUp':     'ami_parkedcallgiveup',
        'ParkedCallsComplete':  'ami_parkedcallscomplete',
        'Cdr':                  'ami_cdr',
        'Alarm':                'ami_alarm',
        'AlarmClear':           'ami_alarmclear',
        'FaxReceived':          'ami_faxreceived',
        'MeetmeJoin':           'ami_meetmejoin',               # when a member joins a conference
        'MeetmeLeave':          'ami_meetmeleave',              # when a member leaves a conference
        'ExtensionStatus':      'ami_extensionstatus',
        'OriginateSuccess':     'ami_originatesuccess',
        'AOriginateSuccess':    'ami_aoriginatesuccess',
        'OriginateFailure':     'ami_originatefailure',
        'AOriginateFailure':    'ami_aoriginatefailure',
        'Rename':               'ami_rename',                   # appears when there is a transfer
        'Newstate':             'ami_newstate',
        'Newcallerid':          'ami_newcallerid',              # useful for tricky managements
        'Newchannel':           'ami_newchannel',
        'Newexten':             'ami_newexten',                 # in order to handle outgoing calls ?
        'MessageWaiting':       'ami_messagewaiting',
        'QueueParams':          'ami_queueparams',
        'QueueMemberAdded':     'ami_queuememberadded',
        'QueueMemberPaused':    'ami_queuememberpaused',
        'QueueMemberRemoved':   'ami_queuememberremoved',
        'QueueMember':          'ami_queuemember',
        'QueueMemberStatus':    'ami_queuememberstatus',
        'QueueStatusComplete':  'ami_queuestatuscomplete',
        'QueueEntry':           'ami_queueentry',
        'Status':               'ami_status',
        'StatusComplete':       'ami_statuscomplete',
        'AgentsComplete':       'ami_agentscomplete',
}


def handle_ami_function(astid, evfunction, this_event):
        """
        Handles the AMI events related to a given function (i.e. containing the Event field).
        It roughly only dispatches them to the relevant commandset's methods.
        """
        try:
                if evfunction == 'Reload':
                        message = this_event.get('Message')
                        log_debug(SYSLOG_WARNING, "AMI:Reload: %s : %s" %(astid, str(this_event)))
                        commandclass.ami_reload(astid, this_event)
                elif evfunction == 'Shutdown':
                        shutdown = this_event.get('Shutdown')
                        restart  = this_event.get('Restart')
                        log_debug(SYSLOG_WARNING, "AMI:Shutdown: %s (how=%s restart=%s)" %(astid, shutdown, restart))
                        commandclass.ami_shutdown(astid, this_event)
                elif evfunction.startswith('UserEvent'):
                        commandclass.ami_userevent(astid, this_event)
                elif (evfunction in evfunction_to_method_name):
                        getattr(commandclass, evfunction_to_method_name[evfunction])(astid, this_event)
                else:
                        log_debug(SYSLOG_WARNING, 'AMI %s ... this event (%s) is not tracked' % (astid, evfunction))
        except Exception, exc:
                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))



def update_amisocks(astid):
        """
        Connects to the Asterisk's AMI (defined by astid) if not yet done.
        Requests a Status when it (re)connects.
        """
        try:
                if astid not in AMI_array_events_fd or AMI_array_events_fd[astid] is False:
                        log_debug(SYSLOG_INFO, '%s : AMI : attempting to connect' % astid)
                        als0 = connect_to_AMI((configs[astid].remoteaddr,
                                               configs[astid].ami_port),
                                              configs[astid].ami_login,
                                              configs[astid].ami_pass,
                                              True)
                        if als0:
                                AMI_array_events_fd[astid] = als0.fd
                                fdlist_full.append(als0.fd)
                                log_debug(SYSLOG_INFO, '%s : AMI : connected' % astid)
                                ret = als0.sendstatus()
                                if not ret:
                                        log_debug(SYSLOG_INFO, '%s : could not send status command' % astid)
                                ret = als0.sendagents()
                                if not ret:
                                        log_debug(SYSLOG_INFO, '%s : could not send agents command' % astid)
                                ret = als0.sendqueuestatus()
                                if not ret:
                                        log_debug(SYSLOG_INFO, '%s : could not send queuestatus command' % astid)
                        else:
                                log_debug(SYSLOG_INFO, '%s : AMI : could NOT connect' % astid)
        except Exception, exc:
                log_debug(SYSLOG_ERR, '--- exception --- %s (update_amisocks) : %s' % (astid, str(exc)))

        try:
                if astid not in AMI_array_user_commands or AMI_array_user_commands[astid] is False:
                        log_debug(SYSLOG_INFO, '%s : AMI (commands)  : attempting to connect' % astid)
                        als1 = connect_to_AMI((configs[astid].remoteaddr,
                                               configs[astid].ami_port),
                                              configs[astid].ami_login,
                                              configs[astid].ami_pass,
                                              False)
                        if als1:
                                AMI_array_user_commands[astid] = als1
                                log_debug(SYSLOG_INFO, '%s : AMI (commands)  : connected' % astid)
                        else:
                                log_debug(SYSLOG_INFO, '%s : AMI (commands)  : could NOT connect' % astid)
        except Exception, exc:
                log_debug(SYSLOG_ERR, '--- exception --- %s (update_amisocks command) : %s' % (astid, str(exc)))


def connect_to_AMI(address, loginname, password, events_on):
        """
        Connects to the AMI through AMIClass.
        """
        lAMIsock = xivo_ami.AMIClass(address, loginname, password, events_on)
        try:
                lAMIsock.connect()
                lAMIsock.login()
        except socket.timeout: pass
        except socket:         pass
        except:
                del lAMIsock
                lAMIsock = False
        return lAMIsock


## \brief Handler for catching signals (in the main thread)
# \param signum signal number
# \param frame frame
# \return none
def sighandler(signum, frame):
        global askedtoquit
        print '--- signal %s (atq = %s) received : quits' % (signum, askedtoquit)
        for t in filter(lambda x: x.getName()<>"MainThread", threading.enumerate()):
                print "--- living thread <%s>" %(t.getName())
                t._Thread__stop()
        askedtoquit = True


## \brief Handler for catching signals (in the main thread)
# \param signum signal number
# \param frame frame
# \return none
def sighandler_reload(signum, frame):
        global askedtoquit
        print '--- signal %s (atq = %s) received : reloads' % (signum, askedtoquit)
        askedtoquit = False

# ==============================================================================
# ==============================================================================

def log_stderr_and_syslog(x):
        print >> sys.stderr, x
        syslogf(SYSLOG_ERR, x)

# ==============================================================================
# Main Code starts here
# ==============================================================================

# daemonize if not in debug mode
if not debug_mode:
        daemonize.daemonize(log_stderr_and_syslog, PIDFILE, True)
else:
        daemonize.create_pidfile_or_die(log_stderr_and_syslog, PIDFILE, True)

signal.signal(signal.SIGINT, sighandler)
signal.signal(signal.SIGTERM, sighandler)
signal.signal(signal.SIGHUP, sighandler_reload)

nreload = 0
plist = {}
directorylist = xivo_contexts.Contexts()
configs = {}
xdname = None

while True: # loops over the reloads
        askedtoquit = False

        time_start = time.time()
        if nreload == 0:
                log_debug(SYSLOG_NOTICE, '# STARTING XIVO Daemon %s (pid %d) / svn %s # (0/3) Starting'
                          %(XIVOVERSION, os.getpid(), __revision__))
        else:
                log_debug(SYSLOG_NOTICE, '# STARTING XIVO Daemon %s (pid %d) / svn %s # (0/3) Reloading (%d)'
                          %(XIVOVERSION, os.getpid(), __revision__, nreload))
        nreload += 1
        
        # global default definitions
        commandset = 'xivocti'
        incoming_tcp_ports = []
        extraconn = ''
        updates_period = 60
        asterisklist = []
        contextlist = []
        userlists = []

        userinfo_by_requester = {}

        cconf = cti_config.Config(xivoconffile)
        xivoconf_general = cconf.read_section('general')

        # loads the general configuration
        if 'commandset' in xivoconf_general:
                commandset = xivoconf_general['commandset']
        if 'incoming_tcp_ports' in xivoconf_general:
                incoming_tcp_ports = xivoconf_general['incoming_tcp_ports'].split(',')
        if 'extraconn' in xivoconf_general:
                extraconn = xivoconf_general['extraconn']
        if 'updates_period' in xivoconf_general:
                updates_period = int(xivoconf_general['updates_period'])
        if 'asterisklist' in xivoconf_general:
                asterisklist = xivoconf_general['asterisklist'].split(',')
        if 'contextlist' in xivoconf_general:
                contextlist = xivoconf_general['contextlist'].split(',')
        if 'userlists' in xivoconf_general:
                userlists = xivoconf_general['userlists'].split(',')

        xivoconf_commandset = cconf.read_section(commandset)

        queued_threads_pipe = os.pipe()
        AMI_array_user_commands = {}
        if commandset in xivo_commandsets.CommandClasses:
                commandclass = xivo_commandsets.CommandClasses[commandset](AMI_array_user_commands, incoming_tcp_ports, queued_threads_pipe)
                xdname = commandclass.xdname
        else:
                commandclass = xivo_commandsets.BaseCommand()
                xdname = commandclass.xdname
                log_debug(SYSLOG_WARNING, '# STARTING %s : no such commandset <%s>' % (xdname, commandset))

        log_debug(SYSLOG_NOTICE, '# STARTING %s / %d' % (xdname, nreload))

        commandclass.set_userlist_urls(userlists)
        commandclass.set_phonelist(plist)
        commandclass.set_contextlist(directorylist)
        commandclass.set_configs(configs)
        commandclass.set_options(xivoconf_commandset)

        for ctx in contextlist:
                xivoconf_context = cconf.read_section(ctx)
                if len(xivoconf_context) > 0:
                        if 'contextname' in xivoconf_context:
                                contextname = xivoconf_context['contextname']
                        if 'directories' in xivoconf_context:
                                directories = xivoconf_context['directories'].split(',')
                                for dr in directories:
                                        xivoconf_dir = cconf.read_section(dr)
                                        directorylist.update(contextname, dr, xivoconf_dir)

        save_for_next_packet_events = {}
        ip_reverse_webi = {}
        ip_reverse_sht = {}

        # loads the configuration for each asterisk
        for astid in asterisklist:
                xivoconf_asterisk = cconf.read_section(astid)
                if len(xivoconf_asterisk) > 0:
                        localaddr = '127.0.0.1'
                        phonelisturl = 'sso.php'
                        ipaddress = '127.0.0.1'
                        ipaddress_webi = '127.0.0.1'
                        ami_port = 5038
                        ami_login = 'xivouser'
                        ami_pass = 'xivouser'
                        cdr_db_uri = userfeatures_db_uri = None
                        realm = 'asterisk'
                        parkingnumber = '700'
                        faxcallerid = 'faxcallerid'
                        linkestablished = ''

                        if 'localaddr' in xivoconf_asterisk:
                                localaddr = xivoconf_asterisk['localaddr']
                        if 'phonelisturl' in xivoconf_asterisk:
                                phonelisturl = xivoconf_asterisk['phonelisturl']
                        if 'ipaddress' in xivoconf_asterisk:
                                ipaddress = xivoconf_asterisk['ipaddress']
                        if 'ipaddress_webi' in xivoconf_asterisk:
                                ipaddress_webi = xivoconf_asterisk['ipaddress_webi']
                        if 'parkingnumber' in xivoconf_asterisk:
                                parkingnumber = int(xivoconf_asterisk['parkingnumber'])
                        if 'faxcallerid' in xivoconf_asterisk:
                                faxcallerid = int(xivoconf_asterisk['faxcallerid'])
                        if 'linkestablished' in xivoconf_asterisk:
                                linkestablished = xivoconf_asterisk['linkestablished']
                        if 'ami_port' in xivoconf_asterisk:
                                ami_port = int(xivoconf_asterisk['ami_port'])
                        if 'ami_login' in xivoconf_asterisk:
                                ami_login = xivoconf_asterisk['ami_login']
                        if 'ami_pass' in xivoconf_asterisk:
                                ami_pass = xivoconf_asterisk['ami_pass']
                        if 'userfeatures_db_uri' in xivoconf_asterisk:
                                userfeatures_db_uri = xivoconf_asterisk['userfeatures_db_uri']
                        if 'cdr_db_uri' in xivoconf_asterisk:
                                cdr_db_uri = xivoconf_asterisk['cdr_db_uri']
                        if 'realm' in xivoconf_asterisk:
                                realm = xivoconf_asterisk['realm']

                        capafeatures = []

                        configs[astid] = xivo_astcfg.AsteriskConfig(astid,
                                                                    localaddr,
                                                                    ipaddress,
                                                                    ipaddress_webi,
                                                                    ami_port,
                                                                    ami_login,
                                                                    ami_pass,
                                                                    userfeatures_db_uri,
                                                                    capafeatures,
                                                                    cdr_db_uri,
                                                                    realm,
                                                                    parkingnumber,
                                                                    faxcallerid,
                                                                    linkestablished)

                        plist[astid] = xivo_phones.PhoneList(astid, commandclass, phonelisturl)

                        if ipaddress not in ip_reverse_sht:
                                ip_reverse_sht[ipaddress] = astid
                        else:
                                log_debug(SYSLOG_WARNING, 'WARNING - IP address already exists for asterisk <%s> - can not set it for <%s>'
                                          % (ip_reverse_sht[ipaddress], astid))
                        if ipaddress_webi not in ip_reverse_webi:
                                ip_reverse_webi[ipaddress_webi] = astid
                        else:
                                log_debug(SYSLOG_WARNING, 'WARNING - IP address (WEBI) already exists for asterisk <%s> - can not set it for <%s>'
                                          % (ip_reverse_webi[ipaddress_webi], astid))
                        save_for_next_packet_events[astid] = ''


        outsock = commandclass.extrasock(extraconn)

        fdlist_full = []
        fdlist_established = {}
        fdlist_listen_cti = {}
        AMI_array_events_fd = {}
        update_userlist = {}
        lastrequest_time = {}
        xivodaemonreload = False
        
        log_debug(SYSLOG_INFO, "the monitored asterisk's is/are : %s" % str(asterisklist))
        log_debug(SYSLOG_INFO, "# STARTING %s # (1/2) AMI socket connections + fetch Web Services" % xdname)

        for astid in configs:
                try:
                        update_userlist[astid] = False
                        lastrequest_time[astid] = time.time()
                        update_amisocks(astid)
                        npl = plist[astid].update_phonelist()
                        commandclass.askstatus(astid, AMI_array_events_fd, npl)
                except Exception, exc:
                        log_debug(SYSLOG_ERR, '--- exception --- %s : failed while setting lists and sockets : %s'
                                  %(astid, str(exc)))
        commandclass.updates() # users' update, ...

        log_debug(SYSLOG_INFO, "# STARTING %s # (2/2) listening sockets (CTI, WEBI, (F)AGI, INFO)" % xdname)
        # opens the listening socket for incoming (CTI, WEBI, (F)AGI, INFO) connections
        for portkind in incoming_tcp_ports:
                pk = portkind.split(':')
                port = pk[0]
                kind = 'INFO'
                bind = '127.0.0.1'
                nmax = '1'
                if len(pk) > 1:
                        kind = pk[1].strip()
                        if len(pk) > 2:
                                bind = pk[2].strip()
                                if len(pk) > 3:
                                        nmax = pk[3].strip()
                UIsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                UIsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                UIsock.bind((bind, int(port)))
                UIsock.listen(10)
                fdlist_listen_cti[UIsock] = '%s:%s' %(kind, nmax)
                fdlist_full.append(UIsock)

        if outsock is not None:
                fdlist_full.append(outsock)
        fdlist_full.append(queued_threads_pipe[0])




        # Main select() loop - Receive messages
        while not askedtoquit:
                try:
                        [sels_i, sels_o, sels_e] = select.select(fdlist_full, [], [], updates_period)
                except Exception, exc:
                        if askedtoquit:
                                try:
                                        print
                                        print 'current open TCP connections : (CTI, WEBI, (F)AGI, INFO) ', fdlist_established
                                        print 'current open TCP connections : (AMI) ', AMI_array_events_fd
                                        print 'current open TCP connections : (OUT) ', outsock
                                        print
                                        os.unlink(PIDFILE)
                                except Exception, exc:
                                        print exc
                                for t in filter(lambda x: x.getName()<>"MainThread", threading.enumerate()):
                                        print "--- (stop) killing thread <%s>" %(t.getName())
                                        t._Thread__stop()
                                sys.exit(5)
                        else:
                                print '--- exception --- after select :', exc
                                askedtoquit = True
                                for s in fdlist_full:
                                        s.close()
                                for t in filter(lambda x: x.getName()<>"MainThread", threading.enumerate()):
                                        print "--- (reload) the thread <%s> remains" %(t.getName())
                                        # t._Thread__stop() # does not work in reload case (vs. stop case)
                                continue
                if sels_i:
                    for sel_i in sels_i:
                        # these AMI connections are used in order to manage AMI commands with incoming events
                        if sel_i in AMI_array_events_fd.values():
                                for astid, val in AMI_array_events_fd.iteritems():
                                        if val is sel_i: break
                                try:
                                        a = AMI_array_events_fd[astid].readline() # (BUFSIZE_ANY)
                                        if len(a) == 0: # end of connection from server side : closing socket
                                                log_debug(SYSLOG_WARNING, "%s : AMI : CLOSING" % astid)
                                                commandclass.dmessage_srv2clt('AMI OFF for <%s>' % astid)
                                                AMI_array_events_fd[astid].close()
                                                fdlist_full.remove(AMI_array_events_fd[astid])
                                                del AMI_array_events_fd[astid]
                                        else:
                                                handle_ami_event(astid, a)
                                except Exception, exc:
                                        log_debug(SYSLOG_ERR, "--- exception --- AMI <%s> : %s" % (astid, str(exc)))

                        # other 'outgoing' connections
                        elif sel_i == outsock:
                                try:
                                        msg = sel_i.recv(BUFSIZE_LARGE, socket.MSG_DONTWAIT)
                                except Exception, exc:
                                        msg = ''
                                        log_debug(SYSLOG_ERR, '--- exception --- outsock : %s' % str(exc))
                                if len(msg) == 0:
                                        sel_i.close()
                                        fdlist_full.remove(sel_i)
                                        outsock = None
                                        log_debug(SYSLOG_WARNING, 'WARNING - outsock has closed the connection')
                                else:
                                        commandclass.handle_outsock(asterisklist[0], msg)

                        # the new TCP connections (CTI, WEBI, (F)AGI, INFO) are catched here
                        elif sel_i in fdlist_listen_cti:
                                [kind, nmax] = fdlist_listen_cti[sel_i].split(':')
                                [conn, sockparams] = sel_i.accept()
                                if kind == 'FAGI':
                                        mfr = conn.makefile('rb', -1)
                                        mfw = conn.makefile('wb', 0)
##                                        try:
##                                                fagi = fastagi.FastAGI(mfr, mfw)
##                                                commandclass.handle_fagi(fagi)
##                                        except Exception, exc:
##                                                log_debug(SYSLOG_ERR, '--- exception --- fastagi : %s' % str(exc))
                                        mfr.close()
                                        mfw.close()
                                        conn.close()
                                else:
                                        log_debug(SYSLOG_INFO, "TCP socket opened on %s:%d (%s)" % (sockparams[0], sockparams[1], kind))
                                        if kind == 'CTI':
                                                commandclass.connected(conn)
                                        # appending the opened socket to the ones watched
                                        # conn.setblocking(0)
                                        conn.settimeout(2)
                                        fdlist_full.append(conn)
                                        fdlist_established[conn] = kind

                        # incoming TCP connections (CTI, WEBI, AGI, INFO)
                        elif sel_i in fdlist_established:
                                try:
                                        ret = False
                                        kind = fdlist_established[sel_i]
                                        requester = '%s:%d' % (sel_i.getpeername()[0], sel_i.getpeername()[1])
                                        try:
                                                msg = sel_i.recv(BUFSIZE_LARGE, socket.MSG_DONTWAIT)
                                                lmsg = len(msg)
                                        except Exception, exc:
                                                lmsg = 0
                                                log_debug(SYSLOG_ERR, '--- exception --- connection to %s (%s) : %s' % (requester, kind, str(exc)))
                                        if lmsg > 0:
                                                try:
                                                        manage_tcp_connections(sel_i, msg, kind)
                                                except Exception:
                                                        log_debug(SYSLOG_ERR, '--- exception --- handling %s (%s) : %s'
                                                                  % (requester, kind, str(except_tb.exception_traceback())))
                                        else:
                                                if kind == 'CTI':
                                                        if sel_i in userinfo_by_requester:
                                                                userinfo = userinfo_by_requester.get(sel_i)
                                                                commandclass.manage_logoff(userinfo)
                                                                del userinfo_by_requester[sel_i]
                                        if kind in ['CTI', 'INFO'] and lmsg > 0:
                                                continue
                                        sel_i.close()
                                        fdlist_full.remove(sel_i)
                                        del fdlist_established[sel_i]
                                        log_debug(SYSLOG_INFO, 'TCP socket closed on %s (%s)' % (requester, kind))
                                except Exception, exc:
                                        log_debug(SYSLOG_ERR, '--- exception [%s] --- %s' % (kind, str(exc)))
                                        try:
                                                fdlist_full.remove(sel_i)
                                                del fdlist_established[sel_i]
                                                sel_i.close()
                                                if sel_i in userinfo_by_requester:
                                                        userinfo = userinfo_by_requester.get(sel_i)
                                                        commandclass.manage_logoff(userinfo)
                                                        del userinfo_by_requester[sel_i]
                                        except Exception, exc2:
                                                log_debug(SYSLOG_ERR, '--- exception (2) [CTI, WEBI, AGI, INFO] --- %s' % str(exc2))

                        # local pipe fd
                        elif queued_threads_pipe[0] == sel_i:
                                try:
                                        disconnlist = commandclass.checkqueue()
                                        for userinfo in disconnlist:
                                                print 'checkqueue return :', userinfo
                                                if 'login' in userinfo and 'connection' in userinfo.get('login'):
                                                        connid = userinfo.get('login')['connection']
                                                        fdlist_full.remove(connid)
                                                        del fdlist_established[connid]
                                                        connid.close()
                                                else:
                                                        log_debug(SYSLOG_WARNING, 'WARNING - no login/connection field present in userinfo')
                                                # commandclass.manage_logoff(userinfo)
                                except Exception, exc:
                                        log_debug(SYSLOG_ERR, '--- exception --- [queued threads] %s' % str(exc))

                        for astid in configs:
                                if (time.time() - lastrequest_time[astid]) > updates_period or update_userlist[astid]:
                                        lastrequest_time[astid] = time.time()
                                        log_debug(SYSLOG_INFO, '[%s] %s : updates (computed timeout) %s'
                                                  % (xdname, astid, time.asctime()))
                                        try:
                                                if outsock is None:
                                                        outsock = commandclass.extrasock(extraconn)
                                                        if outsock is not None:
                                                                fdlist_full.append(outsock)
                                                update_amisocks(astid)
                                                commandclass.regular_update()
                                                plist[astid].update_phonelist()
                                                update_userlist[astid] = False
                                        except Exception, exc:
                                                log_debug(SYSLOG_ERR, '--- exception --- %s : failed while updating lists and sockets (computed timeout) : %s'
                                                          %(astid, str(exc)))
                                        commandclass.updates() # users' update, ...

                else: # when nothing happens on the sockets, we fall here sooner or later
                        log_debug(SYSLOG_INFO, '[%s] updates (select timeout) %s'
                                  % (xdname, time.asctime()))
                        commandclass.updates() # users' update, ...
                        for astid in configs:
                                lastrequest_time[astid] = time.time()
                                try:
                                        if outsock is None:
                                                outsock = commandclass.extrasock(extraconn)
                                                if outsock is not None:
                                                        fdlist_full.append(outsock)
                                        update_amisocks(astid)
                                        commandclass.regular_update()
                                        plist[astid].update_phonelist()
                                except Exception, exc:
                                        log_debug(SYSLOG_ERR, '--- exception --- %s : failed while updating lists and sockets (select s timeout) : %s'
                                                  %(astid, str(exc)))

        log_debug(SYSLOG_NOTICE, 'after askedtoquit loop (%s)' % askedtoquit)
