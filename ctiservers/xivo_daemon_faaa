#!/usr/bin/python
# vim: set fileencoding=utf-8 :

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# Alternatively, XIVO Daemon is available under other licenses directly
# contracted with Pro-formatique SARL. See the LICENSE file at top of the
# source tree or delivered in the installable package in which XIVO Daemon
# is distributed for more details.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

__version__   = '$Revision: 7384 $'
__date__      = '$Date: 2010-01-07 18:52:28 +0100 (Thu, 07 Jan 2010) $'
__copyright__ = 'Copyright (C) 2007-2010 Proformatique'
__author__    = 'Corentin Le Gall'

"""
# 1) General description of XIVO CTI Daemon
# The XIVO CTI Daemon is a general-purpose daemon, whose basic features are :
#  - the monitoring of one or more Asterisk, through AMI
#  - taking care of Asteriks AGI requests
#  - the ability to receive incoming "CTI clients" connections
#  - the ability to relay commands (between a Web interface and Asterisk)
#  - the connection to one or more databases (cdr, directory, ...)
#  - the connection to a given server
# 
# 2) Primary data structures
# 
#  - users list
#  - contexts/companies list
# 
#  - asterisk / configurations
#  - phonelist
#
# 3) Main loop
# The main loop is triggered by a select() on the file descriptors for :
# - the AMI Event sockets (AMIsocks)
# - the incoming TCP sockets (CTI, WEBI, INFO, (F)AGI)
#
# 4) Custom-defined Plugins
#
"""

__revision__ = __version__.split()[1]

# debian.org modules
import getopt
from optparse import OptionParser
import os
import pickle
import select
import signal
import socket
import string
import sys
import threading
import time
import logging
from logging.handlers import SysLogHandler
import Queue
from xivo_ctiservers.client_connection import ClientConnection

__alphanums__ = string.uppercase + string.lowercase + string.digits
waiting_actionid = {}
waiting_actionid_timer = {}
dumpami = False

LOGDAEMONNAME = 'cti-server'
try:
        DAEMONNAME = os.path.basename(sys.argv[0])
except:
        DAEMONNAME = 'xivo_daemon'

# XIVO lib-python modules initialization
XIVO_CONF_FILE            = '/etc/pf-xivo/ctiservers/%s.conf' % DAEMONNAME
PIDFILE                 = '/var/run/%s.pid' % DAEMONNAME
GETOPT_SHORTOPTS        = 'dc:p:'
GETOPT_LONGOPTS         = ["debug", "config=", "pidfile="]
debug_mode = False

def parse_command_line():
    global XIVO_CONF_FILE, PIDFILE, debug_mode
    for opt, arg in getopt.getopt( sys.argv[1:], GETOPT_SHORTOPTS, GETOPT_LONGOPTS)[0]:
        if opt == "-c":
            XIVO_CONF_FILE = arg
        elif opt == "-d":
            debug_mode = True
        elif opt=="-p":
            PIDFILE = arg

parse_command_line()

# XIVO lib-python modules imports
from xivo import anysql
from xivo.BackSQL import backmysql
from xivo.BackSQL import backsqlite

# XIVO CTI modules
from xivo_agid import fastagi
from xivo_ctiservers import xivo_ami
from xivo_ctiservers import xivo_contexts
from xivo_ctiservers import xivo_astcfg
from xivo_ctiservers import cti_config
from xivo_ctiservers import xivo_commandsets
from xivo_ctiservers.CommandSets import *
from xivo_ctiservers.xivo_commandsets import ctidaemonize as daemonize

BUFSIZE_LARGE = 8192
BUFSIZE_ANY = 512

XIVO_CLI_WEBI_HEADER = 'XIVO-CLI-WEBI'
XIVOVERSION = '1.1'



class manage_connection:
    ## \brief Deals with requests from the UI clients.
    # \param connid connection identifier
    # \param msg message to process
    # \param sep separator to split the message
    # \return none
    def manage_cti_connections(connid, msg, sep):
            """
            Handles CTI connections.
            """
            requester = '%s:%d' % connid.getpeername()
            if requester in commandclass.transfers_ref:
                    commandclass.transfer_addbuf(requester, msg)
                    return
            
            multimsg = msg.split(sep)
            for usefulmsgpart in multimsg:
                    # remove tailing \r
                    usefulmsg = usefulmsgpart.split('\r')[0]
                    if len(usefulmsg) == 0:
                            break
                    command = commandclass.parsecommand(usefulmsg)
                    if command.name in commandclass.get_list_commands():
                            try:
                                    if command.type in [xivo_commandsets.CMD_LOGIN_ID,
                                                        xivo_commandsets.CMD_LOGIN_PASS,
                                                        xivo_commandsets.CMD_LOGIN_CAPAS]:
                                            # log.info('LOGIN(%s) %s : args   %s' % (command.type, requester, command.args))
                                            loginparams = commandclass.get_login_params(command, self.asterisklist[0], connid)
                                            # log.info('LOGIN(%s) %s : params %s' % (command.type, requester, loginparams))
                                            uinfo = commandclass.manage_login(loginparams, command.type, userinfo_current.get(connid))
                                            # log.info('LOGIN(%s) %s : uinfo  %s' % (command.type, requester, uinfo))
                                            
                                            if isinstance(uinfo, str):
                                                    commandclass.loginko(loginparams, uinfo, connid)
                                                    log.info('TCP socket %s closed(loginko) on %s' % (self.fdlist_established[connid],
                                                                                                      '%s:%d' % connid.getpeername()))
                                                    del self.fdlist_established[connid]
                                                    connid.close()
                                            else:
                                                    if command.type == xivo_commandsets.CMD_LOGIN_CAPAS:
                                                            uinfo['login']['connection'] = connid
                                                            userinfo_by_requester[connid] = uinfo
                                                            if connid in userinfo_current:
                                                                    del userinfo_current[connid]
                                                    else:
                                                            userinfo_current[connid] = uinfo
                                                    commandclass.loginok(loginparams, uinfo, connid, command.type)
                                    elif command.type == xivo_commandsets.CMD_TRANSFER:
                                            log.info('TRANSFER on %s : %s' % (requester, command.struct))
                                            commandclass.transfer_addref(connid, command.struct)
                                    else:
                                            if connid in userinfo_by_requester:
                                                    commandclass.manage_cticommand(userinfo_by_requester[connid],
                                                                                   command)
                                            else:
                                                    log.warning('unlogged %s is attempting a %s (TCP) : %s'
                                                                % (requester, command.name, command.args))
                            except Exception:
                                    log.exception('CTI connection when managing [%s, %s] for %s'
                                                  % (command.name, command.type, requester))
                    else:
                            connid.sendall('Unknown Command <%s>\n' % command.name)
    
    
    ## \brief Deals with requests from the UI clients.
    # \param connid connection identifier
    # \return none
    def manage_webi_connections(connid, msg, sep):
            """
            Handles WEBI connections.
            """
            requester = '%s:%d' % connid.getpeername()
            requester_ip = connid.getpeername()[0]
            closemenow = True
            
            if requester_ip not in self.ip_reverse_webi:
                    connid.sendall('%s:KO <NOT ALLOWED>\n' % XIVO_CLI_WEBI_HEADER)
                    return closemenow
            astid = self.ip_reverse_webi[requester_ip]
            
            multimsg = msg.split(sep)
            for usefulmsgpart in multimsg:
                    usefulmsg = usefulmsgpart.split('\r')[0]
                    if len(usefulmsg) == 0:
                            break
                    try:
                            if usefulmsg in ['xivo[userlist,update]',
                                             'xivo[agentlist,update]',
                                             'xivo[queuelist,update]',
                                             'xivo[grouplist,update]']:
                                    update_userlist[astid] = True
                                    log.info('%s : WEBI requested %s (%s)' % (astid, usefulmsg, requester))
                            elif usefulmsg == 'xivo[daemon,reload]':
                                    self.askedtoquit = True
                                    log.info('%s : WEBI requested %s (%s)' % (astid, usefulmsg, requester))
                            elif usefulmsg == 'xivo[ctiprofilelist,get]':
                                    log.info('%s : WEBI requested %s (%s)' % (astid, usefulmsg, requester))
                                    connid.sendall('%s:ID <%s>\n' % (XIVO_CLI_WEBI_HEADER, astid))
                                    connid.sendall('%s\n' % commandclass.getprofilelist())
                                    connid.sendall('%s:OK\n' % XIVO_CLI_WEBI_HEADER)
                            elif astid in amilist.ami and amilist.ami[astid]:
                                    stripped_usefulmsg = usefulmsg.strip()
                                    try:
                                            if stripped_usefulmsg == 'moh reload':
                                                    commandclass.pre_moh_reload()
                                            elif stripped_usefulmsg == 'reload':
                                                    commandclass.pre_reload()
                                    except Exception:
                                            log.exception('(pre reloads (%s))' % stripped_usefulmsg)
                                            
                                    closemenow = False
                                    try:
                                            actionid = amilist.execute(astid, 'sendcommand', 'Command', [('Command', stripped_usefulmsg)])
                                            log.info('%s : WEBI requested a <%s> with actionid %s (%s)' % (astid, stripped_usefulmsg,
                                                                                                           actionid, connid))
                                            waiting_actionid[actionid] = connid
                                            waiting_actionid_timer[actionid] = threading.Timer(5, callback_timer_main, ('webirequest', actionid))
                                            waiting_actionid_timer[actionid].start()
                                    except Exception, exc:
                                            log.error('(%s) WEBI command exec <%s> : (client %s) : %s'
                                                      % (astid, stripped_usefulmsg, requester, exc))
                    except Exception, exc:
                            log.error('(%s) WEBI <%s> : (client %s) : %s'
                                      % (astid, usefulmsg.strip(), requester, exc))
                            connid.sendall('%s:KO <Exception : %s>\n' % (XIVO_CLI_WEBI_HEADER, exc))
            return closemenow
    
    
    ## \brief Deals with requests from the UI clients.
    # \param connid connection identifier
    # \return none
    def manage_info_connections(connid, msg, sep):
            """
            Handles INFO connections (basic administration console,
            primarily aimed at displaying informations first).
            """
            global dumpami
            global log
            requester = '%s:%d' % connid.getpeername()
            multimsg = msg.replace('\r', '').split(sep)
            for usefulmsg in multimsg:
                    if len(usefulmsg) == 0:
                            break
                    try:
                            retstr = 'OK'
                            if usefulmsg == 'help':
                                    helptxt = ['',
                                               'help                     : this help',
                                               '-- general purpose commands --',
                                               'show_infos               : gives a few informations about the daemon (version, uptime)',
                                               '-- informations about misc lists --',
                                               'show_users               : the users list',
                                               'show_phones, show_trunks : phones and trunks lists',
                                               'show_queues, show_groups,',
                                               'show_agents              : call-center related lists',
                                               'show_incomingcalls       : did lists',
                                               'show_meetme              : conference rooms',
                                               'show_voicemail           : voicemails',
                                               'show_phonebook           : phonebook contents',
                                               '-- selective lists --',
                                               'show_logged              : only the logged users',
                                               'show_logged_ip           : the human-readable IPs of logged users',
                                               '-- for debugging purposes --',
                                               'loglevel set <level>         : changes the syslog output level',
                                               'show_varsizes <astid>        : gives the number of items of some variables',
                                               'show_var <astid> <varname>   : outputs the contents of one such variable',
                                               'dumpami enable               : enables the line-by-line display of AMI events',
                                               'dumpami disable              : disables it',
                                               '-- slightly advanced features --',
                                               'kick <user>                  : disconnects the user <user>',
                                               'disc <ip> <port>             : closes the socket linked to <ip>:<port> if present',
                                               'ami <astid> <command> <args> : executes the CTI-defined AMI function on <astid>',
                                               'reverse <dirname> <number>   : lookup the number in the given directory',
                                               '']
                                    for helpline in helptxt:
                                            connid.sendall('%s\n' % helpline)
                            elif usefulmsg == 'show_infos':
                                    time_uptime = int(time.time() - time.mktime(time_start))
                                    reply = 'infos=' \
                                            'xivo_version=%s;' \
                                            'server_version=%s;' \
                                            'commandset=%s;' \
                                            'commandset_version=%s;' \
                                            'uptime=%d s' \
                                            % (XIVOVERSION, __revision__,
                                               commandclass.xdname,
                                               commandclass.version(),
                                               time_uptime)
                                    connid.sendall(reply + '\n')
                                    # connid.sendall('server capabilities = %s\n' % (','.join()))
                            elif usefulmsg == 'dumpami enable':
                                    dumpami = True
                            elif usefulmsg == 'dumpami disable':
                                    dumpami = False
                            elif usefulmsg.startswith('loglevel '):
                                    command_args = usefulmsg.split()
                                    if len(command_args) > 2:
                                            action = command_args[1]
                                            levelname = command_args[2]
                                            levels = {'debug' : logging.DEBUG,
                                                      'info' : logging.INFO,
                                                      'warning' : logging.WARNING,
                                                      'error' : logging.ERROR}
                                            if action == 'set':
                                                    if levelname in levels:
                                                            newlevel = levels[levelname]
                                                            log.setLevel(logging.INFO)
                                                            log.info('=== setting loglevel to %s (%s) ===' % (levelname, newlevel))
                                                            log.setLevel(newlevel)
                                                            logging.getLogger('xivocti').setLevel(newlevel)
                                                            logging.getLogger('xivo_ami').setLevel(newlevel)
                                                            logging.getLogger('urllist').setLevel(newlevel)
                                                            connid.sendall('loglevel set to %s (%s)\n' % (levelname, newlevel))
                                                    else:
                                                            connid.sendall('unknown level name <%s> to set\n' % levelname)
                                            elif action == 'get':
                                                    pass
                                            else:
                                                    connid.sendall('unknown action <%s> for loglevel : try set or get\n' % action)
                            elif usefulmsg == 'show_users':
                                    for user, info in commandclass.users().iteritems():
                                            try:
                                                    connid.sendall('%s %s\n' % (user.encode('latin1'), info))
                                            except Exception:
                                                    log.exception('INFO %s' % usefulmsg)
                            elif usefulmsg in ['show_phones', 'show_trunks',
                                               'show_queues', 'show_groups', 'show_agents',
                                               'show_incomingcalls', 'show_phonebook',
                                               'show_meetme', 'show_voicemail']:
                                    itemname = usefulmsg[5:]
                                    for astid, itm in commandclass.getdetails(itemname).iteritems():
                                            try:
                                                    connid.sendall('%s for %s\n' % (itemname, astid))
                                                    for id, idv in itm.keeplist.iteritems():
                                                            connid.sendall('%s %s\n' % (id, idv))
                                            except Exception:
                                                    log.exception('INFO %s' % usefulmsg)
                            elif usefulmsg.startswith('show_var '):
                                    command_args = usefulmsg.split()
                                    if len(command_args) > 2:
                                            astid = command_args[1]
                                            varname = command_args[2]
                                            if hasattr(commandclass, varname):
                                                    tvar = getattr(commandclass, varname)
                                                    if astid in tvar:
                                                            connid.sendall('%s on %s\n' % (varname, astid))
                                                            for ag, agp in tvar[astid].iteritems():
                                                                    connid.sendall('%s %s\n' % (ag, agp))
                                                    else:
                                                            connid.sendall('no such astid %s\n' % astid)
                                            else:
                                                    connid.sendall('no such variable %s\n' % varname)
                                    else:
                                            connid.sendall('first argument : astid value\n')
                                            connid.sendall('second argument : one of %s\n' % commandclass.astid_vars)
                            elif usefulmsg.startswith('show_varsizes '):
                                    command_args = usefulmsg.split()
                                    if len(command_args) > 1:
                                            astid = command_args[1]
                                            for varname in commandclass.astid_vars:
                                                    if hasattr(commandclass, varname):
                                                            tvar = getattr(commandclass, varname)
                                                            if astid in tvar:
                                                                    connid.sendall('%s on %s: %d\n' % (varname, astid, len(tvar[astid])))
                                                            else:
                                                                    connid.sendall('no such astid %s\n' % astid)
                                                    else:
                                                            connid.sendall('no such variable %s\n' % varname)
                                    else:
                                            connid.sendall('argument : astid value\n')
                            elif usefulmsg == 'show_logged_ip':
                                    for user, info in commandclass.connected_users().iteritems():
                                            if 'connection' in info['login']:
                                                    try:
                                                            [ipaddr, ipport] = info['login']['connection'].getpeername()
                                                    except Exception:
                                                            log.exception('INFO %s' % usefulmsg)
                                                            [ipaddr, ipport] = ['err_addr', 'err_port']
                                                    connid.sendall('user %s : ip:port = %s:%s\n' % (user.encode('latin1'), ipaddr, ipport))
                            elif usefulmsg == 'show_logged':
                                    for user, info in commandclass.connected_users().iteritems():
                                            try:
                                                    connid.sendall('%s %s\n' % (user.encode('latin1'), info))
                                            except Exception:
                                                    log.exception('INFO %s' % usefulmsg)
                            elif usefulmsg.startswith('reverse '):
                                    command_args = usefulmsg.split()
                                    if len(command_args) > 2:
                                            dirnames = command_args[1]
                                            numbers = command_args[2:]
                                            for number in numbers:
                                                    reverses = commandclass.findreverse(dirnames, number)
                                                    for number, rep in reverses.iteritems():
                                                            connid.sendall('%s %s\n' % (number, rep))
                            elif usefulmsg.startswith('disc '):
                                    command_args = usefulmsg.split()
                                    if len(command_args) > 2:
                                            ipdef = tuple([command_args[1], int(command_args[2])])
                                            socktoremove = None
                                            for sockid in self.fdlist_established.keys():
                                                    if ipdef == sockid.getpeername():
                                                            socktoremove = sockid
                                            if socktoremove:
                                                    connid.sendall('disconnecting %s (%s)\n'
                                                                   % (socktoremove.getpeername(), self.fdlist_established[socktoremove]))
                                                    socktoremove.close()
                                                    del self.fdlist_established[socktoremove]
                                            else:
                                                    connid.sendall('nobody disconnected\n')
                            elif usefulmsg == 'show_ami':
                                    for astid, ami in amilist.ami.iteritems():
                                            connid.sendall('commands : %s : %s\n' % (astid, ami))
                            elif usefulmsg.startswith('ami '):
                                    amicmd = usefulmsg.split()[1:]
                                    if amicmd:
                                            connid.sendall('ami request %s\n' % amicmd)
                                            if len(amicmd) > 1:
                                                    astid = amicmd[0]
                                                    cmd = amicmd[1]
                                                    cmdargs = amicmd[2:]
                                                    amilist.execute(astid, cmd, *cmdargs)
                            elif usefulmsg.startswith('kick '):
                                    command_args = usefulmsg.split()
                                    try:
                                            if len(command_args) > 1:
                                                    kickuser = command_args[1]
                                                    if kickuser in commandclass.connected_users():
                                                            uinfo = commandclass.connected_users()[kickuser]
                                                            if 'login' in uinfo and 'connection' in uinfo.get('login'):
                                                                    cid = uinfo.get('login')['connection']
                                                                    if cid in self.fdlist_established:
                                                                            del self.fdlist_established[cid]
                                                                            cid.close()
                                                                            commandclass.manage_logout(uinfo, 'admin')
                                                                            del userinfo_by_requester[cid]
                                                                            connid.sendall('kicked %s\n' % kickuser)
                                                                    else:
                                                                            connid.sendall('did not kick %s (socket id not in daemon refs)\n' % kickuser)
                                                            else:
                                                                    connid.sendall('did not kick %s (no connection attributes for the user)\n' % kickuser)
                                                    else:
                                                            connid.sendall('did not kick %s (user not found)\n' % kickuser)
                                            else:
                                                    connid.sendall('nobody to kick\n')
                                    except Exception:
                                            log.exception('INFO %s' % usefulmsg)
                                            connid.sendall('(exception when trying to kick - see server log)\n')
                            elif usefulmsg.startswith('%s:' % commandset):
                                    commandclass.cliaction(connid, usefulmsg)
                            else:
                                    retstr = 'KO'
                            connid.sendall('XIVO-INFO:%s\n' % retstr)
                    except Exception:
                            log.exception('INFO connection [%s] : KO when sending to %s'
                                          % (usefulmsg, requester))
    
    def manage_tcp_connections(sel_i, msg, kind):
            """
            Dispatches the message's handling according to the connection's kind.
            """
            closemenow = True
            if kind == 'CTI':
                    manage_cti_connections(sel_i, msg, commandclass.ctiseparator)
            elif kind == 'WEBI':
                    closemenow = manage_webi_connections(sel_i, msg, '\n')
            elif kind == 'INFO':
                    manage_info_connections(sel_i, msg, '\n')
            elif kind == 'AGI':
                    agireply = commandclass.handle_agi(self.asterisklist[0], msg)
                    if agireply is not None:
                            sel_i.sendall(agireply)
            else:
                    log.warning('unknown connection kind %s' % kind)
            return closemenow


    """
    Management of events that are spied on the AMI
    """
    ## \brief Handling of AMI events occuring in Events=on mode.
    # \param astid the asterisk Id
    # \param idata the data read from the AMI we want to parse
    # \return none
    def handle_ami_event(astid, idata):
            """
            Handles the AMI events occuring on Asterisk.
            If the Event field is there, calls the handle_ami_function() function.
            """
            global save_for_next_packet_events
            if astid not in configs:
                    log.info('%s : no such asterisk Id' % astid)
                    return
            
            full_idata = save_for_next_packet_events[astid] + idata
            evlist = full_idata.split('\r\n\r\n')
            save_for_next_packet_events[astid] = evlist.pop()
            
            for evt in evlist:
                    evt = evt.decode('utf8')
                    this_event = {}
                    nocolon = []
                    for myline in evt.split('\r\n'):
                            if myline.find('\n') < 0:
                                    myfieldvalue = myline.split(': ', 1)
                                    if len(myfieldvalue) == 2:
                                            this_event[myfieldvalue[0]] = myfieldvalue[1]
                                    else:
                                            if myline.startswith('Asterisk Call Manager'):
                                                    log.info('%s : %s' % (astid, myline))
                                            else:
                                                    log.warning('%s unable to parse %s' % (astid, myline))
                            else:
                                    nocolon.append(myline)
                    if len(nocolon) > 1:
                            log.warning('%s nocolon is %s' % (astid, nocolon))
                    evfunction = this_event.get('Event')
                    # log.info('%s AMI(all)  %s  : %s' % (astid, evfunction, this_event))
                    if evfunction is not None:
                            handle_ami_function(astid, evfunction, this_event)
                            if evfunction not in ['Newexten', 'Newchannel', 'Newstate', 'Newcallerid']:
                                    pass
                                    # verboselog('%s %s' % (astid, this_event), True, False)
                    else:
                            response = this_event.get('Response')
                            if response is not None:
                                    if response == 'Follows' and this_event.get('Privilege') == 'Command':
                                            if 'ActionID' in this_event:
                                                    actionid = this_event.get('ActionID')
                                                    connreply = waiting_actionid.get(actionid)
                                                    try:
                                                        if connreply is not None:
                                                            connreply.sendall('%s:ID <%s>\n' % (XIVO_CLI_WEBI_HEADER, astid))
                                                        for noc in nocolon:
                                                            arggs = noc.split('\n')
                                                            for toremove in ['', '--END COMMAND--']:
                                                                while toremove in arggs:
                                                                    arggs.remove(toremove)
                                                            if arggs:
                                                                if connreply is not None:
                                                                    log.info('%s AMI Response : %s : %s' % (astid, actionid, arggs))
                                                                    for argg in arggs:
                                                                        connreply.sendall(argg + '\n')
                                                        if connreply is not None:
                                                            connreply.sendall('%s:OK\n' % XIVO_CLI_WEBI_HEADER)
                                                            log.info('TCP socket %s closed(actionid-ok) on %s' % (self.fdlist_established[connreply],
                                                                                                                  '%s:%d' % connreply.getpeername()))
                                                            del self.fdlist_established[connreply]
                                                            connreply.close()
                                                            del waiting_actionid[actionid]
                                                            waiting_actionid_timer[actionid].cancel()
                                                            del waiting_actionid_timer[actionid]
                                                    except Exception:
                                                        log.exception('%s (command reply to %s, %s)' % (astid, connreply, actionid))
                                            try:
                                                commandclass.amiresponse_follows(astid, this_event, nocolon)
                                            except Exception:
                                                log.exception('%s amiresponse_follows (%s) (%s)' % (astid, this_event, nocolon))
                                    elif response == 'Success':
                                            try:
                                                commandclass.amiresponse_success(astid, this_event, nocolon)
                                            except Exception:
                                                log.exception('%s amiresponse_success (%s) (%s)' % (astid, this_event, nocolon))
                                    elif response == 'Error':
                                            if 'ActionID' in this_event:
                                                    actionid = this_event.get('ActionID')
                                                    connreply = waiting_actionid.get(actionid)
                                                    try:
                                                        if connreply is not None:
                                                            connreply.sendall('%s:ID <%s>\n' % (XIVO_CLI_WEBI_HEADER, astid))
                                                            connreply.sendall('%s:KO\n' % XIVO_CLI_WEBI_HEADER)
                                                            log.info('TCP socket %s closed(actionid-ko) on %s' % (self.fdlist_established[connreply],
                                                                                                                  '%s:%d' % connreply.getpeername()))
                                                            del self.fdlist_established[connreply]
                                                            connreply.close()
                                                            del waiting_actionid[actionid]
                                                            waiting_actionid_timer[actionid].cancel()
                                                            del waiting_actionid_timer[actionid]
                                                    except Exception:
                                                        log.exception('%s (command reply to %s, %s)' % (astid, connreply, actionid))
                                            try:
                                                commandclass.amiresponse_error(astid, this_event, nocolon)
                                            except Exception:
                                                log.exception('%s amiresponse_error (%s) (%s)' % (astid, this_event, nocolon))
                                    else:
                                        log.warning('AMI %s Response=%s (untracked) : %s' % (astid, response, this_event))
                            elif len(this_event) > 0:
                                log.warning('AMI:XXX: <%s> : %s' % (astid, this_event))
                            else:
                                log.warning('AMI %s Other : %s' % (astid, this_event))
    
    
    evfunction_to_method_name = {
            'Registry':             'ami_registry',
            'Dial':                 'ami_dial',
            'Link':                 'ami_link',
            'Unlink':               'ami_unlink',
            'Bridge':               'ami_bridge',                   # (1.6) Seems to replace partly Link/Unlink events
            'Masquerade':           'ami_masquerade',               # (1.6 backported) for indirect transfers & intercepts
            'Hangup':               'ami_hangup',
            'HangupRequest':        'ami_hanguprequest',            # (xivo) to know who 'ordered' the hangup
            'Join':                 'ami_join',
            'Leave':                'ami_leave',
            'DTMF':                 'ami_dtmf',                     # (1.6 backported)
            'PeerStatus':           'ami_peerstatus',
            'Agentlogin':           'ami_agentlogin',
            'Agentlogoff':          'ami_agentlogoff',
            'Agentcallbacklogin':   'ami_agentcallbacklogin',
            'Agentcallbacklogoff':  'ami_agentcallbacklogoff',
            'AgentCalled':          'ami_agentcalled',
            'AgentComplete':        'ami_agentcomplete',
            'AgentsComplete':       'ami_agentscomplete',
            'AgentConnect':         'ami_agentconnect',
            'AgentDump':            'ami_agentdump',
            'Agents':               'ami_agents',
            'ChannelReload':        'ami_channelreload',            # (1.4)
            'ParkedCall':           'ami_parkedcall',               # when the requested parking is acked
            'UnParkedCall':         'ami_unparkedcall',
            'ParkedCallTimeOut':    'ami_parkedcalltimeout',
            'ParkedCallGiveUp':     'ami_parkedcallgiveup',
            'ParkedCallsComplete':  'ami_parkedcallscomplete',
            'DNDState':             'ami_dndstate',
            'Cdr':                  'ami_cdr',
            'Hold':                 'ami_hold',
            'Unhold':               'ami_unhold',
            'Alarm':                'ami_alarm',
            'AlarmClear':           'ami_alarmclear',
            'FaxSent':              'ami_faxsent',
            'FaxReceived':          'ami_faxreceived',
            'MeetmeJoin':           'ami_meetmejoin',               # when a member joins a conference
            'MeetmeNoAuthed':       'ami_meetmenoauthed',           # when a member was accepted or not by an admin
            'MeetmePause':          'ami_meetmepause',              # when a conf chamber is put in pause or activated
            'MeetmeLeave':          'ami_meetmeleave',              # when a member leaves a conference
            'MeetmeMute':           'ami_meetmemute',               # when a member is (un)muted
            'MeetmeTalking':        'ami_meetmetalking',
            'MeetmeList':           'ami_meetmelist',
            'MeetmeListComplete':   'ami_meetmelistcomplete',
            'Transfer':             'ami_transfer',                 # (1.6 backported)
            'ExtensionStatus':      'ami_extensionstatus',
            'OriginateSuccess':     'ami_originatesuccess',
            'AOriginateSuccess':    'ami_aoriginatesuccess',
            'OriginateFailure':     'ami_originatefailure',
            'AOriginateFailure':    'ami_aoriginatefailure',
            'OriginateResponse':    'ami_originateresponse',
            'Rename':               'ami_rename',                   # appears when there is a transfer
            'Newstate':             'ami_newstate',
            'Newcallerid':          'ami_newcallerid',              # useful for tricky managements
            'Newchannel':           'ami_newchannel',
            'Newexten':             'ami_newexten',                 # in order to handle outgoing calls ?
            'MessageWaiting':       'ami_messagewaiting',
            'QueueParams':          'ami_queueparams',
            'QueueMemberAdded':     'ami_queuememberadded',
            'QueueMemberPaused':    'ami_queuememberpaused',
            'QueueMemberRemoved':   'ami_queuememberremoved',
            'QueueMember':          'ami_queuemember',
            'QueueMemberStatus':    'ami_queuememberstatus',
            'QueueStatusComplete':  'ami_queuestatuscomplete',
            'QueueEntry':           'ami_queueentry',
            'QueueCallerAbandon':   'ami_queuecallerabandon',       # (1.4)
            'Status':               'ami_status',
            'StatusComplete':       'ami_statuscomplete',
            'Atxfer':               'ami_atxfer',                   #
    }
    
    
    def handle_ami_function(astid, evfunction, this_event):
        """
        Handles the AMI events related to a given function (i.e. containing the Event field).
        It roughly only dispatches them to the relevant commandset's methods.
        """
        try:
            if 'Privilege' in this_event:
                this_event.pop('Privilege')
            if dumpami:
                todisp = this_event
                if 'Event' in todisp:
                    efn = todisp.pop('Event')
                    for ik, iv in self.fdlist_established.iteritems():
                        if iv == 'INFO':
                            ik.sendall('%s %s %s\n' % (astid, efn, todisp))
            if evfunction == 'Reload':
                log.warning('%s AMI:Reload %s' % (astid, this_event))
                commandclass.ami_reload(astid, this_event)
            elif evfunction == 'Shutdown':
                shutdown = this_event.get('Shutdown')
                restart  = this_event.get('Restart')
                log.warning('%s AMI:Shutdown (how=%s restart=%s)' % (astid, shutdown, restart))
                commandclass.ami_shutdown(astid, this_event)
            elif evfunction.startswith('UserEvent'):
                commandclass.ami_userevent(astid, this_event)
            elif (evfunction in evfunction_to_method_name):
                getattr(commandclass, evfunction_to_method_name[evfunction])(astid, this_event)
            else:
                log.warning('%s AMI ... this event (%s) is not tracked : %s' % (astid, evfunction, this_event))
    
        except Exception:
            log.exception('%s AMI / %s : event %s' % (astid, evfunction, this_event))
    
    
    
    
    def update_amisocks(astid):
        """
        Connects to the Asterisk's AMI (defined by astid) if not yet done.
        Requests a Status when it (re)connects.
        """
        try:
            amilist.setconfig(astid,
                              (configs[astid].remoteaddr,
                               configs[astid].ami_port),
                              configs[astid].ami_login,
                              configs[astid].ami_pass)
            amilist.connect(astid)
            amilist.set_aoriginate(astid, configs[astid].aoriginate)
    
        except Exception:
            log.exception('%s (update_amisocks) %s:%d' % (astid, configs[astid].remoteaddr, configs[astid].ami_port))
        return
    
    tqueue = Queue.Queue()
    
    @staticmethod
    def callback_timer_main(*args):
        thisthread = threading.currentThread()
        tname = thisthread.getName()
        log.info('callback_timer_main (timer finished at %s) %s %s' % (time.asctime(), tname, args))
        thisthread.setName(tname + '-' + '-'.join(args))
        self.tqueue.put(thisthread)
        os.write(pipe_queued_threads_main[1], thisthread.getName())
        return
    
    def checkqueue_main():
        buf = os.read(pipe_queued_threads_main[0], 1024)
        log.info('checkqueue_main : read buf = %s, tqueue size = %d' % (buf, self.tqueue.qsize()))
        while self.tqueue.qsize() > 0:
            thisthread = self.tqueue.get()
            action = thisthread.args[0]
            if action == 'ipbxup':
                # check whether the AMI is already connected,
                # and connects if needed
                astid = thisthread.args[1]
                update_amisocks(astid)
            elif action == 'webirequest':
                # checks whether the given actionid is still ongoing and closes
                # the related WEBI request then
                actionid = thisthread.args[1]
                if actionid in waiting_actionid and actionid in waiting_actionid_timer:
                    conn_to_close = waiting_actionid[actionid]
                    del self.fdlist_established[conn_to_close]
                    conn_to_close.close()
                    del waiting_actionid[actionid]
                    del waiting_actionid_timer[actionid]
                    log.info('closing the WEBI connection %s for the request %s' % (conn_to_close, actionid))
                else:
                    log.warning('the actionid %s has gone' % actionid)
        return



class xivo_deamon:
    # ==============================================================================
    # Main Code starts here
    # ==============================================================================
    def __init__(self):
        # print sys.getdefaultencoding()
        logging.basicConfig(level=logging.INFO)
        #logging.basicConfig(level=logging.DEBUG)
        
        global log

        log = logging.getLogger('main')
        
        try:
            sysloghandler = SysLogHandler('/dev/log', SysLogHandler.LOG_DAEMON)
            formatter = logging.Formatter('%s[%%(process)d] (%%(levelname)s) (%%(name)s): %%(message)s' % LOGDAEMONNAME)
            sysloghandler.setFormatter(formatter)
            logging.getLogger('').addHandler(sysloghandler)
        
        except Exception:
            log.exception('sysloghandler')
        
        if not debug_mode:
            daemonize.daemonize()
        
        daemonize.lock_pidfile_or_die(PIDFILE)

        signal.signal(signal.SIGINT, self.sighandler)
        signal.signal(signal.SIGTERM, self.sighandler)
        signal.signal(signal.SIGHUP, self.sighandler_reload)
    
        self.nreload = 0
        self.directorylist = xivo_contexts.Contexts()
        global configs
        configs = {}
        xdname = None
        while True:
            self.main_loop()

    ## \brief Handler for catching signals (in the main thread)
    # \param signum signal number
    # \param frame frame
    # \return none
    def sighandler(signum, frame):
        log.warning('(sighandler) signal %s (atq = %s) received : quits' % (signum, self.askedtoquit))
        for t in filter(lambda x: x.getName() != 'MainThread', threading.enumerate()):
            print '--- living thread <%s>' % (t.getName())
            t._Thread__stop()
        self.askedtoquit = True
    
    
    ## \brief Handler for catching signals (in the main thread)
    # \param signum signal number
    # \param frame frame
    # \return none
    def sighandler_reload(signum, frame):
        log.warning('(sighandler_reload) signal %s (atq = %s) received : reloads' % (signum, self.askedtoquit))
        self.askedtoquit = False

    
    def update_readconf(self):
        log.info('reparsing config file(s)')
        lconf = cti_config.Config(XIVO_CONF_FILE)
        commandclass.set_cticonfig(lconf)
        commandclass.set_options(self.cconf.read_section('commandset', self.commandset), self.cconf)

    # loads the configuration for each asterisk
    def load_asterisk_conf(self):   # {
        for astid in self.asterisklist:
            xivoconf_asterisk = self.cconf.read_section('ipbx', astid)
            if len(xivoconf_asterisk) > 0:
                localaddr = '127.0.0.1'
                urllist = {}
                ipaddress = '127.0.0.1'
                ipaddress_webi = '127.0.0.1'
                ami_port = 5038
                ami_login = 'xivouser'
                ami_pass = 'xivouser'
                cdr_db_uri = userfeatures_db_uri = None
                realm = 'asterisk'
                parkingnumber = '700'
                faxcallerid = 'faxcallerid'
                linkestablished = ''
                aoriginate = 'AOriginate'
                url_queuelog = None
                
                if 'localaddr' in xivoconf_asterisk:
                    localaddr = xivoconf_asterisk['localaddr']
                for listname in commandclass.weblist.keys():
                    fieldname = 'urllist_%s' % listname
                    if fieldname in xivoconf_asterisk:
                        urllist[listname] = xivoconf_asterisk[fieldname].split(',')
                    else:
                        urllist[listname] = []
                if 'url_queuelog' in xivoconf_asterisk:
                    url_queuelog = xivoconf_asterisk['url_queuelog']
                if 'ipaddress' in xivoconf_asterisk:
                    ipaddress = xivoconf_asterisk['ipaddress']
                if 'ipaddress_webi' in xivoconf_asterisk:
                    ipaddress_webi = xivoconf_asterisk['ipaddress_webi']
                if 'parkingnumber' in xivoconf_asterisk:
                    parkingnumber = int(xivoconf_asterisk['parkingnumber'])
                if 'faxcallerid' in xivoconf_asterisk:
                    faxcallerid = int(xivoconf_asterisk['faxcallerid'])
                if 'linkestablished' in xivoconf_asterisk:
                    linkestablished = xivoconf_asterisk['linkestablished']
                if 'ami_port' in xivoconf_asterisk:
                    ami_port = int(xivoconf_asterisk['ami_port'])
                if 'ami_login' in xivoconf_asterisk:
                    ami_login = xivoconf_asterisk['ami_login']
                if 'ami_pass' in xivoconf_asterisk:
                    ami_pass = xivoconf_asterisk['ami_pass']
                if 'userfeatures_db_uri' in xivoconf_asterisk:
                    userfeatures_db_uri = xivoconf_asterisk['userfeatures_db_uri']
                if 'cdr_db_uri' in xivoconf_asterisk:
                    cdr_db_uri = xivoconf_asterisk['cdr_db_uri']
                if 'realm' in xivoconf_asterisk:
                    realm = xivoconf_asterisk['realm']
                if 'aoriginate' in xivoconf_asterisk:
                    aoriginate = xivoconf_asterisk['aoriginate']
                        
                capafeatures = []
                
                configs[astid] = xivo_astcfg.AsteriskConfig(astid,
                                                            localaddr,
                                                            ipaddress,
                                                            ipaddress_webi,
                                                            ami_port,
                                                            ami_login,
                                                            ami_pass,
                                                            userfeatures_db_uri,
                                                            capafeatures,
                                                            cdr_db_uri,
                                                            realm,
                                                            parkingnumber,
                                                            faxcallerid,
                                                            linkestablished,
                                                            aoriginate)
                
                for ilist in commandclass.weblist.keys():
                    commandclass.set_urllist(astid, ilist, urllist[ilist])
    
                t1 = time.time()
                commandclass.read_queuelog(astid, url_queuelog)
                t2 = time.time()
    
                log.info('%s spent %f seconds to read queuelog file' % (astid, t2 - t1))
                
                if ipaddress not in self.ip_reverse_sht:
                    self.ip_reverse_sht[ipaddress] = astid
                else:
                    log.warning('WARNING - IP address already exists for asterisk <%s> - can not set it for <%s>' %
                                (self.ip_reverse_sht[ipaddress], astid))
                if ipaddress_webi not in self.ip_reverse_webi:
                    self.ip_reverse_webi[ipaddress_webi] = astid
                else:
                    log.warning('WARNING - IP address (WEBI) already exists for asterisk <%s> - can not set it for <%s>' %
                                (self.ip_reverse_webi[ipaddress_webi], astid))
    
                global save_for_next_packet_events
                save_for_next_packet_events[astid] = ''
    # }
    
    def main_loop(self):    # {
        global amilist
        global commandclass

        self.askedtoquit = False
        
        time_start = time.localtime()
        if self.nreload == 0:
            log.info('# STARTING XiVO Daemon %s (pid %d) / svn:%s # (0/3) Starting' %
                     (XIVOVERSION, os.getpid(), __revision__))
        else:
                log.info('# STARTING XiVO Daemon %s (pid %d) / svn:%s # (0/3) Reloading (%d)' %
                         (XIVOVERSION, os.getpid(), __revision__, self.nreload))
        self.nreload += 1
        
        # global default definitions
        incoming_tcp_ports = []
        incoming_udp_ports = []
        self.asterisklist = []
        contextlist = []
        userlists = []
        ctilog = None
        
        userinfo_by_requester = {}
        userinfo_current = {}
        
        self.cconf = cti_config.Config(XIVO_CONF_FILE)
        xivoconf_general = self.cconf.read_section('general', 'general')
        
        # loads the general configuration
        commandset = xivoconf_general.get('commandset', 'xivocti')
        self.commandset = commandset
        if 'incoming_tcp_ports' in xivoconf_general:
            incoming_tcp_ports = xivoconf_general['incoming_tcp_ports'].split(',')
        if 'incoming_udp_ports' in xivoconf_general:
            incoming_udp_ports = xivoconf_general['incoming_udp_ports'].split(',')
        for func in ['CTI', 'WEBI', 'FAGI', 'INFO']:
            fieldname = 'incoming_tcp_%s' % func.lower()
            if fieldname in xivoconf_general:
                bind_and_port = xivoconf_general[fieldname].split(':')
                if len(bind_and_port) > 1:
                    try:
                        incoming_tcp_ports.append('%d:%s:%s' % (int(bind_and_port[1]), func, bind_and_port[0]))
                    except Exception:
                        log.exception('%s definition' % fieldname)
        for func in ['ANNOUNCE']:
            fieldname = 'incoming_udp_%s' % func.lower()
            if fieldname in xivoconf_general:
                bind_and_port = xivoconf_general[fieldname].split(':')
                if len(bind_and_port) > 1:
                    try:
                        incoming_udp_ports.append('%d:%s:%s' % (int(bind_and_port[1]), func, bind_and_port[0]))
                    except Exception:
                        log.exception('%s definition' % fieldname)
    
        extraconn = xivoconf_general.get('extraconn', '')
        updates_period = int(xivoconf_general.get('updates_period', '60'))
        ctilog = xivoconf_general.get('ctilog')
        socktimeout = xivoconf_general.get('sockettimeout', '2')
        logintimeout = int(xivoconf_general.get('logintimeout', '5'))
        apnoeafile = xivoconf_general.get('apnoeafile')
        prefixfile = xivoconf_general.get('prefixfile')
        parting_astid_context = xivoconf_general.get('parting_astid_context')
        if 'asterisklist' in xivoconf_general:
            self.asterisklist = xivoconf_general['asterisklist'].split(',')
        if 'contextlist' in xivoconf_general:
            contextlist = xivoconf_general['contextlist'].split(',')
        if 'userlists' in xivoconf_general:
            userlists = xivoconf_general['userlists'].split(',')
                
        socket.setdefaulttimeout(float(socktimeout))
        
        pipe_queued_threads_commandclass = os.pipe()
        pipe_queued_threads_main = os.pipe()

        amilist = xivo_ami.AMIList()
        if commandset in xivo_commandsets.CommandClasses:
            commandclass = xivo_commandsets.CommandClasses[commandset](amilist,
                                                                       incoming_tcp_ports,
                                                                       pipe_queued_threads_commandclass)
            xdname = commandclass.xdname
        else:
            commandclass = xivo_commandsets.BaseCommand()
            xdname = commandclass.xdname
            log.warning('# STARTING %s : no such commandset <%s>' % (xdname, commandset))

        self.commandclass = commandclass
    
        log.info('# STARTING %s / svn:%s / %d' % (xdname, commandclass.version(), self.nreload))
    
        self.update_readconf()
        commandclass.set_userlist_urls(userlists)
        commandclass.set_contextlist(self.directorylist)
        commandclass.set_configs(configs)
        commandclass.set_ctilog(ctilog)
        commandclass.set_logintimeout(logintimeout)
        
        if apnoeafile:
            try:
                e = open(apnoeafile, 'r')
                torescue = pickle.loads(e.read())
                e.close()
                commandclass.apnoea_rescue(torescue)
            except:
                log.exception('read apnoea file %s' % apnoeafile)
        if prefixfile:
            commandclass.read_internatprefixes(prefixfile)
        if parting_astid_context:
            commandclass.set_partings(parting_astid_context)
                
        for ctx in contextlist:
            xivoconf_context = self.cconf.read_section('context', ctx)
            if len(xivoconf_context) > 0:
                if 'contextname' in xivoconf_context:
                    contextname = xivoconf_context['contextname']
                if 'display' in xivoconf_context:
                    displaysection = xivoconf_context['display']
                    self.directorylist.setdisplay(contextname, self.cconf.read_section('displayitem', displaysection))
                if 'directories' in xivoconf_context:
                    directories = xivoconf_context['directories'].split(',')
                    for dr in directories:
                        xivoconf_dir = self.cconf.read_section('directory', dr)
                        self.directorylist.update(contextname, dr, xivoconf_dir)
                                        
        global save_for_next_packet_events
        save_for_next_packet_events = {}
        self.ip_reverse_webi = {}
        self.ip_reverse_sht = {}

        
        self.load_asterisk_conf()
                        
    
        self.outsock = commandclass.extrasock(extraconn)
    
        self.fdlist_established = {}
        self.fdlist_listen_cti = {}
        self.fdlist_udp_cti = {}
        update_userlist = {}
        lastrequest_time = {}
        xivodaemonreload = False
        
        log.info("the monitored asterisk's is/are : %s" % self.asterisklist)
        log.info('# STARTING %s # (1/2) AMI socket connections + fetch Web Services' % xdname)
        
        for astid in configs: # {
            try:
                update_userlist[astid] = False
                lastrequest_time[astid] = time.time()
                update_amisocks(astid)
            except Exception:
                log.exception('%s : failed while setting lists and sockets' % astid)
        # }
    
        try:
            commandclass.updates() # users' update, ...
        except Exception:
            log.exception('commandclass.updates()')
                
        log.info('# STARTING %s # (2/2) listening sockets (CTI, WEBI, (F)AGI, INFO)' % xdname)
        # opens the listening socket for incoming (CTI, WEBI, (F)AGI, INFO) connections
        for portkind in incoming_tcp_ports:
            pk = portkind.split(':')
            port = pk[0]
            kind = 'INFO'
            bind = '127.0.0.1'
            nmax = '1'
            if len(pk) > 1:
                kind = pk[1].strip()
                if len(pk) > 2:
                    bind = pk[2].strip()
                    if len(pk) > 3:
                        nmax = pk[3].strip()
            UIsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            UIsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            UIsock.bind((bind, int(port)))
            UIsock.listen(10)
            self.fdlist_listen_cti[UIsock] = '%s:%s' % (kind, nmax)
                
        for portkind in incoming_udp_ports:
            pk = portkind.split(':')
            port = pk[0]
            kind = 'INFO'
            bind = '127.0.0.1'
            nmax = '1'
            if len(pk) > 1:
                kind = pk[1].strip()
                if len(pk) > 2:
                    bind = pk[2].strip()
                    if len(pk) > 3:
                        nmax = pk[3].strip()
            UIsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            UIsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            UIsock.bind((bind, int(port)))
            self.fdlist_udp_cti[UIsock] = '%s:%s' % (kind, nmax)
                
        # Main select() loop - Receive messages

        while not self.askedtoquit:
            self.poll_step()
    # }

    def poll_step(self):    # {
        global commandclass

        try:    # {
            fdtodel = []
            for cn in self.fdlist_established.keys():
                if isinstance(cn, ClientConnection):
                    if cn.isClosed:
                        fdtodel.append(cn)
                    if cn.toClose and not cn.need_sending():
                        cn.close()
                        fdtodel.append(cn)
            if fdtodel:
                log.warning('there are fd to delete : %s' % fdtodel)
                for cn in fdtodel:
                    del self.fdlist_established[cn]
                    if cn in userinfo_by_requester:
                        del userinfo_by_requester[cn]
            
            self.fdlist_full = self.fdlist_listen_cti.keys() + self.fdlist_udp_cti.keys() + self.fdlist_established.keys()
            self.fdlist_full.extend(amilist.fdlist())
            self.fdlist_full.append(pipe_queued_threads_commandclass[0])
            self.fdlist_full.append(pipe_queued_threads_main[0])
            if self.outsock is not None:
                self.fdlist_full.append(self.outsock)
            writefds = []
            for iconn, kind in self.fdlist_established.iteritems():
                if kind == 'CTI' and iconn.need_sending():
                    writefds.append(iconn)
            [sels_i, sels_o, sels_e] = select.select(self.fdlist_full, writefds, [], updates_period)
        # }
        except Exception, exc:  # {
                log.exception('(select) probably Ctrl-C or daemon stop or daemon restart ...')
                log.warning('(select) self.askedtoquit=%s fdlist_full=%s' % (self.askedtoquit, self.fdlist_full))
                log.warning('(select) current open TCP connections : (CTI, WEBI, (F)AGI, INFO) %s' % self.fdlist_established)
                log.warning('(select) current open TCP connections : (AMI) %s' % amilist.fdlist())
                log.warning('(select) current open TCP connections : (OUT) %s' % self.outsock)
                
                if self.askedtoquit and apnoeafile:
                        try:
                                tosave = commandclass.apnoea_tosave()
                                e = open(apnoeafile, 'w')
                                e.write(pickle.dumps(tosave))
                                e.close()
                        except:
                                log.exception('write apnoea file %s' % apnoeafile)
                                
                for s in self.fdlist_full:
                        if s in self.fdlist_established and self.fdlist_established[s] == 'CTI':
                                if self.askedtoquit:
                                        commandclass.reset('stop', s)
                                else:
                                        commandclass.reset('reload', s)
                        if isinstance(s, int):
                                os.close(s)
                        else:
                                s.close()
                                
                if self.askedtoquit:
                        commandclass.reset('stop')
                        time_uptime = int(time.time() - time.mktime(time_start))
                        log.info('# STOPPING XiVO Daemon %s (pid %d) / svn:%s # uptime %d s (since %s)'
                                 % (XIVOVERSION, os.getpid(), __revision__,
                                    time_uptime, time.asctime(time_start)))
                        for t in filter(lambda x: x.getName() != 'MainThread', threading.enumerate()):
                                print '--- (stop) killing thread <%s>' % t.getName()
                                t._Thread__stop()
                        daemonize.unlock_pidfile(PIDFILE)
                        sys.exit(5)
                else:
                        commandclass.reset('reload')
                        self.askedtoquit = True
                        for t in filter(lambda x: x.getName() != 'MainThread', threading.enumerate()):
                                print '--- (reload) the thread <%s> remains' % t.getName()
                                # t._Thread__stop() # does not work in reload case (vs. stop case)
                        return
        # }
        try:    # {
            # connexions ready for sending(writing)
            for sel_o in sels_o:
                try:
                    sel_o.process_sending()
                except ClientConnection.CloseException, cexc:
                    if sel_o in userinfo_by_requester:
                        userinfo = userinfo_by_requester.get(sel_o)
                        commandclass.manage_logout(userinfo, 'end_sending')
                        del userinfo_by_requester[sel_o]
                    log.info('TCP socket %s closed(sending %s) on %s' % (self.fdlist_established[sel_o], cexc, sel_o.getpeername()))
        
                    if sel_o in self.fdlist_established:
                        del self.fdlist_established[sel_o]
                    commandclass.disconnected(sel_o)
            if sels_i:
                for sel_i in sels_i:
                        # these AMI connections are used in order to manage AMI commands and events
                        if sel_i in amilist.fdlist():
                                try:
                                        buf = sel_i.readline()
                                        astid = amilist.astid(sel_i)
                                        if len(buf) == 0:
                                                log.warning('%s AMI : CLOSING' % astid)
                                                amilist.remove(astid)
                                                sel_i.close()
                                        else:
                                                if astid is not None:
                                                        try:
                                                                handle_ami_event(astid, buf)
                                                        except Exception:
                                                                log.exception('(handle_ami_event) %s' % astid)
                                except Exception:
                                        log.exception('(amilist)')
                                        
                        # other 'outgoing' connections
                        elif sel_i == self.outsock:
                                try:
                                        msg = sel_i.recv(BUFSIZE_LARGE, socket.MSG_DONTWAIT)
                                except Exception:
                                        log.exception('outsock')
                                        msg = ''
                                if len(msg) == 0:
                                        sel_i.close()
                                        self.outsock = None
                                        log.warning('WARNING - outsock has closed the connection')
                                else:
                                        commandclass.handle_outsock(self.asterisklist[0], msg)
                                        
                        # the UDP messages (ANNOUNCE) are catched here
                        elif sel_i in self.fdlist_udp_cti:
                                [kind, nmax] = self.fdlist_udp_cti[sel_i].split(':')
                                if kind == 'ANNOUNCE':
                                        [data, sockparams] = sel_i.recvfrom(32768)
                                        if sockparams[0] in self.ip_reverse_sht:
                                                astid = self.ip_reverse_sht.get(sockparams[0])
                                        else:
                                                astid = 'xivo'
                                        log.info('UDP %s <%s> %s => %s' % (kind, data.strip(), sockparams, astid))
                                        if astid in configs:
                                                # scheduling astid's AMI reconnection
                                                k = threading.Timer(2, callback_timer_main, ('ipbxup', astid))
                                                k.start()
                                else:
                                        log.warning('unknown kind %s received' % kind)
                                        
                        # the new TCP connections (CTI, WEBI, (F)AGI, INFO) are catched here
                        elif sel_i in self.fdlist_listen_cti:
                                [kind, nmax] = self.fdlist_listen_cti[sel_i].split(':')
                                [connc, sockparams] = sel_i.accept()
                                if kind == 'FAGI':
                                        if sockparams[0] in self.ip_reverse_sht:
                                                astid = self.ip_reverse_sht.get(sockparams[0])
                                        else:
                                                astid = 'xivo'
                                        log.info('TCP socket FAGI opened on %s:%d => %s' % (sockparams[0], sockparams[1], astid))
                                        mfr = connc.makefile('rb', -1)
                                        mfw = connc.makefile('wb', 0)
                                        try:
                                                fagi = fastagi.FastAGI(mfr, mfw)
                                                commandclass.handle_fagi(astid, fagi)
                                        except Exception:
                                                log.exception('(fastagi) %s' % astid)
                                        mfr.close()
                                        mfw.close()
                                        connc.close()
                                        log.info('TCP socket FAGI closed on %s:%d' % (sockparams[0], sockparams[1]))
                                else:
                                        log.info('TCP socket %s opened on %s:%d' % (kind,
                                                                                    sockparams[0], sockparams[1]))
                                        if kind == 'CTI':
                                                connc = ClientConnection(connc, sockparams, commandclass.ctiseparator)
                                                commandclass.connected(connc)
                                        # appending the opened socket to the ones watched
                                        # connc.setblocking(0)
                                        # connc.settimeout(2)
                                        self.fdlist_established[connc] = kind
                                        
                        # incoming TCP connections (CTI, WEBI, AGI, INFO)
                        elif sel_i in self.fdlist_established:
                                try:
                                        kind = self.fdlist_established[sel_i]
                                        requester = '%s:%d' % sel_i.getpeername()
                                        if isinstance(sel_i, ClientConnection):
                                            try:
                                                while True:
                                                    line = sel_i.readline()
                                                    if line is None:
                                                        break
                                                    manage_tcp_connections(sel_i, line, kind)
                                            except ClientConnection.CloseException, cexc:
                                                if kind == 'CTI':
                                                    if sel_i in userinfo_by_requester:
                                                        userinfo = userinfo_by_requester.get(sel_i)
                                                        commandclass.manage_logout(userinfo, 'end_receiving')
                                                        del userinfo_by_requester[sel_i]
                                                if sel_i in self.fdlist_established:
                                                        del self.fdlist_established[sel_i]
                                                if requester in commandclass.transfers_ref:
                                                        commandclass.transfer_endbuf(requester)
                                                log.info('TCP socket %s closed(A %s) on %s' % (kind, cexc, requester))
                                                if kind == 'CTI':
                                                        commandclass.disconnected(sel_i)
                                        else:
                                            closemenow = False
                                            try:
                                                msg = sel_i.recv(BUFSIZE_LARGE, socket.MSG_DONTWAIT)
                                                lmsg = len(msg)
                                            except Exception:
                                                log.exception('connection to %s (%s)' % (requester, kind))
                                                lmsg = 0
                                            if lmsg > 0:
                                                try:
                                                        closemenow = manage_tcp_connections(sel_i, msg, kind)
                                                except Exception:
                                                        log.exception('handling %s (%s)' % (requester, kind))
                                            else:
                                                if kind == 'CTI':
                                                        if sel_i in userinfo_by_requester:
                                                                userinfo = userinfo_by_requester.get(sel_i)
                                                                commandclass.manage_logout(userinfo, 'end_receiving')
                                                                del userinfo_by_requester[sel_i]
                                            doclose = False
                                            if kind == 'WEBI':
                                                doclose = closemenow
                                            elif kind not in ['CTI', 'INFO'] or lmsg == 0:
                                                doclose = True
                                            if doclose:
                                                sel_i.close()
                                                if sel_i in self.fdlist_established:
                                                        del self.fdlist_established[sel_i]
                                                if requester in commandclass.transfers_ref:
                                                        commandclass.transfer_endbuf(requester)
                                                log.info('TCP socket %s closed(B) on %s' % (kind, requester))
                                                if kind == 'CTI':
                                                         commandclass.disconnected(sel_i)
                                except Exception:
                                        # socket.error : exc.args[0]
                                        log.exception('[%s] %s' % (kind, sel_i))
                                        try:
                                                del self.fdlist_established[sel_i]
                                                sel_i.close()
                                                if sel_i in userinfo_by_requester:
                                                        userinfo = userinfo_by_requester.get(sel_i)
                                                        log.warning('logging off %s following unexpected socket breakup' % userinfo)
                                                        commandclass.manage_logout(userinfo, 'exc')
                                                        del userinfo_by_requester[sel_i]
                                                else:
                                                        log.warning('could not find a match for socket %s' % sel_i)
                                        except Exception:
                                                log.exception('[%s] (2nd exception)' % kind)
                                                
                        # local pipe fd
                        elif pipe_queued_threads_commandclass[0] == sel_i:
                                try:
                                        actionqueue = commandclass.checkqueue()
                                        for actionname, actionarg in actionqueue.iteritems():
                                                if actionname == 'disconnlist-tcp':
                                                        # disconnect when timeout after first connection
                                                        disconnlist = actionarg
                                                        if disconnlist:
                                                                log.warning('checkqueue return : should disconnect %d connections' % len(disconnlist))
                                                                for connid in disconnlist:
                                                                        try:
                                                                                commandclass.telldisconn(connid)
                                                                        except Exception:
                                                                                log.exception('disconnlist-tcp')
                                                                        log.info('TCP socket %s closed(disconnlist) on %s'
                                                                                 % (self.fdlist_established[connid],
                                                                                    '%s:%d' % connid.getpeername()))
                                                                        del self.fdlist_established[connid]
                                                                        connid.close()
                                except Exception:
                                        log.exception('[pipe_queued_threads_commandclass]')
                                        
                        elif pipe_queued_threads_main[0] == sel_i:
                                try:
                                        checkqueue_main()
                                except Exception:
                                        log.exception('[pipe_queued_threads_main]')
                                        
                        try:
                                userdiscolist = commandclass.disconnlist
                                if userdiscolist:
                                        log.warning('commandclass.disconnlist : should disconnect %d users' % len(userdiscolist))
                                        for userinfo in userdiscolist:
                                                log.warning('checkqueue return : will disconnect %s' % userinfo)
                                                if 'login' in userinfo and 'connection' in userinfo.get('login'):
                                                        connid = userinfo.get('login')['connection']
                                                        if connid in self.fdlist_established:
                                                                del self.fdlist_established[connid]
                                                        else:
                                                                log.warning('connid %s no more in fdlists' % connid)
                                                        commandclass.manage_logout(userinfo, 'pipe')
                                                        del userinfo_by_requester[connid]
                                                        if not connid.isClosed:
                                                                connid.close()
                                                else:
                                                        log.warning('WARNING - no login/connection field present in userinfo')
                                commandclass.clear_disconnlist()
                        except Exception:
                                log.exception('userdiscolist')
                                
                        for astid in configs:
                                if (time.time() - lastrequest_time[astid]) > updates_period or update_userlist[astid]:
                                        lastrequest_time[astid] = time.time()
                                        log.info('[%s] %s : updates (computed timeout) %s'
                                                  % (xdname, astid, time.asctime()))
                                        try:
                                                if self.outsock is None:
                                                        self.outsock = commandclass.extrasock(extraconn)
                                                update_amisocks(astid)
                                                self.update_readconf()
                                                commandclass.regular_update()
                                                update_userlist[astid] = False
                                        except Exception:
                                                log.exception('%s : failed while updating lists and sockets (computed timeout)' % astid)
                                        try:
                                                commandclass.updates() # users' update, ...
                                        except Exception:
                                                log.exception('commandclass.updates() (computed timeout)')
            else: # when nothing happens on the sockets, we fall here sooner or later
                log.info('[%s] updates (select timeout) %s'
                          % (xdname, time.asctime()))
                try:
                        commandclass.updates() # users' update, ...
                except Exception:
                        log.exception('commandclass.updates() (select timeout)')
                for astid in configs:
                        lastrequest_time[astid] = time.time()
                        try:
                                if self.outsock is None:
                                        self.outsock = commandclass.extrasock(extraconn)
                                update_amisocks(astid)
                                self.update_readconf()
                                commandclass.regular_update()
                        except Exception:
                                log.exception('%s : failed while updating lists and sockets (select timeout)' % astid)
        # }
        except Exception:
            log.exception('poll step')
    # }


xivo_deamon()
