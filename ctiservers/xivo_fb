#!/usr/bin/python

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Alternatively, XIVO Daemon is available under other licenses directly
# contracted with Pro-formatique SARL. See the LICENSE file at top of the
# source tree or delivered in the installable package in which XIVO Daemon
# is distributed for more details.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, you will find one at
# <http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>.

__version__   = '$Revision$'
__date__      = '$Date$'
__copyright__ = 'Copyright (C) 2007, 2008, Proformatique'
__author__    = 'Corentin Le Gall'

## \mainpage
# \section section_1 General description of XIVO Daemon
# The XIVO Daemon aims to monitor all the actions taking place into one or
# more Asterisk servers, in order to provide 2 basic customer facilities :
# - a monitoring switchboard;
# - a customer information popup.
#
# This is achieved thanks to 2 mechanisms :
# - one or more connections to the Asterisk Manager Interface (AMI), where
# all the events can be watched;
# - Asterisk AGI's that send informations when a call is issued.
#
# This daemon is able to manage any number of Asterisk's one might wish.
#
# \section section_2 Initializations
#
# - Fetch the phone number lists from the WEB Interface.
#
# \section section_3 Main loop
# The main loop is triggered by a select() on the file descriptors for :
# - the AMI Event sockets (AMIsocks);
# - the UI sockets (UIsock, WEBIsock);
# - the Caller Information Popup sockets (authentication, keepalive and identrequest).
#
# On reception of AMI Events, handle_ami_event() parses the messages to update
# the detailed status of the channels.
#
# For each UI connection, a list of the open UI connections is updated
# (tcpopens_sb or tcpopens_webi according to the kind of connection).
# This list is the one used to broadcast the miscellaneous updates
# (it is up to the UI clients to fetch the initial status with the "hints"
# command).
#
# \section section_6 Monitoring with AMI
#
# The AMI events are the basis for a channel-by-channel status of the phones.
#
# Many AMI events are watched for, but not all of them are handled yet.
# The most useful ones are now : Dial, Link, Hangup, Rename.
# The following ones : Newexten, Newchannel, Newcallerid, Newstate are useful when dealing
# complex situations (when there are Local/ channels and Queues for instance).
#
# \section section_8 Caller Information Popup management
#
# The daemon has 3 other listening sockets :
# - Login - TCP - (the clients connect to it to login)
# - KeepAlive - UDP - (the clients send datagram to it to inform
#                      of their current state)
# - IdentRequest - TCP - offer a service to ask for localization and
#                        state of the clients.
# we use the SocketServer "framework" to implement the "services"
# see http://docs.python.org/lib/module-SocketServer.html
#
# \section section_9 Data Structures
#
# The statuses of all the lines/channels are stored in the multidimensional array/dict "plist",
# which is an array of PhoneList.
#
# plist[astn].normal[phonenum].chann[channel] are objects of the class ChannelStatus.
# - astn is the Asterisk id
# - phonenum is the phone id (SIP/<xx>, IAX2/<yy>, ...)
# - channel is the full channel name as known by Asterisk
#
## \file xivo_daemon.py
# \brief XIVO CTI server
#
## \namespace xivo_daemon
# \brief XIVO CTI server
#

__revision__ = __version__.split()[1]

# debian.org modules
import ConfigParser
import getopt
import os
import select
import signal
import socket
import sys
import threading
import time

# XIVO lib-python modules initialization
import xivo.to_path
xivoconffile            = "/etc/asterisk/xivo_fb.conf"
GETOPT_SHORTOPTS        = 'dc:'
GETOPT_LONGOPTS         = ["debug", "config="]
debug_mode = False
def config_path():
        global xivoconffile, debug_mode
        for opt, arg in getopt.getopt(
                sys.argv[1:],
                GETOPT_SHORTOPTS,
                GETOPT_LONGOPTS
                )[0]:
                if opt == "-c":
                        xivoconffile = arg
		elif opt == "-d":
			debug_mode = True
config_path()

# XIVO lib-python modules imports
import daemonize
from easyslog import *
import anysql
from BackSQL import backmysql
from BackSQL import backsqlite

# XIVO modules
import xivo_ami
import xivo_phones
import xivo_users
import xivo_contexts
import xivo_commandsets
import xivo_astcfg
from xivo_log import *
from CommandSets import *

configs = {}

# global : userlist
# liste des champs :
#  user :             user name
#  passwd :           password

PIDFILE = 'xivo_fb.pid'
# TODO: command line parameter

BUFSIZE_LARGE = 8192
BUFSIZE_ANY = 512

socket.setdefaulttimeout(2)
XIVO_CLI_WEBI_HEADER = 'XIVO-CLI-WEBI'
XIVOVERSION = '0.3'


## \brief Deals with requests from the UI clients.
# \param connid connection identifier
# \param msg message to process
# \param sep separator to split the message
# \return none
def manage_cti_connections(connid, msg, sep):
        """
        Handles CTI connections
        """
        requester_ip = connid.getpeername()[0]
        requester_port = connid.getpeername()[1]
        requester = '%s:%d' % (requester_ip, requester_port)

        multimsg = msg.split(sep)
        for usefulmsgpart in multimsg:
                usefulmsg = usefulmsgpart.split('\r')[0]
                if len(usefulmsg) == 0:
                        break
                command = commandclass.parsecommand(usefulmsg)
                if command.name in commandclass.get_list_commands():
                        try:
                                if command.type == xivo_commandsets.CMD_LOGIN:
                                        loginparams = commandclass.get_login_params(asterisklist[0], command, connid)
                                        uinfo = commandclass.manage_login(loginparams)
                                        if uinfo.__class__.__name__ == 'str':
                                                commandclass.loginko(loginparams, uinfo, connid)
                                        else:
                                                uinfo['login']['connection'] = connid
                                                commandclass.loginok(loginparams, uinfo)
                                                userinfo_by_requester[connid] = uinfo
                                else:
                                        if connid in userinfo_by_requester:
                                                commandclass.manage_cticommand(userinfo_by_requester[connid],
                                                                               connid,
                                                                               command)
                                        else:
                                                log_debug(SYSLOG_WARNING, "unlogged %s is attempting a %s (TCP) : %s" %(requester, command.name, str(command.args)))
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- CTI connection when managing [%s] for %s : %s'
                                          %(command.name, requester, str(exc)))
                else:
                        connid.send('Unknown Command <%s>\n' % command.name)


## \brief Deals with requests from the UI clients.
# \param connid connection identifier
# \return none
def manage_webi_connections(connid, msg, sep):
        """
        Handles WEBI connections
        """
        requester_ip = connid.getpeername()[0]
        requester_port = connid.getpeername()[1]
        requester = '%s:%d' % (requester_ip, requester_port)

        multimsg = msg.split(sep)
        for usefulmsgpart in multimsg:
                usefulmsg = usefulmsgpart.split('\r')[0]
                if len(usefulmsg) == 0:
                        break
                if requester_ip in ip_reverse_webi:
                        try:
                                astid = ip_reverse_webi[requester_ip]
                                connid.send('%s:ID <%s>\n' %(XIVO_CLI_WEBI_HEADER, astid))
                                if usefulmsg == 'xivo[userlist,update]':
                                        update_userlist[astid] = True
                                        connid.send('%s:OK\n' %(XIVO_CLI_WEBI_HEADER))
                                        log_debug(SYSLOG_INFO, '%s : userlist update request received' % astid)
                                elif astid in AMI_array_user_commands and AMI_array_user_commands[astid]:
                                        stripped_usefulmsg = usefulmsg.strip()
                                        try:
                                                if stripped_usefulmsg == 'moh reload':
                                                        commandclass.pre_moh_reload()
                                                elif stripped_usefulmsg == 'reload':
                                                        commandclass.pre_reload()
                                        except Exception, exc:
                                                log_debug(SYSLOG_ERR, '--- exception --- (pre reloads) : %s' % str(exc))
                                        try:
                                                s = AMI_array_user_commands[astid].execclicommand(stripped_usefulmsg)
                                        except Exception, exc:
                                                log_debug(SYSLOG_ERR, '--- exception --- (%s) WEBI command exec <%s> : (client %s) : %s'
                                                          %(astid, str(stripped_usefulmsg), requester, str(exc)))
                                        try:
                                                for x in s: connid.send(x)
                                                connid.send('%s:OK\n' %(XIVO_CLI_WEBI_HEADER))
                                        except Exception, exc:
                                                log_debug(SYSLOG_ERR, '--- exception --- (%s) WEBI command reply <%s> : (client %s) : %s'
                                                          %(astid, str(stripped_usefulmsg), requester, str(exc)))
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- (%s) WEBI <%s> : (client %s) : %s'
                                          %(astid, str(usefulmsg.strip()), requester, str(exc)))
                                connid.send('%s:KO <Exception : %s>\n' %(XIVO_CLI_WEBI_HEADER, str(exc)))
                else:
                        connid.send('%s:KO <NOT ALLOWED>\n' %(XIVO_CLI_WEBI_HEADER))


## \brief Deals with requests from the UI clients.
# \param connid connection identifier
# \return none
def manage_info_connections(connid, msg, sep):
        """
        Handles INFO connections
        """
        requester = '%s:%d' % (connid.getpeername()[0], connid.getpeername()[1])
        multimsg = msg.replace('\r', '').split(sep)
        for usefulmsg in multimsg:
                if len(usefulmsg) == 0:
                        break
                try:
                        if usefulmsg == "show_infos":
                                time_uptime = int(time.time() - time_start)
                                reply = 'infos=' \
                                        'xivo_version=%s;' \
                                        'server_version=%s;' \
                                        'uptime=%d s' \
                                        %(XIVOVERSION,
                                          __revision__,
                                          time_uptime)
                                connid.send(reply + "\n")
                                # connid.send("server capabilities = %s\n" %(",".join()))
                        elif usefulmsg == 'show_users':
                                for astid in configs:
                                        connid.send("on <%s> :\n" % astid)
                                        for user,info in ulist.byast[astid].listusers().iteritems():
                                                connid.send('%s %s\n' %(user.encode('latin1'), info))
                        elif usefulmsg == 'show_logged':
                                for astid in configs:
                                        connid.send("on <%s> :\n" % astid)
                                        for user,info in ulist.byast[astid].listconnected().iteritems():
                                                connid.send('%s %s\n' %(user.encode('latin1'), info))
                        elif usefulmsg == "show_ami":
                                for amis in AMI_array_events_fd:
                                        connid.send("events   : %s : %s\n" %(amis, str(AMI_array_events_fd[amis])))
                                for amis in AMI_array_user_commands:
                                        connid.send("commands : %s : %s\n" %(amis, str(AMI_array_user_commands[amis])))
                        else:
                                pass
                        connid.send("XIVO-INFO:OK\n")
                except Exception, exc:
                        log_debug(SYSLOG_ERR, '--- exception --- INFO connection [%s] : KO when sending to %s : %s'
                                  %(usefulmsg, requester, str(exc)))



def manage_tcp_connections(sel_i, msg, kind):
        """
        Dispatches the message's handling according to the connection's kind
        """
        if kind == 'CTI':
                manage_cti_connections(sel_i, msg, commandclass.separator)
        elif kind == 'WEBI':
                manage_webi_connections(sel_i, msg, '\n')
        elif kind == 'INFO':
                manage_info_connections(sel_i, msg, '\n')
        elif kind == 'AGI':
                agireply = commandclass.handle_agi(asterisklist[0], msg)
                if agireply is not None:
                        sel_i.send(agireply)
        else:
                log_debug(SYSLOG_WARNING, 'unknown connection kind %s' % kind)


"""
Management of events that are spied on the AMI
"""
## \brief Handling of AMI events occuring in Events=on mode.
# \param astid the asterisk Id
# \param idata the data read from the AMI we want to parse
# \return none
def handle_ami_event(astid, idata):
        """
        Handles the AMI events occuring on Asterisk.
        If the Event field is there, calls the handle_ami_function() function.
        """
        global save_for_next_packet_events
        if astid not in configs:
                log_debug(SYSLOG_INFO, "%s : no such asterisk Id" % astid)
                return

        full_idata = save_for_next_packet_events[astid] + idata
        evlist = full_idata.split("\r\n\r\n")
        save_for_next_packet_events[astid] = evlist.pop()

        for evt in evlist:
                this_event = {}
                for myline in evt.split('\r\n'):
                        myfieldvalue = myline.split(': ', 1)
                        if len(myfieldvalue) == 2:
                                this_event[myfieldvalue[0]] = myfieldvalue[1]
                evfunction = this_event.get('Event')
                verboselog("/%s/ %s" %(astid, str(this_event)), True, False)
                # print '////////', evfunction, '   ------  ', this_event
                if evfunction is not None:
                        handle_ami_function(astid, evfunction, this_event)
                else:
                        response = this_event.get('Response')
                        if response is not None:
                                if response == 'Follows' and this_event.get('Privilege') == 'Command':
                                        log_debug(SYSLOG_INFO, 'AMI %s Response=Follows : %s' % (astid, str(this_event)))
                                elif response == 'Success':
                                        # log_debug(SYSLOG_INFO, 'AMI %s Response=Success : %s' % (astid, str(this_event)))
                                        pass
                                else:
                                        log_debug(SYSLOG_WARNING, 'AMI %s Response=%s (untracked) : %s' % (astid, response, str(this_event)))
                        elif len(this_event) > 0:
                                log_debug(SYSLOG_WARNING, 'AMI:XXX: <%s> : %s' % (astid, str(this_event)))
                        else:
                                log_debug(SYSLOG_WARNING, 'AMI %s Other : %s' % (astid, str(this_event)))


def handle_ami_function(astid, evfunction, this_event):
        """
        Handles the AMI events related to a given function (i.e. containing the Event field).
        It roughly only dispatches them to the relevant commandset's methods.
        """
        try:
                if evfunction == 'Reload':
                        message = this_event.get('Message')
                        log_debug(SYSLOG_WARNING, "AMI:Reload: %s : %s" %(astid, str(this_event)))
                        commandclass.ami_reload(astid, this_event)
                elif evfunction == 'Shutdown':
                        shutdown = this_event.get('Shutdown')
                        restart  = this_event.get('Restart')
                        log_debug(SYSLOG_WARNING, "AMI:Shutdown: %s (how=%s restart=%s)" %(astid, shutdown, restart))
                        commandclass.ami_shutdown(astid, this_event)
                elif evfunction == 'Registry':
                        commandclass.ami_registry(astid, this_event)
                elif evfunction == 'Dial':
                        commandclass.ami_dial(astid, this_event)
                elif evfunction == 'Link':
                        commandclass.ami_link(astid, this_event)
                elif evfunction == 'Unlink':
                        commandclass.ami_unlink(astid, this_event)
                elif evfunction == 'Hangup':
                        commandclass.ami_hangup(astid, this_event)
                elif evfunction == 'Join':
                        commandclass.ami_join(astid, this_event)
                elif evfunction == 'Leave':
                        commandclass.ami_leave(astid, this_event)
                elif evfunction == 'PeerStatus':
                        commandclass.ami_peerstatus(astid, this_event)
                elif evfunction == 'Agentlogin':
                        commandclass.ami_agentlogin(astid, this_event)
                elif evfunction == 'Agentlogoff':
                        commandclass.ami_agentlogoff(astid, this_event)
                elif evfunction == 'Agentcallbacklogin':
                        commandclass.ami_agentcallbacklogin(astid, this_event)
                elif evfunction == 'Agentcallbacklogoff':
                        commandclass.ami_agentcallbacklogoff(astid, this_event)
                elif evfunction == 'AgentCalled':
                        commandclass.ami_agentcalled(astid, this_event)
                elif evfunction == 'AgentComplete':
                        commandclass.ami_agentcomplete(astid, this_event)
                elif evfunction == 'AgentConnect':
                        commandclass.ami_agentconnect(astid, this_event)
                elif evfunction == 'AgentDump':
                        commandclass.ami_agentdump(astid, this_event)
                elif evfunction == 'Agents':
                        commandclass.ami_agents(astid, this_event)
                elif evfunction == 'ParkedCall': # when the requested parking is acked
                        commandclass.ami_parkedcall(astid, this_event)
                elif evfunction == 'UnParkedCall':
                        commandclass.ami_unparkedcall(astid, this_event)
                elif evfunction == 'ParkedCallTimeOut':
                        commandclass.ami_parkedcalltimeout(astid, this_event)
                elif evfunction == 'ParkedCallGiveUp':
                        commandclass.ami_parkedcallgiveup(astid, this_event)
                elif evfunction == 'ParkedCallsComplete':
                        commandclass.ami_parkedcallscomplete(astid, this_event)
                elif evfunction == 'Cdr':
                        commandclass.ami_cdr(astid, this_event)
                elif evfunction == 'Alarm':
                        commandclass.ami_alarm(astid, this_event)
                elif evfunction == 'AlarmClear':
                        commandclass.ami_alarmclear(astid, this_event)
                elif evfunction == 'FaxReceived':
                        commandclass.ami_faxreceived(astid, this_event)
                elif evfunction == 'MeetmeJoin': # when a member joins a conference
                        commandclass.ami_meetmejoin(astid, this_event)
                elif evfunction == 'MeetmeLeave': # when a member leaves a conference
                        commandclass.ami_meetmeleave(astid, this_event)
                elif evfunction == 'ExtensionStatus':
                        commandclass.ami_extensionstatus(astid, this_event)
                elif evfunction == 'OriginateSuccess':
                        commandclass.ami_originatesuccess(astid, this_event)
                elif evfunction == 'AOriginateSuccess':
                        commandclass.ami_aoriginatesuccess(astid, this_event)
                elif evfunction == 'OriginateFailure':
                        commandclass.ami_originatefailure(astid, this_event)
                elif evfunction == 'AOriginateFailure':
                        commandclass.ami_aoriginatefailure(astid, this_event)
                elif evfunction == 'Rename': # appears when there is a transfer
                        commandclass.ami_rename(astid, this_event)
                elif evfunction == 'Newstate':
                        commandclass.ami_newstate(astid, this_event)
                elif evfunction == 'Newcallerid': # useful for tricky managements
                        commandclass.ami_newcallerid(astid, this_event)
                elif evfunction == 'Newchannel':
                        commandclass.ami_newchannel(astid, this_event)
                elif evfunction.startswith('UserEvent'):
                        commandclass.ami_userevent(astid, this_event)
                elif evfunction == 'Newexten': # in order to handle outgoing calls ?
                        commandclass.ami_newexten(astid, this_event)
                elif evfunction == 'MessageWaiting':
                        commandclass.ami_messagewaiting(astid, this_event)
                elif evfunction == 'QueueParams':
                        commandclass.ami_queueparams(astid, this_event)
                elif evfunction == 'QueueMemberAdded':
                        commandclass.ami_queuememberadded(astid, this_event)
                elif evfunction == 'QueueMemberPaused':
                        commandclass.ami_queuememberpaused(astid, this_event)
                elif evfunction == 'QueueMemberRemoved':
                        commandclass.ami_queuememberremoved(astid, this_event)
                elif evfunction == 'QueueMember':
                        commandclass.ami_queuemember(astid, this_event)
                elif evfunction == 'QueueMemberStatus':
                        commandclass.ami_queuememberstatus(astid, this_event)
                elif evfunction == 'Status':
                        commandclass.ami_status(astid, this_event)
                elif evfunction == 'StatusComplete':
                        commandclass.ami_statuscomplete(astid, this_event)
                elif evfunction == 'AgentsComplete':
                        commandclass.ami_agentscomplete(astid, this_event)
                else:
                        log_debug(SYSLOG_WARNING, 'AMI %s ... this event (%s) is not tracked' % (astid, evfunction))
        except Exception, exc:
                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))


## \brief Connects to the AMI if not yet.
# \param astid Asterisk id to (re)connect
# \return none
def update_amisocks(astid):
        """
        Connects to the AMI if not yet done.
        
        """
        try:
                if astid not in AMI_array_events_fd or AMI_array_events_fd[astid] is False:
                        log_debug(SYSLOG_INFO, '%s : AMI : attempting to connect' % astid)
                        als0 = connect_to_AMI((configs[astid].remoteaddr,
                                               configs[astid].ami_port),
                                              configs[astid].ami_login,
                                              configs[astid].ami_pass,
                                              True)
                        if als0:
                                AMI_array_events_fd[astid] = als0.fd
                                fdlist_full.append(als0.fd)
                                log_debug(SYSLOG_INFO, '%s : AMI : connected' % astid)
##                                for x in plist[astid].normal.itervalues():
##                                        x.clear_channels()
                                ret = als0.sendstatus()
                                if not ret:
                                        log_debug(SYSLOG_INFO, '%s : could not send status command' % astid)
                                ret = als0.sendagents()
                                if not ret:
                                        log_debug(SYSLOG_INFO, '%s : could not send agents command' % astid)
                        else:
                                log_debug(SYSLOG_INFO, '%s : AMI : could NOT connect' % astid)
        except Exception, exc:
                log_debug(SYSLOG_ERR, '--- exception --- %s (update_amisocks) : %s' % (astid, str(exc)))

        try:
                if astid not in AMI_array_user_commands or AMI_array_user_commands[astid] is False:
                        log_debug(SYSLOG_INFO, '%s : AMI (commands)  : attempting to connect' % astid)
                        als1 = connect_to_AMI((configs[astid].remoteaddr,
                                               configs[astid].ami_port),
                                              configs[astid].ami_login,
                                              configs[astid].ami_pass,
                                              False)
                        if als1:
                                AMI_array_user_commands[astid] = als1
                                log_debug(SYSLOG_INFO, '%s : AMI (commands)  : connected' % astid)
                        else:
                                log_debug(SYSLOG_INFO, '%s : AMI (commands)  : could NOT connect' % astid)
        except Exception, exc:
                log_debug(SYSLOG_ERR, '--- exception --- %s (update_amisocks command) : %s' % (astid, str(exc)))


## \brief Connects to the AMI through AMIClass.
# \param address IP address
# \param loginname loginname
# \param password password
# \return the socket
def connect_to_AMI(address, loginname, password, events_on):
        """
        Connects to the AMI.
        """
        lAMIsock = xivo_ami.AMIClass(address, loginname, password, events_on)
        try:
                lAMIsock.connect()
                lAMIsock.login()
        except socket.timeout: pass
        except socket:         pass
        except:
                del lAMIsock
                lAMIsock = False
        return lAMIsock



## \brief Handler for catching signals (in the main thread)
# \param signum signal number
# \param frame frame
# \return none
def sighandler(signum, frame):
        global askedtoquit
        print '--- signal %s (atq = %s) received : quits' % (signum, askedtoquit)
        for t in filter(lambda x: x.getName()<>"MainThread", threading.enumerate()):
                print "--- living thread <%s>" %(t.getName())
                t._Thread__stop()
        askedtoquit = True


## \brief Handler for catching signals (in the main thread)
# \param signum signal number
# \param frame frame
# \return none
def sighandler_reload(signum, frame):
        global askedtoquit
        print '--- signal %s (atq = %s) received : reloads' % (signum, askedtoquit)
        askedtoquit = False

# ==============================================================================
# ==============================================================================

def log_stderr_and_syslog(x):
        print >> sys.stderr, x
        syslogf(SYSLOG_ERR, x)

# ==============================================================================
# Main Code starts here
# ==============================================================================

# daemonize if not in debug mode
if not debug_mode:
        daemonize.daemonize(log_stderr_and_syslog, PIDFILE, True)
else:
        daemonize.create_pidfile_or_die(log_stderr_and_syslog, PIDFILE, True)

signal.signal(signal.SIGINT, sighandler)
signal.signal(signal.SIGTERM, sighandler)
signal.signal(signal.SIGHUP, sighandler_reload)

nreload = 0
ulist = xivo_users.Users()
plist = xivo_phones.Phones()
ctxlist = xivo_contexts.Contexts()
xdname = None

while True: # loops over the reloads
        askedtoquit = False

        time_start = time.time()
        if nreload == 0:
                log_debug(SYSLOG_NOTICE, '# STARTING XIVO Daemon %s / svn %s # (0/3) Starting'
                          %(XIVOVERSION, __revision__))
        else:
                log_debug(SYSLOG_NOTICE, '# STARTING XIVO Daemon %s / svn %s # (0/3) Reloading (%d)'
                          %(XIVOVERSION, __revision__, nreload))
        nreload += 1
        
        # global default definitions
        commandset = 'xivosimple'
        incoming_tcp_ports = []
        extraconn = ''
        updates_period = 60
        asterisklist = []
        contextlist = []

        userinfo_by_requester = {}

        xivoconf = ConfigParser.ConfigParser()
        xivoconf.readfp(open(xivoconffile))
        xivoconf_general = dict(xivoconf.items('general'))

        # loads the general configuration
        if 'commandset' in xivoconf_general:
                commandset = xivoconf_general['commandset']
        if 'incoming_tcp_ports' in xivoconf_general:
                incoming_tcp_ports = xivoconf_general['incoming_tcp_ports'].split(',')
        if 'extraconn' in xivoconf_general:
                extraconn = xivoconf_general['extraconn']
        if 'updates_period' in xivoconf_general:
                updates_period = int(xivoconf_general['updates_period'])
        if 'asterisklist' in xivoconf_general:
                asterisklist = xivoconf_general['asterisklist'].split(',')

        queued_threads_pipe = os.pipe()
        AMI_array_user_commands = {}
        commandclass = xivo_commandsets.CommandClasses[commandset](AMI_array_user_commands, incoming_tcp_ports, queued_threads_pipe)

        xdname = commandclass.xdname
        log_debug(SYSLOG_NOTICE, '# STARTING %s / %d' % (xdname, nreload))

        commandclass.set_userlist(ulist)
        commandclass.set_phonelist(plist)
        commandclass.set_contextlist(ctxlist)
        ulist.setcommandclass(commandclass)
        plist.setcommandclass(commandclass)

        save_for_next_packet_events = {}
        ip_reverse_webi = {}
        ip_reverse_sht = {}

        # sets options specific to the commandset
        if commandset in xivoconf.sections():
                xivoconf_cs = dict(xivoconf.items(commandset))
                commandclass.set_options(xivoconf_cs)

        # loads the configuration for each asterisk
        for astid in xivoconf.sections():
                if astid != 'general' and astid in asterisklist:
                        xivoconf_local = dict(xivoconf.items(astid))

                        localaddr = '127.0.0.1'
                        userlist_url = 'sso.php'
                        ipaddress = '127.0.0.1'
                        ipaddress_webi = '127.0.0.1'
                        extrachannels = ''
                        ami_port = 5038
                        ami_login = 'xivouser'
                        ami_pass = 'xivouser'
                        contexts = ''
                        cdr_db_uri = userfeatures_db_uri = None
                        realm = 'asterisk'
                        parkingnumber = '700'
                        faxcallerid = 'faxcallerid'
                        linkestablished = ''

                        if 'localaddr' in xivoconf_local:
                                localaddr = xivoconf_local['localaddr']
                        if 'userlisturl' in xivoconf_local:
                                userlist_url = xivoconf_local['userlisturl']
                        if 'ipaddress' in xivoconf_local:
                                ipaddress = xivoconf_local['ipaddress']
                        if 'ipaddress_webi' in xivoconf_local:
                                ipaddress_webi = xivoconf_local['ipaddress_webi']
                        if 'extrachannels' in xivoconf_local:
                                extrachannels = xivoconf_local['extrachannels']
                        if 'parkingnumber' in xivoconf_local:
                                parkingnumber = int(xivoconf_local['parkingnumber'])
                        if 'faxcallerid' in xivoconf_local:
                                faxcallerid = int(xivoconf_local['faxcallerid'])
                        if 'linkestablished' in xivoconf_local:
                                linkestablished = xivoconf_local['linkestablished']
                        if 'ami_port' in xivoconf_local:
                                ami_port = int(xivoconf_local['ami_port'])
                        if 'ami_login' in xivoconf_local:
                                ami_login = xivoconf_local['ami_login']
                        if 'ami_pass' in xivoconf_local:
                                ami_pass = xivoconf_local['ami_pass']
                        if 'contexts' in xivoconf_local:
                                contexts = xivoconf_local['contexts']
                                if contexts != '':
                                        for c in contexts.split(','):
                                                contextlist.append(c)
                        if 'userfeatures_db_uri' in xivoconf_local:
                                userfeatures_db_uri = xivoconf_local['userfeatures_db_uri']
                        if 'cdr_db_uri' in xivoconf_local:
                                cdr_db_uri = xivoconf_local['cdr_db_uri']
                        if 'realm' in xivoconf_local:
                                realm = xivoconf_local['realm']

                        capafeatures = []
                        unallowed = []

                        configs[astid] = xivo_astcfg.AsteriskConfig(astid,
                                                                    userlist_url,
                                                                    extrachannels,
                                                                    localaddr,
                                                                    ipaddress,
                                                                    ipaddress_webi,
                                                                    ami_port,
                                                                    ami_login,
                                                                    ami_pass,
                                                                    userfeatures_db_uri,
                                                                    capafeatures,
                                                                    cdr_db_uri,
                                                                    realm,
                                                                    parkingnumber,
                                                                    faxcallerid,
                                                                    linkestablished)

                        if ipaddress not in ip_reverse_sht:
                                ip_reverse_sht[ipaddress] = astid
                        else:
                                log_debug(SYSLOG_WARNING, 'WARNING - IP address already exists for asterisk <%s> - can not set it for <%s>'
                                          % (ip_reverse_sht[ipaddress], astid))
                        if ipaddress_webi not in ip_reverse_webi:
                                ip_reverse_webi[ipaddress_webi] = astid
                        else:
                                log_debug(SYSLOG_WARNING, 'WARNING - IP address (WEBI) already exists for asterisk <%s> - can not set it for <%s>'
                                          % (ip_reverse_webi[ipaddress_webi], astid))
                        save_for_next_packet_events[astid] = ''


        for ctx in xivoconf.sections():
                if ctx != 'general' and ctx in contextlist:
                        ctxlist.update(ctx, dict(xivoconf.items(ctx)))


        outsock = commandclass.extrasock(extraconn)
        commandclass.set_configs(configs)

        fdlist_full = []
        fdlist_established = {}
        fdlist_listen_cti = {}
        AMI_array_events_fd = {}
        update_userlist = {}
        lastrequest_time = {}
        
        log_debug(SYSLOG_INFO, "the monitored asterisk's is/are : %s" % str(asterisklist))
        log_debug(SYSLOG_INFO, "# STARTING %s # (1/2) AMI socket connections + fetch Web Services" % xdname)

        for astid in configs:
                try:
                        update_userlist[astid] = False
                        lastrequest_time[astid] = time.time()
                        update_amisocks(astid)
                        plist.update(astid, configs[astid])
                        ulist.update(astid)
                except Exception, exc:
                        log_debug(SYSLOG_ERR, '--- exception --- %s : failed while setting lists and sockets : %s'
                                  %(astid, str(exc)))

        log_debug(SYSLOG_INFO, "# STARTING %s # (2/2) listening sockets (CTI, WEBI, AGI, INFO)" % xdname)
        # opens the listening socket for incoming (CTI, WEBI, AGI, INFO) connections
        for portkind in incoming_tcp_ports:
                pk = portkind.split(':')
                port = pk[0]
                kind = 'INFO'
                bind = '127.0.0.1'
                nmax = '1'
                if len(pk) > 1:
                        kind = pk[1].strip()
                        if len(pk) > 2:
                                bind = pk[2].strip()
                                if len(pk) > 3:
                                        nmax = pk[3].strip()
                UIsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                UIsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                UIsock.bind((bind, int(port)))
                UIsock.listen(10)
                fdlist_listen_cti[UIsock] = '%s:%s' %(kind, nmax)
                fdlist_full.append(UIsock)

        if outsock is not None:
                fdlist_full.append(outsock)
        fdlist_full.append(queued_threads_pipe[0])




        # Main select() loop - Receive messages
        while not askedtoquit:
                try:
                        [sels_i, sels_o, sels_e] = select.select(fdlist_full, [], [], updates_period)
                except Exception, exc:
                        if askedtoquit:
                                try:
                                        print
                                        print 'current open TCP connections : (CTI, WEBI, AGI, INFO) ', fdlist_established
                                        print 'current open TCP connections : (AMI) ', AMI_array_events_fd
                                        print 'current open TCP connections : (OUT) ', outsock
                                        print
                                        os.unlink(PIDFILE)
                                except Exception, exc:
                                        print exc
                                for t in filter(lambda x: x.getName()<>"MainThread", threading.enumerate()):
                                        print "--- (stop) killing thread <%s>" %(t.getName())
                                        t._Thread__stop()
                                sys.exit(5)
                        else:
                                print '--- exception --- after select :', exc
                                askedtoquit = True
                                for s in fdlist_full:
                                        s.close()
                                for t in filter(lambda x: x.getName()<>"MainThread", threading.enumerate()):
                                        print "--- (reload) the thread <%s> remains" %(t.getName())
                                        # t._Thread__stop() # does not work in reload case (vs. stop case)
                                continue
                if sels_i:
                    for sel_i in sels_i:
                        # these AMI connections are used in order to manage AMI commands with incoming events
                        if sel_i in AMI_array_events_fd.values():
                                for astid, val in AMI_array_events_fd.iteritems():
                                        if val is sel_i: break
                                try:
                                        a = AMI_array_events_fd[astid].readline() # (BUFSIZE_ANY)
                                        if len(a) == 0: # end of connection from server side : closing socket
                                                log_debug(SYSLOG_WARNING, "%s : AMI : CLOSING" % astid)
                                                commandclass.dmessage_srv2clt('AMI OFF for <%s>' % astid)
                                                AMI_array_events_fd[astid].close()
                                                fdlist_full.remove(AMI_array_events_fd[astid])
                                                del AMI_array_events_fd[astid]
                                        else:
                                                handle_ami_event(astid, a)
                                except Exception, exc:
                                        log_debug(SYSLOG_ERR, "--- exception --- AMI <%s> : %s" % (astid, str(exc)))

                        # other 'outgoing' connections
                        elif sel_i == outsock:
                                try:
                                        msg = sel_i.recv(BUFSIZE_LARGE)
                                except Exception, exc:
                                        msg = ''
                                        log_debug(SYSLOG_ERR, '--- exception --- outsock : %s' % str(exc))
                                if len(msg) == 0:
                                        sel_i.close()
                                        fdlist_full.remove(sel_i)
                                        outsock = None
                                        log_debug(SYSLOG_WARNING, 'WARNING - outsock has closed the connection')
                                else:
                                        commandclass.handle_outsock(asterisklist[0], msg)

                        # the new TCP connections (CTI, WEBI, AGI, INFO) are catched here
                        elif sel_i in fdlist_listen_cti:
                                [kind, nmax] = fdlist_listen_cti[sel_i].split(':')
                                [conn, sockparams] = sel_i.accept()
                                log_debug(SYSLOG_INFO, "TCP socket opened on %s:%d (%s)" % (sockparams[0], sockparams[1], kind))
                                if kind == 'CTI':
                                        commandclass.connected(conn)
                                # appending the opened socket to the ones watched
                                conn.setblocking(0)
                                fdlist_full.append(conn)
                                fdlist_established[conn] = kind

                        # incoming TCP connections (CTI, WEBI, AGI, INFO)
                        elif sel_i in fdlist_established:
                                requester = '%s:%d' % (sel_i.getpeername()[0], sel_i.getpeername()[1])
                                kind = fdlist_established[sel_i]
                                try:
                                        msg = sel_i.recv(BUFSIZE_LARGE)
                                        lmsg = len(msg)
                                except Exception, exc:
                                        lmsg = 0
                                        log_debug(SYSLOG_ERR, '--- exception --- connection to %s (%s) : %s' % (requester, kind, str(exc)))
                                if lmsg > 0:
                                        try:
                                                manage_tcp_connections(sel_i, msg, kind)
                                        except Exception, exc:
                                                log_debug(SYSLOG_ERR, '--- exception --- handling %s (%s) : %s' % (requester, kind, str(exc)))
                                else:
                                        if kind == 'CTI':
                                                if sel_i in userinfo_by_requester:
                                                        userinfo = userinfo_by_requester.get(sel_i)
                                                        commandclass.manage_logoff(userinfo)
                                                        del userinfo_by_requester[sel_i]
                                if kind in ['CTI', 'INFO'] and lmsg > 0:
                                        continue
                                sel_i.close()
                                fdlist_full.remove(sel_i)
                                del fdlist_established[sel_i]
                                log_debug(SYSLOG_INFO, 'TCP socket closed on %s (%s)' % (requester, kind))

                        # local pipe fd
                        elif queued_threads_pipe[0] == sel_i:
                                disconnlist = commandclass.checkqueue()
                                try:
                                        for userinfo in disconnlist:
                                                print 'checkqueue return :', userinfo
                                                if 'connection' in userinfo.get('login'):
                                                        userinfo.get('login')['connection'].close()
                                                        fdlist_full.remove(userinfo.get('login')['connection'])
                                                else:
                                                        log_debug(SYSLOG_WARNING, 'WARNING - no connection field present in userinfo')
                                                commandclass.manage_logoff(userinfo)
                                except Exception, exc:
                                        log_debug(SYSLOG_ERR, '--- exception --- %s' % str(exc))




                        for astid in configs:
                                if (time.time() - lastrequest_time[astid]) > updates_period or update_userlist[astid]:
                                        lastrequest_time[astid] = time.time()
                                        log_debug(SYSLOG_INFO, '[%s] %s : updates (computed timeout) %s'
                                                  % (xdname, astid, time.asctime()))
                                        try:
                                                if outsock is None:
                                                        outsock = commandclass.extrasock(extraconn)
                                                        if outsock is not None:
                                                                fdlist_full.append(outsock)
                                                update_amisocks(astid)
                                                plist.update(astid, configs[astid])
                                                ulist.update(astid)
                                                update_userlist[astid] = False
                                        except Exception, exc:
                                                log_debug(SYSLOG_ERR, '--- exception --- %s : failed while updating lists and sockets (computed timeout) : %s'
                                                          %(astid, str(exc)))

                else: # when nothing happens on the sockets, we fall here sooner or later
                        log_debug(SYSLOG_INFO, '[%s] updates (select timeout) %s'
                                  % (xdname, time.asctime()))
                        for astid in configs:
                                lastrequest_time[astid] = time.time()
                                try:
                                        if outsock is None:
                                                outsock = commandclass.extrasock(extraconn)
                                                if outsock is not None:
                                                        fdlist_full.append(outsock)
                                        update_amisocks(astid)
                                        plist.update(astid, configs[astid])
                                        ulist.update(astid)
                                except Exception, exc:
                                        log_debug(SYSLOG_ERR, '--- exception --- %s : failed while updating lists and sockets (select s timeout) : %s'
                                                  %(astid, str(exc)))

        log_debug(SYSLOG_NOTICE, 'after askedtoquit loop (%s)' % askedtoquit)
