"""Factory for tuples with named fields and methods for introspection and partial content substitution

Copyright (C) 2007, Proformatique

"""

__version__ = "$Revision$ $Date$"
__license__ = """
    Copyright (C) 2007, Proformatique

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
"""

import sys as _sys
from collections import NamedTuple as _NamedTuple

def ReplTuple(typename, s):
	"""Class created by ReplTuple are like those created by NamedTuple
	(subclass of tuple with named fields), and they also include the
	following additional methods:
	
	* replace(self, **dct) which creates a copy of self except arguments
	  passed to this method override attributes of self in the returned
	  instance.
	* iteritems(self) which returns an iterator of attribute,value pairs.
	* items(self) which returns a list of attribute,value pairs.
	* iterattrs(self) which returns an iterator of readable attributes.
	* attrs(self): which returns a list of readable attributes.
	
	Of course you can't give a name reserved for one of the above method
	to the fields of the type you're creating with this function - this
	will raise a ValueError exception if you try.
	
	"""
	field_names = s.split()
	for mth_name in ('replace', 'iteritems', 'items', 'iterattrs', 'attrs'):
		if mth_name in field_names:
			raise ValueError, 'Field name ' + repr(mth_name) + ' is forbidden for types generated by ReplTuple()'
	nt = _NamedTuple(typename, s)
	def replace(self, **dct):
		"""Returns a new instance containing the same thing as this one
		except for arguments passed to this method, whose respective
		values replace those of attributes with the corresponding name
		in the returned instance.
		
		Remember that instances of this class are invariant anyway.

		>>> Person = ReplTuple('Person', 'firstname lastname age gender')
		>>> me = Person('Guillaume', 'Knispel', 23, 'M')
		>>> et_brother = me.replace(firstname='ET', age=42, gender='Unknown')
		>>> et_brother
		Person(firstname='ET', lastname='Knispel', age=42, gender='Unknown')
		>>> me
		Person(firstname='Guillaume', lastname='Knispel', age=23, gender='M')
		>>> alien = me.replace(eating = et_brother)
		Traceback (most recent call last):
			[...]
		AttributeError: 'Person' object has no attribute 'eating'
		
		"""
		for k in dct:
			if k not in field_names:
				raise AttributeError, repr(typename) + ' object has no attribute ' + repr(k)
		return type(self)(**dict(((a,dct.get(a,getattr(self,a))) for a in field_names)))
	nt.replace = replace
	def iteritems(self):
		"""Returns an iterator of attribute,value pairs. """
		return ((k,getattr(self,k)) for k in field_names)
	nt.iteritems = iteritems
	def items(self):
		"""Returns a list of attribute,value pairs. """
		return [(k,getattr(self,k)) for k in field_names]
	nt.items = items
	def iterattrs(self):
		"""Returns an iterator of readable attributes. """
		return iter(field_names)
	nt.iterattrs = iterattrs
	def attrs(self):
		"""Returns a list of readable attributes. """
		return field_names
	nt.attrs = attrs
        if hasattr(_sys, '_getframe'):
		nt.__module__ = _sys._getframe(1).f_globals['__name__']
	return nt

__all__ = ['ReplTuple']
