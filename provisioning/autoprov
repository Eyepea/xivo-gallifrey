#!/usr/bin/python
"""Autoprovisioning daemon for XIVO
"""

__version__ = "$Revision$ $Date$"
__license__ = """
    Copyright (C) 2007-2010  Proformatique <technique@proformatique.com>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

CONFIG_FILE         = "/etc/pf-xivo/provisioning.conf" # can be overridden by cmd line param
GETOPT_SHORTOPTS    = "b:l:dfc:p:h"
PIDFILE             = "/var/run/autoprov.pid"
TABLE               = 'phone'
GEN_TABLE           = 'general'
UF_TABLE            = 'userfeatures'
SIP_TABLE           = 'usersip'
FK_TABLE            = 'phonefunckey'
XNUM_TABLE          = 'extenumbers'
TECH_SIP            = 'sip' # only allowed tech right now
TECH_SCCP           = 'sccp'

SYSLOG_NAME         = 'autoprovisioning'

import sys

def help_screen():
    print >> sys.stderr, \
"""Syntax:
%s [-b <dburi>] [-l <loglevel>] [-d] [-f] [-c <conffile>] [-p <pidfile>] [-h]

-b <dburi>      Override Database URI with <dburi>
-l <loglevel>   Emit traces with <loglevel> details, must be one of:
                critical, error, warning, info, debug
-d              Don't call the main function, for installation test purposes
-f              Foreground, don't daemonize
-c <conffile>   Use <conffile> instead of %s
-p <pidfile>    Use <pidfile> instead of %s
-h              Display this help screen and exit
""" % (sys.argv[0], repr(CONFIG_FILE), repr(PIDFILE))
    sys.exit(1)

from getopt import getopt, GetoptError

import os
import cgi
import traceback
import logging
from logging.handlers import SysLogHandler

from xivo import anysql
from xivo.BackSQL import backsqlite # pylint: disable-msg=W0611
from xivo.BackSQL import backmysql # pylint: disable-msg=W0611

from BaseHTTPServer import BaseHTTPRequestHandler

from xivo.ThreadingHTTPServer import ThreadingHTTPServer

from xivo import xivo_config
from xivo.xivo_config import ProvGeneralConf as Pgc
from xivo import network
from xivo import all_phones # pylint: disable-msg=W0611

from xivo.moresynchro import RWLock
from xivo.moresynchro import ListLock
from xivo import daemonize

from xivo.xivo_helpers import speed_dial_key_extension, fkey_extension

log = logging.getLogger('autoprov') # pylint: disable-msg=C0103

def replace_keys(dico, repl_dico):
    "return dict(((repl_dico[k],v) for (k,v) in dico.iteritems()))"
    return dict(((repl_dico[k], v) for (k, v) in dico.iteritems()))

def name_from_first_last(first, last):
    "Construct full name from first and last."
    if first and last:
        return first + ' ' + last
    if first:
        return first
    if last:
        return last
    return ''

def field_empty(f):
    return (f is None) or (f == "")

class SQLBackEnd:
    """
    An information backend for this provisioning daemon,
    using the Xivo SQL database.
    """
    def __init__(self, db):
        self.__db = db

    # === INTERNAL FUNCTIONS ===

    def generic_sql_request(self, foobar, *remain):
        """
        Generic function to generate a safe context to issue any
        SQL request.
        """
        conn = anysql.connect_by_uri(self.__db)
        try:
            a = foobar(conn, *remain)
        except Exception:
            log.exception("SQL request failed")
            a = None
        conn.close()
        return a

    @staticmethod
    def method_select_one(conn, request, columns, parameters):
        """
        Internally called in a safe context to execute SELECT
        SQL queries and return their result (only one row).
        """
        cursor = conn.cursor()
        cursor.query(request, columns, parameters)
        row = cursor.fetchone()
        if not row:
            return row
        return dict(row.iteritems())

    def sql_select_one(self, request, columns, parameters):
        """
        Does a SELECT SQL query and returns only one row.
        If the query returns no result, this method returns None
        """
        return self.generic_sql_request(self.method_select_one, request, columns, parameters)

    @staticmethod
    def method_select_all(conn, request, columns, parameters):
        """
        Internally called in a safe context to execute SELECT
        SQL queries and return their result (all rows).
        """
        cursor = conn.cursor()
        cursor.query(request, columns, parameters)
        rows = cursor.fetchall()
        if not rows:
            return rows
        return [ dict(row.iteritems()) for row in rows ]

    def sql_select_all(self, request, columns, parameters):
        "Does a SELECT SQL query and returns all rows."
        return self.generic_sql_request(self.method_select_all, request, columns, parameters)

    @staticmethod
    def method_commit(conn, request, columns, parameters):
        """
        Internally called in a safe context to commit the result of
        SQL queries that modify the database content.
        """
        cursor = conn.cursor()
        cursor.query(request, columns, parameters)
        conn.commit()

    def sql_modify(self, request, columns, parameters):
        "Does a SQL query that is going to modify the database."
        return self.generic_sql_request(self.method_commit, request, columns, parameters)

    # === ENTRY POINTS ===

    def phone_by_macaddr(self, macaddr):
        """
        Lookup a phone description by Mac Address in the database.

        Returns a dictionary with the following keys:
                'macaddr', 'vendor', 'model', 'proto', 'iduserfeatures', 'isinalan'
        or None
        """
        return self.sql_select_one(
                "SELECT ${columns} FROM %s WHERE macaddr = %s" % (TABLE, '%s'),
                ('macaddr', 'vendor', 'model', 'proto', 'iduserfeatures', 'isinalan'),
                (macaddr,))

    def get_extensions(self):
        extensions = {'callgroup':          None,
                      'callqueue':          None,
                      'calluser':           None,
                      'enablednd':          None,
                      'fwdunc':             None,
                      'parkext':            None,
                      'pickup':             None,
                      'pickupexten':        None,
                      'phoneprogfunckey':   None,
                      'vmusermsg':          None}

        res = self.sql_select_all(
                     ("SELECT ${columns} FROM %s "
                     "WHERE type IN ('extenfeatures', 'featuremap', 'generalfeatures') "
                     "AND typeval IN (" + ", ".join(["%%s"] * len(extensions)) + ")")
                     % (XNUM_TABLE,),
                     ('typeval', 'exten'),
                     extensions.keys())

        if res:
            extensions.update(dict([x['typeval'], x['exten']] for x in res))

        return extensions

    def config_by_something_proto(self, something_column, something_content, proto):
        """
        Query the database to return a phone configuration.

        something_column - name of the column of the table 'userfeatures'
                           used to select the right phone
        something_content - content to be match against the content of
                            the column identified by something_column

        Returns a dictionary with the following keys:
            'firstname', 'lastname', 'name': user civil status
                note that the name is constructed from the
                first and last name
            'iduserfeatures': user id in the userfeatures table
            'provcode': provisioning code
            'ident': protocol specific identification
            'passwd': protocol specific password
            'dtmfmode': DTMF mode
            'simultcalls': number of simultaneous calls (multiline)
            'number': extension number
            'proto': protocol
            'mailbox': voicemail mailbox
            'subscribemwi': MWI subscription
            'funckey': mapping where keys are function key number
                 and values a tuple (exten, supervise).
                 .exten is the extension to speed dial/supervise
                 .supervise is True if & only if supervision is
                  activated on this function key

        NOTE: when configuring SCCP protocol, we need much less values:
            'proto'         : protocol == sccp
            'extensions'    : empty dict (for compatibility, no real use)
            'iduserfeatures': user id in userfeatures table

        Right now proto must evaluate to 'sip' or 'sccp'
        """
        if proto == TECH_SCCP:
            confdico = self.sql_select_one(
                ("SELECT ${columns} "
                 "FROM %s "
                 "WHERE %s.protocol = %s AND %s.%s = %s")
                % (UF_TABLE, UF_TABLE, '%s', UF_TABLE, something_column, '%s'), 
                ('id', 'protocolid', 'timezone'),
                (proto, something_content),
            )

            if not confdico:
                return {'proto': proto, 'extensions': {}}
            if confdico['timezone'] is None or not confdico['timezone']:
                generaldico = self.sql_select_one(
                    ("SELECT ${columns} "
                     "FROM %s")
                     % GEN_TABLE,
                     ('timezone',),
                     ())
                confdico['timezone'] = generaldico['timezone']

            extrainfos = self.sql_select_one(
                "SELECT ${columns} "
                "FROM usersccp, sccpline "
                "WHERE usersccp.defaultline = sccpline.id AND usersccp.id = %s",
                ('addons', 'language'),
                (confdico['protocolid'],)
            )

            confdico.update(extrainfos)
            confdico.update({'proto': proto, 'extensions': {}})
            confdico['iduserfeatures'] = confdico['id']

            return confdico

        if proto != TECH_SIP:
            raise ValueError, "proto must be 'sip' or 'sccp' for now"

        mapping = {
            UF_TABLE+".firstname":       'firstname',
            UF_TABLE+".lastname":        'lastname',
            SIP_TABLE+".name":           'ident',
            SIP_TABLE+".secret":         'passwd',
            SIP_TABLE+".dtmfmode":       'dtmfmode',
            UF_TABLE+".simultcalls":     'simultcalls',
            UF_TABLE+".number":          'number',
            UF_TABLE+".id":              'iduserfeatures',
            UF_TABLE+".provisioningid":  'provcode',
            UF_TABLE+".protocol":        'proto',
            SIP_TABLE+".mailbox":        'mailbox',
            SIP_TABLE+".subscribemwi":   'subscribemwi',
            SIP_TABLE+".language":       'language',
            UF_TABLE+".timezone":        'timezone',
        }
        confdico = self.sql_select_one(
            ("SELECT ${columns} "
              "FROM %s LEFT OUTER JOIN %s "
                    "ON %s.protocolid = %s.id AND %s.protocol = %s "
              "WHERE %s." + something_column + " = %s")
              % (UF_TABLE, SIP_TABLE,
                 UF_TABLE, SIP_TABLE, UF_TABLE, '%s',
                 UF_TABLE, '%s'),
            mapping.keys(),
            (proto, something_content))
        if not confdico:
            return None
        confdico = replace_keys(confdico, mapping)
        confdico['name'] = name_from_first_last(confdico['firstname'],
                                                confdico['lastname'])
        confdico['extensions'] = self.get_extensions()
        if confdico['timezone'] is None or not confdico['timezone']:
            generaldico = self.sql_select_one(
                ("SELECT ${columns} "
                 "FROM %s")
                 % GEN_TABLE,
                 ['timezone'],
                 ())
            confdico['timezone'] = generaldico['timezone']

        function_key_list = self.sql_select_all(
            ("SELECT ${columns} "
             "FROM %s "
             "LEFT OUTER JOIN %s AS extenumleft "
             "ON  %s.typeextenumbers = extenumleft.type "
             "AND %s.typevalextenumbers = extenumleft.typeval "
             "LEFT OUTER JOIN %s AS extenumright "
             "ON  %s.typeextenumbersright = extenumright.type "
             "AND %s.typevalextenumbersright = extenumright.typeval "
             "LEFT OUTER JOIN %s "
             "ON %s.typevalextenumbersright = %s.id "
             "WHERE iduserfeatures = %%s")
             % (FK_TABLE,
                XNUM_TABLE,
                FK_TABLE,
                FK_TABLE,
                XNUM_TABLE,
                FK_TABLE,
                FK_TABLE,
                UF_TABLE,
                FK_TABLE,
                UF_TABLE),
            [FK_TABLE+x for x in ('.fknum',
                                  '.exten',
                                  '.supervision',
                                  '.progfunckey',
                                  '.iduserfeatures',
                                  '.label',
                                  '.typeextenumbersright',
                                  '.typevalextenumbersright')]
            + ['extenumleft.exten', 'extenumright.exten',
               'extenumleft.type', 'extenumleft.typeval',
               'extenumright.type', 'extenumright.typeval']
            + [UF_TABLE+x for x in ('.firstname', '.lastname', '.id')],
            (confdico['iduserfeatures'],))

        funckey = {}
        for fk in function_key_list:
            isbsfilter = False
            fknum = fk[FK_TABLE+'.fknum']
            label = fk[FK_TABLE+'.label']
            exten = fk[FK_TABLE+'.exten']

            fkey = {'exten':        None,
                    'label':        label,
                    'supervision':  bool(int(fk[FK_TABLE+'.supervision']))}

            # SPECIAL CASES:
            if fk['extenumleft.type'] is None:
                # group, queue or user without number
                if fk['extenumright.type'] is None \
                    and fk[FK_TABLE+'.typeextenumbersright'] in ('group',
                                                                 'queue',
                                                                 'user'):
                    fkey['exten'] = \
                        fkey_extension(
                            confdico['extensions'].get('call' + fk[FK_TABLE+'.typeextenumbersright']),
                            (fk[FK_TABLE+'.typevalextenumbersright'],))

                    funckey[fknum] = fkey
                    continue
            elif fk['extenumleft.type'] == 'extenfeatures':
                if fk['extenumleft.typeval'] == 'bsfilter':
                    isbsfilter = True
                elif bool(fk[FK_TABLE+'.progfunckey']):
                    if exten is None and fk[FK_TABLE+'.typevalextenumbersright'] is not None:
                        exten = '*' + fk[FK_TABLE+'.typevalextenumbersright']

                    fkey['exten'] = \
                        fkey_extension(
                            confdico['extensions'].get('phoneprogfunckey'),
                            (fk[FK_TABLE+'.iduserfeatures'],
                             fk['extenumleft.exten'],
                             exten))

                    funckey[fknum] = fkey
                    continue

            if label is None \
               and fk[FK_TABLE+'.typeextenumbersright'] == 'user' \
               and fk[UF_TABLE+'.id']:
                label = name_from_first_last(fk[UF_TABLE+'.firstname'],
                                             fk[UF_TABLE+'.lastname'])

                if isbsfilter:
                    fkey['label'] = "BS:%s" % label
                else:
                    fkey['label'] = label

            fkey['exten'] = \
                speed_dial_key_extension(
                    fk['extenumleft.exten'],
                    fk['extenumright.exten'],
                    exten,
                    confdico['number'],
                    isbsfilter)

            funckey[fknum] = fkey

        confdico['funckey'] = funckey
        return confdico

    def config_by_iduserfeatures_proto(self, iduserfeatures, proto):
        """
        Lookup the configuration information of the phone in the
        database, by ID of the 'userfeatures' table, and protocol.

        Right now proto must evaluate to 'sip' or 'sccp'
        """
        return self.config_by_something_proto(
                    'id', iduserfeatures, proto)

    def config_by_provcode_proto(self, provcode, proto):
        """
        Lookup the configuration information of the phone in the
        database, by provisioning code and protocol.

        Right now proto must evaluate to 'sip' or 'sccp'
        """
        return self.config_by_something_proto(
                    'provisioningid', provcode, proto)

    def config_by_name_proto(self, name, proto):
        """
        Lookup the configuration information on the phone in the
        database, by protocol name and protocol.

        Right now proto must evaluate to 'sip' or 'sccp'
        """
        return self.config_by_something_proto(
                    'name', name, proto)

    def save_phone(self, phone):
        """
        Save phone informations in the database.
        phone must be a dictionary and contain the following keys:

        'macaddr', 'vendor', 'model', 'proto', 'iduserfeatures', 'isinalan'
        """
        columns = ('macaddr', 'vendor', 'model', 'proto', 'iduserfeatures', 'isinalan')
        self.sql_modify(
            ("REPLACE INTO %s (${columns})"
             " VALUES (%s, %s, %s, %s, %s, %s)")
             % (TABLE, '%s', '%s', '%s', '%s', '%s', '%s'),
            columns,
            [ phone[x] for x in columns ])

    def phone_by_iduserfeatures(self, iduserfeatures):
        """
        Lookup phone information by user information (iduserfeatures)
        Right now this is limited to the 'sip' protocol, so the result
        is a single phone description in the form of a dictionary
        containing the classic keys.
        XXX This comment is out of date.

        'macaddr', 'vendor', 'model', 'proto', 'iduserfeatures', 'isinalan'
        """
        return self.sql_select_one(
            ("SELECT ${columns} FROM %s "
             "WHERE iduserfeatures = %s")
             % (TABLE, '%s'),
            ('macaddr', 'vendor', 'model', 'proto', 'iduserfeatures', 'isinalan'),
            (iduserfeatures,))

    def delete_phone_by_iduserfeatures(self, iduserfeatures):
        """
        Delete any phone in the database having the given
        iduserfeatures.
        """
        self.sql_modify(
            "DELETE FROM %s WHERE iduserfeatures = %s" % ( TABLE, '%s'),
            None,
            (iduserfeatures,))

    def find_orphan_phones(self):
        """
        Find every phones that do not have a corresponding user
        anymore, but that are neither provisioned in state GUEST. Used
        at startup to maintain the coherency of the whole provisioning
        subsystem.

        Returns a list of dictionaries, each of the latter representing
        informations stored in the base about a phone with the classic
        keys :

        'macaddr', 'vendor', 'model', 'proto', 'iduserfeatures', 'isinalan'
        """
        mapping = dict([(TABLE + '.' + x, x)
                        for x in ('macaddr', 'vendor', 'model',
                                  'proto', 'iduserfeatures', 'isinalan')])
        orphans = self.sql_select_all(
            ( "SELECT ${columns} FROM %s LEFT JOIN %s"
              " ON %s.iduserfeatures = %s.id"
              " WHERE %s.iduserfeatures != 0 AND %s.id is NULL" )
              % (TABLE, UF_TABLE,
                 TABLE, UF_TABLE,
                 TABLE, UF_TABLE),
            mapping.keys(),
            ())
        if not orphans:
            return orphans
        return [replace_keys(row, mapping) for row in orphans]

class CommonProvContext:
    def __init__(self, userlocks, maclocks, dbinfos, rwlock):
        # There is no locking order because my ListLocks don't block.
        self.userlocks = userlocks
        self.maclocks = maclocks
        self.dbinfos = dbinfos
        self.rwlock = rwlock

class Error(Exception):
    pass
class BadRequest(Error):
    pass
class MissingParam(BadRequest):
    pass
class ConflictError(Error):
    pass
class NotFoundError(Error):
    pass

ExceptToHTTP = {
    BadRequest: 400,
    ConflictError: 409,
    NotFoundError: 404
}

def __mode_dependant_provlogic_locked(mode, ctx, phone, config, prev_iduserfeatures):
    """
    This function resolves conflicts or abort by raising an exception
    for the current provisioning in progress.
    """
    if mode == 'authoritative':
        log.debug("__mode_dependant_provlogic_locked() in authoritative mode for phone %s and user %s", phone['macaddr'], config['iduserfeatures'])
        existing_phone = ctx.dbinfos.phone_by_iduserfeatures(config['iduserfeatures'])
        if existing_phone and existing_phone['macaddr'] != phone['macaddr']:
            log.info("__mode_dependant_provlogic_locked(): phone %s to be put back in guest state, because another one (%s) is being provisioned for the same user", existing_phone['macaddr'], phone['macaddr'])
            existing_phone['mode'] = 'authoritative'
            existing_phone['actions'] = 'no'
            existing_phone['iduserfeatures'] = '0'
            __provisioning('__internal_to_guest', ctx, existing_phone)
    elif mode == 'notification':
        log.debug("__mode_dependant_provlogic_locked() in notification mode for phone %s and user %s", phone['macaddr'], config['iduserfeatures'])
        if prev_iduserfeatures:
            if config['iduserfeatures'] != prev_iduserfeatures:
                log.error("__mode_dependant_provlogic_locked(): outdated iduserfeatures received for update notification of phone %r; wanted %s; got %s", phone, prev_iduserfeatures, config['iduserfeatures'])
                raise ConflictError, "Outdated iduserfeatures received for update notification of phone %r; wanted %s; got %s" % (phone, prev_iduserfeatures, config['iduserfeatures'])
        existing_phone = ctx.dbinfos.phone_by_iduserfeatures(config['iduserfeatures'])
        if not existing_phone:
            log.error("__mode_dependant_provlogic_locked(): non existing phone %r to update for iduserfeatures %s", phone, config['iduserfeatures'])
            raise ConflictError, "Non existing phone %r to update for iduserfeatures %s" % (phone, config['iduserfeatures'])
        if existing_phone['macaddr'] != phone['macaddr']:
            log.error("__mode_dependant_provlogic_locked(): another phone %r already exists instead of %r for iduserfeatures %s", existing_phone, phone, config['iduserfeatures'])
            raise ConflictError, "Another phone %r already exists instead of %r for iduserfeatures %s" % (existing_phone, phone, config['iduserfeatures'])
        # nothing more to do: no exception has been raised so the caller
        # will continue the correct execution of its own code flow

def __save_phone(ctx, phone, config):
    "Save new configuration of the local phone in the database."
    if "iduserfeatures" not in phone and config is not None \
       and "iduserfeatures" in config:
        log.debug("__provisioning(): iduserfeatures=%r from config to phone", config["iduserfeatures"])
        phone["iduserfeatures"] = config["iduserfeatures"]
    if "iduserfeatures" in phone:
        log.info("__provisioning(): SAVING phone %r informations to backend", phone)
        ctx.dbinfos.save_phone(phone)

def __provisioning(mode, ctx, phone):
    "Provisioning high level logic for the described phone"
    # I only allow "sip" or "sccp" right now
    if phone["proto"] != TECH_SIP and phone["proto"] != TECH_SCCP:
        log.error("__provisioning(): the only supported protocols "
                  "right now are SIP and SCCP, but I got %s", phone["proto"])
        raise BadRequest, "Unknown protocol '%s' != 'sip' or 'sccp'" % phone["proto"]

    log.info("__provisioning(): handling phone %r - mode %r", phone, mode)

    prev_iduserfeatures = None
    if mode == "notification":
        phonedesc = ctx.dbinfos.phone_by_macaddr(phone["macaddr"])
        if phonedesc is None:
            log.error("__provisioning(): No phone has been found in the database for this mac address %s", phone["macaddr"])
            raise NotFoundError, "No phone has been found in the database for this mac address %s" % phone["macaddr"]
        phone['isinalan'] = phonedesc['isinalan']
        phone['vendor'] = phonedesc['vendor']
        phone['model'] = phonedesc['model']
        prev_iduserfeatures = phonedesc['iduserfeatures']

    if field_empty(phone['vendor']) or field_empty(phone['model']) or field_empty(phone['isinalan']):
        log.error("__provisioning(): Empty model or vendor or isinalan in phone %r", phone)
        raise BadRequest, "Empty model or vendor or isinalan in phone %r" % phone

    if "provcode" in phone and phone["provcode"] != "0" and \
       not xivo_config.well_formed_provcode(phone["provcode"]):
        log.error("__provisioning(): Invalid provcode %s", phone["provcode"])
        raise NotFoundError, "Invalid provcode %s" % phone["provcode"]

    if phone["actions"] != "no":
        if "ipv4" not in phone:
            log.debug("__provisioning(): trying to get IPv4 address from Mac Address %s", phone["macaddr"])
            phone["ipv4"] = xivo_config.ipv4_from_macaddr(phone["macaddr"])
            if phone["ipv4"] is None:
                phone["actions"] = "no"
        if phone["actions"] != "no" and phone["ipv4"] is None:
            log.error("__provisioning(): Actions enabled but got no IP address (for phone with Mac Address %s)", phone["macaddr"])
            raise NotFoundError, "Actions enabled but got no IP address (for phone with Mac Address %s)" % phone["macaddr"]

    log.debug("__provisioning(): locking phone %s", phone["macaddr"])
    if not ctx.maclocks.try_acquire(phone["macaddr"]):
        log.warning("__provisioning(): Operation already in progress for %s", phone["macaddr"])
        raise ConflictError, "Operation already in progress for phone %s" % phone["macaddr"]
    try:
        log.debug("__provisioning(): phone instance from description")
        prov_inst = xivo_config.phone_factory(phone)

        if "provcode" in phone and phone["provcode"] == "0":
            phone["iduserfeatures"] = "0"

        if mode == "upgradefw":
            log.info("__provisioning(): upgrading firmware for phone %r", phone)
            prov_inst.action_upgradefw()
        elif "iduserfeatures" in phone and phone["iduserfeatures"] == "0":
            log.info("__provisioning(): reinitializing provisioning to GUEST for phone %r", phone)
            config = ctx.dbinfos.config_by_name_proto('guest', phone["proto"])
            prov_inst.generate_reinitprov(config)
            __save_phone(ctx, phone, None)
            prov_inst.action_reinit()
        else:
            if "iduserfeatures" in phone:
                log.info("__provisioning(): getting configuration from iduserfeatures for phone %r", phone)
                config = ctx.dbinfos.config_by_iduserfeatures_proto(phone["iduserfeatures"], phone["proto"])
            else:
                log.info("__provisioning(): getting configuration from provcode for phone %r", phone)
                config = ctx.dbinfos.config_by_provcode_proto(phone["provcode"], phone["proto"])
            if config is not None \
               and 'iduserfeatures' in config \
               and config['iduserfeatures']:
                log.debug("__provisioning(): locking user %s", config['iduserfeatures'])
                if not ctx.userlocks.try_acquire(config['iduserfeatures']):
                    log.warning("__provisioning(): Operation already in progress for user %s", config['iduserfeatures'])
                    raise ConflictError, "Operation already in progress for user %s" % config['iduserfeatures']
                try:
                    log.info("__provisioning(): AUTOPROV'isioning phone %r with config %r", phone, config)
                    __mode_dependant_provlogic_locked(mode, ctx, phone, config, prev_iduserfeatures)
                    prov_inst.generate_autoprov(config)
                    __save_phone(ctx, phone, config)
                    prov_inst.action_reboot()
                finally:
                    log.debug("__provisioning(): unlocking user %s", config['iduserfeatures'])
                    ctx.userlocks.release(config['iduserfeatures'])
            else:
                log.error("__provisioning(): not AUTOPROV'isioning phone %r cause no config found or no iduserfeatures in config", phone)
                raise NotFoundError, "no config found or no iduserfeatures in config for phone %r" % phone
    finally:
        log.debug("__provisioning(): unlocking phone %s", phone["macaddr"])
        ctx.maclocks.release(phone["macaddr"])

def __userdeleted(ctx, iduserfeatures):
    "Does what has to be done when a user is deleted."
    log.info("__userdeleted(): handling deletion of user %s", iduserfeatures)
    if not ctx.userlocks.try_acquire(iduserfeatures):
        log.warning("__userdeleted(): Operation already in progress for user %s", iduserfeatures)
        raise ConflictError, "Operation already in progress for user %s" % iduserfeatures
    try:
        phone = ctx.dbinfos.phone_by_iduserfeatures(iduserfeatures)
        if phone:
            log.info("__userdeleted(): phone to destroy, because destruction of its owner - %r", phone)
            phone['mode'] = 'authoritative'
            phone['actions'] = 'no'
            phone['iduserfeatures'] = '0'
            __provisioning('userdeleted', ctx, phone)
        # the following line will just destroy non 'sip' provisioning
        # with the same "iduserfeatures", and as they are none for now
        # it's not really useful but might become so in the future
        ctx.dbinfos.delete_phone_by_iduserfeatures(iduserfeatures)
    finally:
        ctx.userlocks.release(iduserfeatures)

def __bootdhcp(ctx, phone):
    log.info("__bootdhcp(): handling dhcp of phone %s", phone['macaddr'])
    phone['mode'] = 'authoritative'
    phone['actions'] = 'no'
    phonedesc = ctx.dbinfos.phone_by_macaddr(phone['macaddr'])
    if phonedesc:
        phone['iduserfeatures'] = str(phonedesc['iduserfeatures'])
    else:
        phone['iduserfeatures'] = '0'
    __provisioning('bootdhcp', ctx, phone)

def __upgradefw(ctx, phone):
    log.info("__upgradefw(): handling firmware upgrade of phone %s", phone["macaddr"])
    phone['mode'] = 'authoritative'
    phone['actions'] = 'no'
    __provisioning('upgradefw', ctx, phone)


# Safe locking API for provisioning and related stuffs

def lock_and_provision(mode, ctx, phone):
    """
    Will attempt to provision with a global lock
    hold in shared mode
    """
    log.debug("Entering lock_and_provision(mode=%r, phone=%r)", mode, phone)
    if not ctx.rwlock.acquire_read(Pgc['excl_del_lock_to_s']):
        raise ConflictError, "Could not acquire the global lock in shared mode"
    try:
        __provisioning(mode, ctx, phone)
    finally:
        ctx.rwlock.release()
        log.debug("Leaving lock_and_provision for Mac Address %s", phone["macaddr"])

def lock_and_userdel(ctx, iduserfeatures):
    """
    Will attempt to delete informations related to the user identified by
    iduserfeatures from areas we are handling in the information backend,
    with a global lock hold for exclusive access.
    """
    log.debug("Entering lock_and_userdel %s", iduserfeatures)
    if not ctx.rwlock.acquire_write(Pgc['excl_del_lock_to_s']):
        raise ConflictError, "Could not acquire the global lock in exclusive mode"
    try:
        __userdeleted(ctx, iduserfeatures)
    finally:
        ctx.rwlock.release()
        log.debug("Leaving lock_and_userdel %s", iduserfeatures)

def lock_and_bootdhcp(ctx, phone):
    log.debug("Entering lock_and_bootdhcp %s", phone["macaddr"])
    if not ctx.rwlock.acquire_read(Pgc['excl_del_lock_to_s']):
        raise ConflictError, "Could not acquire the global lock in shared mode"
    try:
        __bootdhcp(ctx, phone)
    finally:
        ctx.rwlock.release()
        log.debug("Leaving lock_and_bootdhcp for Mac Address %s", phone["macaddr"])

def lock_and_upgradefw(ctx, phone):
    log.debug("Entering lock_and_upgradefw %s", phone["macaddr"])
    if not ctx.rwlock.acquire_read(Pgc['excl_del_lock_to_s']):
        raise ConflictError, "Could not acquire the global lock in shared mode"
    try:
        __upgradefw(ctx, phone)
    finally:
        ctx.rwlock.release()
        log.debug("Leaving lock_and_upgradefw %s", phone["macaddr"])

def clean_at_startup(ctx):
    "Put back every non guest orphan phones in GUEST state at startup."
    orphans = ctx.dbinfos.find_orphan_phones()
    if not orphans:
        return
    for phone in orphans:
        log.info("clean_at_startup(): about to remove orphan %r at startup", phone)
        try:
            lock_and_userdel(ctx, phone['iduserfeatures'])
        except Exception:
            log.exception("unexpected exception catched in clean_at_startup")
            log.error("fall back: simply deleting phone with macaddr %r from the DB", phone['macaddr'])
            ctx.dbinfos.delete_phone_by_macaddr(phone['macaddr'])

class ProvHttpHandler(BaseHTTPRequestHandler):
    """
    ThreadingHTTPServer will create one instance of this class for the
    handling of each incoming connection received by this daemon, and each
    instance will run in a separated thread.
    Base methods of BaseHTTPRequestHandler are used to do the basic HTTP
    parsing of the HTTP request that is to be handled, and new methods are
    added that implement the high level behavior of autoprovisioning and
    related operations.
    """
    def __init__(self, request, client_address, server):
        self.my_server = server
        self.my_ctx = self.my_server.my_ctx
        self.posted = None
        BaseHTTPRequestHandler.__init__(self, request, client_address, server)

    # Override the setup method, taken from SocketServer.py and modified.

    def setup(self):
        self.connection = self.request
        self.connection.settimeout(float(Pgc['http_read_request_to_s']))
        self.rfile = self.connection.makefile('rb', self.rbufsize)
        self.wfile = self.connection.makefile('wb', self.wbufsize)

    # HTTP responses

    def send_response_headers_200(self, content_type = "text/plain"):
        self.send_response(200)
        self.send_header("Content-Type", content_type)
        self.send_header("Cache-Control", "no-cache")
        self.send_header("Pragma", "no-cache")
        self.end_headers()
    def send_response_lines(self, req_lines):
        self.send_response_headers_200()
        self.wfile.writelines([x+"\r\n" for x in req_lines])
    def answer_404(self, err_str = None):
        log.info("answer_404(): sending not found message to %s", self.client_address)
        self.send_error(404, err_str)
    def send_error_explain(self, errno, perso_message):
        self.send_response(errno)
        self.end_headers()
        self.wfile.write(self.error_message_format % {
            'code': errno,
            'message': perso_message,
            'explain': self.responses[errno][1]
        })

    # Get POSTED informations in self.posted
    def get_posted(self):
        """
        Extract a payload of a POST HTTP method that has the
        following format:

        name1=value1
        name2=value2
        ...
        nameN=valueN

        A dictionary {'name1':'value1,
                      'name2':'value2',
                      ...
                      'nameN':'valueN' } is then stored in self.posted
        """
        lines = []
        # This will raise an exception if not present or not an integer
        # This is the wanted behavior
        datalength = int(self.headers['Content-Length'])
        readbytes = 0
        if not datalength:
            self.posted = {}
        line = self.rfile.readline()
        while line and line.strip() and readbytes < datalength:
            lines.append(tuple(line.strip().split('=', 1)))
            readbytes += len(line)
            if readbytes < datalength:
                line = self.rfile.readline()
            else:
                line = None
        self.posted = dict(lines)

    # Extract interesting stuff from self.posted
    def save_posted_vars(self, d, variables):
        """
        Store in the dictionary d each variable of the variables
        list present in self.posted, raising an exception if some
        are missing.
        """
        for v in variables:
            if v not in self.posted:
                raise MissingParam, v + " missing in posted command"
            d[v] = self.posted[v]
    def save_macaddr_ipv4(self, phone):
        """
        Save 'macaddr' in phone from self.posted or raise a
        MissingParam exception, and optionally save 'ipv4'.
        """
        if "macaddr" not in self.posted:
            raise MissingParam, "Mac Address not given"
        phone["macaddr"] = network.normalize_mac_address(self.posted["macaddr"])
        if "ipv4" in self.posted:
            phone["ipv4"] = self.posted["ipv4"]
    def save_iduserfeatures_or_provcode(self, phone):
        """
        Save 'iduserfeatures' in phone from self.posted in priority,
        or save 'provcode' if 'iduserfeatures' was not present.
        """
        try:
            self.save_posted_vars(phone, ("iduserfeatures",))
        except MissingParam:
            self.save_posted_vars(phone, ("provcode",))
    def save_firmware(self, phone):
        """
        Save optionally 'firmware' in phone from self.posted.
        """
        if "firmware" in self.posted:
            phone["firmware"] = self.posted["firmware"]

    def posted_infos(self, *thetuple):
        """
        Generic function to retrieve every needed provisioning info
        from the request.
        """
        phone = {}
        self.save_posted_vars(phone, thetuple)
        self.save_iduserfeatures_or_provcode(phone)
        self.save_macaddr_ipv4(phone)
        self.save_firmware(phone)
        return phone
    def posted_phone_infos(self):
        "Used in 'authoritative' mode"
        return self.posted_infos("from", "proto", "vendor", "model", "actions", "isinalan")
    def posted_light_infos(self):
        "Used in 'notification' mode"
        return self.posted_infos("from", "proto", "actions")
    def posted_userdeleted_infos(self):
        "Used in 'userdeleted' mode"
        userinfo = {}
        self.save_posted_vars(userinfo, ("from", "iduserfeatures", "actions"))
        return userinfo
    def posted_bootdhcp_infos(self):
        "Used in 'bootdhcp' mode"
        phone = {}
        self.save_posted_vars(phone, ("from", "proto", "vendor", "model", "actions", "isinalan"))
        self.save_macaddr_ipv4(phone)
        self.save_firmware(phone)
        return phone
    def posted_upgradefw_infos(self):
        "Used in 'upgradefw' mode"
        phone = {}
        self.save_posted_vars(phone, ("from", "proto", "vendor", "model", "firmware", "actions", "isinalan"))
        self.save_macaddr_ipv4(phone)
        return phone

    def log_message(self, fmt, *args):
        "Override default logging method."
        log.info(fmt, *args)

    def full_xcept_sender(self, errcode):
        return lambda x:self.send_error_explain(
            errcode,
            ''.join(("<pre>\n", cgi.escape(x), "</pre>\n"))
        )

    # Main handling functions

    def handle_prov(self):
        "Does whatever action is asked by the peer"
        phone = None
        userinfo = None
        log.info("handle_prov(): handling /prov POST request for peer %s", self.client_address)
        try:
            self.get_posted()
            if "mode" not in self.posted:
                log.error("handle_prov(): No mode posted")
                raise BadRequest, "No mode posted"

            if self.posted["mode"] == "authoritative":
                log.info("handle_prov(): creating phone internal representation using full posted infos.")
                phone = self.posted_phone_infos()
                lock_and_provision(self.posted['mode'], self.my_ctx, phone)
            elif self.posted["mode"] == "notification":
                log.info("handle_prov(): creating phone internal representation using light posted infos.")
                phone = self.posted_light_infos()
                lock_and_provision(self.posted['mode'], self.my_ctx, phone)
            elif self.posted["mode"] == "userdeleted":
                log.info("handle_prov(): user deletion")
                userinfo = self.posted_userdeleted_infos()
                lock_and_userdel(self.my_ctx, userinfo['iduserfeatures'])
            elif self.posted["mode"] == "bootdhcp":
                log.info("handle_prov(): boot from dhcp")
                phone = self.posted_bootdhcp_infos()
                lock_and_bootdhcp(self.my_ctx, phone)
            elif self.posted["mode"] == "upgradefw":
                log.info("handle_prov(): firmware upgrade")
                phone = self.posted_upgradefw_infos()
                lock_and_upgradefw(self.my_ctx, phone)
            else:
                log.error("handle_prov(): Unknown mode %s", self.posted["mode"])
                raise BadRequest, "Unknown mode %s" % self.posted["mode"]
        except Exception, x:
            log.info("handle_prov(): action FAILED - phone %r - userinfo %r", phone, userinfo)
            errcode = 500
            for t, rcode in ExceptToHTTP.iteritems():
                if isinstance(x, t):
                    errcode = rcode
                    break
            self.full_xcept_sender(errcode)(''.join(traceback.format_exception(*sys.exc_info())))
            log.exception("error during provisioning")
            return
        log.info("handle_prov(): provisioning OK for phone %r", phone)
        self.send_response_lines(('Ok',))

    def handle_list(self):
        "Respond with the list of supported Vendors / Models"
        log.info("handle_list(): handling /list GET request for peer %s", self.client_address)
        self.send_response_headers_200()
        for phonekey, phoneclass in xivo_config.phone_vendor_iter_key_class():
            phones = phoneclass.get_phones()
            self.wfile.write(phonekey + '="' + phoneclass.__name__.replace('"','\\"') + '"\r\n')
            self.wfile.writelines([(phonekey + '.' + x[0] + '="' + x[1].replace('"','\\"') + '"\r\n') for x in phones])

    # === ENTRY POINTS (called FROM BaseHTTPRequestHandler) ===

    def do_POST(self):
        log.info("do_POST(): handling POST request to path %s for peer %s", self.path, self.client_address)
        if self.path == '/prov':
            self.handle_prov()
        else: self.answer_404()

    def do_GET(self):
        log.info("do_GET(): handling GET request to path %s for peer %s", self.path, self.client_address)
        if self.path == '/list':
            self.handle_list()
        else: self.answer_404()


def main(log_level, foreground):
    """
    @log_level: one of logging.DEBUG to logging.CRITICAL
    @foreground: True => don't daemonize
    """
    logging.basicConfig(level=logging.DEBUG)
    sysloghandler = SysLogHandler("/dev/log", SysLogHandler.LOG_DAEMON)
    sysloghandler.setFormatter(logging.Formatter("%s[%%(process)d]: %%(message)s" % SYSLOG_NAME))
    root_logger = logging.getLogger('')
    root_logger.addHandler(sysloghandler)

    try:
        # autoprov demon runs as root and creates file as root.root
        # atftpd server runs as nobody and allows write access in
        # /tftpboot/ for everybody, so we use umask 022 here to avoid
        # success of atftpd when it tries to write files.
        os.umask(022)
        if log_level != logging.DEBUG:
            root_logger.setLevel(logging.INFO)
        log.info("Starting up")
        if not foreground:
            log.info("Transforming into a daemon from hell")
            daemonize.daemonize()
        log.info("locking PID")
        daemonize.lock_pidfile_or_die(PIDFILE)
        try:
            os.umask(022) # daemonize() reset umask
            log.info("HTTP server creation")
            http_server = ThreadingHTTPServer(
                (Pgc['listen_ipv4'], Pgc['listen_port']),
                ProvHttpHandler
            )
            http_server.my_ctx = CommonProvContext(
                ListLock(), # userlocks
                ListLock(), # maclocks
                SQLBackEnd(Pgc['database_uri']),
                RWLock()
            )
            log.info("Orphan phones cleanup")
            clean_at_startup(http_server.my_ctx) # pylint: disable-msg=E1101
            root_logger.setLevel(log_level)
            log.info("Will now serve incoming HTTP requests")
            http_server.serve_forever()
        finally:
            daemonize.unlock_pidfile(PIDFILE)
    except SystemExit:
        raise
    except:
        log.exception("unexpected error")


def get_log_level_by_name(loglevel_name):
    levels = {
        'CRITICAL': logging.CRITICAL,
        'ERROR': logging.ERROR,
        'WARNING': logging.WARNING,
        'WARN': logging.WARN,
        'INFO': logging.INFO,
        'DEBUG': logging.DEBUG,
    }
    loglevel_name = loglevel_name.upper()
    if loglevel_name in levels:
        return levels[loglevel_name]
    else:
        raise ValueError, "Unknown log level %r" % loglevel_name


def init():
    """
    Global namespace pollution avoidance
    """
    global Pgc
    global PIDFILE
    global CONFIG_FILE

    dontlauchmain = False
    foreground = False
    log_level = logging.INFO

    dburi_override = None
    log_level_override = None
    try:
        opts = getopt(sys.argv[1:], GETOPT_SHORTOPTS)[0]
    except GetoptError, x:
        print >> sys.stderr, x
        help_screen()
    for k, v in opts: # DO NOT MERGE THE TWO LOOPS
        if k == '-h':
            help_screen()
    for k, v in opts:
        if '-l' == k:
            log_level_override = v
        elif '-d' == k:
            dontlauchmain = True
        elif '-f' == k:
            foreground = True
        elif '-b' == k:
            dburi_override = v
        elif '-p' == k:
            PIDFILE = v
        elif '-c' == k:
            CONFIG_FILE = v

    xivo_config.LoadConfig(CONFIG_FILE)

    if log_level_override is not None:
        Pgc['log_level'] = log_level_override
    log_level = get_log_level_by_name(Pgc['log_level'])
    if dburi_override is not None:
        Pgc['database_uri'] = dburi_override

    # We could daemonize and if we do we will chdir to '/',
    # so get absolute pathname or anything else relative to
    # database uri that could depends upon current envt.
    Pgc['database_uri'] = anysql.c14n_uri(Pgc['database_uri'])

    xivo_config.phone_classes_setup()

    return dontlauchmain, foreground, log_level


dontlauchmain, foreground, log_level = init()

if __name__ == '__main__' and not dontlauchmain:
    main(log_level, foreground)
