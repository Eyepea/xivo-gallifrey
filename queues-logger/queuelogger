#!/usr/bin/python
# vim: set expandtab ts=4 sw=4 sts=4 fileencoding=utf-8:

__version__   = '$Revision$'
__date__      = '$Date$'

import cjson
import logging
from logging.handlers import RotatingFileHandler
import sys
import time
import urllib2

from optparse import OptionParser

from xivo import daemonize
from xivo_queuelogger.ami_conn import *
from xivo_queuelogger.ami_logger import *

DAEMONNAME = 'queues-logger'
LOGDAEMONNAME = DAEMONNAME
PIDFILE = '/var/run/%s.pid' % DAEMONNAME
XIVO_CONF_FILE = 'https://localhost/service/ipbx/json.php/private/queuelogger/configuration'
LOGFILENAME = '/var/log/pf-xivo-queues-logger/daemon.log'

usage = \
'''
%prog [options]

 return code:
 * 0: you typed --help
 * 1: unable to connect to server
 * 2: this server is not a valid AMI server
 * 3: your credential are wrong - verify your login/password
 * 4: *impossible*
'''

logging.basicConfig(level = logging.INFO)
log = logging.getLogger('main')

def parse_cmd_line():
# {
    parser = OptionParser(usage)

    parser.add_option("-u", "--uri", dest="anysql_uri", type="string",
                      help="an anysql uri",
                      metavar="",
                      default="sqlite3:/var/lib/pf-xivo-queues-logger/sqlite3/queuestat.db")

    parser.add_option("-w", "--web-config-uri", dest="webconfig_uri", type="string",
                      help="specify a queuelogger webconfig URI to be sure to use "
                           "the same database than the one used by the xivo_daemon",
                      metavar=XIVO_CONF_FILE,
                      default=XIVO_CONF_FILE)

    parser.add_option("-i", "--ip", dest="ip", type="string",
                      help="monitor AMI ip",
                      metavar="127.0.0.1",
                      default="127.0.0.1")

    parser.add_option("-p", "--port", dest="port", type="int",
                      help="monitor AMI port",
                      metavar="5038",
                      default=5038)

    parser.add_option("-l", "--ami-user-login", dest="user", type="string",
                      help="AMI user for login",
                      metavar="xivouser",
                      default="xivouser")

    parser.add_option("-x", "--password", dest="password", type="string",
                      help="AMI user password",
                      metavar="xivouser",
                      default="xivouser")

    parser.add_option("-d", "--debug", dest = "debug", action = "store_true",
                      help = "debug mode",
                      default = False)

    (options, args) = parser.parse_args()

    return options
# }


def request_config(webconfig_uri):
    anysql_uri = None
    if webconfig_uri != '':
        try:
            req = urllib2.Request(url = webconfig_uri)
            config_file = cjson.decode(urllib2.urlopen(req).read())
            anysql_uri = config_file.get('db_uri')
        except Exception, exc:
            log.exception('Could not access to %s' % (webconfig_uri))
            anysql_uri = None
    return anysql_uri


def main():
# {
    # define the logging properties, before anything else
    try:
        logfilehandler = RotatingFileHandler(LOGFILENAME)
        formatter = logging.Formatter('%%(asctime)s %s[%%(process)d] (%%(levelname)s) (%%(name)s): %%(message)s'
                                      % LOGDAEMONNAME)
        logfilehandler.setFormatter(formatter)
        logging.getLogger('').addHandler(logfilehandler)
    except Exception:
        log.exception('logfilehandler')

    options = parse_cmd_line()

    if not options.debug:
        daemonize.daemonize()
    daemonize.lock_pidfile_or_die(PIDFILE)

    # fetch the database URI on a queue_logger JSON config
    # normally something like XIVO_CONF_FILE
    options.anysql_uri = request_config(options.webconfig_uri)

    try:
        ami_conn(options)
        log.info('Seems we are connected to the AMI (first try)')
    except socket.error, msg:
        log.exception('Unable to connect to AMI (%s)' % msg)

    time_before_retry = 1

    while time_before_retry:
        if not options.anysql_uri:
            log.warning('attempting to fetch the config from WEBI again, tbr is %d sec now '
                        % time_before_retry)
            options.anysql_uri = request_config(options.webconfig_uri)

        if options.anysql_uri:
            loop_ret = ami_logger.loop(options)
            log.warning('End of the loop ... tbr is %d sec now'
                        % time_before_retry)

            if loop_ret and loop_ret[1]>1:
                log.error(loop_ret[0])
                return loop_ret[1]
            elif loop_ret and loop_ret[1] != -3:
                log.error(loop_ret[0])

        time.sleep(time_before_retry)
        time_before_retry += 2

        try:
            ami_conn(options)
            log.info('Seems we are connected to the AMI (try when tbr is %d sec)'
                     % time_before_retry)
        except:
            log.exception('%s:%d| Unable to reconnect, next try scheduled in %d sec'
                          % (options.ip, options.port, time_before_retry))

    daemonize.unlock_pidfile(PIDFILE)

    return 4
# }

try:
    sys.exit(main())
except KeyboardInterrupt:
    sys.stderr.write('\nbye\n')
