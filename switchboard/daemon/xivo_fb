#!/usr/bin/python
# $Revision$
# $Date$
#
# Authors : Thomas Bernard, Corentin Le Gall, Benoit Thinot, Guillaume Knispel
#           Proformatique
#           67, rue Voltaire
#           92800 PUTEAUX
#           (+33/0)1.41.38.99.60
#           mailto:technique@proformatique.com
#           (C) 2007 Proformatique
#

## \mainpage
# \section section_1 General description of XIVO Daemon
# The XIVO Daemon aims to monitor all the actions taking place into one or
# more Asterisk servers, in order to provide 2 basic customer facilities :
# - a monitoring switchboard;
# - a customer information popup.
#
# This is achieved thanks to 2 mechanisms :
# - one or more connections to the Asterisk Manager Interface (AMI), where
# all the events can be watched;
# - Asterisk AGI's that send informations when a call is issued.
#
# This daemon is able to manage any number of Asterisk's one might wish.
#
# \section section_2 Initializations
#
# - Fetch the phone number lists from the WEB Interface.
#
# \section section_3 Main loop
# The main loop is triggered by a select() on the file descriptors for :
# - the AMI Event sockets (AMIsocks);
# - the UI sockets (UIsock, WEBIsock);
# - the Caller Information Popup sockets (authentication, keepalive and identrequest).
#
# On reception of AMI Events, handle_ami_event() parses the messages to update
# the detailed status of the channels.
#
# For each UI connection, a list of the open UI connections is updated
# (tcpopens_sb or tcpopens_webi according to the kind of connection).
# This list is the one used to broadcast the miscellaneous updates
# (it is up to the UI clients to fetch the initial status with the "hints"
# command).
#
# \section section_6 Monitoring with AMI
#
# The AMI events are the basis for a channel-by-channel status of the phones.
#
# Many AMI events are watched for, but not all of them are handled yet.
# The most useful ones are now : Dial, Link, Hangup, Rename.
# The following ones : Newexten, Newchannel, Newcallerid, Newstate are useful when dealing
# complex situations (when there are Local/ channels and Queues for instance).
#
# \section section_8 Caller Information Popup management
#
# The daemon has 3 other listening sockets :
# - Login - TCP - (the clients connect to it to login)
# - KeepAlive - UDP - (the clients send datagram to it to inform
#                      of their current state)
# - IdentRequest - TCP - offer a service to ask for localization and
#                        state of the clients.
# we use the SocketServer "framework" to implement the "services"
# see http://docs.python.org/lib/module-SocketServer.html
#
# \section section_9 Data Structures
#
# The statuses of all the lines/channels are stored in the multidimensional array/dict "plist",
# which is an array of PhoneList.
#
# plist[astn].normal[phonenum].chann[channel] are objects of the class ChannelStatus.
# - astn is the Asterisk id
# - phonenum is the phone id (SIP/<xx>, IAX2/<yy>, ...)
# - channel is the full channel name as known by Asterisk
#
## \file xivo_daemon.py
# \brief XIVO CTI server
#
## \namespace xivo_daemon
# \brief XIVO CTI server
#

__version__ = "$Revision$ $Date$"
__revision__ = __version__.split()[1]

# debian.org modules
import csv
import string
import ConfigParser
import commands
import getopt
import md5
import os
import pickle
import random
import re
import select
import signal
import socket
import SocketServer
import sys
import syslog
import threading
import time
import urllib
import _sre

# XIVO lib-python modules initialization
import xivo.to_path
xivoconffile            = "/etc/asterisk/xivo_fb.conf"
GETOPT_SHORTOPTS        = 'dc:'
GETOPT_LONGOPTS         = ["debug", "config="]
debug_mode = False
def config_path():
        global xivoconffile, debug_mode
        for opt, arg in getopt.getopt(
                sys.argv[1:],
                GETOPT_SHORTOPTS,
                GETOPT_LONGOPTS
                )[0]:
                if opt == "-c":
                        xivoconffile = arg
		elif opt == "-d":
			debug_mode = True
config_path()

# XIVO lib-python modules imports
import daemonize
from easyslog import *
import anysql
from BackSQL import backmysql
from BackSQL import backsqlite

# XIVO modules
import sendfiche
import xivo_ami
import xivo_ldap
import xivo_commandsets
import xivo_astcfg
from xivo_common import *
from xivo_log import *

# the first line would be better, but the second one is useful because of freezing needs
from CommandSets import *
# import XivoSimple

allowed_states = ['available', 'away', 'outtolunch', 'donotdisturb', 'berightback']

# global : userlist
# liste des champs :
#  user :             user name
#  passwd :           password
#  sessionid :        session id generated at connection
#  sessiontimestamp : last time when the client proved itself to be ALIVE :)
#  ip :               ip address of the client (current session)
#  port :             port here the client is listening.
#  state :            cf. allowed_states
# The user identifier will likely be its phone number

PIDFILE = '/var/run/xivo_fb.pid'
# TODO: command line parameter

BUFSIZE_LARGE = 8192
BUFSIZE_UDP = 2048
BUFSIZE_ANY = 512

SUBSCRIBES_N_PER_UNIT_OF_TIME = 20
SUBSCRIBES_TIME_UNIT_IN_S     = 1

socket.setdefaulttimeout(2)
XIVO_CLI_WEBI_HEADER = 'XIVO-CLI-WEBI'
REQUIRED_CLIENT_VERSION = 2025
XIVOVERSION = '0.3'
PDF2FAX= '/usr/share/asterisk/bin/pdf2fax'

# capabilities
CAPA_CUSTINFO    = 1 <<  0
CAPA_PRESENCE    = 1 <<  1
CAPA_HISTORY     = 1 <<  2
CAPA_DIRECTORY   = 1 <<  3
CAPA_DIAL        = 1 <<  4
CAPA_FEATURES    = 1 <<  5
CAPA_PEERS       = 1 <<  6
CAPA_MESSAGE     = 1 <<  7
CAPA_SWITCHBOARD = 1 <<  8
CAPA_AGENTS      = 1 <<  9
CAPA_FAX         = 1 << 10
CAPA_DATABASE    = 1 << 11

# this list shall be defined through more options in WEB Interface
CAPA_ALMOST_ALL = CAPA_CUSTINFO | CAPA_PRESENCE | CAPA_HISTORY  | CAPA_DIRECTORY | \
                  CAPA_DIAL | CAPA_FEATURES | CAPA_PEERS | \
                  CAPA_SWITCHBOARD | CAPA_AGENTS | CAPA_FAX | CAPA_DATABASE

map_capas = {
        'customerinfo'     : CAPA_CUSTINFO,
        'presence'         : CAPA_PRESENCE,
        'history'          : CAPA_HISTORY,
        'directory'        : CAPA_DIRECTORY,
        'dial'             : CAPA_DIAL,
        'features'         : CAPA_FEATURES,
        'peers'            : CAPA_PEERS,
        'instantmessaging' : CAPA_MESSAGE,
        'switchboard'      : CAPA_SWITCHBOARD,
        'agents'           : CAPA_AGENTS,
        'fax'              : CAPA_FAX,
        'database'         : CAPA_DATABASE
        }

PATH_SPOOL_ASTERISK_FAX = '/var/spool/asterisk/fax'

"""
Functions related to user-driven requests : history, directory, ...
These functions should not deal with CTI clients directly, however.
"""




"""
Communication with CTI clients
"""

def send_msg_to_cti_client(uinfo, message):
        if message is None:
                return
        try:
                if 'tcpmode' in uinfo:
                        conntype = uinfo.get('tcpmode')
                        if conntype:
                                # TCP
                                if 'connection' in uinfo:
                                        mysock = uinfo['connection']
                                        mysock.send(message + '\n')
                                else:
                                        log_debug(SYSLOG_WARNING,
                                                  'no connection field defined for user <%s> (TCP)' % uinfo.get('user'))
                        else:
                                # UDP
                                if 'connection' in uinfo:
                                        mysock = uinfo['connection'].request[1]
                                        mysock.sendto(message, uinfo['connection'].client_address)
                                else:
                                        log_debug(SYSLOG_WARNING,
                                                  'no connection field defined for user <%s> (UDP)' % uinfo.get('user'))
        except Exception, exc:
                log_debug(SYSLOG_ERR, '--- exception --- (send_msg_to_cti_client) send <%s ...> has failed for user <%s> : %s'
                          %(message[0:40], uinfo.get('user'), str(exc)))


def manage_login(cfg, requester_ip, requester_port, socket):
        global userinfo_by_requester
        for argum in commandclass.required_login_params():
                if argum not in cfg:
                        log_debug(SYSLOG_WARNING, 'missing argument when user attempts to log in : <%s>' % argum)
                        return commandclass.loginko(cfg, 'missing:%s' % argum)

        if cfg.get('astid') in configs:
                astid  = cfg.get('astid')
        else:
                log_debug(SYSLOG_INFO, "login command attempt from SB : asterisk name <%s> unknown" % cfg.get('astid'))
                return commandclass.loginko(cfg, 'asterisk_name')
        proto    = cfg.get('proto').lower()
        userid   = cfg.get('userid')
        state    = cfg.get('state')
        [whoami, whatsmyos] = cfg.get('ident').split("@")
        password = cfg.get('passwd')
        version  = cfg.get('version')
        phonenum = cfg.get('phonenum')
        if version == '':
                version = '0'

        if int(version) < REQUIRED_CLIENT_VERSION:
                return commandclass.loginko(cfg, 'version_client:%s;%d' % (version, REQUIRED_CLIENT_VERSION))

        capa_user = []
        ulist[astid].acquire()
        try:
                userinfo = ulist[astid].finduser(userid)
                if userinfo == None:
                        repstr = commandclass.loginko(cfg, 'user_not_found')
                        log_debug(SYSLOG_INFO, "no user found %s" % str(cfg))
                elif password != userinfo['passwd']:
                        repstr = commandclass.loginko(cfg, 'login_passwd')
                else:
                        reterror = check_user_connection(userinfo, whoami)
                        if reterror is None:
                                for capa in configs[astid].capas_s:
                                        if capa in map_capas and (map_capas[capa] & userinfo.get('capas')):
                                                capa_user.append(capa)

                                sessionid = '%u' % random.randint(0,999999999)
                                connect_user(userinfo, sessionid,
                                             requester_ip, requester_port,
                                             whoami, whatsmyos, True, state,
                                             False, socket.makefile('w'))

                                repstr = commandclass.loginok(userinfo, capa_user, [XIVOVERSION, __revision__], configs, cfg)
                                userinfo['connection'] = socket
                                u_phonenum = userinfo.get('phonenum')
                                if u_phonenum is None:
                                        userinfo['phonenum'] = phonenum
                                userinfo_by_requester[requester_ip + ":" + requester_port] = [userinfo.get('astid'),
                                                                                              proto,
                                                                                              userid,
                                                                                              userinfo.get('context'),
                                                                                              userinfo.get('capas'),
                                                                                              userinfo.get('phonenum')]
                                plist[astid].send_availstate_update(userid, state)
                        else:
                                repstr = commandclass.loginko(cfg, reterror)
        finally:
                ulist[astid].release()

        print 'manage_login', repstr
        return repstr


# AGI connection (formerly known as 'Fiche')
def manage_agi_connections_tcp(connid):
        global fdlist_full
        requester = ':'.join([connid.getpeername()[0], str(connid.getpeername()[1])])

        try:
                msg = connid.recv(BUFSIZE_LARGE)
        except socket.timeout, exc:
                msg = ''
                log_debug(SYSLOG_ERR, '--- exception --- F connection : a socket timeout occured when recv from %s : %s'
                          %(requester, str(exc)))
        except socket.error, exc:
                msg = ''
                log_debug(SYSLOG_ERR, '--- exception --- F connection : a socket error occured when recv from %s : %s'
                          %(requester, str(exc)))
        except Exception, exc:
                msg = ''
                log_debug(SYSLOG_ERR, '--- exception --- F connection : an Exception occured when recv from %s : %s - %s'
                          %(requester, str(exc), exc.__class__))
        if len(msg) == 0:
                try:
                        connid.close()
                        fdlist_full.remove(connid)
                        tcpopens_fc.remove(connid)
                        log_debug(SYSLOG_INFO, "TCP (F) socket closed from %s" % requester)
                except Exception, exc:
                        log_debug(SYSLOG_ERR, '--- exception --- F connection [%s] : a problem occured when trying to close %s : %s'
                                  %(msg, str(connid), str(exc)))
        else:
                re_push = re.match('PUSH <(\S+)> <(\S+)> <(\S+)> <(\S+)>', msg.strip())
                if re_push != None:
                        inchannel = re_push.group(1)
                        cidnum    = re_push.group(2)
                        sdanum    = re_push.group(3)
                        prevupto  = re_push.group(4)
                        print 'INCOMING CALL ## PUSH received #', inchannel, cidnum, sdanum, prevupto
                        whattodo = commandclass.elect(asterisklist[0], inchannel, cidnum, sdanum, prevupto)
                        msgforagi = 'PULL_START %s PULL_STOP' % pickle.dumps(whattodo)
                        print 'INCOMING CALL ## sending pickled reply to AGI'
                        connid.send(msgforagi)
                        connid.close()
                        fdlist_full.remove(connid)
                        tcpopens_fc.remove(connid)
                        log_debug(SYSLOG_INFO, "TCP (F) socket closed from %s" % requester)


## \brief Deals with requests from the UI clients.
# \param connid connection identifier
# \param allow_events tells if this connection belongs to events-allowed ones
# (for switchboard) or to events-disallowed ones (for WEBI CLI commands)
# \return none
def manage_webi_cti_connections_tcp(connid, allow_events):
        global AMI_array_user_commands, fdlist_full
        requester_ip = connid.getpeername()[0]
        requester_port = str(connid.getpeername()[1])
        requester = ':'.join([requester_ip, requester_port])

        try:
                msg = connid.recv(BUFSIZE_LARGE)
        except socket.timeout, exc:
                msg = ''
                log_debug(SYSLOG_ERR, '--- exception --- UI connection : a socket timeout occured when recv from %s : %s'
                          %(requester, str(exc)))
        except socket.error, exc:
                msg = ''
                log_debug(SYSLOG_ERR, '--- exception --- UI connection : a socket error occured when recv from %s : %s'
                          %(requester, str(exc)))
        except Exception, exc:
                msg = ''
                log_debug(SYSLOG_ERR, '--- exception --- UI connection : an Exception occured when recv from %s : %s - %s'
                          %(requester, str(exc), exc.__class__))
        if len(msg) == 0:
                try:
                        connid.close()
                        fdlist_full.remove(connid)
                        if allow_events:
                                tcpopens_sb.remove(connid)
                                log_debug(SYSLOG_INFO, "TCP (SB)  socket closed from %s" % requester)
                                if requester in userinfo_by_requester:
                                        astid    = userinfo_by_requester[requester][0]
                                        tech     = userinfo_by_requester[requester][1]
                                        username = userinfo_by_requester[requester][2]
                                        userinfo = ulist[astid].finduser(username)
                                        if userinfo == None:
                                                log_debug(SYSLOG_INFO, "no user found for %s/%s" %(astid, username))
                                        else:
                                                ulist[astid].disconnect_user(username)
                                        del userinfo_by_requester[requester]
                        else:
                                tcpopens_webi.remove(connid)
                                log_debug(SYSLOG_INFO, "TCP (WEBI) socket closed from %s" % requester)

                except Exception, exc:
                        log_debug(SYSLOG_ERR, '--- exception --- UI connection [%s] : a problem occured when trying to close %s : %s'
                                  %(msg, str(connid), str(exc)))
        else:
            if allow_events:
                    multimsg = msg.split('/')
            else:
                    multimsg = msg.split('\n')
            for usefulmsgpart in multimsg:
                usefulmsg = usefulmsgpart.split('\r')[0]
                # debug/setup functions
                if usefulmsg == "show_infos":
                        try:
                                time_uptime = int(time.time() - time_start)
                                reply = 'infos=' \
                                        'xivo_version=%s;' \
                                        'server_version=%s;' \
                                        'clients_required_version=%d;' \
                                        'uptime=%d s;' \
                                        'logged_sb=%d/%d;' \
                                        'logged_xc=%d/%d' \
                                        %(XIVOVERSION,
                                          __revision__,
                                          REQUIRED_CLIENT_VERSION, time_uptime,
                                          conngui_sb, maxgui_sb, conngui_xc, maxgui_xc)
                                connid.send(reply + "\n")
                                # connid.send("server capabilities = %s\n" %(",".join()))
                                connid.send("%s:OK\n" %(XIVO_CLI_WEBI_HEADER))
                                if not allow_events:
                                        connid.close()
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- UI connection [%s] : KO when sending to %s : %s'
                                          %(usefulmsg, requester, str(exc)))
                elif usefulmsg == "show_phones":
                        try:
                                for astid, plast in plist.iteritems():
                                        k1 = plast.normal.keys()
                                        k1.sort()
                                        for kk in k1:
                                                canal = plast.normal[kk].chann
                                                connid.send('%10s %10s %6s [%s : %12s - %4d s] %4d %s\n'
                                                               %(plast.astid,
                                                                 kk,
                                                                 plast.normal[kk].towatch,
                                                                 plast.normal[kk].tech,
                                                                 plast.normal[kk].hintstatus,
                                                                 int(time.time() - plast.normal[kk].lasttime),
                                                                 len(canal),
                                                                 str(canal.keys())))
                                connid.send("%s:OK\n" %(XIVO_CLI_WEBI_HEADER))
                                if not allow_events:
                                        connid.close()
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- UI connection [%s] : KO when sending to %s : %s'
                                          %(usefulmsg, requester, str(exc)))
                elif usefulmsg == "show_busy":
                        try:
                                for astid, plast in plist.iteritems():
                                        connid.send('%s : normal=%d queues=%d oldqueues=%d\n'
                                                       %(astid, len(plast.normal), len(plast.queues), len(plast.oldqueues)))
                                        k1 = plast.oldqueues.keys()
                                        k1.sort()
                                        for kk in k1:
                                                connid.send('%s : %s %d\n' %(astid, kk, len(plast.oldqueues[kk])))
                                connid.send("%s:OK\n" %(XIVO_CLI_WEBI_HEADER))
                                if not allow_events:
                                        connid.close()
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- UI connection [%s] : KO when sending to %s : %s'
                                          %(usefulmsg, requester, str(exc)))
                elif usefulmsg == 'show_users':
                        try:
                                for astid in configs:
                                        connid.send("on <%s> :\n" % astid)
                                        for user,info in ulist[astid].listusers().iteritems():
                                                connid.send('%s %s\n' %(user, info))
                                if requester in userinfo_by_requester:
                                        connid.send('%s\n' % str(userinfo_by_requester[requester]))
                                connid.send("%s:OK\n" %(XIVO_CLI_WEBI_HEADER))
                                if not allow_events:
                                        connid.close()
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- UI connection [%s] : KO when sending to %s : %s'
                                          %(usefulmsg, requester, str(exc)))
                elif usefulmsg == 'show_logged':
                        try:
                                for astid in configs:
                                        connid.send("on <%s> :\n" % astid)
                                        for user,info in ulist[astid].listconnected().iteritems():
                                                connid.send('%s %s\n' %(user, info))
                                if requester in userinfo_by_requester:
                                        connid.send('%s\n' % str(userinfo_by_requester[requester]))
                                connid.send("%s:OK\n" %(XIVO_CLI_WEBI_HEADER))
                                if not allow_events:
                                        connid.close()
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- UI connection [%s] : KO when sending to %s : %s'
                                          %(usefulmsg, requester, str(exc)))
                elif usefulmsg == "show_ami":
                        try:
                                for amis in AMI_array_events_fd:
                                        connid.send("events   : %s : %s\n" %(amis, str(AMI_array_events_fd[amis])))
                                for amis in AMI_array_user_commands:
                                        connid.send("commands : %s : %s\n" %(amis, str(AMI_array_user_commands[amis])))
                                connid.send("%s:OK\n" %(XIVO_CLI_WEBI_HEADER))
                                if not allow_events:
                                        connid.close()
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- UI connection [%s] : KO when sending to %s : %s'
                                          %(usefulmsg, requester, str(exc)))
                elif usefulmsg != "":
                    if allow_events: # i.e. if SB-style connection
                        command = commandclass.parsecommand(usefulmsg)
                        if command.name in commandclass.get_list_commands():
                                if command.type == xivo_commandsets.CMD_LOGIN:
                                        try:
                                                cfg = commandclass.get_login_params(asterisklist[0], command, connid)
                                                repstr = manage_login(cfg, requester_ip, requester_port, connid)
                                                connid.send(repstr)
                                        except Exception, exc:
                                                log_debug(SYSLOG_ERR, '--- exception --- UI connection [%s] : a problem occured when sending to %s : %s'
                                                          %(command.name, requester, str(exc)))
                                else:
                                        log_debug(SYSLOG_INFO, "%s is attempting a %s (TCP) : %s" %(requester, command.name, str(command.args)))
                                        try:
                                                if requester in userinfo_by_requester:
                                                        resp = commandclass.manage_srv2clt(userinfo_by_requester[requester],
                                                                                           ['tcp', connid],
                                                                                           command,
                                                                                           configs)
                                                        try:
                                                                if resp is not None:
                                                                        connid.send(resp + '\n')
                                                        except Exception, exc:
                                                                log_debug(SYSLOG_ERR, '--- exception --- (sending TCP) %s' % str(exc))
                                        except Exception, exc:
                                                log_debug(SYSLOG_ERR, '--- exception --- UI connection [%s] : a problem occured when sending to %s : %s'
                                                          %(command.name, requester, str(exc)))
                        else:
                                connid.send('Unknown Command %s\n' % command.name)


                    else: # i.e. if WEBI-style connection
                                if requester_ip in ip_reverse_webi:
                                        try:
                                                astid = ip_reverse_webi[requester_ip]
                                                connid.send('%s:ID <%s>\n' %(XIVO_CLI_WEBI_HEADER, astid))
                                                if usefulmsg == 'xivo[userlist,update]':
                                                        update_userlist[astid] = True
                                                        connid.send('%s:OK\n' %(XIVO_CLI_WEBI_HEADER))
                                                        log_debug(SYSLOG_INFO, '%s : userlist update request received' % astid)
                                                elif astid in AMI_array_user_commands and AMI_array_user_commands[astid]:
                                                        stripped_usefulmsg = usefulmsg.strip()
                                                        try:
                                                                if stripped_usefulmsg == 'moh reload':
                                                                        commandclass.pre_moh_reload()
                                                                elif stripped_usefulmsg == 'reload':
                                                                        commandclass.pre_reload()
                                                        except Exception, exc:
                                                                log_debug(SYSLOG_ERR, '--- exception --- (pre reloads) : %s' % str(exc))
                                                        try:
                                                                s = AMI_array_user_commands[astid].execclicommand(stripped_usefulmsg)
                                                        except Exception, exc:
                                                                log_debug(SYSLOG_ERR, '--- exception --- (%s) WEBI command exec <%s> : (client %s) : %s'
                                                                          %(astid, str(stripped_usefulmsg), requester, str(exc)))
                                                        try:
                                                                for x in s: connid.send(x)
                                                                connid.send('%s:OK\n' %(XIVO_CLI_WEBI_HEADER))
                                                        except Exception, exc:
                                                                log_debug(SYSLOG_ERR, '--- exception --- (%s) WEBI command reply <%s> : (client %s) : %s'
                                                                          %(astid, str(stripped_usefulmsg), requester, str(exc)))
                                        except Exception, exc:
                                                log_debug(SYSLOG_ERR, '--- exception --- (%s) WEBI <%s> : (client %s) : %s'
                                                          %(astid, str(usefulmsg.strip()), requester, str(exc)))
                                                connid.send('%s:KO <Exception : %s>\n' %(XIVO_CLI_WEBI_HEADER, str(exc)))
                                else:
                                        connid.send('%s:KO <NOT ALLOWED>\n' %(XIVO_CLI_WEBI_HEADER))
                                try:
                                        connid.close()
                                        fdlist_full.remove(connid)
                                        tcpopens_webi.remove(connid)
                                        log_debug(SYSLOG_INFO, 'TCP (WEBI) socket closed towards %s' % requester)
                                except Exception, exc:
                                        log_debug(SYSLOG_ERR, '--- exception --- (%s) WEBI could not close properly %s'
                                                  %(astid, requester))



"""
Management of events that are spied on the AMI
"""


## \brief Handling of AMI events occuring in Events=on mode.
# \param astid the asterisk Id
# \param idata the data read from the AMI we want to parse
# \return none
def handle_ami_event(astid, idata):
        global plist, save_for_next_packet_events
        if astid not in configs:
                log_debug(SYSLOG_INFO, "%s : no such asterisk Id" % astid)
                return

        full_idata = save_for_next_packet_events[astid] + idata
        evlist = full_idata.split("\r\n\r\n")
        save_for_next_packet_events[astid] = evlist.pop()
        plist_thisast = plist[astid]

        for evt in evlist:
                this_event = {}
                for myline in evt.split('\r\n'):
                        myfieldvalue = myline.split(': ', 1)
                        if len(myfieldvalue) == 2:
                                this_event[myfieldvalue[0]] = myfieldvalue[1]
                evfunction = this_event.get('Event')
                verboselog("/%s/ %s" %(astid, str(this_event)), True, False)
                # print '////////', evfunction, '   ------  ', this_event
                if evfunction == 'Dial':
                        try:
                                commandclass.ami_dial(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
                elif evfunction == 'Link':
                        try:
                                commandclass.ami_link(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
                elif evfunction == 'Unlink':
                        try:
                                commandclass.ami_unlink(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
                elif evfunction == 'Hangup':
                        try:
                                commandclass.ami_hangup(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
                elif evfunction == 'Reload':
                        message = this_event.get('Message')
                        log_debug(SYSLOG_WARNING, "AMI:Reload: %s : %s" %(astid, str(this_event)))
                elif evfunction == 'Shutdown':
                        shutdown = this_event.get('Shutdown')
                        restart  = this_event.get('Restart')
                        log_debug(SYSLOG_WARNING, "AMI:Shutdown: %s (how=%s restart=%s)" %(astid, shutdown, restart))
                elif evfunction == 'Join':
                        try:
                                commandclass.ami_join(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
                elif evfunction == 'Leave':
                        try:
                                commandclass.ami_leave(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
                elif evfunction == 'PeerStatus':
                        # <-> register's ? notify's ?
                        pass
                elif evfunction == 'Agentlogin':
                        try:
                                commandclass.ami_agentlogin(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
                elif evfunction == 'Agentlogoff':
                        try:
                                commandclass.ami_agentlogoff(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
                elif evfunction == 'Agentcallbacklogoff':
                        try:
                                commandclass.ami_agentcallbacklogoff(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))

                elif evfunction == 'Agentcallbacklogin':
                        log_debug(SYSLOG_INFO, '//AMI:Agentcallbacklogin// %s : %s' %(astid, str(this_event)))
                elif evfunction == 'AgentCalled':
                        log_debug(SYSLOG_INFO, '//AMI:AgentCalled// %s : %s' %(astid, str(this_event)))
                elif evfunction == 'ParkedCall':
                        # when a requested parking is established
                        try:
                                commandclass.ami_parkedcall(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
                elif evfunction == 'UnParkedCall':
                        # when somebody (From) took the call
                        try:
                                commandclass.ami_unparkedcall(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
                elif evfunction == 'ParkedCallTimeOut':
                        # when the timeout has occured
                        try:
                                commandclass.ami_parkedcalltimeout(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
                elif evfunction == 'ParkedCallGiveUp':
                        # when the peer is tired
                        try:
                                commandclass.ami_parkedcallgiveup(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
                elif evfunction == 'ParkedCallsComplete':
                        log_debug(SYSLOG_INFO, '//AMI:ParkedCallsComplete// %s : %s' %(astid, str(this_event)))
                elif evfunction == 'Cdr':
                        log_debug(SYSLOG_INFO, '//AMI:Cdr// %s : %s' %(astid, str(this_event)))
                elif evfunction == 'Alarm':
                        log_debug(SYSLOG_INFO, '//AMI:Alarm// %s : %s' %(astid, str(this_event)))
                elif evfunction == 'AlarmClear':
                        log_debug(SYSLOG_INFO, '//AMI:AlarmClear// %s : %s' %(astid, str(this_event)))
                elif evfunction == 'FaxReceived':
                        log_debug(SYSLOG_INFO, '//AMI:FaxReceived// %s : %s' %(astid, str(this_event)))
                elif evfunction == 'Registry':
                        log_debug(SYSLOG_INFO, 'AMI:Registry: %s : username=%s channel=%s domain=%s status=%s'
                                  %(astid, this_event.get('Username'), this_event.get('Channel'), this_event.get('Domain'), this_event.get('Status')))
                elif evfunction == 'MeetmeJoin':
                        channel = this_event.get('Channel')
                        meetme  = this_event.get('Meetme')
                        usernum = this_event.get('Usernum')
                        log_debug(SYSLOG_INFO, 'AMI:MeetmeJoin %s : %s %s %s'
                                  %(astid, channel, meetme, usernum))
                elif evfunction == 'MeetmeLeave':
                        channel = this_event.get('Channel')
                        meetme  = this_event.get('Meetme')
                        usernum = this_event.get('Usernum')
                        log_debug(SYSLOG_INFO, 'AMI:MeetmeLeave %s : %s %s %s'
                                  %(astid, channel, meetme, usernum))
                elif evfunction == 'ExtensionStatus':
                        exten   = this_event.get('Exten')
                        context = this_event.get('Context')
                        status  = this_event.get('Status')
                        # log_debug(SYSLOG_INFO, 'AMI:ExtensionStatus: %s : %s %s %s' %(astid, exten, context, status))

                        sipphone = 'SIP/%s' % exten
                        if sipphone in plist_thisast.normal:
                                normv = plist_thisast.normal[sipphone]
                                normv.set_lasttime(time.time())
                                sippresence = 'Timeout'
                                if status == '-1':
                                        sippresence = 'Fail'
                                elif status == '0':
                                        sippresence = 'Ready'
                                elif status == '1':
                                        sippresence = 'On the phone'
                                elif status == '4':
                                        sippresence = 'Unavailable'
                                elif status == '8':
                                        sippresence = 'Ringing'
                                normv.set_hintstatus(sippresence)
                                plist_thisast.update_gui_clients(sipphone, "SIP-NTFY")
                        
                        # QueueMemberStatus ExtensionStatus
                        #                 0                  AST_DEVICE_UNKNOWN
                        #                 1               0  AST_DEVICE_NOT_INUSE  /  libre
                        #                 2               1  AST_DEVICE IN USE     / en ligne
                        #                 3                  AST_DEVICE_BUSY
                        #                                 4  AST_EXTENSION_UNAVAILABLE ?
                        #                 5                  AST_DEVICE_UNAVAILABLE
                        #                 6 AST_EXTENSION_RINGING = 8  appele
                elif evfunction == 'OriginateSuccess':
                        try:
                                commandclass.ami_originatesuccess(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
                elif evfunction == 'AOriginateSuccess':
                        try:
                                commandclass.ami_aoriginatesuccess(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
                elif evfunction == 'OriginateFailure':
                        try:
                                commandclass.ami_originatefailure(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
                        # log_debug(SYSLOG_INFO, 'AMI:OriginateFailure: %s - reason = %s' % (astid, this_event.get('Reason')))
                elif evfunction == 'AOriginateFailure':
                        try:
                                commandclass.ami_aoriginatefailure(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
                        # log_debug(SYSLOG_INFO, 'AMI:AOriginateFailure: %s - reason = %s' % (astid, this_event.get('Reason')))
                        #define AST_CONTROL_HANGUP              1
                        #define AST_CONTROL_RING                2
                        #define AST_CONTROL_RINGING             3
                        #define AST_CONTROL_ANSWER              4
                        #define AST_CONTROL_BUSY                5
                        #define AST_CONTROL_TAKEOFFHOOK         6
                        #define AST_CONTROL_OFFHOOK             7
                        #define AST_CONTROL_CONGESTION          8
                        #define AST_CONTROL_FLASH               9
                        #define AST_CONTROL_WINK                10
                elif evfunction == 'Rename':
                        # appears when there is a transfer
                        try:
                                commandclass.ami_rename(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
                elif evfunction == 'Newstate':
                        pass
                elif evfunction == 'Newcallerid':
                        # for tricky managements
                        try:
                                commandclass.ami_newcallerid(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
                elif evfunction == 'Newchannel':
                        pass
                elif evfunction == 'UserEventFeature': # UserEvent(Feature,AppData: <context>|<num>|<unc>|<enable/disable>|<redir>)
                        try:
                                appdata = this_event.get('AppData').split('|')
                                log_debug(SYSLOG_INFO, 'AMI:UserEventFeature: %s : %s' % (astid, str(appdata)))
                                ctx = appdata[0]
                                userid = appdata[1]
                                feature = appdata[2]
                                enable = ''
                                value = ''
                                if len(appdata) >= 4:
                                        enable = appdata[3]
                                if len(appdata) >= 5:
                                        value = appdata[4]
                                strupdate = commandclass.features_srv2clt('update', ';'.join([astid, ctx, userid, feature, ':'.join([enable, value])]))
                                send_msg_to_cti_clients(strupdate)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- (UserEventFeature) <%s> : %s' %(str(this_event), str(exc)))
                elif evfunction is not None and evfunction.startswith('UserEvent'):
                        try:
                                commandclass.ami_userevent(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
                elif evfunction == 'Newexten': # in order to handle outgoing calls ?
                        chan    = this_event.get('Channel')
                        exten   = this_event.get('Extension')
                        context = this_event.get('Context')
                        if exten not in ['s', 'h', 't', 'enum']:
                                #print '--- exten :', chan, exten
                                plist_thisast.normal_channel_fills(chan, DUMMY_MYNUM,
                                                                   'Calling', 0, DIR_TO_STRING,
                                                                   DUMMY_RCHAN, exten, 'ami-ne0')
                        else:
                                pass
                        application = this_event.get('Application')
                        if application == 'Set':
                                #print application, this_event
                                pass
                        elif application == 'AGI':
                                #print application, this_event
                                pass
                        elif application == 'VoiceMailMain': # when s.o. checks one's own VM
                                #print application, this_event
                                pass
                        elif application == 'MeetMe':
                                #print application, this_event
                                pass
                        elif application == 'Park':
                                #print application, this_event
                                pass
                        elif application == 'Queue':
                                appdata = this_event.get('AppData')
                                exten   = this_event.get('Extension')
                                context = this_event.get('Context')
                                channel = this_event.get('Channel')
                                # print application, appdata, exten, context, channel
                        elif application == 'VoiceMail': # when s.o. falls to s.o.(else)'s VM
                                #print application, this_event
                                pass
                        elif application not in ['Hangup', 'NoOp', 'Dial', 'Macro', 'MacroExit',
                                                 'Devstate', 'Playback',
                                                 'Answer', 'Background',
                                                 'AGI', 'Goto', 'GotoIf', 'SIPAddHeader', 'Wait']:
                                #print this_event
                                pass

                elif evfunction == 'MessageWaiting':
                        try:
                                commandclass.ami_messagewaiting(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
                elif evfunction == 'QueueParams':
                        pass
                elif evfunction == 'QueueMemberAdded':
                        pass
                elif evfunction == 'QueueMemberPaused':
                        pass
                elif evfunction == 'QueueMemberRemoved':
                        pass
                elif evfunction == 'QueueMember':
                        log_debug(SYSLOG_INFO, '//AMI:QueueMember// %s : %s' %(astid, str(this_event)))
                elif evfunction == 'QueueMemberStatus':
                        try:
                                commandclass.ami_queuememberstatus(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
                elif evfunction == 'Agents':
                        try:
                                commandclass.ami_agents(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
                elif evfunction == 'Status':
                        try:
                                commandclass.ami_status(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
                elif evfunction == 'StatusComplete':
                        log_debug(SYSLOG_INFO, 'AMI %s StatusComplete' % astid)
                elif evfunction == 'AgentsComplete':
                        log_debug(SYSLOG_INFO, 'AMI %s AgentsComplete' % astid)
                elif this_event.get('Response') == 'Follows' and this_event.get('Privilege') == 'Command':
                        log_debug(SYSLOG_INFO, 'AMI %s Response=Follows : %s' % (astid, str(this_event)))
                elif this_event.get('Response') == 'Success':
                        msg = this_event.get('Message')
                        if msg == 'Extension Status':
                                status  = this_event.get('Status')
                                hint    = this_event.get('Hint')
                                context = this_event.get('Context')
                                exten   = this_event.get('Exten')
                                # 90 seconds are needed to retrieve ~ 9000 phone statuses from an asterisk (on daemon startup)
                                if hint in plist_thisast.normal:
                                        normv = plist_thisast.normal[hint]
                                        normv.set_lasttime(time.time())
                                        sippresence = 'Timeout'
                                        if status == '-1':
                                                sippresence = 'Fail'
                                        elif status == '0':
                                                sippresence = 'Ready'
                                        elif status == '1':
                                                sippresence = 'On the phone'
                                        elif status == '4':
                                                sippresence = 'Unavailable'
                                        elif status == '8':
                                                sippresence = 'Ringing'
                                        normv.set_hintstatus(sippresence)
                                        plist_thisast.update_gui_clients(hint, "SIP-NTFY")
                                
                                # log_debug(SYSLOG_INFO, 'AMI %s Response=Success (Extension Status) %s %s %s %s' % (astid, status, hint, context, exten))
                        else:
                                log_debug(SYSLOG_INFO, 'AMI %s Response=Success : %s' % (astid, str(this_event)))
                elif len(this_event) > 0:
                        log_debug(SYSLOG_INFO, 'AMI:XXX: <%s> : %s' % (astid, str(this_event)))
                else:
                        log_debug(SYSLOG_INFO, 'AMI %s Other : %s' % (astid, str(this_event)))


## \brief Connects to the AMI if not yet.
# \param astid Asterisk id to (re)connect
# \return none
def update_amisocks(astid):
        try:
                if astid not in AMI_array_events_fd or AMI_array_events_fd[astid] is False:
                        log_debug(SYSLOG_INFO, '%s : AMI : attempting to connect' % astid)
                        als0 = connect_to_AMI((configs[astid].remoteaddr,
                                               configs[astid].ami_port),
                                              configs[astid].ami_login,
                                              configs[astid].ami_pass,
                                              True)
                        if als0:
                                AMI_array_events_fd[astid] = als0.fd
                                fdlist_full.append(als0.fd)
                                log_debug(SYSLOG_INFO, '%s : AMI : connected' % astid)
                                for x in plist[astid].normal.itervalues():
                                        x.clear_channels()
                                ret = als0.sendstatus()
                                if not ret:
                                        log_debug(SYSLOG_INFO, '%s : could not send status command' % astid)
                                ret = als0.sendagents()
                                if not ret:
                                        log_debug(SYSLOG_INFO, '%s : could not send agents command' % astid)
                        else:
                                log_debug(SYSLOG_INFO, '%s : AMI : could NOT connect' % astid)
        except Exception, exc:
                log_debug(SYSLOG_ERR, '--- exception --- %s (update_amisocks) : %s' % (astid, str(exc)))

        try:
                if astid not in AMI_array_user_commands or AMI_array_user_commands[astid] is False:
                        log_debug(SYSLOG_INFO, '%s : AMI (commands)  : attempting to connect' % astid)
                        als1 = connect_to_AMI((configs[astid].remoteaddr,
                                               configs[astid].ami_port),
                                              configs[astid].ami_login,
                                              configs[astid].ami_pass,
                                              False)
                        if als1:
                                AMI_array_user_commands[astid] = als1
                                log_debug(SYSLOG_INFO, '%s : AMI (commands)  : connected' % astid)
                        else:
                                log_debug(SYSLOG_INFO, '%s : AMI (commands)  : could NOT connect' % astid)
        except Exception, exc:
                log_debug(SYSLOG_ERR, '--- exception --- %s (update_amisocks command) : %s' % (astid, str(exc)))


## \brief Updates the list of sip numbers according to the SSO then sends old and new peers to the UIs.
# The reconnection to the AMI is also done here when it has been broken.
# If the AMI sockets are dead, a reconnection is also attempted here.
# \param astid the asterisk Id
# \return none
# \sa get_phonelist_fromurl
def update_phonelist(astid):
        global plist

        try:
                dt1 = time.time()
                [userl, sipnuml] = configs[astid].get_phonelist_fromurl()
                userl = commandclass.getuserlist()
                for ul, vv in userl.iteritems():
                        ulist[astid].adduser(userl[ul])
                # print sipnuml
                if sipnuml is None:
                        return
                dt2 = time.time()
                for x in configs[astid].extrachannels.split(','):
                        if x != '': sipnuml[x] = [x, '', '', x.split('/')[1], '', False]
                sipnumlistnew = dict.fromkeys(sipnuml.keys())
        except Exception, exc:
                log_debug(SYSLOG_ERR, '--- exception --- %s : get_phonelist_fromurl failed : %s' %(astid, str(exc)))
                sipnuml = {}

        sipnumlistold = dict.fromkeys(filter(lambda j: plist[astid].normal[j].towatch, plist[astid].normal))
        dt3 = time.time()
        plist[astid].lsttoadd = []
        plist[astid].lsttodel = []
        for snl in sipnumlistold:
                pln = plist[astid].normal[snl]
                if snl not in sipnumlistnew:
                        plist[astid].lstdodel.append(":".join(["del",
                                                               astid,
                                                               pln.build_basestatus() + ';']))
                        ulist[astid].deluser(pln.tech.lower() + pln.phoneid)
                        del plist[astid].normal[snl] # or = "Absent"/0 ?
                else:
                        pln.updateIfNeeded(sipnuml[snl])
        dt4 = time.time()
        for snl in sipnumlistnew:
                if snl not in sipnumlistold:
                        if astid in AMI_array_events_fd:
                                AMI_array_events_fd[astid].write('Action: ExtensionState\r\n'
                                                                 'Exten: %s\r\n'
                                                                 'Context: %s\r\n'
                                                                 '\r\n'
                                                                 %(sipnuml[snl][3], sipnuml[snl][4]))
                        if snl.find("SIP") == 0:
                                plist[astid].normal[snl] = LineProp("SIP",
                                                                    snl.split("/")[1],
                                                                    sipnuml[snl][3],
                                                                    sipnuml[snl][4],
                                                                    "Timeout", True)
                                # replaced previous 'BefSubs' initial status here : avoids flooding of Timeout's
                                # when many phones are added at once
                        elif snl.find("IAX2") == 0:
                                plist[astid].normal[snl] = LineProp("IAX2",
                                                                    snl.split("/")[1],
                                                                    sipnuml[snl][3],
                                                                    sipnuml[snl][4],
                                                                    "Ready", True)
                        elif snl.find("mISDN") == 0:
                                plist[astid].normal[snl] = LineProp("mISDN",
                                                                    snl.split("/")[1],
                                                                    sipnuml[snl][3],
                                                                    sipnuml[snl][4],
                                                                    "Ready", True)
                        elif snl.find("Zap") == 0:
                                plist[astid].normal[snl] = LineProp("Zap",
                                                                    snl.split("/")[1],
                                                                    sipnuml[snl][3],
                                                                    sipnuml[snl][4],
                                                                    "Ready", True)
                        else:
                                log_debug(SYSLOG_WARNING, 'format <%s> not supported' % snl)
                                
                        if snl in plist[astid].normal:
                                plist[astid].normal[snl].set_callerid(sipnuml[snl])

                        plist[astid].lsttoadd.append(":".join(["add",
                                                               astid,
                                                               plist[astid].normal[snl].build_basestatus(),
                                                               plist[astid].normal[snl].build_cidstatus(),
                                                               plist[astid].normal[snl].build_fullstatlist() + ';']))
        dt5 = time.time()
        log_debug(SYSLOG_INFO, '%s : sent ExtensionState request for new phones (%f seconds)' %(astid, (dt5-dt4)))
        if len(plist[astid].lsttodel) > 0 or len(plist[astid].lsttoadd) > 0:
                strupdate = commandclass.phones_srv2clt('signal-deloradd',
                                                        [astid,
                                                         len(plist[astid].lsttodel),
                                                         len(plist[astid].lsttoadd),
                                                         len(plist[astid].normal)])
                send_msg_to_cti_clients(strupdate)
                verboselog(strupdate, False, True)
        dt6 = time.time()
        #print 'update_phonelist', dt2-dt1, dt3-dt2, dt4-dt3, dt5-dt4, dt6-dt5


## \brief Connects to the AMI through AMIClass.
# \param address IP address
# \param loginname loginname
# \param password password
# \return the socket
def connect_to_AMI(address, loginname, password, events_on):
        lAMIsock = xivo_ami.AMIClass(address, loginname, password, events_on)
        try:
                lAMIsock.connect()
                lAMIsock.login()
        except socket.timeout: pass
        except socket:         pass
        except:
                del lAMIsock
                lAMIsock = False
        return lAMIsock


## \class LocalChannel
# \brief Properties of a temporary "Local" channel.
class LocalChannel:
        # \brief Class initialization.
        def __init__(self, istate, icallerid):
                self.state = istate
                self.callerid = icallerid
                self.peer = ""
        # \brief Sets the state and the peer channel name.
        def set_chan(self, istate, ipeer):
                self.state = istate
                if ipeer != "":
                        self.peer = ipeer
        def set_callerid(self, icallerid):
                self.callerid = icallerid


## file xivo_astusers : BEGIN

## \class PhoneList
# \brief Properties of the lines of a given Asterisk
class PhoneList:
        ## \var astid
        # \brief Asterisk id, the same as the one given in the configs

        ## \var normal
        # \brief "Normal" phone lines, like SIP, IAX, Zap, ...

        ## \var queues
        # \brief To store queues' statuses

        ## \var oldqueues
        # \brief To store closed queues channels

        ##  \brief Class initialization.
        def __init__(self, iastid, icclass):
                self.astid = iastid
                self.commandclass = icclass
                self.normal = {}
                self.queues = {}
                self.oldqueues = {}
                self.star10 = []
                self.lsttoadd = {}
                self.lsttodel = {}


        def update_gui_clients(self, phonenum, fromwhom):
                phoneinfo = (fromwhom,
                             self.astid,
                             self.normal[phonenum].build_basestatus(),
                             self.normal[phonenum].build_cidstatus(),
                             self.normal[phonenum].build_fullstatlist())
                if self.normal[phonenum].towatch:
                        strupdate = self.commandclass.phones_srv2clt('update', phoneinfo)
                else:
                        strupdate = self.commandclass.phones_srv2clt('noupdate', phoneinfo)
                send_msg_to_cti_clients(strupdate)
                # verboselog(strupdate, False, True)


        def send_availstate_update(self, username, state):
                try:
                        if username.find("sip") == 0:
                                phoneid = "SIP/" + username.split("sip")[1]
                        elif username.find("iax") == 0:
                                phoneid = "IAX/" + username.split("iax")[1]
                        else:
                                phoneid = ""

                        if phoneid in self.normal:
                                if state == "unknown" or self.normal[phoneid].imstat != state:
                                        self.normal[phoneid].set_imstat(state)
                                        self.normal[phoneid].update_time()
                                        self.update_gui_clients(phoneid, "kfc-sau")
                        else:
                                log_debug(SYSLOG_WARNING, "<%s> is not in my phone list" % phoneid)
                except Exception, exc:
                        log_debug(SYSLOG_ERR, '--- exception --- send_availstate_update : %s' % str(exc))


        def normal_channel_fills(self, chan_src, num_src,
                                 action, timeup, direction,
                                 chan_dst, num_dst, comment):
                phoneid_src = channel_splitter(chan_src)
                phoneid_dst = channel_splitter(chan_dst)

                if phoneid_src not in self.normal:
                        self.normal[phoneid_src] = LineProp(phoneid_src.split("/")[0],
                                                            phoneid_src.split("/")[1],
                                                            phoneid_src.split("/")[1],
                                                            "which-context?", "hintstatus?", False)
                do_update = self.normal[phoneid_src].set_chan(chan_src, action, timeup, direction, chan_dst, num_dst, num_src)
                if do_update:
                        self.update_gui_clients(phoneid_src, comment + "F")


## file xivo_astusers : END

## file xivo_lineprop : BEGIN

## \class ChannelStatus
# \brief Properties of a Channel, as given by the AMI.
class ChannelStatus:
        ## \var status
        # \brief Channel status

        ## \var deltatime
        # \brief Elapsed time spent by the channel with the current status

        ## \var time
        # \brief Absolute time

        ## \var direction
        # \brief "To" or "From"

        ## \var channel_peer
        # \brief Channel name of the peer with whom it is in relation

        ## \var channel_num
        # \brief Phone number of the peer with whom it is in relation

        ##  \brief Class initialization.
        def __init__(self, istatus, dtime, idir, ipeerch, ipeernum, itime, imynum):
                self.status = istatus
                self.special = "" # voicemail, meetme, ...
                self.deltatime = dtime
                self.time = itime
                self.direction = idir
                self.channel_peer = ipeerch
                self.channel_num = ipeernum
                self.channel_mynum = imynum
        def updateDeltaTime(self, dtime):
                self.deltatime = dtime
        def setChannelPeer(self, ipeerch):
                self.channel_peer = ipeerch
        def setChannelNum(self, ipeernum):
                self.channel_num = ipeernum

        def getChannelPeer(self):
                return self.channel_peer
        def getChannelNum(self):
                return self.channel_num
        def getChannelMyNum(self):
                return self.channel_mynum
        def getDirection(self):
                return self.direction
        def getTime(self):
                return self.time
        def getDeltaTime(self):
                return self.deltatime
        def getStatus(self):
                return self.status


## \class LineProp
# \brief Properties of a phone line. It might contain many channels.
class LineProp:
        ## \var tech
        # \brief Protocol of the phone (SIP, IAX2, ...)
        
        ## \var phoneid
        # \brief Phone identifier
        
        ## \var phonenum
        # \brief Phone number
        
        ## \var context
        # \brief Context
        
        ## \var lasttime
        # \brief Last time the phone has received a reply from a SUBSCRIBE
        
        ## \var chann
        # \brief List of Channels, with their properties as ChannelStatus
        
        ## \var hintstatus
        # \brief Status given through SIP presence detection
        
        ## \var imstat
        # \brief Instant Messaging status, as given by Xivo Clients
        
        ## \var voicemail
        # \brief Voicemail status
        
        ## \var queueavail
        # \brief Queue availability
        
        ## \var callerid
        # \brief Caller ID
        
        ## \var towatch
        # \brief Boolean value that tells whether this phone is watched by the switchboards
        
        ##  \brief Class initialization.
        def __init__(self, itech, iphoneid, iphonenum, icontext, ihintstatus, itowatch):
                self.tech = itech
                self.phoneid  = iphoneid
                self.phonenum = iphonenum
                self.context = icontext
                self.lasttime = 0
                self.chann = {}
                self.hintstatus = ihintstatus # Asterisk "hints" status
                self.imstat = "unknown"  # XMPP / Instant Messaging status
                self.voicemail = ""  # Voicemail status
                self.queueavail = "" # Availability as a queue member
                self.calleridfull = "nobody"
                self.calleridfirst = "nobody"
                self.calleridlast = "nobody"
                self.groups = ""
                self.towatch = itowatch
        def set_tech(self, itech):
                self.tech = itech
        def set_phoneid(self, iphoneid):
                self.phoneid = iphoneid
        def set_phonenum(self, iphonenum):
                self.phonenum = iphonenum
        def set_hintstatus(self, ihintstatus):
                self.hintstatus = ihintstatus
        def set_imstat(self, istatus):
                self.imstat = istatus
        def set_lasttime(self, ilasttime):
                self.lasttime = ilasttime

        def build_basestatus(self):
                basestatus = (self.tech.lower(),
                              self.phoneid,
                              self.phonenum,
                              self.context,
                              self.imstat,
                              self.hintstatus,
                              self.voicemail,
                              self.queueavail)
                return ":".join(basestatus)
        def build_cidstatus(self):
                cidstatus = (self.calleridfull,
                             self.calleridfirst,
                             self.calleridlast)
                return ":".join(cidstatus)
        ## \brief Builds the channel-by-channel part for the hints/update replies.
        # \param phoneid the "pointer" to the Asterisk phone statuses
        # \return the string containing the statuses for each channel of the given phone
        def build_fullstatlist(self):
                nchans = len(self.chann)
                fstat = [str(nchans)]
                for chan, phone_chan in self.chann.iteritems():
                        fstat.extend((":", chan, ":",
                                      phone_chan.getStatus(), ":",
                                      str(phone_chan.getDeltaTime()), ":",
                                      phone_chan.getDirection(), ":",
                                      phone_chan.getChannelPeer(), ":",
                                      phone_chan.getChannelNum()))
                return ''.join(fstat)

        def set_callerid(self, icallerid):
                self.calleridfull  = icallerid[0]
                self.calleridfirst = icallerid[1]
                self.calleridlast  = icallerid[2]
        def updateIfNeeded(self, icallerid):
                if icallerid[0:3] != (self.calleridfull, self.calleridfirst, self.calleridlast):
                        log_debug(SYSLOG_INFO, 'updated parameters for user <%s/%s> : %s => %s'
                                  % (self.tech, self.phoneid,
                                     (self.calleridfull, self.calleridfirst, self.calleridlast),
                                     icallerid[0:3]))
                        self.calleridfull  = icallerid[0]
                        self.calleridfirst = icallerid[1]
                        self.calleridlast  = icallerid[2]
        ##  \brief Updates the time elapsed on a channel according to current time.
        def update_time(self):
                nowtime = time.time()
                for ic in self.chann:
                        dtime = int(nowtime - self.chann[ic].getTime())
                        self.chann[ic].updateDeltaTime(dtime)
        ##  \brief Removes all channels.
        def clear_channels(self):
                self.chann = {}
        ##  \brief Adds a channel or changes its properties.
        # If the values of status, itime, peerch and/or peernum are empty,
        # they are not updated : the previous value is kept.
        # \param ichan the Channel to hangup.
        # \param status the status to set
        # \param itime the elapsed time to set
        def set_chan(self, ichan, status, itime, idir, peerch, peernum, mynum):
                #print "<%s> <%s> <%s> <%s> <%s> <%s> <%s>" %(ichan, status, itime, idir, peerch, peernum, mynum)
                do_update = True
                if mynum == "<unknown>" and is_normal_channel(ichan):
                        mynum = channel_splitter(ichan)
                        #               if peernum == "<unknown>" and is_normal_channel(peerch):
                        #                       peernum = channel_splitter(peerch)
                # does not update peerch and peernum if the new values are empty
                newstatus = status
                newdir = idir
                newpeerch = peerch
                newpeernum = peernum
                newmynum = mynum
                if ichan in self.chann:
                        thischannel = self.chann[ichan]
                        oldpeernum = thischannel.getChannelNum()

                        if status  == "": newstatus = thischannel.getStatus()
                        if idir    == "": newdir = thischannel.getDirection()
                        if peerch  == "": newpeerch = thischannel.getChannelPeer()
                        if oldpeernum != "": newpeernum = oldpeernum
                        if mynum   == "": newmynum = thischannel.getChannelMyNum()

                        # mynum != thischannel.getChannelMyNum()
                        # when dialing "*10", there are many successive newextens occuring, that reset
                        # the time counter to 0
                        if status == thischannel.getStatus() and \
                           idir == thischannel.getDirection() and \
                           peerch == thischannel.getChannelPeer() and \
                           peernum == thischannel.getChannelNum():
                                do_update = False

                if do_update:
                        firsttime = time.time()
                        self.chann[ichan] = ChannelStatus(newstatus, itime, newdir,
                                                          newpeerch, newpeernum, firsttime - itime,
                                                          newmynum)
                        for ic in self.chann:
                                self.chann[ic].updateDeltaTime(int(firsttime - self.chann[ic].getTime()))
                return do_update


        ##  \brief Hangs up a Channel.
        # \param ichan the Channel to hangup.
        def set_chan_hangup(self, ichan):
                nichan = ichan
                if ichan.find("<ZOMBIE>") >= 0:
                        log_debug(SYSLOG_INFO, "sch channel contains a <ZOMBIE> part (%s) : sending hup to %s anyway" %(ichan,nichan))
                        nichan = ichan.split("<ZOMBIE>")[0]
                firsttime = time.time()
                self.chann[nichan] = ChannelStatus("Hangup", 0, "", "", "", firsttime, "")
                for ic in self.chann:
                        self.chann[ic].updateDeltaTime(int(firsttime - self.chann[ic].getTime()))

        ##  \brief Removes a Channel.
        # \param ichan the Channel to remove.
        def del_chan(self, ichan):
                nichan = ichan
                if ichan.find("<ZOMBIE>") >= 0:
                        log_debug(SYSLOG_INFO, "dch channel contains a <ZOMBIE> part (%s) : deleting %s anyway" %(ichan,nichan))
                        nichan = ichan.split("<ZOMBIE>")[0]
                if nichan in self.chann: del self.chann[nichan]

## file xivo_lineprop : END

class Context:
        def __init__(self):
                self.uri = ''
                self.sqltable = ''
                self.sheetui = ''
                self.search_titles = []
                self.search_valid_fields = []
                self.search_matching_fields = []
                self.sheet_valid_fields = []
                self.sheet_matching_fields = []
                self.sheet_callidmatch = []
        def setUri(self, uri):
                self.uri = uri
        def setSqlTable(self, sqltable):
                self.sqltable = sqltable
        def setSheetUi(self, sheetui):
                self.sheetui = sheetui

        def setSearchValidFields(self, vf):
                self.search_valid_fields = vf
                for x in vf:
                        self.search_titles.append(x[0])
        def setSearchMatchingFields(self, mf):
                self.search_matching_fields = mf

        def setSheetValidFields(self, vf):
                self.sheet_valid_fields = vf
        def setSheetMatchingFields(self, mf):
                self.sheet_matching_fields = mf
        def setSheetCallidMatch(self, cidm):
                self.sheet_callidmatch = cidm

        def result_by_valid_field(self, result):
                reply_by_field = []
                for [dummydispname, dbnames_list, keepspaces] in self.search_valid_fields:
                        field_value = ""
                        for dbname in dbnames_list:
                                if dbname in result and field_value is "":
                                        field_value = result[dbname]
                        if keepspaces:
                                reply_by_field.append(field_value)
                        else:
                                reply_by_field.append(field_value.replace(' ', ''))
                return reply_by_field


## file xivo_astusers : BEGIN

## \class AsteriskConfig
# \brief Properties of an Asterisk server
class AsteriskUsers:
        def __init__(self, iastid):
                self.astid = iastid
                self.lock = threading.Condition()
                self.list = {}
                return

        def acquire(self):
                self.lock.acquire()
                return

        def release(self):
                self.lock.release()
                return

        def adduser(self, inparams):
                [tech, user, passwd, context, phonenum, agentnum, isinitialized, cti_allowed, options] = inparams
                if self.list.has_key(user):
                        # updates
                        self.list[user]['tech']     = tech
                        self.list[user]['passwd']   = passwd
                        self.list[user]['context']  = context
                        self.list[user]['phonenum'] = phonenum
                        self.list[user]['agentnum'] = agentnum
                        self.list[user]['init']     = isinitialized
                else:
                        self.list[user] = {'astid'    : self.astid,
                                           'tech'     : tech,
                                           'user'     : user,
                                           'passwd'   : passwd,
                                           'context'  : context,
                                           'phonenum' : phonenum,
                                           'agentnum' : agentnum,
                                           'cbstatus' : 'undefined',
                                           'calls'    : {},
                                           'queuelist': {},
                                           'init'     : isinitialized,
                                           'options'  : options,
                                           'capas'    : 0}
                        if cti_allowed == '1':
                                self.list[user]['capas'] = CAPA_ALMOST_ALL
                        else:
                                self.list[user]['capas'] = 0

        def deluser(self, user):
                if self.list.has_key(user):
                        self.list.pop(user)

        def finduser(self, user):
                return self.list.get(user)

#        def findagent(self, agentid):
#                return self.list.get(user)

        def setmonitor(self, user, monit):
                try:
                        self.lock.acquire()
                        if user in self.list:
                                self.list[user]['monit'] = monit
                finally:
                        self.lock.release()

        def todisconnect(self):
                todisc_list = []
                try:
                        self.lock.acquire()
                        for user,info in self.list.iteritems():
                                if 'sessiontimestamp' in info:
                                        if time.time() - info.get('sessiontimestamp') > xivoclient_session_timeout:
                                                self.disconnect_user(user)
                                                todisc_list.append(user)
                finally:
                        self.lock.release()
                return todisc_list

        def disconnect_user(self, user):
                # conngui_xc, conngui_sb
                try:
                        self.lock.acquire()
                        userinfo = self.list[user]
                        if 'sessionid' in userinfo:
                                del userinfo['sessionid']
                                del userinfo['sessiontimestamp']
                                del userinfo['logintimestamp']
                                del userinfo['ip']
                                del userinfo['port']
                                del userinfo['cticlienttype']
                                del userinfo['cticlientos']
                                del userinfo['tcpmode']
                                del userinfo['socket']
                                if 'connection' in userinfo:
                                        del userinfo['connection']
                                if 'monit' in userinfo:
                                        del userinfo['monit']
                finally:
                        self.lock.release()

        def sendmessage(self, strupdate):
                return
                if strupdate is not None:
                        try:
                                self.lock.acquire()
                                for user,info in self.list.iteritems():
                                        send_msg_to_cti_client(info, strupdate)
                        finally:
                                self.lock.release()

        def update_services(self):
                try:
                        self.lock.acquire()
                        for user,info in self.list.iteritems():
                                if 'monit' in info:
                                        monit = info['monit']                                
                                        updatemsg = build_features_get([monit[0], monit[1], monit[2]])
                                        send_msg_to_cti_client(info, updatemsg)
                finally:
                        self.lock.release()

        def listusers(self):
                lst = {}
                try:
                        self.lock.acquire()
                        for user,info in self.list.iteritems():
                                lst[user] = info
                finally:
                        self.lock.release()
                return lst

        def listconnected(self):
                lst = {}
                try:
                        self.lock.acquire()
                        for user,info in self.list.iteritems():
                                if 'logintimestamp' in info:
                                        lst[user] = info
                finally:
                        self.lock.release()
                return lst

## file xivo_astusers : END


def check_user_connection(userinfo, whoami):
        if userinfo.has_key('init'):
                if not userinfo['init']:
                        return 'uninit_phone'
        if userinfo.has_key('sessiontimestamp'):
                if time.time() - userinfo.get('sessiontimestamp') < xivoclient_session_timeout:
                        if 'lastconnwins' in userinfo:
                                if userinfo['lastconnwins'] is True:
                                        # one should then disconnect the first peer
                                        pass
                                else:
                                        return 'already_connected'
                        else:
                                return 'already_connected'
        if whoami == 'XC':
                if conngui_xc >= maxgui_xc:
                        return 'xcusers:%d' % maxgui_xc
        else:
                if conngui_sb >= maxgui_sb:
                        return 'sbusers:%d' % maxgui_sb
        return None


def connect_user(userinfo, sessionid, iip, iport,
                 whoami, whatsmyos, tcpmode, state,
                 lastconnwins, socket):
        global conngui_xc, conngui_sb
        try:
                userinfo['sessionid'] = sessionid
                userinfo['sessiontimestamp'] = time.time()
                userinfo['logintimestamp'] = time.time()
                userinfo['ip'] = iip
                userinfo['port'] = iport
                userinfo['cticlienttype'] = whoami
                userinfo['cticlientos'] = whatsmyos
                userinfo['tcpmode'] = tcpmode
                userinfo['socket'] = socket
                # lastconnwins was introduced in the aim of forcing a new connection to take on for
                # a given user, however it might breed problems if the previously logged-in process
                # tries to reconnect ... unless we send something asking to Kill the process
                userinfo['lastconnwins'] = False # lastconnwins

                # we first check if 'state' has already been set for this customer, in which case
                # the CTI clients will be sent back this previous state
                if 'state' in userinfo:
                        futurestate = userinfo.get('state')
                        # only if it was a "defined" state anyway
                        if futurestate in allowed_states:
                                state = futurestate

                if state in allowed_states:
                        userinfo['state'] = state
                else:
                        log_debug(SYSLOG_WARNING, '(user %s) : state <%s> is not an allowed one => undefinedstate-connect'
                                  % (userinfo.get('user'), state))
                        userinfo['state'] = 'undefinedstate-connect'
                if whoami == 'XC':
                        conngui_xc = conngui_xc + 1
                elif whoami == 'SB':
                        conngui_sb = conngui_sb + 1
        except Exception, exc:
                log_debug(SYSLOG_ERR, "--- exception --- connect_user %s : %s" %(str(userinfo), str(exc)))


## \class IdentRequestHandler
# \brief Gives client identification to the profile pusher.
# The connection is kept alive so several requests can be made on the same open TCP connection.
class IdentRequestHandler(SocketServer.StreamRequestHandler):
        def handle(self):
                threading.currentThread().setName('ident-%s:%d' %(self.client_address[0], self.client_address[1]))
                line = self.rfile.readline().strip()
##                log_debug(SYSLOG_INFO, "IdentRequestHandler (TCP) : client = %s:%d / <%s>"
##                          %(self.client_address[0],
##                            self.client_address[1],
##                            line))
                retline = 'ERROR'
                action = ''
                # PUSH user callerid msg
                re_push = re.match('PUSH (\S+) (\S+) <(\S*)> ?(.*)', line)
                if re_push != None:
                        called = re_push.group(1)
                        callerid = re_push.group(2)
                        callerctx = re_push.group(3)
                        msg = re_push.group(4)
                        action = 'PUSH'
                else:
                        log_debug(SYSLOG_ERR, 'PUSH command <%s> invalid' % line)
                        return

                if callerctx in contexts_cl:
                        ctxinfo = contexts_cl.get(callerctx)
                else:
                        log_debug(SYSLOG_WARNING, 'WARNING - no section has been defined for the context <%s>' % callerctx)
                        ctxinfo = contexts_cl.get('')

                astid = ip_reverse_sht[self.client_address[0]]
		ulist[astid].acquire()
		try:
			try:
				userinfo = ulist[astid].finduser(called)
                                state_userinfo = 'unknown'
                                
				if userinfo == None:
					log_debug(SYSLOG_INFO, '%s : User <%s> not found (Call)' % (astid, called))
				elif userinfo.has_key('ip') and userinfo.has_key('port') \
					 and userinfo.has_key('state') and userinfo.has_key('sessionid') \
					 and userinfo.has_key('sessiontimestamp'):
					if time.time() - userinfo.get('sessiontimestamp') > xivoclient_session_timeout:
                                                log_debug(SYSLOG_INFO, '%s : User <%s> session expired (Call)' % (astid, called))
                                                userinfo = None
					else:
						capalist = (userinfo.get('capas') & configs[astid].capas_i)
						if (capalist & CAPA_CUSTINFO):
                                                        state_userinfo = userinfo.get('state')
                                                else:
                                                        userinfo = None
				else:
					log_debug(SYSLOG_WARNING, '%s : User <%s> session not defined (Call)' % (astid, called))
                                        userinfo = None

                                sipcid = "SIP/%s" % callerid
                                localdirinfo = None
                                if sipcid in plist[astid].normal:
                                        localdirinfo = [plist[astid].normal[sipcid].calleridfull,
                                                        plist[astid].normal[sipcid].calleridfirst,
                                                        plist[astid].normal[sipcid].calleridlast]
                                calleridname = sendfiche.sendficheasync(userinfo,
                                                                        ctxinfo,
                                                                        callerid,
                                                                        msg,
                                                                        xivoconf,
                                                                        localdirinfo)
                                retline = 'USER %s STATE %s CIDNAME %s' %(called, state_userinfo, calleridname)
			except Exception, exc:
                                log_debug(SYSLOG_ERR, "--- exception --- error push : %s" %(str(exc)))
				retline = 'ERROR PUSH %s' %(str(exc))
		finally:
			ulist[astid].release()

                try:
                        log_debug(SYSLOG_INFO, "PUSH : replying <%s>" % retline)
                        self.wfile.write(retline + '\r\n')
                except Exception, exc:
                        # something bad happened.
                        log_debug(SYSLOG_ERR, '--- exception --- IdentRequestHandler/Exception : %s'
                                  % str(exc))
                        return


def getboolean(fname, string):
        if string not in fname:
                return True
        else:
                value = fname.get(string)
                if value in ['false', '0', 'False']:
                        return False
                else:
                        return True


## \class MyTCPServer
# \brief TCPServer with the reuse address on.
class MyTCPServer(SocketServer.ThreadingTCPServer):
        allow_reuse_address = True


## \brief Handler for catching signals (in the main thread)
# \param signum signal number
# \param frame frame
# \return none
def sighandler(signum, frame):
        global askedtoquit
        print "--- signal", signum, "received : quits"
        for t in filter(lambda x: x.getName()<>"MainThread", threading.enumerate()):
                print "--- living thread <%s>" %(t.getName())
                t._Thread__stop()
        askedtoquit = True


## \brief Handler for catching signals (in the main thread)
# \param signum signal number
# \param frame frame
# \return none
def sighandler_reload(signum, frame):
        global askedtoquit
        print "--- signal", signum, "received : reloads"
        askedtoquit = False

# ==============================================================================
# ==============================================================================

def log_stderr_and_syslog(x):
        print >> sys.stderr, x
        syslogf(SYSLOG_ERR, x)

# ==============================================================================
# Main Code starts here
# ==============================================================================

# daemonize if not in debug mode
if not debug_mode:
        daemonize.daemonize(log_stderr_and_syslog, PIDFILE, True)
else:
        daemonize.create_pidfile_or_die(log_stderr_and_syslog, PIDFILE, True)

signal.signal(signal.SIGINT, sighandler)
signal.signal(signal.SIGTERM, sighandler)
signal.signal(signal.SIGHUP, sighandler_reload)

nreload = 0

while True: # loops over the reloads
        askedtoquit = False

        time_start = time.time()
        if nreload == 0:
                log_debug(SYSLOG_NOTICE, '# STARTING XIVO Daemon %s / svn %s # (0/3) Starting'
                          %(XIVOVERSION, __revision__))
        else:
                log_debug(SYSLOG_NOTICE, '# STARTING XIVO Daemon %s / svn %s # (0/3) Reloading (%d)'
                          %(XIVOVERSION, __revision__, nreload))
        nreload += 1
        
        # global default definitions
        commandset = 'xivosimple'
        port_request = 5002
        port_ui_srv = 4949
        port_webi = 5004
        port_operat = 4950
        port_comm_agi_daemon = 4970
        port_sv = 4946
        xivo_db = 'mysql://asterisk:proformatique@127.0.0.1:3306/asterisk?charset=utf8'
        xivoclient_session_timeout = 60
        phonelist_update_period = 60
        asterisklist = []
        contextlist = []
        maxgui_sb = 3
        maxgui_xc = 10
        conngui_xc = 0
        conngui_sb = 0
        evt_filename = "/var/log/pf-xivo-cti-server/ami_events.log"
        gui_filename = "/var/log/pf-xivo-cti-server/gui.log"
        with_advert = False
        address_operat = ''

        userinfo_by_requester = {}

        xivoconf = ConfigParser.ConfigParser()
        xivoconf.readfp(open(xivoconffile))
        xivoconf_general = dict(xivoconf.items('general'))

        # loads the general configuration
        if 'commandset' in xivoconf_general:
                commandset = xivoconf_general['commandset']
        if 'port_fiche_keepalive' in xivoconf_general:
                port_keepalive = int(xivoconf_general['port_fiche_keepalive'])
        if 'port_fiche_agi' in xivoconf_general:
                port_request = int(xivoconf_general['port_fiche_agi'])
        if 'port_switchboard' in xivoconf_general:
                port_ui_srv = int(xivoconf_general['port_switchboard'])
        if 'port_webi' in xivoconf_general:
                port_webi = int(xivoconf_general['port_webi'])
        if 'port_sv' in xivoconf_general:
                port_sv = int(xivoconf_general['port_sv'])
        if 'port_operat' in xivoconf_general:
                port_operat = int(xivoconf_general['port_operat'])
        if 'port_comm_agi_daemon' in xivoconf_general:
                port_comm_agi_daemon = int(xivoconf_general['port_comm_agi_daemon'])
        if 'address_operat' in xivoconf_general:
                address_operat = xivoconf_general['address_operat']
        if 'operatini' in xivoconf_general:
                operatini = xivoconf_general['operatini']
        if 'xivo_db' in xivoconf_general:
                xivo_db = xivoconf_general['xivo_db']
        if 'xivoclient_session_timeout' in xivoconf_general:
                xivoclient_session_timeout = int(xivoconf_general['xivoclient_session_timeout'])
        if 'phonelist_update_period' in xivoconf_general:
                phonelist_update_period = int(xivoconf_general['phonelist_update_period'])
        if 'asterisklist' in xivoconf_general:
                asterisklist = xivoconf_general['asterisklist'].split(',')
        if 'maxgui_sb' in xivoconf_general:
                maxgui_sb = int(xivoconf_general['maxgui_sb'])
        if 'maxgui_xc' in xivoconf_general:
                maxgui_xc = int(xivoconf_general['maxgui_xc'])
        if 'evtfile' in xivoconf_general:
                evt_filename = xivoconf_general['evtfile']
        if 'guifile' in xivoconf_general:
                gui_filename = xivoconf_general['guifile']

        if 'advert' in xivoconf_general: with_advert = True


        OperatSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
                OperatSock.connect((address_operat, port_operat))
        except Exception, exc:
                log_debug(SYSLOG_WARNING, 'WARNING - Could not connect to Operat Serveur (%s, %d) : %s'
                          % (address_operat, port_operat, str(exc)))
                OperatSock = None


        queued_threads_pipe = os.pipe()
        AMI_array_user_commands = {}
        cclass = xivo_commandsets.CommandClasses[commandset]
        commandclass = cclass(ulist, AMI_array_user_commands, OperatSock, port_sv, operatini, queued_threads_pipe)

        save_for_next_packet_events = {}
        faxbuffer = {}
        ip_reverse_webi = {}
        ip_reverse_sht = {}

        # loads the configuration for each asterisk
        for astid in xivoconf.sections():
                if astid != 'general' and astid in asterisklist:
                        xivoconf_local = dict(xivoconf.items(astid))

                        localaddr = '127.0.0.1'
                        userlist_url = 'sso.php'
                        ipaddress = '127.0.0.1'
                        ipaddress_webi = '127.0.0.1'
                        extrachannels = ''
                        ami_port = 5038
                        ami_login = 'xivouser'
                        ami_pass = 'xivouser'
                        contexts = ''
                        userfeatures_db_uri = ''
                        cdr_db_uri = ''
                        realm = 'asterisk'
                        parkingnumber = '700'
                        faxcallerid = 'faxcallerid'
                        linkestablished = ''
                        capas_s = []
                        capas_i = 0

                        if 'localaddr' in xivoconf_local:
                                localaddr = xivoconf_local['localaddr']
                        if 'userlisturl' in xivoconf_local:
                                userlist_url = xivoconf_local['userlisturl']
                        if 'ipaddress' in xivoconf_local:
                                ipaddress = xivoconf_local['ipaddress']
                        if 'ipaddress_webi' in xivoconf_local:
                                ipaddress_webi = xivoconf_local['ipaddress_webi']
                        if 'extrachannels' in xivoconf_local:
                                extrachannels = xivoconf_local['extrachannels']
                        if 'parkingnumber' in xivoconf_local:
                                parkingnumber = int(xivoconf_local['parkingnumber'])
                        if 'faxcallerid' in xivoconf_local:
                                faxcallerid = int(xivoconf_local['faxcallerid'])
                        if 'linkestablished' in xivoconf_local:
                                linkestablished = xivoconf_local['linkestablished']
                        if 'ami_port' in xivoconf_local:
                                ami_port = int(xivoconf_local['ami_port'])
                        if 'ami_login' in xivoconf_local:
                                ami_login = xivoconf_local['ami_login']
                        if 'ami_pass' in xivoconf_local:
                                ami_pass = xivoconf_local['ami_pass']
                        if 'contexts' in xivoconf_local:
                                contexts = xivoconf_local['contexts']
                                if contexts != '':
                                        for c in contexts.split(','):
                                                contextlist.append(c)
                        if 'capabilities' in xivoconf_general and xivoconf_general['capabilities']:
                                capas_s = xivoconf_general['capabilities'].split(',')
                        if 'capabilities' in xivoconf_local and xivoconf_local['capabilities']:
                                capas_s = xivoconf_local['capabilities'].split(',')
                        for capa in capas_s:
                                if capa in map_capas: capas_i |= map_capas[capa]
                        if 'userfeatures_db_uri' in xivoconf_local:
                                userfeatures_db_uri = xivoconf_local['userfeatures_db_uri']
                        if 'cdr_db_uri' in xivoconf_local:
                                cdr_db_uri = xivoconf_local['cdr_db_uri']
                        if 'realm' in xivoconf_local:
                                realm = xivoconf_local['realm']
                        for capauser, capadefs in xivoconf_local.iteritems():
                                if capauser.find('capas_') == 0:
                                        cuser = capauser[6:].split('/')
                                        cdefs = capadefs.split(',')

                        capafeatures = []
                        unallowed = []
                        if userfeatures_db_uri is not '':
                                conn = anysql.connect_by_uri(userfeatures_db_uri)
                                cursor = conn.cursor()
                                params = ['features']
                                columns = ('commented', 'context', 'name')
                                query = 'SELECT ${columns} FROM extensions WHERE context = %s'
                                cursor.query(query,
                                             columns,
                                             params)
                                results = cursor.fetchall()
                                conn.close()
                                for res in results:
                                        if res[0] == 0:
                                                capafeatures.append(res[2])
                                        else:
                                                unallowed.append(res[2])
                        #print "%s : allowed     : %s" %(i, str(capafeatures))
                        #print "%s : not allowed : %s" %(i, str(unallowed))

                        configs[astid] = xivo_astcfg.AsteriskConfig(astid,
                                                                    userlist_url,
                                                                    extrachannels,
                                                                    localaddr,
                                                                    ipaddress,
                                                                    ipaddress_webi,
                                                                    ami_port,
                                                                    ami_login,
                                                                    ami_pass,
                                                                    userfeatures_db_uri,
                                                                    capas_s,
                                                                    capas_i,
                                                                    capafeatures,
                                                                    cdr_db_uri,
                                                                    realm,
                                                                    parkingnumber,
                                                                    faxcallerid,
                                                                    linkestablished)
                        ulist[astid] = AsteriskUsers(astid)
                        commandclass.set_cdr_uri(cdr_db_uri, xivo_db)

                        if ipaddress not in ip_reverse_sht:
                                ip_reverse_sht[ipaddress] = astid
                        else:
                                log_debug(SYSLOG_WARNING, 'WARNING - IP address already exists for asterisk <%s> - can not set it for <%s>'
                                          % (ip_reverse_sht[ipaddress], astid))
                        if ipaddress_webi not in ip_reverse_webi:
                                ip_reverse_webi[ipaddress_webi] = astid
                        else:
                                log_debug(SYSLOG_WARNING, 'WARNING - IP address (WEBI) already exists for asterisk <%s> - can not set it for <%s>'
                                          % (ip_reverse_webi[ipaddress_webi], astid))
                        save_for_next_packet_events[astid] = ''
                        faxbuffer[astid] = []

        contexts_cl[''] = Context()
        # loads the configuration for each context
        for i in xivoconf.sections():
                if i != 'general' and i in contextlist:
                        xivoconf_local = dict(xivoconf.items(i))
                        dir_db_uri = ''
                        dir_db_sqltable = ''
                        dir_db_sheetui = ''

                        if 'dir_db_uri' in xivoconf_local:
                                dir_db_uri = xivoconf_local['dir_db_uri']
                        if 'dir_db_sqltable' in xivoconf_local:
                                dir_db_sqltable = xivoconf_local['dir_db_sqltable']
                        if 'dir_db_sheetui' in xivoconf_local:
                                dir_db_sheetui = xivoconf_local['dir_db_sheetui']

                        z = Context()
                        z.setUri(dir_db_uri)
                        z.setSqlTable(dir_db_sqltable)
                        z.setSheetUi(dir_db_sheetui)

                        fnames = {}
                        snames = {}
                        for field in xivoconf_local:
                                if field.find('dir_db_search') == 0:
                                        ffs = field.split('.')
                                        if len(ffs) == 3:
                                                if ffs[1] not in fnames:
                                                        fnames[ffs[1]] = {}
                                                fnames[ffs[1]][ffs[2]] = xivoconf_local[field]
                                elif field.find('dir_db_sheet') == 0:
                                        ffs = field.split('.')
                                        if len(ffs) == 3:
                                                if ffs[1] not in snames:
                                                        snames[ffs[1]] = {}
                                                snames[ffs[1]][ffs[2]] = xivoconf_local[field]
                                        elif len(ffs) == 2 and ffs[1] == 'callidmatch':
                                                z.setSheetCallidMatch(xivoconf_local[field].split(','))

                        search_vfields = []
                        search_mfields = []
                        for fname in fnames.itervalues():
                                if 'display' in fname and 'match' in fname:
                                        dbnames = fname['match']
                                        if dbnames != '':
                                                dbnames_list = dbnames.split(',')
                                                for dbn in dbnames_list:
                                                        if dbn not in search_mfields:
                                                                search_mfields.append(dbn)
                                                keepspaces = getboolean(fname, 'space')
                                                search_vfields.append([fname['display'], dbnames_list, keepspaces])
                        z.setSearchValidFields(search_vfields)
                        z.setSearchMatchingFields(search_mfields)
                        
                        sheet_vfields = []
                        sheet_mfields = []
                        for fname in snames.itervalues():
                                if 'field' in fname and 'match' in fname:
                                        dbnames = fname['match']
                                        if dbnames != '':
                                                dbnames_list = dbnames.split(',')
                                                for dbn in dbnames_list:
                                                        if dbn not in sheet_mfields:
                                                                sheet_mfields.append(dbn)
                                                sheet_vfields.append([fname['field'], dbnames_list, False])

                        z.setSheetValidFields(sheet_vfields)
                        z.setSheetMatchingFields(sheet_mfields)
                        
                        contexts_cl[i] = z

        # TODO: maybe we should listen on only one interface (localhost ?)
        requestserver = MyTCPServer(('', port_request), IdentRequestHandler)
        fdlist_full = [requestserver.socket]

        if debug_mode:
                # opens the evtfile for output in append mode
                try:
                        evtfile = open(evt_filename, 'a')
                except Exception, exc:
                        print "Could not open %s in append mode : %s" %(evt_filename,exc)
                        evtfile = False
                # opens the guifile for output in append mode
                try:
                        guifile = open(gui_filename, 'a')
                except Exception, exc:
                        print "Could not open %s in append mode : %s" %(gui_filename,exc)
                        guifile = False
        
        AMI_array_events_fd = {}
        update_userlist = {}
        lastrequest_time = {}

        log_debug(SYSLOG_INFO, "the monitored asterisk's is/are : %s" % str(asterisklist))
        log_debug(SYSLOG_INFO, "# STARTING XIVO Daemon # (1/2) AMI socket connections + fetch Web Services")

        tcpopens_sb = []
        tcpopens_webi = []
        tcpopens_fc = []

        for astid in configs:
                try:
                        plist[astid] = PhoneList(astid, commandclass)
                        update_userlist[astid] = False
                        lastrequest_time[astid] = time.time()

                        update_amisocks(astid)
                        # users_to_kick = ulist[astid].todisconnect()
                        update_phonelist(astid)
                except Exception, exc:
                        log_debug(SYSLOG_ERR, '--- exception --- %s : failed while setting lists and sockets : %s'
                                  %(astid, str(exc)))

        xdal = None
        # xivo daemon advertising
        if with_advert:
                xda = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                xda.bind(("", 5010))
                xda.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                # xda.sendto('xivo_daemon:%d:%s' %(len(configs), configs.join(':')), ("255.255.255.255", 5011))

                xdal = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                xdal.bind(("", 5011))
                fdlist_full.append(xdal)

        log_debug(SYSLOG_INFO, "# STARTING XIVO Daemon # (2/2) listening UI sockets")
        # opens the listening socket for UI connections
        UIsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        UIsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        UIsock.bind(("", port_ui_srv))
        UIsock.listen(10)
        fdlist_full.append(UIsock)
        
        UIsock2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        UIsock2.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        UIsock2.bind(("", port_sv))
        UIsock2.listen(10)
        fdlist_full.append(UIsock2)

        # opens the listening socket for WEBI/CLI connections
        WEBIsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        WEBIsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        WEBIsock.bind(("", port_webi))
        WEBIsock.listen(10)
        fdlist_full.append(WEBIsock)

        # opens the listening socket for WEBI/CLI connections
        Fsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        Fsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        Fsock.bind(("", port_comm_agi_daemon))
        Fsock.listen(10)
        fdlist_full.append(Fsock)

        if OperatSock is not None:
                fdlist_full.append(OperatSock)
        fdlist_full.append(queued_threads_pipe[0])

        # Receive messages
        while not askedtoquit:
                try:
                        [i, o, e] = select.select(fdlist_full, [], [], phonelist_update_period)
                except Exception, exc:
                        if askedtoquit:
                                try:
                                        send_msg_to_cti_clients("ERROR server_stopped")
                                        print
                                        print 'current open TCP connections : (SB)  ', tcpopens_sb
                                        print 'current open TCP connections : (WEBI)', tcpopens_webi
                                        print 'current open TCP connections : (FC)  ', tcpopens_fc
                                        print 'current open TCP connections : (AMI) ', AMI_array_events_fd
                                        print 'current open TCP connections : (OP)  ', OperatSock
                                        print
                                        os.unlink(PIDFILE)
                                except Exception, exc:
                                        print exc
                                if debug_mode:
                                        # Close files and sockets
                                        evtfile.close()
                                        guifile.close()
                                for t in filter(lambda x: x.getName()<>"MainThread", threading.enumerate()):
                                        print "--- (stop) killing thread <%s>" %(t.getName())
                                        t._Thread__stop()
                                sys.exit(5)
                        else:
                                print '--- exception --- after select :', exc
                                send_msg_to_cti_clients("ERROR server_reloaded")
                                askedtoquit = True
                                for s in fdlist_full:
                                        s.close()
                                for t in filter(lambda x: x.getName()<>"MainThread", threading.enumerate()):
                                        print "--- (reload) the thread <%s> remains" %(t.getName())
                                        # t._Thread__stop() # does not work in reload case (vs. stop case)
                                continue
                if i:
                        if requestserver.socket in i:
                                requestserver.handle_request()
                        # these AMI connections are used in order to manage AMI commands with incoming events
                        elif filter(lambda j: j in AMI_array_events_fd.itervalues(), i):
                                res = filter(lambda j: j in AMI_array_events_fd.itervalues(), i)[0]
                                for astid, val in AMI_array_events_fd.iteritems():
                                        if val is res: break
                                try:
                                        a = AMI_array_events_fd[astid].readline() # (BUFSIZE_ANY)
                                        if len(a) == 0: # end of connection from server side : closing socket
                                                log_debug(SYSLOG_WARNING, "%s : AMI : CLOSING" % astid)
                                                strmessage = commandclass.dmessage_srv2clt('AMI OFF for <%s>' % astid)
                                                send_msg_to_cti_clients(strmessage)
                                                AMI_array_events_fd[astid].close()
                                                fdlist_full.remove(AMI_array_events_fd[astid])
                                                del AMI_array_events_fd[astid]
                                        else:
                                                handle_ami_event(astid, a)
                                except Exception, exc:
                                        log_debug(SYSLOG_ERR, "--- exception --- AMI <%s> : %s" % (astid, str(exc)))
                        # the new UI (SB) connections are catched here
                        elif UIsock in i:
                                [conn, UIsockparams] = UIsock.accept()
                                log_debug(SYSLOG_INFO, "TCP (SB)  socket opened on   %s:%d" % (UIsockparams[0], UIsockparams[1]))
                                commandclass.connected_srv2clt(conn, '%s:%d' % (UIsockparams[0], UIsockparams[1]))
                                # appending the opened socket to the ones watched
                                conn.setblocking(0)
                                fdlist_full.append(conn)
                                tcpopens_sb.append(conn)
                        elif UIsock2 in i:
                                [conn, UIsock2params] = UIsock2.accept()
                                log_debug(SYSLOG_INFO, "TCP (SB)  socket opened on   %s:%d" % (UIsock2params[0], UIsock2params[1]))
                                commandclass.connected_srv2clt(conn, '%s:%d' % (UIsock2params[0], UIsock2params[1]))
                                # appending the opened socket to the ones watched
                                conn.setblocking(0)
                                fdlist_full.append(conn)
                                tcpopens_sb.append(conn)
                        # the new UI (WEBI) connections are catched here
                        elif WEBIsock in i:
                                [conn, WEBIsockparams] = WEBIsock.accept()
                                log_debug(SYSLOG_INFO, "TCP (WEBI) socket opened on   %s:%d" % (WEBIsockparams[0], WEBIsockparams[1]))
                                # appending the opened socket to the ones watched
                                conn.setblocking(0)
                                fdlist_full.append(conn)
                                tcpopens_webi.append(conn)

                        elif Fsock in i:
                                [conn, Fsockparams] = Fsock.accept()
                                log_debug(SYSLOG_INFO, "TCP (F) socket opened on   %s:%d on %s" % (Fsockparams[0], Fsockparams[1], time.time()))
                                # appending the opened socket to the ones watched
                                fdlist_full.append(conn)
                                conn.setblocking(0)
                                tcpopens_fc.append(conn)

                        # open UI (SB) connections
                        elif filter(lambda j: j in i, tcpopens_sb):
                                conn = filter(lambda j: j in i, tcpopens_sb)[0]
                                try:
                                        manage_webi_cti_connections_tcp(conn, True)
                                except Exception, exc:
                                        log_debug(SYSLOG_ERR, '--- exception --- XC/SB tcp connection : %s' % str(exc))
                        # open UI (WEBI) connections
                        elif filter(lambda j: j in i, tcpopens_webi):
                                conn = filter(lambda j: j in i, tcpopens_webi)[0]
                                try:
                                        manage_webi_cti_connections_tcp(conn, False)
                                except Exception, exc:
                                        log_debug(SYSLOG_ERR, '--- exception --- WEBI tcp connection : %s' % str(exc))
                        # AGI connections
                        elif filter(lambda j: j in i, tcpopens_fc):
                                conn = filter(lambda j: j in i, tcpopens_fc)[0]
                                try:
                                        manage_agi_connections_tcp(conn)
                                except Exception, exc:
                                        log_debug(SYSLOG_ERR, '--- exception --- F tcp connection : %s' % str(exc))

                        elif OperatSock in i:
                                try:
                                        msg = OperatSock.recv(BUFSIZE_LARGE)
                                except Exception, exc:
                                        log_debug(SYSLOG_ERR, '--- exception --- OperatSock : %s' % str(exc))
                                        msg = ''
                                if len(msg) == 0:
                                        OperatSock.close()
                                        fdlist_full.remove(OperatSock)
                                        log_debug(SYSLOG_WARNING, 'WARNING - Operat Serveur has closed the connection')
                                else:
                                        commandclass.svreply(asterisklist[0], msg)

                        elif queued_threads_pipe[0] in i:
                                disconnlist = commandclass.checkqueue()
                                try:
                                        for userinfo in disconnlist:
                                                print 'checkqueue return :', userinfo
                                                if 'connection' in userinfo:
                                                        userinfo['connection'].close()
                                                        fdlist_full.remove(userinfo['connection'])
                                                else:
                                                        log_debug(SYSLOG_WARNING, 'WARNING - no connection field present in userinfo')
                                                ulist[userinfo['astid']].disconnect_user(userinfo['user'])
                                except Exception, exc:
                                        log_debug(SYSLOG_ERR, '--- exception --- %s' % str(exc))
                        # advertising from other xivo_daemon's around
                        elif xdal in i:
                                [data, addrsip] = xdal.recvfrom(BUFSIZE_UDP)
                                log_debug(SYSLOG_INFO, 'a xivo_fb is around : <%s>' % str(addrsip))
                        else:
                                log_debug(SYSLOG_INFO, "unknown socket <%s>" % str(i))

                        for astid in configs:
                                if (time.time() - lastrequest_time[astid]) > phonelist_update_period or update_userlist[astid]:
                                        lastrequest_time[astid] = time.time()
                                        log_debug(SYSLOG_INFO, '%s : update_phonelist (computed timeout) %s'
                                                  % (astid, time.strftime("%H:%M:%S", time.localtime())))
                                        try:
                                                update_amisocks(astid)
                                                # users_to_kick = ulist[astid].todisconnect()
                                                # update_phonelist(astid)
                                                ulist[astid].update_services()
                                                update_userlist[astid] = False
                                        except Exception, exc:
                                                log_debug(SYSLOG_ERR, '--- exception --- %s : failed while updating lists and sockets (computed timeout) : %s'
                                                          %(astid, str(exc)))

                else: # when nothing happens on the sockets, we fall here sooner or later
##                        log_debug(SYSLOG_INFO, 'update_phonelist (select s timeout) %s'
##                                  % time.strftime("%H:%M:%S", time.localtime()))
                        for astid in configs:
                                lastrequest_time[astid] = time.time()
                                try:
                                        update_amisocks(astid)
                                        # users_to_kick = ulist[astid].todisconnect()
                                        # update_phonelist(astid)
                                except Exception, exc:
                                        log_debug(SYSLOG_ERR, '--- exception --- %s : failed while updating lists and sockets (select s timeout) : %s'
                                                  %(astid, str(exc)))

        log_debug(SYSLOG_NOTICE, 'after askedtoquit loop')
