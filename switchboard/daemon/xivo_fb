#!/usr/bin/python

# This is an extension to XIVO Daemon, authorized by Pro-formatique SARL
# for sub-licensing under a separated contract.
#
# Licensing of this code is NOT bounded by the terms of the
# GNU General Public License.
#
# See the LICENSE file at top of the source tree or delivered in the
# installable package in which XIVO Daemon is distributed for more details.

# $Revision$
# $Date$

## \mainpage
# \section section_1 General description of XIVO Daemon
# The XIVO Daemon aims to monitor all the actions taking place into one or
# more Asterisk servers, in order to provide 2 basic customer facilities :
# - a monitoring switchboard;
# - a customer information popup.
#
# This is achieved thanks to 2 mechanisms :
# - one or more connections to the Asterisk Manager Interface (AMI), where
# all the events can be watched;
# - Asterisk AGI's that send informations when a call is issued.
#
# This daemon is able to manage any number of Asterisk's one might wish.
#
# \section section_2 Initializations
#
# - Fetch the phone number lists from the WEB Interface.
#
# \section section_3 Main loop
# The main loop is triggered by a select() on the file descriptors for :
# - the AMI Event sockets (AMIsocks);
# - the UI sockets (UIsock, WEBIsock);
# - the Caller Information Popup sockets (authentication, keepalive and identrequest).
#
# On reception of AMI Events, handle_ami_event() parses the messages to update
# the detailed status of the channels.
#
# For each UI connection, a list of the open UI connections is updated
# (tcpopens_sb or tcpopens_webi according to the kind of connection).
# This list is the one used to broadcast the miscellaneous updates
# (it is up to the UI clients to fetch the initial status with the "hints"
# command).
#
# \section section_6 Monitoring with AMI
#
# The AMI events are the basis for a channel-by-channel status of the phones.
#
# Many AMI events are watched for, but not all of them are handled yet.
# The most useful ones are now : Dial, Link, Hangup, Rename.
# The following ones : Newexten, Newchannel, Newcallerid, Newstate are useful when dealing
# complex situations (when there are Local/ channels and Queues for instance).
#
# \section section_8 Caller Information Popup management
#
# The daemon has 3 other listening sockets :
# - Login - TCP - (the clients connect to it to login)
# - KeepAlive - UDP - (the clients send datagram to it to inform
#                      of their current state)
# - IdentRequest - TCP - offer a service to ask for localization and
#                        state of the clients.
# we use the SocketServer "framework" to implement the "services"
# see http://docs.python.org/lib/module-SocketServer.html
#
# \section section_9 Data Structures
#
# The statuses of all the lines/channels are stored in the multidimensional array/dict "plist",
# which is an array of PhoneList.
#
# plist[astn].normal[phonenum].chann[channel] are objects of the class ChannelStatus.
# - astn is the Asterisk id
# - phonenum is the phone id (SIP/<xx>, IAX2/<yy>, ...)
# - channel is the full channel name as known by Asterisk
#
## \file xivo_daemon.py
# \brief XIVO CTI server
#
## \namespace xivo_daemon
# \brief XIVO CTI server
#

__version__ = "$Revision$ $Date$"
__revision__ = __version__.split()[1]

# debian.org modules
import csv
import string
import ConfigParser
import commands
import getopt
import md5
import os
import pickle
import random
import re
import select
import signal
import socket
import SocketServer
import sys
import syslog
import threading
import time
import urllib
import _sre

# XIVO lib-python modules initialization
import xivo.to_path
xivoconffile            = "/etc/asterisk/xivo_fb.conf"
GETOPT_SHORTOPTS        = 'dc:'
GETOPT_LONGOPTS         = ["debug", "config="]
debug_mode = False
def config_path():
        global xivoconffile, debug_mode
        for opt, arg in getopt.getopt(
                sys.argv[1:],
                GETOPT_SHORTOPTS,
                GETOPT_LONGOPTS
                )[0]:
                if opt == "-c":
                        xivoconffile = arg
		elif opt == "-d":
			debug_mode = True
config_path()

# XIVO lib-python modules imports
import daemonize
from easyslog import *
import anysql
from BackSQL import backmysql
from BackSQL import backsqlite

# XIVO modules
import xivo_ami
import xivo_phones
import xivo_users
import xivo_commandsets
import xivo_astcfg
from xivo_log import *
from CommandSets import *

configs = {}

# global : userlist
# liste des champs :
#  user :             user name
#  passwd :           password

PIDFILE = '/var/run/xivo_fb.pid'
# TODO: command line parameter

BUFSIZE_LARGE = 8192
BUFSIZE_ANY = 512

socket.setdefaulttimeout(2)
XIVO_CLI_WEBI_HEADER = 'XIVO-CLI-WEBI'
XIVOVERSION = '0.3'


# AGI connection
def manage_agi_connections(connid, msg):
        """
        Handles AGI connections
        """
        re_push = re.match('PUSH <(\S+)> <(\S+)> <(\S+)> <(\S+)>', msg.strip())
        if re_push != None:
                inchannel = re_push.group(1)
                cidnum    = re_push.group(2)
                sdanum    = re_push.group(3)
                prevupto  = re_push.group(4)
                print 'INCOMING CALL ## PUSH received #', inchannel, cidnum, sdanum, prevupto
                whattodo = commandclass.elect(asterisklist[0], inchannel, cidnum, sdanum, prevupto)
                msgforagi = 'PULL_START %s PULL_STOP' % pickle.dumps(whattodo)
                print 'INCOMING CALL ## sending pickled reply to AGI'
                connid.send(msgforagi)


## \brief Deals with requests from the UI clients.
# \param connid connection identifier
# \param allow_events tells if this connection belongs to events-allowed ones
# (for switchboard) or to events-disallowed ones (for WEBI CLI commands)
# \return none
def manage_webi_cti_connections_tcp(connid, msg, allow_events, sep):
        """
        Handles WEBI and CTI connections
        """
        requester_ip = connid.getpeername()[0]
        requester_port = connid.getpeername()[1]
        requester = '%s:%d' % (requester_ip, requester_port)

        multimsg = msg.split(sep)
        for usefulmsgpart in multimsg:
                usefulmsg = usefulmsgpart.split('\r')[0]
                # debug/setup functions
                if usefulmsg == "show_infos":
                        try:
                                time_uptime = int(time.time() - time_start)
                                reply = 'infos=' \
                                        'xivo_version=%s;' \
                                        'server_version=%s;' \
                                        'uptime=%d s' \
                                        %(XIVOVERSION,
                                          __revision__,
                                          time_uptime)
                                connid.send(reply + "\n")
                                # connid.send("server capabilities = %s\n" %(",".join()))
                                connid.send("%s:OK\n" %(XIVO_CLI_WEBI_HEADER))
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- UI connection [%s] : KO when sending to %s : %s'
                                          %(usefulmsg, requester, str(exc)))
                elif usefulmsg == 'show_users':
                        try:
                                for astid in configs:
                                        connid.send("on <%s> :\n" % astid)
                                        for user,info in ulist.byast[astid].listusers().iteritems():
                                                connid.send('%s %s\n' %(user.encode('latin1'), info))
                                if connid in userinfo_by_requester:
                                        connid.send('%s\n' % str(userinfo_by_requester[connid]))
                                connid.send("%s:OK\n" %(XIVO_CLI_WEBI_HEADER))
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- UI connection [%s] : KO when sending to %s : %s'
                                          %(usefulmsg, requester, str(exc)))
                elif usefulmsg == 'show_logged':
                        try:
                                for astid in configs:
                                        connid.send("on <%s> :\n" % astid)
                                        for user,info in ulist.byast[astid].listconnected().iteritems():
                                                connid.send('%s %s\n' %(user.encode('latin1'), info))
                                if connid in userinfo_by_requester:
                                        connid.send('%s\n' % str(userinfo_by_requester[connid]))
                                connid.send("%s:OK\n" %(XIVO_CLI_WEBI_HEADER))
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- UI connection [%s] : KO when sending to %s : %s'
                                          %(usefulmsg, requester, str(exc)))
                elif usefulmsg == "show_ami":
                        try:
                                for amis in AMI_array_events_fd:
                                        connid.send("events   : %s : %s\n" %(amis, str(AMI_array_events_fd[amis])))
                                for amis in AMI_array_user_commands:
                                        connid.send("commands : %s : %s\n" %(amis, str(AMI_array_user_commands[amis])))
                                connid.send("%s:OK\n" %(XIVO_CLI_WEBI_HEADER))
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- UI connection [%s] : KO when sending to %s : %s'
                                          %(usefulmsg, requester, str(exc)))
                elif usefulmsg != "":
                    if allow_events: # i.e. if CTI-style connection
                        command = commandclass.parsecommand(usefulmsg)
                        if command.name in commandclass.get_list_commands():
                                if command.type == xivo_commandsets.CMD_LOGIN:
                                        try:
                                                loginparams = commandclass.get_login_params(asterisklist[0], command, connid)
                                                uinfo = commandclass.manage_login(loginparams)
                                                print uinfo
                                                if uinfo.__class__ == 'str':
                                                        commandclass.loginko(loginparams, uinfo, connid)
                                                else:
                                                        uinfo['login']['connection'] = connid
                                                        commandclass.loginok(loginparams, uinfo)
                                                        userinfo_by_requester[connid] = uinfo
                                        except Exception, exc:
                                                log_debug(SYSLOG_ERR, '--- exception --- UI connection [%s] : a problem occured when sending to %s : %s'
                                                          %(command.name, requester, str(exc)))
                                else:
                                        try:
                                                if connid in userinfo_by_requester:
                                                        resp = commandclass.manage_cticommand(userinfo_by_requester[connid],
                                                                                              connid,
                                                                                              command,
                                                                                              configs)
                                                        if resp is not None:
                                                                try:
                                                                        connid.send(resp + '\n')
                                                                except Exception, exc:
                                                                        log_debug(SYSLOG_ERR, '--- exception --- (sending TCP) %s' % str(exc))
                                                else:
                                                        log_debug(SYSLOG_WARNING, "%s is attempting a %s (TCP) : %s" %(requester, command.name, str(command.args)))
                                        except Exception, exc:
                                                log_debug(SYSLOG_ERR, '--- exception --- UI connection [%s] : a problem occured when sending to %s : %s'
                                                          %(command.name, requester, str(exc)))
                        else:
                                connid.send('Unknown Command %s\n' % command.name)


                    else: # i.e. if WEBI-style connection
                                if requester_ip in ip_reverse_webi:
                                        try:
                                                astid = ip_reverse_webi[requester_ip]
                                                connid.send('%s:ID <%s>\n' %(XIVO_CLI_WEBI_HEADER, astid))
                                                if usefulmsg == 'xivo[userlist,update]':
                                                        update_userlist[astid] = True
                                                        connid.send('%s:OK\n' %(XIVO_CLI_WEBI_HEADER))
                                                        log_debug(SYSLOG_INFO, '%s : userlist update request received' % astid)
                                                elif astid in AMI_array_user_commands and AMI_array_user_commands[astid]:
                                                        stripped_usefulmsg = usefulmsg.strip()
                                                        try:
                                                                if stripped_usefulmsg == 'moh reload':
                                                                        commandclass.pre_moh_reload()
                                                                elif stripped_usefulmsg == 'reload':
                                                                        commandclass.pre_reload()
                                                        except Exception, exc:
                                                                log_debug(SYSLOG_ERR, '--- exception --- (pre reloads) : %s' % str(exc))
                                                        try:
                                                                s = AMI_array_user_commands[astid].execclicommand(stripped_usefulmsg)
                                                        except Exception, exc:
                                                                log_debug(SYSLOG_ERR, '--- exception --- (%s) WEBI command exec <%s> : (client %s) : %s'
                                                                          %(astid, str(stripped_usefulmsg), requester, str(exc)))
                                                        try:
                                                                for x in s: connid.send(x)
                                                                connid.send('%s:OK\n' %(XIVO_CLI_WEBI_HEADER))
                                                        except Exception, exc:
                                                                log_debug(SYSLOG_ERR, '--- exception --- (%s) WEBI command reply <%s> : (client %s) : %s'
                                                                          %(astid, str(stripped_usefulmsg), requester, str(exc)))
                                        except Exception, exc:
                                                log_debug(SYSLOG_ERR, '--- exception --- (%s) WEBI <%s> : (client %s) : %s'
                                                          %(astid, str(usefulmsg.strip()), requester, str(exc)))
                                                connid.send('%s:KO <Exception : %s>\n' %(XIVO_CLI_WEBI_HEADER, str(exc)))
                                else:
                                        connid.send('%s:KO <NOT ALLOWED>\n' %(XIVO_CLI_WEBI_HEADER))


def manage_tcp_connections(sel_i, msg, kind):
        """
        Dispatches the message's handling according to the connection
        """
        if kind == 'CTI':
                manage_webi_cti_connections_tcp(sel_i, msg, True, '/')
        elif kind == 'WEBI':
                manage_webi_cti_connections_tcp(sel_i, msg, False, '\n')
        elif kind == 'AGI':
                manage_agi_connections(sel_i, msg)
        else:
                print 'unknown kind %s' % kind


"""
Management of events that are spied on the AMI
"""
## \brief Handling of AMI events occuring in Events=on mode.
# \param astid the asterisk Id
# \param idata the data read from the AMI we want to parse
# \return none
def handle_ami_event(astid, idata):
        """
        Handles the AMI events occuring on Asterisk.
        This function roughly only dispatches them to the relevant commandset's method.
        """
        global save_for_next_packet_events
        if astid not in configs:
                log_debug(SYSLOG_INFO, "%s : no such asterisk Id" % astid)
                return

        full_idata = save_for_next_packet_events[astid] + idata
        evlist = full_idata.split("\r\n\r\n")
        save_for_next_packet_events[astid] = evlist.pop()

        for evt in evlist:
                this_event = {}
                for myline in evt.split('\r\n'):
                        myfieldvalue = myline.split(': ', 1)
                        if len(myfieldvalue) == 2:
                                this_event[myfieldvalue[0]] = myfieldvalue[1]
                evfunction = this_event.get('Event')
                verboselog("/%s/ %s" %(astid, str(this_event)), True, False)
                # print '////////', evfunction, '   ------  ', this_event
                if evfunction is not None:
                        handle_ami_function(astid, evfunction, this_event)
                else:
                        response = this_event.get('Response')
                        if response is not None:
                                if response == 'Follows' and this_event.get('Privilege') == 'Command':
                                        log_debug(SYSLOG_INFO, 'AMI %s Response=Follows : %s' % (astid, str(this_event)))
                                elif response == 'Success':
                                        # log_debug(SYSLOG_INFO, 'AMI %s Response=Success : %s' % (astid, str(this_event)))
                                        pass
                                else:
                                        log_debug(SYSLOG_WARNING, 'AMI %s Response=%s (untracked) : %s' % (astid, response, str(this_event)))
                        elif len(this_event) > 0:
                                log_debug(SYSLOG_WARNING, 'AMI:XXX: <%s> : %s' % (astid, str(this_event)))
                        else:
                                log_debug(SYSLOG_WARNING, 'AMI %s Other : %s' % (astid, str(this_event)))


def handle_ami_function(astid, evfunction, this_event):
        global prev_registry_event
        if evfunction == 'Dial':
                        try:
                                commandclass.ami_dial(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
        elif evfunction == 'Link':
                        try:
                                commandclass.ami_link(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
        elif evfunction == 'Unlink':
                        try:
                                commandclass.ami_unlink(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
        elif evfunction == 'Hangup':
                        try:
                                commandclass.ami_hangup(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
        elif evfunction == 'Reload':
                        message = this_event.get('Message')
                        log_debug(SYSLOG_WARNING, "AMI:Reload: %s : %s" %(astid, str(this_event)))
        elif evfunction == 'Shutdown':
                        shutdown = this_event.get('Shutdown')
                        restart  = this_event.get('Restart')
                        log_debug(SYSLOG_WARNING, "AMI:Shutdown: %s (how=%s restart=%s)" %(astid, shutdown, restart))
        elif evfunction == 'Join':
                        try:
                                commandclass.ami_join(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
        elif evfunction == 'Leave':
                        try:
                                commandclass.ami_leave(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
        elif evfunction == 'PeerStatus':
                        # <-> register's ? notify's ?
                        pass
        elif evfunction == 'Agentlogin':
                        try:
                                commandclass.ami_agentlogin(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
        elif evfunction == 'Agentlogoff':
                        try:
                                commandclass.ami_agentlogoff(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
        elif evfunction == 'Agentcallbacklogoff':
                        try:
                                commandclass.ami_agentcallbacklogoff(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))

        elif evfunction == 'Agentcallbacklogin':
                        log_debug(SYSLOG_INFO, '//AMI:Agentcallbacklogin// %s : %s' %(astid, str(this_event)))
        elif evfunction == 'AgentCalled':
                        log_debug(SYSLOG_INFO, '//AMI:AgentCalled// %s : %s' %(astid, str(this_event)))
        elif evfunction == 'ParkedCall':
                        # when a requested parking is established
                        try:
                                commandclass.ami_parkedcall(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
        elif evfunction == 'UnParkedCall':
                        # when somebody (From) took the call
                        try:
                                commandclass.ami_unparkedcall(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
        elif evfunction == 'ParkedCallTimeOut':
                        # when the timeout has occured
                        try:
                                commandclass.ami_parkedcalltimeout(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
        elif evfunction == 'ParkedCallGiveUp':
                        # when the peer is tired and hangs up
                        try:
                                commandclass.ami_parkedcallgiveup(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
        elif evfunction == 'ParkedCallsComplete':
                        log_debug(SYSLOG_INFO, '//AMI:ParkedCallsComplete// %s : %s' %(astid, str(this_event)))
        elif evfunction == 'Cdr':
                        log_debug(SYSLOG_INFO, '//AMI:Cdr// %s : %s' %(astid, str(this_event)))
        elif evfunction == 'Alarm':
                        log_debug(SYSLOG_INFO, '//AMI:Alarm// %s : %s' %(astid, str(this_event)))
        elif evfunction == 'AlarmClear':
                        log_debug(SYSLOG_INFO, '//AMI:AlarmClear// %s : %s' %(astid, str(this_event)))
        elif evfunction == 'FaxReceived':
                        log_debug(SYSLOG_INFO, '//AMI:FaxReceived// %s : %s' %(astid, str(this_event)))
        elif evfunction == 'Registry':
                        log_debug(SYSLOG_INFO, 'AMI:Registry: %s : username=%s channel=%s domain=%s status=%s'
                                  %(astid, this_event.get('Username'), this_event.get('Channel'), this_event.get('Domain'), this_event.get('Status')))
                        prev_registry_event = this_event
        elif evfunction == 'MeetmeJoin':
                        # when a member joins a conference
                        try:
                                commandclass.ami_meetmejoin(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
        elif evfunction == 'MeetmeLeave':
                        # when a member leaves a conference
                        try:
                                commandclass.ami_meetmeleave(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
        elif evfunction == 'ExtensionStatus':
                        pass

                        # QueueMemberStatus ExtensionStatus
                        #                 0                  AST_DEVICE_UNKNOWN
                        #                 1               0  AST_DEVICE_NOT_INUSE  /  libre
                        #                 2               1  AST_DEVICE IN USE     / en ligne
                        #                 3                  AST_DEVICE_BUSY
                        #                                 4  AST_EXTENSION_UNAVAILABLE ?
                        #                 5                  AST_DEVICE_UNAVAILABLE
                        #                 6 AST_EXTENSION_RINGING = 8  appele
        elif evfunction == 'OriginateSuccess':
                        try:
                                commandclass.ami_originatesuccess(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
        elif evfunction == 'AOriginateSuccess':
                        try:
                                commandclass.ami_aoriginatesuccess(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
        elif evfunction == 'OriginateFailure':
                        try:
                                commandclass.ami_originatefailure(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
                        # log_debug(SYSLOG_INFO, 'AMI:OriginateFailure: %s - reason = %s' % (astid, this_event.get('Reason')))
        elif evfunction == 'AOriginateFailure':
                        try:
                                commandclass.ami_aoriginatefailure(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
                        # log_debug(SYSLOG_INFO, 'AMI:AOriginateFailure: %s - reason = %s' % (astid, this_event.get('Reason')))
                        #define AST_CONTROL_HANGUP              1
                        #define AST_CONTROL_RING                2
                        #define AST_CONTROL_RINGING             3
                        #define AST_CONTROL_ANSWER              4
                        #define AST_CONTROL_BUSY                5
                        #define AST_CONTROL_TAKEOFFHOOK         6
                        #define AST_CONTROL_OFFHOOK             7
                        #define AST_CONTROL_CONGESTION          8
                        #define AST_CONTROL_FLASH               9
                        #define AST_CONTROL_WINK                10
        elif evfunction == 'Rename':
                        # appears when there is a transfer
                        try:
                                commandclass.ami_rename(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
        elif evfunction == 'Newstate':
                        pass
        elif evfunction == 'Newcallerid':
                        # for tricky managements
                        try:
                                commandclass.ami_newcallerid(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
        elif evfunction == 'Newchannel':
                        pass
        elif evfunction.startswith('UserEvent'):
                        try:
                                commandclass.ami_userevent(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
        elif evfunction == 'Newexten': # in order to handle outgoing calls ?
                        pass
        elif evfunction == 'MessageWaiting':
                        try:
                                commandclass.ami_messagewaiting(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
        elif evfunction == 'QueueParams':
                        pass
        elif evfunction == 'QueueMemberAdded':
                        pass
        elif evfunction == 'QueueMemberPaused':
                        pass
        elif evfunction == 'QueueMemberRemoved':
                        pass
        elif evfunction == 'QueueMember':
                        log_debug(SYSLOG_INFO, '//AMI:QueueMember// %s : %s' %(astid, str(this_event)))
        elif evfunction == 'QueueMemberStatus':
                        try:
                                commandclass.ami_queuememberstatus(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
        elif evfunction == 'Agents':
                        try:
                                commandclass.ami_agents(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
        elif evfunction == 'Status':
                        try:
                                commandclass.ami_status(astid, this_event)
                        except Exception, exc:
                                log_debug(SYSLOG_ERR, '--- exception --- AMI / %s : %s : %s' % (evfunction, str(exc), str(this_event)))
        elif evfunction == 'StatusComplete':
                        log_debug(SYSLOG_INFO, 'AMI %s StatusComplete' % astid)
        elif evfunction == 'AgentsComplete':
                        log_debug(SYSLOG_INFO, 'AMI %s AgentsComplete' % astid)
        else:
                        log_debug(SYSLOG_WARNING, 'AMI %s ... not tracked event %s' % (astid, evfunction))



## \brief Connects to the AMI if not yet.
# \param astid Asterisk id to (re)connect
# \return none
def update_amisocks(astid):
        """
        Connects to the AMI if not yet done.
        
        """
        try:
                if astid not in AMI_array_events_fd or AMI_array_events_fd[astid] is False:
                        log_debug(SYSLOG_INFO, '%s : AMI : attempting to connect' % astid)
                        als0 = connect_to_AMI((configs[astid].remoteaddr,
                                               configs[astid].ami_port),
                                              configs[astid].ami_login,
                                              configs[astid].ami_pass,
                                              True)
                        if als0:
                                AMI_array_events_fd[astid] = als0.fd
                                fdlist_full.append(als0.fd)
                                log_debug(SYSLOG_INFO, '%s : AMI : connected' % astid)
##                                for x in plist[astid].normal.itervalues():
##                                        x.clear_channels()
                                ret = als0.sendstatus()
                                if not ret:
                                        log_debug(SYSLOG_INFO, '%s : could not send status command' % astid)
                                ret = als0.sendagents()
                                if not ret:
                                        log_debug(SYSLOG_INFO, '%s : could not send agents command' % astid)
                        else:
                                log_debug(SYSLOG_INFO, '%s : AMI : could NOT connect' % astid)
        except Exception, exc:
                log_debug(SYSLOG_ERR, '--- exception --- %s (update_amisocks) : %s' % (astid, str(exc)))

        try:
                if astid not in AMI_array_user_commands or AMI_array_user_commands[astid] is False:
                        log_debug(SYSLOG_INFO, '%s : AMI (commands)  : attempting to connect' % astid)
                        als1 = connect_to_AMI((configs[astid].remoteaddr,
                                               configs[astid].ami_port),
                                              configs[astid].ami_login,
                                              configs[astid].ami_pass,
                                              False)
                        if als1:
                                AMI_array_user_commands[astid] = als1
                                log_debug(SYSLOG_INFO, '%s : AMI (commands)  : connected' % astid)
                        else:
                                log_debug(SYSLOG_INFO, '%s : AMI (commands)  : could NOT connect' % astid)
        except Exception, exc:
                log_debug(SYSLOG_ERR, '--- exception --- %s (update_amisocks command) : %s' % (astid, str(exc)))


## \brief Connects to the AMI through AMIClass.
# \param address IP address
# \param loginname loginname
# \param password password
# \return the socket
def connect_to_AMI(address, loginname, password, events_on):
        """
        Connects to the AMI.
        """
        lAMIsock = xivo_ami.AMIClass(address, loginname, password, events_on)
        try:
                lAMIsock.connect()
                lAMIsock.login()
        except socket.timeout: pass
        except socket:         pass
        except:
                del lAMIsock
                lAMIsock = False
        return lAMIsock



## \brief Handler for catching signals (in the main thread)
# \param signum signal number
# \param frame frame
# \return none
def sighandler(signum, frame):
        global askedtoquit
        print "--- signal", signum, "received : quits"
        for t in filter(lambda x: x.getName()<>"MainThread", threading.enumerate()):
                print "--- living thread <%s>" %(t.getName())
                t._Thread__stop()
        askedtoquit = True


## \brief Handler for catching signals (in the main thread)
# \param signum signal number
# \param frame frame
# \return none
def sighandler_reload(signum, frame):
        global askedtoquit
        print "--- signal", signum, "received : reloads"
        askedtoquit = False

# ==============================================================================
# ==============================================================================

def log_stderr_and_syslog(x):
        print >> sys.stderr, x
        syslogf(SYSLOG_ERR, x)

# ==============================================================================
# Main Code starts here
# ==============================================================================

# daemonize if not in debug mode
if not debug_mode:
        daemonize.daemonize(log_stderr_and_syslog, PIDFILE, True)
else:
        daemonize.create_pidfile_or_die(log_stderr_and_syslog, PIDFILE, True)

signal.signal(signal.SIGINT, sighandler)
signal.signal(signal.SIGTERM, sighandler)
signal.signal(signal.SIGHUP, sighandler_reload)

nreload = 0
ulist = xivo_users.Users()
plist = xivo_phones.Phones()

while True: # loops over the reloads
        askedtoquit = False

        time_start = time.time()
        if nreload == 0:
                log_debug(SYSLOG_NOTICE, '# STARTING XIVO Daemon %s / svn %s # (0/3) Starting'
                          %(XIVOVERSION, __revision__))
        else:
                log_debug(SYSLOG_NOTICE, '# STARTING XIVO Daemon %s / svn %s # (0/3) Reloading (%d)'
                          %(XIVOVERSION, __revision__, nreload))
        nreload += 1
        
        # global default definitions
        commandset = 'xivosimple'
        incoming_tcp_ports = []
        extraconn = ''
        xivo_db = 'mysql://asterisk:proformatique@127.0.0.1:3306/asterisk?charset=utf8'
        updates_period = 60
        asterisklist = []
        contextlist = []
        evt_filename = '/var/log/pf-xivo-cti-server/ami_events.log'
        gui_filename = '/var/log/pf-xivo-cti-server/gui.log'

        userinfo_by_requester = {}

        xivoconf = ConfigParser.ConfigParser()
        xivoconf.readfp(open(xivoconffile))
        xivoconf_general = dict(xivoconf.items('general'))

        # loads the general configuration
        if 'commandset' in xivoconf_general:
                commandset = xivoconf_general['commandset']
        if 'incoming_tcp_ports' in xivoconf_general:
                incoming_tcp_ports = xivoconf_general['incoming_tcp_ports'].split(',')
        if 'extraconn' in xivoconf_general:
                extraconn = xivoconf_general['extraconn']
        if 'operatini' in xivoconf_general:
                operatini = xivoconf_general['operatini']
        if 'xivo_db' in xivoconf_general:
                xivo_db = xivoconf_general['xivo_db']
        if 'updates_period' in xivoconf_general:
                updates_period = int(xivoconf_general['updates_period'])
        if 'asterisklist' in xivoconf_general:
                asterisklist = xivoconf_general['asterisklist'].split(',')
        if 'evtfile' in xivoconf_general:
                evt_filename = xivoconf_general['evtfile']
        if 'guifile' in xivoconf_general:
                gui_filename = xivoconf_general['guifile']


        queued_threads_pipe = os.pipe()
        AMI_array_user_commands = {}
        # for cset in ['xivonew', commandset]:
        commandclass = xivo_commandsets.CommandClasses[commandset](ulist, AMI_array_user_commands, incoming_tcp_ports, operatini, queued_threads_pipe)
        ulist.setcommandclass(commandclass)
        plist.setcommandclass(commandclass)

        outsock = commandclass.extrasock(extraconn)

        save_for_next_packet_events = {}
        ip_reverse_webi = {}
        ip_reverse_sht = {}

        # loads the configuration for each asterisk
        for astid in xivoconf.sections():
                if astid != 'general' and astid in asterisklist:
                        xivoconf_local = dict(xivoconf.items(astid))

                        localaddr = '127.0.0.1'
                        userlist_url = 'sso.php'
                        ipaddress = '127.0.0.1'
                        ipaddress_webi = '127.0.0.1'
                        extrachannels = ''
                        ami_port = 5038
                        ami_login = 'xivouser'
                        ami_pass = 'xivouser'
                        contexts = ''
                        userfeatures_db_uri = ''
                        cdr_db_uri = ''
                        realm = 'asterisk'
                        parkingnumber = '700'
                        faxcallerid = 'faxcallerid'
                        linkestablished = ''
                        capas_s = []
                        capas_i = 0

                        if 'localaddr' in xivoconf_local:
                                localaddr = xivoconf_local['localaddr']
                        if 'userlisturl' in xivoconf_local:
                                userlist_url = xivoconf_local['userlisturl']
                        if 'ipaddress' in xivoconf_local:
                                ipaddress = xivoconf_local['ipaddress']
                        if 'ipaddress_webi' in xivoconf_local:
                                ipaddress_webi = xivoconf_local['ipaddress_webi']
                        if 'extrachannels' in xivoconf_local:
                                extrachannels = xivoconf_local['extrachannels']
                        if 'parkingnumber' in xivoconf_local:
                                parkingnumber = int(xivoconf_local['parkingnumber'])
                        if 'faxcallerid' in xivoconf_local:
                                faxcallerid = int(xivoconf_local['faxcallerid'])
                        if 'linkestablished' in xivoconf_local:
                                linkestablished = xivoconf_local['linkestablished']
                        if 'ami_port' in xivoconf_local:
                                ami_port = int(xivoconf_local['ami_port'])
                        if 'ami_login' in xivoconf_local:
                                ami_login = xivoconf_local['ami_login']
                        if 'ami_pass' in xivoconf_local:
                                ami_pass = xivoconf_local['ami_pass']
                        if 'contexts' in xivoconf_local:
                                contexts = xivoconf_local['contexts']
                                if contexts != '':
                                        for c in contexts.split(','):
                                                contextlist.append(c)
                        if 'userfeatures_db_uri' in xivoconf_local:
                                userfeatures_db_uri = xivoconf_local['userfeatures_db_uri']
                        if 'cdr_db_uri' in xivoconf_local:
                                cdr_db_uri = xivoconf_local['cdr_db_uri']
                        if 'realm' in xivoconf_local:
                                realm = xivoconf_local['realm']

                        capafeatures = []
                        unallowed = []
                        if userfeatures_db_uri is not '':
                                conn = anysql.connect_by_uri(userfeatures_db_uri)
                                cursor = conn.cursor()
                                params = ['features']
                                columns = ('commented', 'context', 'name')
                                query = 'SELECT ${columns} FROM extensions WHERE context = %s'
                                cursor.query(query,
                                             columns,
                                             params)
                                results = cursor.fetchall()
                                conn.close()
                                for res in results:
                                        if res[0] == 0:
                                                capafeatures.append(res[2])
                                        else:
                                                unallowed.append(res[2])
                        #print "%s : allowed     : %s" %(i, str(capafeatures))
                        #print "%s : not allowed : %s" %(i, str(unallowed))

                        configs[astid] = xivo_astcfg.AsteriskConfig(astid,
                                                                    userlist_url,
                                                                    extrachannels,
                                                                    localaddr,
                                                                    ipaddress,
                                                                    ipaddress_webi,
                                                                    ami_port,
                                                                    ami_login,
                                                                    ami_pass,
                                                                    userfeatures_db_uri,
                                                                    capas_s,
                                                                    capas_i,
                                                                    capafeatures,
                                                                    cdr_db_uri,
                                                                    realm,
                                                                    parkingnumber,
                                                                    faxcallerid,
                                                                    linkestablished)
                        ulist.set_ast_list(astid)
                        commandclass.set_cdr_uri(cdr_db_uri, xivo_db)

                        if ipaddress not in ip_reverse_sht:
                                ip_reverse_sht[ipaddress] = astid
                        else:
                                log_debug(SYSLOG_WARNING, 'WARNING - IP address already exists for asterisk <%s> - can not set it for <%s>'
                                          % (ip_reverse_sht[ipaddress], astid))
                        if ipaddress_webi not in ip_reverse_webi:
                                ip_reverse_webi[ipaddress_webi] = astid
                        else:
                                log_debug(SYSLOG_WARNING, 'WARNING - IP address (WEBI) already exists for asterisk <%s> - can not set it for <%s>'
                                          % (ip_reverse_webi[ipaddress_webi], astid))
                        save_for_next_packet_events[astid] = ''

        fdlist_full = []
        fdlist_established = {}
        fdlist_listen_cti = {}

        if debug_mode:
                # opens the evtfile for output in append mode
                try:
                        evtfile = open(evt_filename, 'a')
                except Exception, exc:
                        print "Could not open %s in append mode : %s" %(evt_filename,exc)
                        evtfile = False
                # opens the guifile for output in append mode
                try:
                        guifile = open(gui_filename, 'a')
                except Exception, exc:
                        print "Could not open %s in append mode : %s" %(gui_filename,exc)
                        guifile = False
        
        AMI_array_events_fd = {}
        update_userlist = {}
        lastrequest_time = {}

        log_debug(SYSLOG_INFO, "the monitored asterisk's is/are : %s" % str(asterisklist))
        log_debug(SYSLOG_INFO, "# STARTING XIVO Daemon # (1/2) AMI socket connections + fetch Web Services")

        for astid in configs:
                try:
                        update_userlist[astid] = False
                        lastrequest_time[astid] = time.time()
                        update_amisocks(astid)
                        plist.update(astid)
                        ulist.update(astid)
                except Exception, exc:
                        log_debug(SYSLOG_ERR, '--- exception --- %s : failed while setting lists and sockets : %s'
                                  %(astid, str(exc)))

        log_debug(SYSLOG_INFO, "# STARTING XIVO Daemon # (2/2) listening UI sockets")
        # opens the listening socket for incoming (CTI, WEBI, AGI) connections
        for portkind in incoming_tcp_ports:
                [port, kind] = portkind.split(':')
                UIsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                UIsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                UIsock.bind(("", int(port)))
                UIsock.listen(10)
                fdlist_listen_cti[UIsock] = kind.strip()
                fdlist_full.append(UIsock)

        if outsock is not None:
                fdlist_full.append(outsock)
        fdlist_full.append(queued_threads_pipe[0])

        # Receive messages
        while not askedtoquit:
                try:
                        [sels_i, sels_o, sels_e] = select.select(fdlist_full, [], [], updates_period)
                except Exception, exc:
                        if askedtoquit:
                                try:
                                        print
                                        print 'current open TCP connections : (CTI, WEBI, AGI) ', fdlist_established
                                        print 'current open TCP connections : (AMI) ', AMI_array_events_fd
                                        print 'current open TCP connections : (OP)  ', outsock
                                        print
                                        os.unlink(PIDFILE)
                                except Exception, exc:
                                        print exc
                                if debug_mode:
                                        # Close files and sockets
                                        evtfile.close()
                                        guifile.close()
                                for t in filter(lambda x: x.getName()<>"MainThread", threading.enumerate()):
                                        print "--- (stop) killing thread <%s>" %(t.getName())
                                        t._Thread__stop()
                                sys.exit(5)
                        else:
                                print '--- exception --- after select :', exc
                                askedtoquit = True
                                for s in fdlist_full:
                                        s.close()
                                for t in filter(lambda x: x.getName()<>"MainThread", threading.enumerate()):
                                        print "--- (reload) the thread <%s> remains" %(t.getName())
                                        # t._Thread__stop() # does not work in reload case (vs. stop case)
                                continue
                if sels_i:
                    for sel_i in sels_i:
                        # these AMI connections are used in order to manage AMI commands with incoming events
                        if sel_i in AMI_array_events_fd.values():
                                for astid, val in AMI_array_events_fd.iteritems():
                                        if val is sel_i: break
                                try:
                                        a = AMI_array_events_fd[astid].readline() # (BUFSIZE_ANY)
                                        if len(a) == 0: # end of connection from server side : closing socket
                                                log_debug(SYSLOG_WARNING, "%s : AMI : CLOSING" % astid)
                                                strmessage = commandclass.dmessage_srv2clt('AMI OFF for <%s>' % astid)
                                                AMI_array_events_fd[astid].close()
                                                fdlist_full.remove(AMI_array_events_fd[astid])
                                                del AMI_array_events_fd[astid]
                                        else:
                                                handle_ami_event(astid, a)
                                except Exception, exc:
                                        log_debug(SYSLOG_ERR, "--- exception --- AMI <%s> : %s" % (astid, str(exc)))

                        # other 'outgoing' connections
                        elif sel_i == outsock:
                                try:
                                        msg = sel_i.recv(BUFSIZE_LARGE)
                                except Exception, exc:
                                        log_debug(SYSLOG_ERR, '--- exception --- outsock : %s' % str(exc))
                                        msg = ''
                                if len(msg) == 0:
                                        sel_i.close()
                                        fdlist_full.remove(sel_i)
                                        outsock = None
                                        log_debug(SYSLOG_WARNING, 'WARNING - outsock has closed the connection')
                                else:
                                        commandclass.svreply(asterisklist[0], msg)

                        # the new TCP connections (CTI, WEBI, AGI) are catched here
                        elif sel_i in fdlist_listen_cti:
                                kind = fdlist_listen_cti[sel_i]
                                [conn, sockparams] = sel_i.accept()
                                log_debug(SYSLOG_INFO, "TCP socket opened on %s:%d (%s)" % (sockparams[0], sockparams[1], kind))
                                if kind == 'CTI':
                                        commandclass.connected(conn)
                                # appending the opened socket to the ones watched
                                conn.setblocking(0)
                                fdlist_full.append(conn)
                                fdlist_established[conn] = kind

                        # incoming TCP connections (CTI, WEBI, AGI)
                        elif sel_i in fdlist_established:
                                requester = '%s:%d' % (sel_i.getpeername()[0], sel_i.getpeername()[1])
                                kind = fdlist_established[sel_i]
                                try:
                                        msg = sel_i.recv(BUFSIZE_LARGE)
                                        lmsg = len(msg)
                                except Exception, exc:
                                        lmsg = 0
                                        log_debug(SYSLOG_ERR, '--- exception --- connection to %s (%s) : %s' % (requester, kind, str(exc)))
                                if lmsg > 0:
                                        try:
                                                manage_tcp_connections(sel_i, msg, kind)
                                        except Exception, exc:
                                                log_debug(SYSLOG_ERR, '--- exception --- handling %s (%s) : %s' % (requester, kind, str(exc)))
                                else:
                                        if kind == 'CTI':
                                                if sel_i in userinfo_by_requester:
                                                        userinfo = userinfo_by_requester.get(sel_i)
                                                        ulist.disconnect_user(userinfo)
                                                        del userinfo_by_requester[sel_i]
                                if kind in ['WEBI', 'AGI'] or kind == 'CTI' and lmsg == 0:
                                        sel_i.close()
                                        fdlist_full.remove(sel_i)
                                        del fdlist_established[sel_i]
                                        log_debug(SYSLOG_INFO, 'TCP socket closed on %s (%s)' % (requester, kind))

                        # local pipe fd
                        elif queued_threads_pipe[0] == sel_i:
                                disconnlist = commandclass.checkqueue()
                                try:
                                        for userinfo in disconnlist:
                                                print 'checkqueue return :', userinfo
                                                if 'connection' in userinfo.get('login'):
                                                        userinfo.get('login')['connection'].close()
                                                        fdlist_full.remove(userinfo.get('login')['connection'])
                                                else:
                                                        log_debug(SYSLOG_WARNING, 'WARNING - no connection field present in userinfo')
                                                ulist.disconnect_user(userinfo)
                                except Exception, exc:
                                        log_debug(SYSLOG_ERR, '--- exception --- %s' % str(exc))




                        for astid in configs:
                                if (time.time() - lastrequest_time[astid]) > updates_period or update_userlist[astid]:
                                        lastrequest_time[astid] = time.time()
                                        log_debug(SYSLOG_INFO, '%s : updates (computed timeout) %s'
                                                  % (astid, time.strftime("%H:%M:%S", time.localtime())))
                                        try:
                                                if outsock is None:
                                                        outsock = commandclass.extrasock(extraconn)
                                                        if outsock is not None:
                                                                fdlist_full.append(outsock)
                                                update_amisocks(astid)
                                                plist.update(astid)
                                                ulist.update(astid)
                                                update_userlist[astid] = False
                                        except Exception, exc:
                                                log_debug(SYSLOG_ERR, '--- exception --- %s : failed while updating lists and sockets (computed timeout) : %s'
                                                          %(astid, str(exc)))

                else: # when nothing happens on the sockets, we fall here sooner or later
                        log_debug(SYSLOG_INFO, 'updates (select timeout) %s'
                                  % time.strftime("%H:%M:%S", time.localtime()))
                        for astid in configs:
                                lastrequest_time[astid] = time.time()
                                try:
                                        if outsock is None:
                                                outsock = commandclass.extrasock(extraconn)
                                                if outsock is not None:
                                                        fdlist_full.append(outsock)
                                        update_amisocks(astid)
                                        plist.update(astid)
                                        ulist.update(astid)
                                except Exception, exc:
                                        log_debug(SYSLOG_ERR, '--- exception --- %s : failed while updating lists and sockets (select s timeout) : %s'
                                                  %(astid, str(exc)))

        log_debug(SYSLOG_NOTICE, 'after askedtoquit loop')
