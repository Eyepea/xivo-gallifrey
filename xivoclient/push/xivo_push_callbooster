#! /usr/bin/python
# vim: set fileencoding=utf-8 :
#
# This is an extension to XIVO Daemon, authorized by Pro-formatique SARL
# for sub-licensing under a separated contract.
#
# Licensing of this code is NOT bounded by the terms of the
# GNU General Public License.
#
# See the LICENSE file at top of the source tree or delivered in the
# installable package in which XIVO Daemon is distributed for more details.

"""
This is the AGI called when a call is incoming on XIVO-FB2.
"""

__version__   = '$Revision$'
__date__      = '$Date$'
__copyright__ = 'Copyright (C) 2007, 2008, Proformatique'
__author__    = 'Corentin Le Gall'

import xivo.to_path
import anysql
from BackSQL import backmysql
from BackSQL import backsqlite
import ConfigParser
import os
import pickle
import re
import sys
import socket
from agi import *

agi = AGI()

## \brief Logs a message into the Asterisk CLI
# \param txt message to send to the CLI
def print_verbose(txt):
        agi.verbose("push_callbooster : %s" % txt)

def rfindpath(acc, mfile, kind):
        if len(acc) > 0:
                partfile = '%s/%s/%s/%s' % (path_sounds_byadh, '/'.join(acc), kind, mfile)
        else:
                partfile = '%s/%s' % (path_sounds_global.get(kind), mfile)
        fullfile1 = '%s/%s.wav' % (path_sounds_asterisk, partfile)
        fullfile2 = '%s/%s.WAV' % (path_sounds_asterisk, partfile)
        if os.path.exists(fullfile1) or os.path.exists(fullfile2):
                return [acc, partfile]
        else:
                if len(acc) == 3:
                        if acc[2] != '0':
                                tacc = [acc[0], acc[1], '0']
                        else:
                                tacc = [acc[0], acc[1]]
                elif len(acc) == 2:
                        if acc[1] != '0':
                                tacc = [acc[0], '0']
                        else:
                                tacc = [acc[0]]
                elif len(acc) == 1:
                        if acc[0] != '0':
                                tacc = ['0']
                        else:
                                tacc = []

                if len(acc) > 0:
                        [nacc, npartfile] = rfindpath(tacc, mfile, kind)
                else:
                        [nacc, npartfile] = [None, None]
                return [nacc, npartfile]

def findpath_and_set(acc, argum, kind, varname):
        [fpath, partfile] = rfindpath(acc, argum, kind)
        if partfile is not None:
                agi.set_variable(varname, partfile)
        else:
                print_verbose('%s (%s) : %s does not exist on filesystem' % (varname, str(acc), argum))

def moh_check(path):
        conn_ast = anysql.connect_by_uri(xivo_db_uri)
        cursor_ast = conn_ast.cursor()
        columns = ('category', 'var_name', 'var_val')
        cursor_ast.query("SELECT ${columns} FROM musiconhold WHERE var_name = %s AND category = %s",
                         columns,
                         ('directory', path))
        results = cursor_ast.fetchall()
        if results == ():
                return 'callbooster'
        else:
                print_verbose('an moh path was found in the DB for %s : %s' % (path, results[0][2]))
                return path


# ==============================================================================
# Main Code starts here
# ==============================================================================

CONFIG_XIVO_DAEMON = '/etc/asterisk/xivo_daemon_ns.conf'

port_comm_agi_daemon = 4970
path_sounds_asterisk = '/var/lib/asterisk/sounds'
path_sounds_byadh = 'callbooster'
path_sounds_global = {'Sons' : 'web-interface/callbooster-sons',
                      'Repondeurs' : 'web-interface/callbooster-repondeurs'}
xivo_db_uri = 'mysql://asterisk:proformatique@127.0.0.1:3306/asterisk?charset=utf8'

xivocfg = ConfigParser.ConfigParser()
try:
        xivocfg.readfp(open(CONFIG_XIVO_DAEMON))
        xivocfg_general = dict(xivocfg.items('general'))
        if 'port_comm_agi_daemon' in xivocfg_general:
                port_comm_agi_daemon = int(xivocfg_general.get('port_comm_agi_daemon'))
        if 'path_sounds_asterisk' in xivocfg_general:
                path_sounds_asterisk = xivocfg_general.get('path_sounds_asterisk')
        if 'path_sounds_byadh' in xivocfg_general:
                path_sounds_byadh = xivocfg_general.get('path_sounds_byadh')
        xivocfg_callbooster = dict(xivocfg.items('callbooster'))
        if 'xivo_db_uri' in xivocfg_callbooster:
                xivo_db_uri = xivocfg_callbooster.get('xivo_db_uri')
##        if 'path_sounds_global' in xivocfg_general:
##                path_sounds_global = xivocfg_general.get('path_sounds_global')
except Exception, exc:
        print_verbose('could not access to config in %s (err = %s) : default config used' % (CONFIG_XIVO_DAEMON, str(exc)))


action = 'exit'
callednum = sys.argv[1]
mysda = callednum[-4:]
print_verbose('in callbooster AGI <%s> <%s>' % (callednum, mysda))

cidnum    = agi.env['agi_callerid']
prevwhere = agi.get_variable('CB_AGI_WHERE')
inchannel = agi.get_variable('CHANNEL')
if prevwhere == '':
        upto = '0'
else:
        upto = prevwhere

try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect(('127.0.0.1', port_comm_agi_daemon))
        s.send('PUSH <%s> <%s> <%s> <%s>\r\n' % (inchannel, cidnum, callednum, upto))
        pushreply = s.recv(8192)
        # print_verbose('before pickle loads : <%s>' % str(pushreply))
        # format PULL_START (struct) PULL_STOP
        try:
                n = pickle.loads(pushreply[11:-10])
        except Exception, exc:
                n = None
                print_verbose('could not pickle.loads the answer from daemon')
        # print_verbose('pickle loads : %s' % str(n))
        if n is not None:
                action = n['action']
                delay  = n['delay']
                argum  = n['argument']
                where  = n['newupto']
                queuename = n['queuename']
                dialplan = n['dialplan']
                print_verbose('%s %s %s %s %s : %s' % (action, delay, argum, where, queuename, str(dialplan)))
        else:
                action = 'exit'
                delay  = 0
                print_verbose('could not unpickle the reply : set CB_AGI_STATUS to exit')
except Exception, exc:
        action = 'exit'
        delay  = 0
        print_verbose('could not connect to daemon : %s' % str(exc))


# sets the action before further treatment (in order for dialplan to end in the exit case)
agi.set_variable('CB_AGI_STATUS', action)

print_verbose('CB : received ACTION=%s WAIT=%ds ARG=%s WHERE=%s QUEUENAME=%s' %(action, int(delay), argum, where, queuename))

if action == 'secretariat':
        if argum is None:
                agi.set_variable('CB_FIRST_WELCOME', 'already')

if action == 'tel' or action == 'bas' or action == 'fic':
        telargs = argum.split('-')
        agi.set_variable('CB_AGI_TEL_NUM', telargs[0])
        agi.set_variable('CB_AGI_TEL_DELAY', telargs[1])
        agi.set_variable('CB_AGI_TEL_CHERCHE', telargs[2])
        agi.set_variable('CB_AGI_TEL_PATIENTE', telargs[3])

if action == 'rep':
        if 'soundpath' in dialplan:
                acc = dialplan['soundpath'].split('/')
                findpath_and_set(acc, argum, 'Repondeurs', 'CB_AGI_ARG')

if action == 'mes':
        argums = argum.split(';')
        if 'soundpath' in dialplan:
                agi.set_variable('CB_AGI_MES_INDEX', argums[2])
                acc = dialplan['soundpath'].split('/')
                findpath_and_set(acc, argums[0], 'Repondeurs', 'CB_AGI_MES_MES')
        agi.set_variable('CB_AGI_MES_SDA', mysda)

if dialplan is not None:
        if dialplan['record'] is not None:
                agi.set_variable('CB_AGI_RECORD', dialplan['record'])
        if 'soundpath' in dialplan:
                acc = dialplan['soundpath'].split('/')
                findpath_and_set(acc, dialplan['M001003'], 'Sons', 'CB_AGI_MES_WELCOME')
                for mfile in ['M002', 'M005', 'M006', 'M007', 'M008', 'M009', 'M012', 'M025']:
                        if mfile in dialplan['sounds']:
                                findpath_and_set(acc, mfile, 'Sons', 'CB_AGI_MES_%s' % mfile)
                if 'M018' in dialplan['sounds']:
                        moh_class = moh_check(dialplan['soundpath'])
                        agi.set_variable('CB_AGI_MES_WAITINGMUSIC', moh_class)

# saving the current CB 'dialplan' position and status, might be useful for true dialplan decisions
agi.set_variable('CB_AGI_WHERE', where)

# setting the Queue() to call
agi.set_variable('CB_AGI_QUEUE_NAME', queuename)
# delay to set for Queue()
if delay == 0:
        agi.set_variable('CB_AGI_QUEUE_WAIT', 36000)
else:
        agi.set_variable('CB_AGI_QUEUE_WAIT', delay)
